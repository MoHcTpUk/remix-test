var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x2) => typeof require < "u" ? require : typeof Proxy < "u" ? new Proxy(x2, {
  get: (a3, b2) => (typeof require < "u" ? require : a3)[b2]
}) : x2)(function(x2) {
  if (typeof require < "u")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x2 + '" is not supported');
});
var __esm = (fn, res) => function() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from2, except, desc) => {
  if (from2 && typeof from2 == "object" || typeof from2 == "function")
    for (let key2 of __getOwnPropNames(from2))
      !__hasOwnProp.call(to, key2) && key2 !== except && __defProp(to, key2, { get: () => from2[key2], enumerable: !(desc = __getOwnPropDesc(from2, key2)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
)), __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);

// node_modules/cookie/index.js
var require_cookie = __commonJS({
  "node_modules/cookie/index.js"(exports) {
    "use strict";
    exports.parse = parse5;
    exports.serialize = serialize2;
    var decode = decodeURIComponent, encode = encodeURIComponent, fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
    function parse5(str2, options2) {
      if (typeof str2 != "string")
        throw new TypeError("argument str must be a string");
      for (var obj = {}, opt = options2 || {}, pairs2 = str2.split(";"), dec = opt.decode || decode, i3 = 0; i3 < pairs2.length; i3++) {
        var pair = pairs2[i3], index2 = pair.indexOf("=");
        if (!(index2 < 0)) {
          var key2 = pair.substring(0, index2).trim();
          if (obj[key2] == null) {
            var val = pair.substring(index2 + 1, pair.length).trim();
            val[0] === '"' && (val = val.slice(1, -1)), obj[key2] = tryDecode(val, dec);
          }
        }
      }
      return obj;
    }
    function serialize2(name, val, options2) {
      var opt = options2 || {}, enc = opt.encode || encode;
      if (typeof enc != "function")
        throw new TypeError("option encode is invalid");
      if (!fieldContentRegExp.test(name))
        throw new TypeError("argument name is invalid");
      var value2 = enc(val);
      if (value2 && !fieldContentRegExp.test(value2))
        throw new TypeError("argument val is invalid");
      var str2 = name + "=" + value2;
      if (opt.maxAge != null) {
        var maxAge = opt.maxAge - 0;
        if (isNaN(maxAge) || !isFinite(maxAge))
          throw new TypeError("option maxAge is invalid");
        str2 += "; Max-Age=" + Math.floor(maxAge);
      }
      if (opt.domain) {
        if (!fieldContentRegExp.test(opt.domain))
          throw new TypeError("option domain is invalid");
        str2 += "; Domain=" + opt.domain;
      }
      if (opt.path) {
        if (!fieldContentRegExp.test(opt.path))
          throw new TypeError("option path is invalid");
        str2 += "; Path=" + opt.path;
      }
      if (opt.expires) {
        if (typeof opt.expires.toUTCString != "function")
          throw new TypeError("option expires is invalid");
        str2 += "; Expires=" + opt.expires.toUTCString();
      }
      if (opt.httpOnly && (str2 += "; HttpOnly"), opt.secure && (str2 += "; Secure"), opt.sameSite) {
        var sameSite = typeof opt.sameSite == "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
        switch (sameSite) {
          case !0:
            str2 += "; SameSite=Strict";
            break;
          case "lax":
            str2 += "; SameSite=Lax";
            break;
          case "strict":
            str2 += "; SameSite=Strict";
            break;
          case "none":
            str2 += "; SameSite=None";
            break;
          default:
            throw new TypeError("option sameSite is invalid");
        }
      }
      return str2;
    }
    function tryDecode(str2, decode2) {
      try {
        return decode2(str2);
      } catch {
        return str2;
      }
    }
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/warnings.js
function warnOnce(condition, message) {
  !condition && !alreadyWarned[message] && (alreadyWarned[message] = !0, console.warn(message));
}
var alreadyWarned, init_warnings = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/warnings.js"() {
    alreadyWarned = {};
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/cookies.js
async function encodeCookieValue(sign2, value2, secrets) {
  let encoded = encodeData(value2);
  return secrets.length > 0 && (encoded = await sign2(encoded, secrets[0])), encoded;
}
async function decodeCookieValue(unsign, value2, secrets) {
  if (secrets.length > 0) {
    for (let secret of secrets) {
      let unsignedValue = await unsign(value2, secret);
      if (unsignedValue !== !1)
        return decodeData(unsignedValue);
    }
    return null;
  }
  return decodeData(value2);
}
function encodeData(value2) {
  return btoa(myUnescape(encodeURIComponent(JSON.stringify(value2))));
}
function decodeData(value2) {
  try {
    return JSON.parse(decodeURIComponent(myEscape(atob(value2))));
  } catch {
    return {};
  }
}
function myEscape(value2) {
  let str2 = value2.toString(), result2 = "", index2 = 0, chr, code;
  for (; index2 < str2.length; )
    chr = str2.charAt(index2++), /[\w*+\-./@]/.exec(chr) ? result2 += chr : (code = chr.charCodeAt(0), code < 256 ? result2 += "%" + hex(code, 2) : result2 += "%u" + hex(code, 4).toUpperCase());
  return result2;
}
function hex(code, length) {
  let result2 = code.toString(16);
  for (; result2.length < length; )
    result2 = "0" + result2;
  return result2;
}
function myUnescape(value2) {
  let str2 = value2.toString(), result2 = "", index2 = 0, chr, part;
  for (; index2 < str2.length; ) {
    if (chr = str2.charAt(index2++), chr === "%") {
      if (str2.charAt(index2) === "u") {
        if (part = str2.slice(index2 + 1, index2 + 5), /^[\da-f]{4}$/i.exec(part)) {
          result2 += String.fromCharCode(parseInt(part, 16)), index2 += 5;
          continue;
        }
      } else if (part = str2.slice(index2, index2 + 2), /^[\da-f]{2}$/i.exec(part)) {
        result2 += String.fromCharCode(parseInt(part, 16)), index2 += 2;
        continue;
      }
    }
    result2 += chr;
  }
  return result2;
}
function warnOnceAboutExpiresCookie(name, expires) {
  warnOnce(!expires, `The "${name}" cookie has an "expires" property set. This will cause the expires value to not be updated when the session is committed. Instead, you should set the expires value when serializing the cookie. You can use \`commitSession(session, { expires })\` if using a session storage object, or \`cookie.serialize("value", { expires })\` if you're using the cookie directly.`);
}
var import_cookie, createCookieFactory, isCookie, init_cookies = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/cookies.js"() {
    import_cookie = __toESM(require_cookie());
    init_warnings();
    createCookieFactory = ({
      sign: sign2,
      unsign
    }) => (name, cookieOptions = {}) => {
      let {
        secrets,
        ...options2
      } = {
        secrets: [],
        path: "/",
        sameSite: "lax",
        ...cookieOptions
      };
      return warnOnceAboutExpiresCookie(name, options2.expires), {
        get name() {
          return name;
        },
        get isSigned() {
          return secrets.length > 0;
        },
        get expires() {
          return typeof options2.maxAge < "u" ? new Date(Date.now() + options2.maxAge * 1e3) : options2.expires;
        },
        async parse(cookieHeader, parseOptions) {
          if (!cookieHeader)
            return null;
          let cookies = (0, import_cookie.parse)(cookieHeader, {
            ...options2,
            ...parseOptions
          });
          return name in cookies ? cookies[name] === "" ? "" : await decodeCookieValue(unsign, cookies[name], secrets) : null;
        },
        async serialize(value2, serializeOptions) {
          return (0, import_cookie.serialize)(name, value2 === "" ? "" : await encodeCookieValue(sign2, value2, secrets), {
            ...options2,
            ...serializeOptions
          });
        }
      };
    }, isCookie = (object) => object != null && typeof object.name == "string" && typeof object.isSigned == "boolean" && typeof object.parse == "function" && typeof object.serialize == "function";
  }
});

// node_modules/@web3-storage/multipart-parser/esm/src/utils.js
function stringToArray(s3) {
  let utf8 = unescape(encodeURIComponent(s3));
  return Uint8Array.from(utf8, (_24, i3) => utf8.charCodeAt(i3));
}
function arrayToString(a3) {
  let utf8 = String.fromCharCode.apply(null, a3);
  return decodeURIComponent(escape(utf8));
}
function mergeArrays(...arrays) {
  let out = new Uint8Array(arrays.reduce((total, arr2) => total + arr2.length, 0)), offset = 0;
  for (let arr2 of arrays)
    out.set(arr2, offset), offset += arr2.length;
  return out;
}
function arraysEqual(a3, b2) {
  if (a3.length !== b2.length)
    return !1;
  for (let i3 = 0; i3 < a3.length; i3++)
    if (a3[i3] !== b2[i3])
      return !1;
  return !0;
}
var init_utils = __esm({
  "node_modules/@web3-storage/multipart-parser/esm/src/utils.js"() {
  }
});

// node_modules/@web3-storage/multipart-parser/esm/src/search.js
function coerce(a3) {
  return a3 instanceof Uint8Array ? (index2) => a3[index2] : a3;
}
function jsmemcmp(buf1, pos1, buf2, pos2, len) {
  let fn1 = coerce(buf1), fn2 = coerce(buf2);
  for (let i3 = 0; i3 < len; ++i3)
    if (fn1(pos1 + i3) !== fn2(pos2 + i3))
      return !1;
  return !0;
}
function createOccurenceTable(s3) {
  let table = new Array(256).fill(s3.length);
  if (s3.length > 1)
    for (let i3 = 0; i3 < s3.length - 1; i3++)
      table[s3[i3]] = s3.length - 1 - i3;
  return table;
}
var MATCH, StreamSearch, ReadableStreamSearch, EOQ, QueueableStreamSearch, init_search = __esm({
  "node_modules/@web3-storage/multipart-parser/esm/src/search.js"() {
    init_utils();
    MATCH = Symbol("Match"), StreamSearch = class {
      constructor(needle) {
        this._lookbehind = new Uint8Array(), typeof needle == "string" ? this._needle = needle = stringToArray(needle) : this._needle = needle, this._lastChar = needle[needle.length - 1], this._occ = createOccurenceTable(needle);
      }
      feed(chunk) {
        let pos2 = 0, tokens, allTokens = [];
        for (; pos2 !== chunk.length; )
          [pos2, ...tokens] = this._feed(chunk, pos2), allTokens.push(...tokens);
        return allTokens;
      }
      end() {
        let tail = this._lookbehind;
        return this._lookbehind = new Uint8Array(), tail;
      }
      _feed(data2, bufPos) {
        let tokens = [], pos2 = -this._lookbehind.length;
        if (pos2 < 0) {
          for (; pos2 < 0 && pos2 <= data2.length - this._needle.length; ) {
            let ch = this._charAt(data2, pos2 + this._needle.length - 1);
            if (ch === this._lastChar && this._memcmp(data2, pos2, this._needle.length - 1))
              return pos2 > -this._lookbehind.length && tokens.push(this._lookbehind.slice(0, this._lookbehind.length + pos2)), tokens.push(MATCH), this._lookbehind = new Uint8Array(), [
                pos2 + this._needle.length,
                ...tokens
              ];
            pos2 += this._occ[ch];
          }
          if (pos2 < 0)
            for (; pos2 < 0 && !this._memcmp(data2, pos2, data2.length - pos2); )
              pos2++;
          if (pos2 >= 0)
            tokens.push(this._lookbehind), this._lookbehind = new Uint8Array();
          else {
            let bytesToCutOff = this._lookbehind.length + pos2;
            return bytesToCutOff > 0 && (tokens.push(this._lookbehind.slice(0, bytesToCutOff)), this._lookbehind = this._lookbehind.slice(bytesToCutOff)), this._lookbehind = Uint8Array.from(new Array(this._lookbehind.length + data2.length), (_24, i3) => this._charAt(data2, i3 - this._lookbehind.length)), [
              data2.length,
              ...tokens
            ];
          }
        }
        for (pos2 += bufPos; pos2 <= data2.length - this._needle.length; ) {
          let ch = data2[pos2 + this._needle.length - 1];
          if (ch === this._lastChar && data2[pos2] === this._needle[0] && jsmemcmp(this._needle, 0, data2, pos2, this._needle.length - 1))
            return pos2 > bufPos && tokens.push(data2.slice(bufPos, pos2)), tokens.push(MATCH), [
              pos2 + this._needle.length,
              ...tokens
            ];
          pos2 += this._occ[ch];
        }
        if (pos2 < data2.length) {
          for (; pos2 < data2.length && (data2[pos2] !== this._needle[0] || !jsmemcmp(data2, pos2, this._needle, 0, data2.length - pos2)); )
            ++pos2;
          pos2 < data2.length && (this._lookbehind = data2.slice(pos2));
        }
        return pos2 > 0 && tokens.push(data2.slice(bufPos, pos2 < data2.length ? pos2 : data2.length)), [
          data2.length,
          ...tokens
        ];
      }
      _charAt(data2, pos2) {
        return pos2 < 0 ? this._lookbehind[this._lookbehind.length + pos2] : data2[pos2];
      }
      _memcmp(data2, pos2, len) {
        return jsmemcmp(this._charAt.bind(this, data2), pos2, this._needle, 0, len);
      }
    }, ReadableStreamSearch = class {
      constructor(needle, _readableStream) {
        this._readableStream = _readableStream, this._search = new StreamSearch(needle);
      }
      async *[Symbol.asyncIterator]() {
        let reader = this._readableStream.getReader();
        try {
          for (; ; ) {
            let result2 = await reader.read();
            if (result2.done)
              break;
            yield* this._search.feed(result2.value);
          }
          let tail = this._search.end();
          tail.length && (yield tail);
        } finally {
          reader.releaseLock();
        }
      }
    }, EOQ = Symbol("End of Queue"), QueueableStreamSearch = class {
      constructor(needle) {
        this._chunksQueue = [], this._closed = !1, this._search = new StreamSearch(needle);
      }
      push(...chunks) {
        if (this._closed)
          throw new Error("cannot call push after close");
        this._chunksQueue.push(...chunks), this._notify && this._notify();
      }
      close() {
        if (this._closed)
          throw new Error("close was already called");
        this._closed = !0, this._chunksQueue.push(EOQ), this._notify && this._notify();
      }
      async *[Symbol.asyncIterator]() {
        for (; ; ) {
          let chunk;
          for (; !(chunk = this._chunksQueue.shift()); )
            await new Promise((resolve2) => this._notify = resolve2), this._notify = void 0;
          if (chunk === EOQ)
            break;
          yield* this._search.feed(chunk);
        }
        let tail = this._search.end();
        tail.length && (yield tail);
      }
    };
  }
});

// node_modules/@web3-storage/multipart-parser/esm/src/index.js
function parseContentDisposition(header) {
  let parts = header.split(";").map((part) => part.trim());
  if (parts.shift() !== "form-data")
    throw new Error('malformed content-disposition header: missing "form-data" in `' + JSON.stringify(parts) + "`");
  let out = {};
  for (let part of parts) {
    let kv = part.split("=", 2);
    if (kv.length !== 2)
      throw new Error("malformed content-disposition header: key-value pair not found - " + part + " in `" + header + "`");
    let [name, value2] = kv;
    if (value2[0] === '"' && value2[value2.length - 1] === '"')
      out[name] = value2.slice(1, -1).replace(/\\"/g, '"');
    else if (value2[0] !== '"' && value2[value2.length - 1] !== '"')
      out[name] = value2;
    else if (value2[0] === '"' && value2[value2.length - 1] !== '"' || value2[0] !== '"' && value2[value2.length - 1] === '"')
      throw new Error("malformed content-disposition header: mismatched quotations in `" + header + "`");
  }
  if (!out.name)
    throw new Error("malformed content-disposition header: missing field name in `" + header + "`");
  return out;
}
function parsePartHeaders(lines) {
  let entries = [], disposition = !1, line2;
  for (; typeof (line2 = lines.shift()) < "u"; ) {
    let colon = line2.indexOf(":");
    if (colon === -1)
      throw new Error("malformed multipart-form header: missing colon");
    let header = line2.slice(0, colon).trim().toLowerCase(), value2 = line2.slice(colon + 1).trim();
    switch (header) {
      case "content-disposition":
        disposition = !0, entries.push(...Object.entries(parseContentDisposition(value2)));
        break;
      case "content-type":
        entries.push([
          "contentType",
          value2
        ]);
    }
  }
  if (!disposition)
    throw new Error("malformed multipart-form header: missing content-disposition");
  return Object.fromEntries(entries);
}
async function readHeaderLines(it, needle) {
  let firstChunk = !0, lastTokenWasMatch = !1, headerLines = [[]], crlfSearch = new StreamSearch(CRLF);
  for (; ; ) {
    let result2 = await it.next();
    if (result2.done)
      throw new Error("malformed multipart-form data: unexpected end of stream");
    if (firstChunk && result2.value !== MATCH && arraysEqual(result2.value.slice(0, 2), dash))
      return [
        void 0,
        new Uint8Array()
      ];
    let chunk;
    if (result2.value !== MATCH)
      chunk = result2.value;
    else if (!lastTokenWasMatch)
      chunk = needle;
    else
      throw new Error("malformed multipart-form data: unexpected boundary");
    if (!chunk.length)
      continue;
    firstChunk && (firstChunk = !1);
    let tokens = crlfSearch.feed(chunk);
    for (let [i3, token2] of tokens.entries()) {
      let isMatch = token2 === MATCH;
      if (!(!isMatch && !token2.length)) {
        if (lastTokenWasMatch && isMatch)
          return tokens.push(crlfSearch.end()), [
            headerLines.filter((chunks) => chunks.length).map(mergeArrays2).map(arrayToString),
            mergeArrays(...tokens.slice(i3 + 1).map((token3) => token3 === MATCH ? CRLF : token3))
          ];
        (lastTokenWasMatch = isMatch) ? headerLines.push([]) : headerLines[headerLines.length - 1].push(token2);
      }
    }
  }
}
async function* streamMultipart(body, boundary) {
  let needle = mergeArrays(dash, stringToArray(boundary)), it = new ReadableStreamSearch(needle, body)[Symbol.asyncIterator]();
  for (; ; ) {
    let result2 = await it.next();
    if (result2.done)
      return;
    if (result2.value === MATCH)
      break;
  }
  let crlfSearch = new StreamSearch(CRLF);
  for (; ; ) {
    let feedChunk = function(chunk) {
      let chunks = [];
      for (let token2 of crlfSearch.feed(chunk))
        trailingCRLF && chunks.push(CRLF), (trailingCRLF = token2 === MATCH) || chunks.push(token2);
      return mergeArrays(...chunks);
    }, [headerLines, tail] = await readHeaderLines(it, needle);
    if (!headerLines)
      return;
    async function nextToken() {
      let result2 = await it.next();
      if (result2.done)
        throw new Error("malformed multipart-form data: unexpected end of stream");
      return result2;
    }
    let trailingCRLF = !1, done2 = !1;
    async function nextChunk() {
      let result2 = await nextToken(), chunk;
      if (result2.value !== MATCH)
        chunk = result2.value;
      else if (!trailingCRLF)
        chunk = CRLF;
      else
        return done2 = !0, { value: crlfSearch.end() };
      return { value: feedChunk(chunk) };
    }
    let bufferedChunks = [{ value: feedChunk(tail) }];
    for (yield {
      ...parsePartHeaders(headerLines),
      data: {
        [Symbol.asyncIterator]() {
          return this;
        },
        async next() {
          for (; ; ) {
            let result2 = bufferedChunks.shift();
            if (!result2)
              break;
            if (result2.value.length > 0)
              return result2;
          }
          for (; ; ) {
            if (done2)
              return {
                done: done2,
                value: void 0
              };
            let result2 = await nextChunk();
            if (result2.value.length > 0)
              return result2;
          }
        }
      }
    }; !done2; )
      bufferedChunks.push(await nextChunk());
  }
}
var mergeArrays2, dash, CRLF, init_src = __esm({
  "node_modules/@web3-storage/multipart-parser/esm/src/index.js"() {
    init_search();
    init_utils();
    mergeArrays2 = Function.prototype.apply.bind(mergeArrays, void 0), dash = stringToArray("--"), CRLF = stringToArray(`\r
`);
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/formData.js
function composeUploadHandlers(...handlers) {
  return async (part) => {
    for (let handler of handlers) {
      let value2 = await handler(part);
      if (typeof value2 < "u" && value2 !== null)
        return value2;
    }
  };
}
async function parseMultipartFormData(request, uploadHandler) {
  let contentType = request.headers.get("Content-Type") || "", [type2, boundary] = contentType.split(/\s*;\s*boundary=/);
  if (!request.body || !boundary || type2 !== "multipart/form-data")
    throw new TypeError("Could not parse content as FormData.");
  let formData = new FormData(), parts = streamMultipart(request.body, boundary);
  for await (let part of parts) {
    if (part.done)
      break;
    typeof part.filename == "string" && (part.filename = part.filename.split(/[/\\]/).pop());
    let value2 = await uploadHandler(part);
    typeof value2 < "u" && value2 !== null && formData.append(part.name, value2);
  }
  return formData;
}
var init_formData = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/formData.js"() {
    init_src();
  }
});

// node_modules/@remix-run/router/dist/router.js
var router_exports = {};
__export(router_exports, {
  AbortedDeferredError: () => AbortedDeferredError,
  Action: () => Action,
  ErrorResponse: () => ErrorResponse,
  IDLE_BLOCKER: () => IDLE_BLOCKER,
  IDLE_FETCHER: () => IDLE_FETCHER,
  IDLE_NAVIGATION: () => IDLE_NAVIGATION,
  UNSAFE_DEFERRED_SYMBOL: () => UNSAFE_DEFERRED_SYMBOL,
  UNSAFE_DeferredData: () => DeferredData,
  UNSAFE_convertRoutesToDataRoutes: () => convertRoutesToDataRoutes,
  UNSAFE_getPathContributingMatches: () => getPathContributingMatches,
  UNSAFE_invariant: () => invariant,
  UNSAFE_warning: () => warning,
  createBrowserHistory: () => createBrowserHistory,
  createHashHistory: () => createHashHistory,
  createMemoryHistory: () => createMemoryHistory,
  createPath: () => createPath,
  createRouter: () => createRouter,
  createStaticHandler: () => createStaticHandler,
  defer: () => defer,
  generatePath: () => generatePath,
  getStaticContextFromError: () => getStaticContextFromError,
  getToPathname: () => getToPathname,
  isDeferredData: () => isDeferredData,
  isRouteErrorResponse: () => isRouteErrorResponse,
  joinPaths: () => joinPaths,
  json: () => json,
  matchPath: () => matchPath,
  matchRoutes: () => matchRoutes,
  normalizePathname: () => normalizePathname,
  parsePath: () => parsePath,
  redirect: () => redirect,
  resolvePath: () => resolvePath,
  resolveTo: () => resolveTo,
  stripBasename: () => stripBasename
});
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source2 = arguments[i3];
      for (var key2 in source2)
        Object.prototype.hasOwnProperty.call(source2, key2) && (target[key2] = source2[key2]);
    }
    return target;
  }, _extends.apply(this, arguments);
}
function createMemoryHistory(options2) {
  options2 === void 0 && (options2 = {});
  let {
    initialEntries = ["/"],
    initialIndex,
    v5Compat = !1
  } = options2, entries;
  entries = initialEntries.map((entry2, index3) => createMemoryLocation(entry2, typeof entry2 == "string" ? null : entry2.state, index3 === 0 ? "default" : void 0));
  let index2 = clampIndex(initialIndex ?? entries.length - 1), action3 = Action.Pop, listener = null;
  function clampIndex(n3) {
    return Math.min(Math.max(n3, 0), entries.length - 1);
  }
  function getCurrentLocation() {
    return entries[index2];
  }
  function createMemoryLocation(to, state, key2) {
    state === void 0 && (state = null);
    let location = createLocation(entries ? getCurrentLocation().pathname : "/", to, state, key2);
    return warning(location.pathname.charAt(0) === "/", "relative pathnames are not supported in memory history: " + JSON.stringify(to)), location;
  }
  function createHref(to) {
    return typeof to == "string" ? to : createPath(to);
  }
  return {
    get index() {
      return index2;
    },
    get action() {
      return action3;
    },
    get location() {
      return getCurrentLocation();
    },
    createHref,
    createURL(to) {
      return new URL(createHref(to), "http://localhost");
    },
    encodeLocation(to) {
      let path2 = typeof to == "string" ? parsePath(to) : to;
      return {
        pathname: path2.pathname || "",
        search: path2.search || "",
        hash: path2.hash || ""
      };
    },
    push(to, state) {
      action3 = Action.Push;
      let nextLocation = createMemoryLocation(to, state);
      index2 += 1, entries.splice(index2, entries.length, nextLocation), v5Compat && listener && listener({
        action: action3,
        location: nextLocation,
        delta: 1
      });
    },
    replace(to, state) {
      action3 = Action.Replace;
      let nextLocation = createMemoryLocation(to, state);
      entries[index2] = nextLocation, v5Compat && listener && listener({
        action: action3,
        location: nextLocation,
        delta: 0
      });
    },
    go(delta) {
      action3 = Action.Pop;
      let nextIndex = clampIndex(index2 + delta), nextLocation = entries[nextIndex];
      index2 = nextIndex, listener && listener({
        action: action3,
        location: nextLocation,
        delta
      });
    },
    listen(fn) {
      return listener = fn, () => {
        listener = null;
      };
    }
  };
}
function createBrowserHistory(options2) {
  options2 === void 0 && (options2 = {});
  function createBrowserLocation(window2, globalHistory) {
    let {
      pathname,
      search,
      hash
    } = window2.location;
    return createLocation(
      "",
      {
        pathname,
        search,
        hash
      },
      globalHistory.state && globalHistory.state.usr || null,
      globalHistory.state && globalHistory.state.key || "default"
    );
  }
  function createBrowserHref(window2, to) {
    return typeof to == "string" ? to : createPath(to);
  }
  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options2);
}
function createHashHistory(options2) {
  options2 === void 0 && (options2 = {});
  function createHashLocation(window2, globalHistory) {
    let {
      pathname = "/",
      search = "",
      hash = ""
    } = parsePath(window2.location.hash.substr(1));
    return createLocation(
      "",
      {
        pathname,
        search,
        hash
      },
      globalHistory.state && globalHistory.state.usr || null,
      globalHistory.state && globalHistory.state.key || "default"
    );
  }
  function createHashHref(window2, to) {
    let base = window2.document.querySelector("base"), href = "";
    if (base && base.getAttribute("href")) {
      let url = window2.location.href, hashIndex = url.indexOf("#");
      href = hashIndex === -1 ? url : url.slice(0, hashIndex);
    }
    return href + "#" + (typeof to == "string" ? to : createPath(to));
  }
  function validateHashLocation(location, to) {
    warning(location.pathname.charAt(0) === "/", "relative pathnames are not supported in hash history.push(" + JSON.stringify(to) + ")");
  }
  return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options2);
}
function invariant(value2, message) {
  if (value2 === !1 || value2 === null || typeof value2 > "u")
    throw new Error(message);
}
function warning(cond, message) {
  if (!cond) {
    typeof console < "u" && console.warn(message);
    try {
      throw new Error(message);
    } catch {
    }
  }
}
function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
function getHistoryState(location, index2) {
  return {
    usr: location.state,
    key: location.key,
    idx: index2
  };
}
function createLocation(current, to, state, key2) {
  return state === void 0 && (state = null), _extends({
    pathname: typeof current == "string" ? current : current.pathname,
    search: "",
    hash: ""
  }, typeof to == "string" ? parsePath(to) : to, {
    state,
    key: to && to.key || key2 || createKey()
  });
}
function createPath(_ref) {
  let {
    pathname = "/",
    search = "",
    hash = ""
  } = _ref;
  return search && search !== "?" && (pathname += search.charAt(0) === "?" ? search : "?" + search), hash && hash !== "#" && (pathname += hash.charAt(0) === "#" ? hash : "#" + hash), pathname;
}
function parsePath(path2) {
  let parsedPath = {};
  if (path2) {
    let hashIndex = path2.indexOf("#");
    hashIndex >= 0 && (parsedPath.hash = path2.substr(hashIndex), path2 = path2.substr(0, hashIndex));
    let searchIndex = path2.indexOf("?");
    searchIndex >= 0 && (parsedPath.search = path2.substr(searchIndex), path2 = path2.substr(0, searchIndex)), path2 && (parsedPath.pathname = path2);
  }
  return parsedPath;
}
function getUrlBasedHistory(getLocation, createHref, validateLocation, options2) {
  options2 === void 0 && (options2 = {});
  let {
    window: window2 = document.defaultView,
    v5Compat = !1
  } = options2, globalHistory = window2.history, action3 = Action.Pop, listener = null, index2 = getIndex();
  index2 == null && (index2 = 0, globalHistory.replaceState(_extends({}, globalHistory.state, {
    idx: index2
  }), ""));
  function getIndex() {
    return (globalHistory.state || {
      idx: null
    }).idx;
  }
  function handlePop() {
    action3 = Action.Pop;
    let nextIndex = getIndex(), delta = nextIndex == null ? null : nextIndex - index2;
    index2 = nextIndex, listener && listener({
      action: action3,
      location: history.location,
      delta
    });
  }
  function push2(to, state) {
    action3 = Action.Push;
    let location = createLocation(history.location, to, state);
    validateLocation && validateLocation(location, to), index2 = getIndex() + 1;
    let historyState = getHistoryState(location, index2), url = history.createHref(location);
    try {
      globalHistory.pushState(historyState, "", url);
    } catch {
      window2.location.assign(url);
    }
    v5Compat && listener && listener({
      action: action3,
      location: history.location,
      delta: 1
    });
  }
  function replace(to, state) {
    action3 = Action.Replace;
    let location = createLocation(history.location, to, state);
    validateLocation && validateLocation(location, to), index2 = getIndex();
    let historyState = getHistoryState(location, index2), url = history.createHref(location);
    globalHistory.replaceState(historyState, "", url), v5Compat && listener && listener({
      action: action3,
      location: history.location,
      delta: 0
    });
  }
  function createURL(to) {
    let base = window2.location.origin !== "null" ? window2.location.origin : window2.location.href, href = typeof to == "string" ? to : createPath(to);
    return invariant(base, "No window.location.(origin|href) available to create URL for href: " + href), new URL(href, base);
  }
  let history = {
    get action() {
      return action3;
    },
    get location() {
      return getLocation(window2, globalHistory);
    },
    listen(fn) {
      if (listener)
        throw new Error("A history only accepts one active listener");
      return window2.addEventListener(PopStateEventType, handlePop), listener = fn, () => {
        window2.removeEventListener(PopStateEventType, handlePop), listener = null;
      };
    },
    createHref(to) {
      return createHref(window2, to);
    },
    createURL,
    encodeLocation(to) {
      let url = createURL(to);
      return {
        pathname: url.pathname,
        search: url.search,
        hash: url.hash
      };
    },
    push: push2,
    replace,
    go(n3) {
      return globalHistory.go(n3);
    }
  };
  return history;
}
function isIndexRoute(route) {
  return route.index === !0;
}
function convertRoutesToDataRoutes(routes2, detectErrorBoundary2, parentPath, manifest) {
  return parentPath === void 0 && (parentPath = []), manifest === void 0 && (manifest = {}), routes2.map((route, index2) => {
    let treePath = [...parentPath, index2], id4 = typeof route.id == "string" ? route.id : treePath.join("-");
    if (invariant(route.index !== !0 || !route.children, "Cannot specify children on an index route"), invariant(!manifest[id4], 'Found a route id collision on id "' + id4 + `".  Route id's must be globally unique within Data Router usages`), isIndexRoute(route)) {
      let indexRoute = _extends({}, route, {
        hasErrorBoundary: detectErrorBoundary2(route),
        id: id4
      });
      return manifest[id4] = indexRoute, indexRoute;
    } else {
      let pathOrLayoutRoute = _extends({}, route, {
        id: id4,
        hasErrorBoundary: detectErrorBoundary2(route),
        children: void 0
      });
      return manifest[id4] = pathOrLayoutRoute, route.children && (pathOrLayoutRoute.children = convertRoutesToDataRoutes(route.children, detectErrorBoundary2, treePath, manifest)), pathOrLayoutRoute;
    }
  });
}
function matchRoutes(routes2, locationArg, basename2) {
  basename2 === void 0 && (basename2 = "/");
  let location = typeof locationArg == "string" ? parsePath(locationArg) : locationArg, pathname = stripBasename(location.pathname || "/", basename2);
  if (pathname == null)
    return null;
  let branches = flattenRoutes(routes2);
  rankRouteBranches(branches);
  let matches = null;
  for (let i3 = 0; matches == null && i3 < branches.length; ++i3)
    matches = matchRouteBranch(
      branches[i3],
      safelyDecodeURI(pathname)
    );
  return matches;
}
function flattenRoutes(routes2, branches, parentsMeta, parentPath) {
  branches === void 0 && (branches = []), parentsMeta === void 0 && (parentsMeta = []), parentPath === void 0 && (parentPath = "");
  let flattenRoute = (route, index2, relativePath) => {
    let meta2 = {
      relativePath: relativePath === void 0 ? route.path || "" : relativePath,
      caseSensitive: route.caseSensitive === !0,
      childrenIndex: index2,
      route
    };
    meta2.relativePath.startsWith("/") && (invariant(meta2.relativePath.startsWith(parentPath), 'Absolute route path "' + meta2.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."), meta2.relativePath = meta2.relativePath.slice(parentPath.length));
    let path2 = joinPaths([parentPath, meta2.relativePath]), routesMeta = parentsMeta.concat(meta2);
    route.children && route.children.length > 0 && (invariant(
      route.index !== !0,
      "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path2 + '".')
    ), flattenRoutes(route.children, branches, routesMeta, path2)), !(route.path == null && !route.index) && branches.push({
      path: path2,
      score: computeScore(path2, route.index),
      routesMeta
    });
  };
  return routes2.forEach((route, index2) => {
    var _route$path;
    if (route.path === "" || !((_route$path = route.path) != null && _route$path.includes("?")))
      flattenRoute(route, index2);
    else
      for (let exploded of explodeOptionalSegments(route.path))
        flattenRoute(route, index2, exploded);
  }), branches;
}
function explodeOptionalSegments(path2) {
  let segments = path2.split("/");
  if (segments.length === 0)
    return [];
  let [first, ...rest] = segments, isOptional = first.endsWith("?"), required = first.replace(/\?$/, "");
  if (rest.length === 0)
    return isOptional ? [required, ""] : [required];
  let restExploded = explodeOptionalSegments(rest.join("/")), result2 = [];
  return result2.push(...restExploded.map((subpath) => subpath === "" ? required : [required, subpath].join("/"))), isOptional && result2.push(...restExploded), result2.map((exploded) => path2.startsWith("/") && exploded === "" ? "/" : exploded);
}
function rankRouteBranches(branches) {
  branches.sort((a3, b2) => a3.score !== b2.score ? b2.score - a3.score : compareIndexes(a3.routesMeta.map((meta2) => meta2.childrenIndex), b2.routesMeta.map((meta2) => meta2.childrenIndex)));
}
function computeScore(path2, index2) {
  let segments = path2.split("/"), initialScore = segments.length;
  return segments.some(isSplat) && (initialScore += splatPenalty), index2 && (initialScore += indexRouteValue), segments.filter((s3) => !isSplat(s3)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
function compareIndexes(a3, b2) {
  return a3.length === b2.length && a3.slice(0, -1).every((n3, i3) => n3 === b2[i3]) ? a3[a3.length - 1] - b2[b2.length - 1] : 0;
}
function matchRouteBranch(branch, pathname) {
  let {
    routesMeta
  } = branch, matchedParams = {}, matchedPathname = "/", matches = [];
  for (let i3 = 0; i3 < routesMeta.length; ++i3) {
    let meta2 = routesMeta[i3], end3 = i3 === routesMeta.length - 1, remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/", match = matchPath({
      path: meta2.relativePath,
      caseSensitive: meta2.caseSensitive,
      end: end3
    }, remainingPathname);
    if (!match)
      return null;
    Object.assign(matchedParams, match.params);
    let route = meta2.route;
    matches.push({
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match.pathname]),
      pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),
      route
    }), match.pathnameBase !== "/" && (matchedPathname = joinPaths([matchedPathname, match.pathnameBase]));
  }
  return matches;
}
function generatePath(originalPath, params) {
  params === void 0 && (params = {});
  let path2 = originalPath;
  path2.endsWith("*") && path2 !== "*" && !path2.endsWith("/*") && (warning(!1, 'Route path "' + path2 + '" will be treated as if it were ' + ('"' + path2.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path2.replace(/\*$/, "/*") + '".')), path2 = path2.replace(/\*$/, "/*"));
  let prefix = path2.startsWith("/") ? "/" : "", segments = path2.split(/\/+/).map((segment, index2, array) => {
    if (index2 === array.length - 1 && segment === "*")
      return params["*"];
    let keyMatch = segment.match(/^:(\w+)(\??)$/);
    if (keyMatch) {
      let [, key2, optional] = keyMatch, param = params[key2];
      return optional === "?" ? param ?? "" : (param == null && invariant(!1, 'Missing ":' + key2 + '" param'), param);
    }
    return segment.replace(/\?$/g, "");
  }).filter((segment) => !!segment);
  return prefix + segments.join("/");
}
function matchPath(pattern, pathname) {
  typeof pattern == "string" && (pattern = {
    path: pattern,
    caseSensitive: !1,
    end: !0
  });
  let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end), match = pathname.match(matcher);
  if (!match)
    return null;
  let matchedPathname = match[0], pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1"), captureGroups = match.slice(1);
  return {
    params: paramNames.reduce((memo13, paramName, index2) => {
      if (paramName === "*") {
        let splatValue = captureGroups[index2] || "";
        pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
      }
      return memo13[paramName] = safelyDecodeURIComponent(captureGroups[index2] || "", paramName), memo13;
    }, {}),
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path2, caseSensitive, end3) {
  caseSensitive === void 0 && (caseSensitive = !1), end3 === void 0 && (end3 = !0), warning(path2 === "*" || !path2.endsWith("*") || path2.endsWith("/*"), 'Route path "' + path2 + '" will be treated as if it were ' + ('"' + path2.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path2.replace(/\*$/, "/*") + '".'));
  let paramNames = [], regexpSource = "^" + path2.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/\/:(\w+)/g, (_24, paramName) => (paramNames.push(paramName), "/([^\\/]+)"));
  return path2.endsWith("*") ? (paramNames.push("*"), regexpSource += path2 === "*" || path2 === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : end3 ? regexpSource += "\\/*$" : path2 !== "" && path2 !== "/" && (regexpSource += "(?:(?=\\/|$))"), [new RegExp(regexpSource, caseSensitive ? void 0 : "i"), paramNames];
}
function safelyDecodeURI(value2) {
  try {
    return decodeURI(value2);
  } catch (error2) {
    return warning(!1, 'The URL path "' + value2 + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + error2 + ").")), value2;
  }
}
function safelyDecodeURIComponent(value2, paramName) {
  try {
    return decodeURIComponent(value2);
  } catch (error2) {
    return warning(!1, 'The value for the URL param "' + paramName + '" will not be decoded because' + (' the string "' + value2 + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + error2 + ").")), value2;
  }
}
function stripBasename(pathname, basename2) {
  if (basename2 === "/")
    return pathname;
  if (!pathname.toLowerCase().startsWith(basename2.toLowerCase()))
    return null;
  let startIndex = basename2.endsWith("/") ? basename2.length - 1 : basename2.length, nextChar = pathname.charAt(startIndex);
  return nextChar && nextChar !== "/" ? null : pathname.slice(startIndex) || "/";
}
function resolvePath(to, fromPathname) {
  fromPathname === void 0 && (fromPathname = "/");
  let {
    pathname: toPathname,
    search = "",
    hash = ""
  } = typeof to == "string" ? parsePath(to) : to;
  return {
    pathname: toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  return relativePath.split("/").forEach((segment) => {
    segment === ".." ? segments.length > 1 && segments.pop() : segment !== "." && segments.push(segment);
  }), segments.length > 1 ? segments.join("/") : "/";
}
function getInvalidPathError(char, field, dest, path2) {
  return "Cannot include a '" + char + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path2) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
}
function getPathContributingMatches(matches) {
  return matches.filter((match, index2) => index2 === 0 || match.route.path && match.route.path.length > 0);
}
function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
  isPathRelative === void 0 && (isPathRelative = !1);
  let to;
  typeof toArg == "string" ? to = parsePath(toArg) : (to = _extends({}, toArg), invariant(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to)), invariant(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to)), invariant(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to)));
  let isEmptyPath = toArg === "" || to.pathname === "", toPathname = isEmptyPath ? "/" : to.pathname, from2;
  if (isPathRelative || toPathname == null)
    from2 = locationPathname;
  else {
    let routePathnameIndex = routePathnames.length - 1;
    if (toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      for (; toSegments[0] === ".."; )
        toSegments.shift(), routePathnameIndex -= 1;
      to.pathname = toSegments.join("/");
    }
    from2 = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path2 = resolvePath(to, from2), hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/"), hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  return !path2.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash) && (path2.pathname += "/"), path2;
}
function getToPathname(to) {
  return to === "" || to.pathname === "" ? "/" : typeof to == "string" ? parsePath(to).pathname : to.pathname;
}
function isTrackedPromise(value2) {
  return value2 instanceof Promise && value2._tracked === !0;
}
function unwrapTrackedPromise(value2) {
  if (!isTrackedPromise(value2))
    return value2;
  if (value2._error)
    throw value2._error;
  return value2._data;
}
function isRouteErrorResponse(error2) {
  return error2 != null && typeof error2.status == "number" && typeof error2.statusText == "string" && typeof error2.internal == "boolean" && "data" in error2;
}
function createRouter(init4) {
  invariant(init4.routes.length > 0, "You must provide a non-empty routes array to createRouter");
  let detectErrorBoundary2 = init4.detectErrorBoundary || defaultDetectErrorBoundary, manifest = {}, dataRoutes = convertRoutesToDataRoutes(init4.routes, detectErrorBoundary2, void 0, manifest), inFlightDataRoutes, future2 = _extends({
    v7_normalizeFormMethod: !1
  }, init4.future), unlistenHistory = null, subscribers = /* @__PURE__ */ new Set(), savedScrollPositions2 = null, getScrollRestorationKey = null, getScrollPosition = null, initialScrollRestored = init4.hydrationData != null, initialMatches = matchRoutes(dataRoutes, init4.history.location, init4.basename), initialErrors = null;
  if (initialMatches == null) {
    let error2 = getInternalRouterError(404, {
      pathname: init4.history.location.pathname
    }), {
      matches,
      route
    } = getShortCircuitMatches(dataRoutes);
    initialMatches = matches, initialErrors = {
      [route.id]: error2
    };
  }
  let initialized = !initialMatches.some((m2) => m2.route.lazy) && (!initialMatches.some((m2) => m2.route.loader) || init4.hydrationData != null), router2, state = {
    historyAction: init4.history.action,
    location: init4.history.location,
    matches: initialMatches,
    initialized,
    navigation: IDLE_NAVIGATION,
    restoreScrollPosition: init4.hydrationData != null ? !1 : null,
    preventScrollReset: !1,
    revalidation: "idle",
    loaderData: init4.hydrationData && init4.hydrationData.loaderData || {},
    actionData: init4.hydrationData && init4.hydrationData.actionData || null,
    errors: init4.hydrationData && init4.hydrationData.errors || initialErrors,
    fetchers: /* @__PURE__ */ new Map(),
    blockers: /* @__PURE__ */ new Map()
  }, pendingAction = Action.Pop, pendingPreventScrollReset = !1, pendingNavigationController, isUninterruptedRevalidation = !1, isRevalidationRequired = !1, cancelledDeferredRoutes = [], cancelledFetcherLoads = [], fetchControllers = /* @__PURE__ */ new Map(), incrementingLoadId = 0, pendingNavigationLoadId = -1, fetchReloadIds = /* @__PURE__ */ new Map(), fetchRedirectIds = /* @__PURE__ */ new Set(), fetchLoadMatches = /* @__PURE__ */ new Map(), activeDeferreds = /* @__PURE__ */ new Map(), blockerFunctions = /* @__PURE__ */ new Map(), ignoreNextHistoryUpdate = !1;
  function initialize() {
    return unlistenHistory = init4.history.listen((_ref) => {
      let {
        action: historyAction,
        location,
        delta
      } = _ref;
      if (ignoreNextHistoryUpdate) {
        ignoreNextHistoryUpdate = !1;
        return;
      }
      warning(blockerFunctions.size === 0 || delta != null, "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.");
      let blockerKey = shouldBlockNavigation({
        currentLocation: state.location,
        nextLocation: location,
        historyAction
      });
      if (blockerKey && delta != null) {
        ignoreNextHistoryUpdate = !0, init4.history.go(delta * -1), updateBlocker(blockerKey, {
          state: "blocked",
          location,
          proceed() {
            updateBlocker(blockerKey, {
              state: "proceeding",
              proceed: void 0,
              reset: void 0,
              location
            }), init4.history.go(delta);
          },
          reset() {
            deleteBlocker(blockerKey), updateState({
              blockers: new Map(router2.state.blockers)
            });
          }
        });
        return;
      }
      return startNavigation(historyAction, location);
    }), state.initialized || startNavigation(Action.Pop, state.location), router2;
  }
  function dispose() {
    unlistenHistory && unlistenHistory(), subscribers.clear(), pendingNavigationController && pendingNavigationController.abort(), state.fetchers.forEach((_24, key2) => deleteFetcher(key2)), state.blockers.forEach((_24, key2) => deleteBlocker(key2));
  }
  function subscribe(fn) {
    return subscribers.add(fn), () => subscribers.delete(fn);
  }
  function updateState(newState) {
    state = _extends({}, state, newState), subscribers.forEach((subscriber) => subscriber(state));
  }
  function completeNavigation(location, newState) {
    var _location$state, _location$state2;
    let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === "loading" && ((_location$state = location.state) == null ? void 0 : _location$state._isRedirect) !== !0, actionData;
    newState.actionData ? Object.keys(newState.actionData).length > 0 ? actionData = newState.actionData : actionData = null : isActionReload ? actionData = state.actionData : actionData = null;
    let loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData;
    for (let [key2] of blockerFunctions)
      deleteBlocker(key2);
    let preventScrollReset = pendingPreventScrollReset === !0 || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && ((_location$state2 = location.state) == null ? void 0 : _location$state2._isRedirect) !== !0;
    inFlightDataRoutes && (dataRoutes = inFlightDataRoutes, inFlightDataRoutes = void 0), updateState(_extends({}, newState, {
      actionData,
      loaderData,
      historyAction: pendingAction,
      location,
      initialized: !0,
      navigation: IDLE_NAVIGATION,
      revalidation: "idle",
      restoreScrollPosition: getSavedScrollPosition(location, newState.matches || state.matches),
      preventScrollReset,
      blockers: new Map(state.blockers)
    })), isUninterruptedRevalidation || pendingAction === Action.Pop || (pendingAction === Action.Push ? init4.history.push(location, location.state) : pendingAction === Action.Replace && init4.history.replace(location, location.state)), pendingAction = Action.Pop, pendingPreventScrollReset = !1, isUninterruptedRevalidation = !1, isRevalidationRequired = !1, cancelledDeferredRoutes = [], cancelledFetcherLoads = [];
  }
  async function navigate(to, opts) {
    if (typeof to == "number") {
      init4.history.go(to);
      return;
    }
    let {
      path: path2,
      submission,
      error: error2
    } = normalizeNavigateOptions(to, future2, opts), currentLocation = state.location, nextLocation = createLocation(state.location, path2, opts && opts.state);
    nextLocation = _extends({}, nextLocation, init4.history.encodeLocation(nextLocation));
    let userReplace = opts && opts.replace != null ? opts.replace : void 0, historyAction = Action.Push;
    userReplace === !0 ? historyAction = Action.Replace : userReplace === !1 || submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search && (historyAction = Action.Replace);
    let preventScrollReset = opts && "preventScrollReset" in opts ? opts.preventScrollReset === !0 : void 0, blockerKey = shouldBlockNavigation({
      currentLocation,
      nextLocation,
      historyAction
    });
    if (blockerKey) {
      updateBlocker(blockerKey, {
        state: "blocked",
        location: nextLocation,
        proceed() {
          updateBlocker(blockerKey, {
            state: "proceeding",
            proceed: void 0,
            reset: void 0,
            location: nextLocation
          }), navigate(to, opts);
        },
        reset() {
          deleteBlocker(blockerKey), updateState({
            blockers: new Map(state.blockers)
          });
        }
      });
      return;
    }
    return await startNavigation(historyAction, nextLocation, {
      submission,
      pendingError: error2,
      preventScrollReset,
      replace: opts && opts.replace
    });
  }
  function revalidate() {
    if (interruptActiveLoads(), updateState({
      revalidation: "loading"
    }), state.navigation.state !== "submitting") {
      if (state.navigation.state === "idle") {
        startNavigation(state.historyAction, state.location, {
          startUninterruptedRevalidation: !0
        });
        return;
      }
      startNavigation(pendingAction || state.historyAction, state.navigation.location, {
        overrideNavigation: state.navigation
      });
    }
  }
  async function startNavigation(historyAction, location, opts) {
    pendingNavigationController && pendingNavigationController.abort(), pendingNavigationController = null, pendingAction = historyAction, isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === !0, saveScrollPosition(state.location, state.matches), pendingPreventScrollReset = (opts && opts.preventScrollReset) === !0;
    let routesToUse = inFlightDataRoutes || dataRoutes, loadingNavigation = opts && opts.overrideNavigation, matches = matchRoutes(routesToUse, location, init4.basename);
    if (!matches) {
      let error2 = getInternalRouterError(404, {
        pathname: location.pathname
      }), {
        matches: notFoundMatches,
        route
      } = getShortCircuitMatches(routesToUse);
      cancelActiveDeferreds(), completeNavigation(location, {
        matches: notFoundMatches,
        loaderData: {},
        errors: {
          [route.id]: error2
        }
      });
      return;
    }
    if (isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {
      completeNavigation(location, {
        matches
      });
      return;
    }
    pendingNavigationController = new AbortController();
    let request = createClientSideRequest(init4.history, location, pendingNavigationController.signal, opts && opts.submission), pendingActionData, pendingError;
    if (opts && opts.pendingError)
      pendingError = {
        [findNearestBoundary(matches).route.id]: opts.pendingError
      };
    else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {
      let actionOutput = await handleAction(request, location, opts.submission, matches, {
        replace: opts.replace
      });
      if (actionOutput.shortCircuited)
        return;
      pendingActionData = actionOutput.pendingActionData, pendingError = actionOutput.pendingActionError, loadingNavigation = _extends({
        state: "loading",
        location
      }, opts.submission), request = new Request(request.url, {
        signal: request.signal
      });
    }
    let {
      shortCircuited,
      loaderData,
      errors
    } = await handleLoaders(request, location, matches, loadingNavigation, opts && opts.submission, opts && opts.fetcherSubmission, opts && opts.replace, pendingActionData, pendingError);
    shortCircuited || (pendingNavigationController = null, completeNavigation(location, _extends({
      matches
    }, pendingActionData ? {
      actionData: pendingActionData
    } : {}, {
      loaderData,
      errors
    })));
  }
  async function handleAction(request, location, submission, matches, opts) {
    interruptActiveLoads();
    let navigation = _extends({
      state: "submitting",
      location
    }, submission);
    updateState({
      navigation
    });
    let result2, actionMatch = getTargetMatch(matches, location);
    if (!actionMatch.route.action && !actionMatch.route.lazy)
      result2 = {
        type: ResultType.error,
        error: getInternalRouterError(405, {
          method: request.method,
          pathname: location.pathname,
          routeId: actionMatch.route.id
        })
      };
    else if (result2 = await callLoaderOrAction("action", request, actionMatch, matches, manifest, detectErrorBoundary2, router2.basename), request.signal.aborted)
      return {
        shortCircuited: !0
      };
    if (isRedirectResult(result2)) {
      let replace;
      return opts && opts.replace != null ? replace = opts.replace : replace = result2.location === state.location.pathname + state.location.search, await startRedirectNavigation(state, result2, {
        submission,
        replace
      }), {
        shortCircuited: !0
      };
    }
    if (isErrorResult(result2)) {
      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);
      return (opts && opts.replace) !== !0 && (pendingAction = Action.Push), {
        pendingActionData: {},
        pendingActionError: {
          [boundaryMatch.route.id]: result2.error
        }
      };
    }
    if (isDeferredResult(result2))
      throw getInternalRouterError(400, {
        type: "defer-action"
      });
    return {
      pendingActionData: {
        [actionMatch.route.id]: result2.data
      }
    };
  }
  async function handleLoaders(request, location, matches, overrideNavigation, submission, fetcherSubmission, replace, pendingActionData, pendingError) {
    let loadingNavigation = overrideNavigation;
    loadingNavigation || (loadingNavigation = _extends({
      state: "loading",
      location,
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0
    }, submission));
    let activeSubmission = submission || fetcherSubmission ? submission || fetcherSubmission : loadingNavigation.formMethod && loadingNavigation.formAction && loadingNavigation.formData && loadingNavigation.formEncType ? {
      formMethod: loadingNavigation.formMethod,
      formAction: loadingNavigation.formAction,
      formData: loadingNavigation.formData,
      formEncType: loadingNavigation.formEncType
    } : void 0, routesToUse = inFlightDataRoutes || dataRoutes, [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init4.history, state, matches, activeSubmission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, fetchLoadMatches, routesToUse, init4.basename, pendingActionData, pendingError);
    if (cancelActiveDeferreds((routeId) => !(matches && matches.some((m2) => m2.route.id === routeId)) || matchesToLoad && matchesToLoad.some((m2) => m2.route.id === routeId)), matchesToLoad.length === 0 && revalidatingFetchers.length === 0)
      return completeNavigation(location, _extends({
        matches,
        loaderData: {},
        errors: pendingError || null
      }, pendingActionData ? {
        actionData: pendingActionData
      } : {})), {
        shortCircuited: !0
      };
    if (!isUninterruptedRevalidation) {
      revalidatingFetchers.forEach((rf) => {
        let fetcher = state.fetchers.get(rf.key), revalidatingFetcher = {
          state: "loading",
          data: fetcher && fetcher.data,
          formMethod: void 0,
          formAction: void 0,
          formEncType: void 0,
          formData: void 0,
          " _hasFetcherDoneAnything ": !0
        };
        state.fetchers.set(rf.key, revalidatingFetcher);
      });
      let actionData = pendingActionData || state.actionData;
      updateState(_extends({
        navigation: loadingNavigation
      }, actionData ? Object.keys(actionData).length === 0 ? {
        actionData: null
      } : {
        actionData
      } : {}, revalidatingFetchers.length > 0 ? {
        fetchers: new Map(state.fetchers)
      } : {}));
    }
    pendingNavigationLoadId = ++incrementingLoadId, revalidatingFetchers.forEach((rf) => fetchControllers.set(rf.key, pendingNavigationController));
    let {
      results: results2,
      loaderResults,
      fetcherResults
    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, request);
    if (request.signal.aborted)
      return {
        shortCircuited: !0
      };
    revalidatingFetchers.forEach((rf) => fetchControllers.delete(rf.key));
    let redirect6 = findRedirect(results2);
    if (redirect6)
      return await startRedirectNavigation(state, redirect6, {
        replace
      }), {
        shortCircuited: !0
      };
    let {
      loaderData,
      errors
    } = processLoaderData(state, matches, matchesToLoad, loaderResults, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds);
    activeDeferreds.forEach((deferredData, routeId) => {
      deferredData.subscribe((aborted) => {
        (aborted || deferredData.done) && activeDeferreds.delete(routeId);
      });
    }), markFetchRedirectsDone();
    let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);
    return _extends({
      loaderData,
      errors
    }, didAbortFetchLoads || revalidatingFetchers.length > 0 ? {
      fetchers: new Map(state.fetchers)
    } : {});
  }
  function getFetcher(key2) {
    return state.fetchers.get(key2) || IDLE_FETCHER;
  }
  function fetch2(key2, routeId, href, opts) {
    if (isServer)
      throw new Error("router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback.");
    fetchControllers.has(key2) && abortFetcher(key2);
    let matches = matchRoutes(inFlightDataRoutes || dataRoutes, href, init4.basename);
    if (!matches) {
      setFetcherError(key2, routeId, getInternalRouterError(404, {
        pathname: href
      }));
      return;
    }
    let {
      path: path2,
      submission
    } = normalizeNavigateOptions(href, future2, opts, !0), match = getTargetMatch(matches, path2);
    if (pendingPreventScrollReset = (opts && opts.preventScrollReset) === !0, submission && isMutationMethod(submission.formMethod)) {
      handleFetcherAction(key2, routeId, path2, match, matches, submission);
      return;
    }
    fetchLoadMatches.set(key2, {
      routeId,
      path: path2
    }), handleFetcherLoader(key2, routeId, path2, match, matches, submission);
  }
  async function handleFetcherAction(key2, routeId, path2, match, requestMatches, submission) {
    if (interruptActiveLoads(), fetchLoadMatches.delete(key2), !match.route.action && !match.route.lazy) {
      let error2 = getInternalRouterError(405, {
        method: submission.formMethod,
        pathname: path2,
        routeId
      });
      setFetcherError(key2, routeId, error2);
      return;
    }
    let existingFetcher = state.fetchers.get(key2), fetcher = _extends({
      state: "submitting"
    }, submission, {
      data: existingFetcher && existingFetcher.data,
      " _hasFetcherDoneAnything ": !0
    });
    state.fetchers.set(key2, fetcher), updateState({
      fetchers: new Map(state.fetchers)
    });
    let abortController = new AbortController(), fetchRequest = createClientSideRequest(init4.history, path2, abortController.signal, submission);
    fetchControllers.set(key2, abortController);
    let actionResult = await callLoaderOrAction("action", fetchRequest, match, requestMatches, manifest, detectErrorBoundary2, router2.basename);
    if (fetchRequest.signal.aborted) {
      fetchControllers.get(key2) === abortController && fetchControllers.delete(key2);
      return;
    }
    if (isRedirectResult(actionResult)) {
      fetchControllers.delete(key2), fetchRedirectIds.add(key2);
      let loadingFetcher = _extends({
        state: "loading"
      }, submission, {
        data: void 0,
        " _hasFetcherDoneAnything ": !0
      });
      return state.fetchers.set(key2, loadingFetcher), updateState({
        fetchers: new Map(state.fetchers)
      }), startRedirectNavigation(state, actionResult, {
        submission,
        isFetchActionRedirect: !0
      });
    }
    if (isErrorResult(actionResult)) {
      setFetcherError(key2, routeId, actionResult.error);
      return;
    }
    if (isDeferredResult(actionResult))
      throw getInternalRouterError(400, {
        type: "defer-action"
      });
    let nextLocation = state.navigation.location || state.location, revalidationRequest = createClientSideRequest(init4.history, nextLocation, abortController.signal), routesToUse = inFlightDataRoutes || dataRoutes, matches = state.navigation.state !== "idle" ? matchRoutes(routesToUse, state.navigation.location, init4.basename) : state.matches;
    invariant(matches, "Didn't find any matches after fetcher action");
    let loadId = ++incrementingLoadId;
    fetchReloadIds.set(key2, loadId);
    let loadFetcher = _extends({
      state: "loading",
      data: actionResult.data
    }, submission, {
      " _hasFetcherDoneAnything ": !0
    });
    state.fetchers.set(key2, loadFetcher);
    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(
      init4.history,
      state,
      matches,
      submission,
      nextLocation,
      isRevalidationRequired,
      cancelledDeferredRoutes,
      cancelledFetcherLoads,
      fetchLoadMatches,
      routesToUse,
      init4.basename,
      {
        [match.route.id]: actionResult.data
      },
      void 0
    );
    revalidatingFetchers.filter((rf) => rf.key !== key2).forEach((rf) => {
      let staleKey = rf.key, existingFetcher2 = state.fetchers.get(staleKey), revalidatingFetcher = {
        state: "loading",
        data: existingFetcher2 && existingFetcher2.data,
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        " _hasFetcherDoneAnything ": !0
      };
      state.fetchers.set(staleKey, revalidatingFetcher), fetchControllers.set(staleKey, abortController);
    }), updateState({
      fetchers: new Map(state.fetchers)
    });
    let {
      results: results2,
      loaderResults,
      fetcherResults
    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, revalidationRequest);
    if (abortController.signal.aborted)
      return;
    fetchReloadIds.delete(key2), fetchControllers.delete(key2), revalidatingFetchers.forEach((r3) => fetchControllers.delete(r3.key));
    let redirect6 = findRedirect(results2);
    if (redirect6)
      return startRedirectNavigation(state, redirect6);
    let {
      loaderData,
      errors
    } = processLoaderData(state, state.matches, matchesToLoad, loaderResults, void 0, revalidatingFetchers, fetcherResults, activeDeferreds), doneFetcher = {
      state: "idle",
      data: actionResult.data,
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0,
      " _hasFetcherDoneAnything ": !0
    };
    state.fetchers.set(key2, doneFetcher);
    let didAbortFetchLoads = abortStaleFetchLoads(loadId);
    state.navigation.state === "loading" && loadId > pendingNavigationLoadId ? (invariant(pendingAction, "Expected pending action"), pendingNavigationController && pendingNavigationController.abort(), completeNavigation(state.navigation.location, {
      matches,
      loaderData,
      errors,
      fetchers: new Map(state.fetchers)
    })) : (updateState(_extends({
      errors,
      loaderData: mergeLoaderData(state.loaderData, loaderData, matches, errors)
    }, didAbortFetchLoads ? {
      fetchers: new Map(state.fetchers)
    } : {})), isRevalidationRequired = !1);
  }
  async function handleFetcherLoader(key2, routeId, path2, match, matches, submission) {
    let existingFetcher = state.fetchers.get(key2), loadingFetcher = _extends({
      state: "loading",
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0
    }, submission, {
      data: existingFetcher && existingFetcher.data,
      " _hasFetcherDoneAnything ": !0
    });
    state.fetchers.set(key2, loadingFetcher), updateState({
      fetchers: new Map(state.fetchers)
    });
    let abortController = new AbortController(), fetchRequest = createClientSideRequest(init4.history, path2, abortController.signal);
    fetchControllers.set(key2, abortController);
    let result2 = await callLoaderOrAction("loader", fetchRequest, match, matches, manifest, detectErrorBoundary2, router2.basename);
    if (isDeferredResult(result2) && (result2 = await resolveDeferredData(result2, fetchRequest.signal, !0) || result2), fetchControllers.get(key2) === abortController && fetchControllers.delete(key2), fetchRequest.signal.aborted)
      return;
    if (isRedirectResult(result2)) {
      await startRedirectNavigation(state, result2);
      return;
    }
    if (isErrorResult(result2)) {
      let boundaryMatch = findNearestBoundary(state.matches, routeId);
      state.fetchers.delete(key2), updateState({
        fetchers: new Map(state.fetchers),
        errors: {
          [boundaryMatch.route.id]: result2.error
        }
      });
      return;
    }
    invariant(!isDeferredResult(result2), "Unhandled fetcher deferred data");
    let doneFetcher = {
      state: "idle",
      data: result2.data,
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0,
      " _hasFetcherDoneAnything ": !0
    };
    state.fetchers.set(key2, doneFetcher), updateState({
      fetchers: new Map(state.fetchers)
    });
  }
  async function startRedirectNavigation(state2, redirect6, _temp) {
    var _window;
    let {
      submission,
      replace,
      isFetchActionRedirect
    } = _temp === void 0 ? {} : _temp;
    redirect6.revalidate && (isRevalidationRequired = !0);
    let redirectLocation = createLocation(
      state2.location,
      redirect6.location,
      _extends({
        _isRedirect: !0
      }, isFetchActionRedirect ? {
        _isFetchActionRedirect: !0
      } : {})
    );
    if (invariant(redirectLocation, "Expected a location on the redirect navigation"), ABSOLUTE_URL_REGEX.test(redirect6.location) && isBrowser && typeof ((_window = window) == null ? void 0 : _window.location) < "u") {
      let url = init4.history.createURL(redirect6.location), isDifferentBasename = stripBasename(url.pathname, init4.basename || "/") == null;
      if (window.location.origin !== url.origin || isDifferentBasename) {
        replace ? window.location.replace(redirect6.location) : window.location.assign(redirect6.location);
        return;
      }
    }
    pendingNavigationController = null;
    let redirectHistoryAction = replace === !0 ? Action.Replace : Action.Push, {
      formMethod,
      formAction,
      formEncType,
      formData
    } = state2.navigation;
    !submission && formMethod && formAction && formData && formEncType && (submission = {
      formMethod,
      formAction,
      formEncType,
      formData
    }), redirectPreserveMethodStatusCodes.has(redirect6.status) && submission && isMutationMethod(submission.formMethod) ? await startNavigation(redirectHistoryAction, redirectLocation, {
      submission: _extends({}, submission, {
        formAction: redirect6.location
      }),
      preventScrollReset: pendingPreventScrollReset
    }) : isFetchActionRedirect ? await startNavigation(redirectHistoryAction, redirectLocation, {
      overrideNavigation: {
        state: "loading",
        location: redirectLocation,
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0
      },
      fetcherSubmission: submission,
      preventScrollReset: pendingPreventScrollReset
    }) : await startNavigation(redirectHistoryAction, redirectLocation, {
      overrideNavigation: {
        state: "loading",
        location: redirectLocation,
        formMethod: submission ? submission.formMethod : void 0,
        formAction: submission ? submission.formAction : void 0,
        formEncType: submission ? submission.formEncType : void 0,
        formData: submission ? submission.formData : void 0
      },
      preventScrollReset: pendingPreventScrollReset
    });
  }
  async function callLoadersAndMaybeResolveData(currentMatches, matches, matchesToLoad, fetchersToLoad, request) {
    let results2 = await Promise.all([...matchesToLoad.map((match) => callLoaderOrAction("loader", request, match, matches, manifest, detectErrorBoundary2, router2.basename)), ...fetchersToLoad.map((f2) => f2.matches && f2.match ? callLoaderOrAction("loader", createClientSideRequest(init4.history, f2.path, request.signal), f2.match, f2.matches, manifest, detectErrorBoundary2, router2.basename) : {
      type: ResultType.error,
      error: getInternalRouterError(404, {
        pathname: f2.path
      })
    })]), loaderResults = results2.slice(0, matchesToLoad.length), fetcherResults = results2.slice(matchesToLoad.length);
    return await Promise.all([resolveDeferredResults(currentMatches, matchesToLoad, loaderResults, request.signal, !1, state.loaderData), resolveDeferredResults(currentMatches, fetchersToLoad.map((f2) => f2.match), fetcherResults, request.signal, !0)]), {
      results: results2,
      loaderResults,
      fetcherResults
    };
  }
  function interruptActiveLoads() {
    isRevalidationRequired = !0, cancelledDeferredRoutes.push(...cancelActiveDeferreds()), fetchLoadMatches.forEach((_24, key2) => {
      fetchControllers.has(key2) && (cancelledFetcherLoads.push(key2), abortFetcher(key2));
    });
  }
  function setFetcherError(key2, routeId, error2) {
    let boundaryMatch = findNearestBoundary(state.matches, routeId);
    deleteFetcher(key2), updateState({
      errors: {
        [boundaryMatch.route.id]: error2
      },
      fetchers: new Map(state.fetchers)
    });
  }
  function deleteFetcher(key2) {
    fetchControllers.has(key2) && abortFetcher(key2), fetchLoadMatches.delete(key2), fetchReloadIds.delete(key2), fetchRedirectIds.delete(key2), state.fetchers.delete(key2);
  }
  function abortFetcher(key2) {
    let controller = fetchControllers.get(key2);
    invariant(controller, "Expected fetch controller: " + key2), controller.abort(), fetchControllers.delete(key2);
  }
  function markFetchersDone(keys2) {
    for (let key2 of keys2) {
      let doneFetcher = {
        state: "idle",
        data: getFetcher(key2).data,
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        " _hasFetcherDoneAnything ": !0
      };
      state.fetchers.set(key2, doneFetcher);
    }
  }
  function markFetchRedirectsDone() {
    let doneKeys = [];
    for (let key2 of fetchRedirectIds) {
      let fetcher = state.fetchers.get(key2);
      invariant(fetcher, "Expected fetcher: " + key2), fetcher.state === "loading" && (fetchRedirectIds.delete(key2), doneKeys.push(key2));
    }
    markFetchersDone(doneKeys);
  }
  function abortStaleFetchLoads(landedId) {
    let yeetedKeys = [];
    for (let [key2, id4] of fetchReloadIds)
      if (id4 < landedId) {
        let fetcher = state.fetchers.get(key2);
        invariant(fetcher, "Expected fetcher: " + key2), fetcher.state === "loading" && (abortFetcher(key2), fetchReloadIds.delete(key2), yeetedKeys.push(key2));
      }
    return markFetchersDone(yeetedKeys), yeetedKeys.length > 0;
  }
  function getBlocker(key2, fn) {
    let blocker = state.blockers.get(key2) || IDLE_BLOCKER;
    return blockerFunctions.get(key2) !== fn && blockerFunctions.set(key2, fn), blocker;
  }
  function deleteBlocker(key2) {
    state.blockers.delete(key2), blockerFunctions.delete(key2);
  }
  function updateBlocker(key2, newBlocker) {
    let blocker = state.blockers.get(key2) || IDLE_BLOCKER;
    invariant(blocker.state === "unblocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "proceeding" || blocker.state === "blocked" && newBlocker.state === "unblocked" || blocker.state === "proceeding" && newBlocker.state === "unblocked", "Invalid blocker state transition: " + blocker.state + " -> " + newBlocker.state), state.blockers.set(key2, newBlocker), updateState({
      blockers: new Map(state.blockers)
    });
  }
  function shouldBlockNavigation(_ref2) {
    let {
      currentLocation,
      nextLocation,
      historyAction
    } = _ref2;
    if (blockerFunctions.size === 0)
      return;
    blockerFunctions.size > 1 && warning(!1, "A router only supports one blocker at a time");
    let entries = Array.from(blockerFunctions.entries()), [blockerKey, blockerFunction] = entries[entries.length - 1], blocker = state.blockers.get(blockerKey);
    if (!(blocker && blocker.state === "proceeding") && blockerFunction({
      currentLocation,
      nextLocation,
      historyAction
    }))
      return blockerKey;
  }
  function cancelActiveDeferreds(predicate) {
    let cancelledRouteIds = [];
    return activeDeferreds.forEach((dfd, routeId) => {
      (!predicate || predicate(routeId)) && (dfd.cancel(), cancelledRouteIds.push(routeId), activeDeferreds.delete(routeId));
    }), cancelledRouteIds;
  }
  function enableScrollRestoration(positions, getPosition, getKey) {
    if (savedScrollPositions2 = positions, getScrollPosition = getPosition, getScrollRestorationKey = getKey || ((location) => location.key), !initialScrollRestored && state.navigation === IDLE_NAVIGATION) {
      initialScrollRestored = !0;
      let y2 = getSavedScrollPosition(state.location, state.matches);
      y2 != null && updateState({
        restoreScrollPosition: y2
      });
    }
    return () => {
      savedScrollPositions2 = null, getScrollPosition = null, getScrollRestorationKey = null;
    };
  }
  function saveScrollPosition(location, matches) {
    if (savedScrollPositions2 && getScrollRestorationKey && getScrollPosition) {
      let userMatches = matches.map((m2) => createUseMatchesMatch(m2, state.loaderData)), key2 = getScrollRestorationKey(location, userMatches) || location.key;
      savedScrollPositions2[key2] = getScrollPosition();
    }
  }
  function getSavedScrollPosition(location, matches) {
    if (savedScrollPositions2 && getScrollRestorationKey && getScrollPosition) {
      let userMatches = matches.map((m2) => createUseMatchesMatch(m2, state.loaderData)), key2 = getScrollRestorationKey(location, userMatches) || location.key, y2 = savedScrollPositions2[key2];
      if (typeof y2 == "number")
        return y2;
    }
    return null;
  }
  function _internalSetRoutes(newRoutes) {
    inFlightDataRoutes = newRoutes;
  }
  return router2 = {
    get basename() {
      return init4.basename;
    },
    get state() {
      return state;
    },
    get routes() {
      return dataRoutes;
    },
    initialize,
    subscribe,
    enableScrollRestoration,
    navigate,
    fetch: fetch2,
    revalidate,
    createHref: (to) => init4.history.createHref(to),
    encodeLocation: (to) => init4.history.encodeLocation(to),
    getFetcher,
    deleteFetcher,
    dispose,
    getBlocker,
    deleteBlocker,
    _internalFetchControllers: fetchControllers,
    _internalActiveDeferreds: activeDeferreds,
    _internalSetRoutes
  }, router2;
}
function createStaticHandler(routes2, opts) {
  invariant(routes2.length > 0, "You must provide a non-empty routes array to createStaticHandler");
  let manifest = {}, detectErrorBoundary2 = (opts == null ? void 0 : opts.detectErrorBoundary) || defaultDetectErrorBoundary, dataRoutes = convertRoutesToDataRoutes(routes2, detectErrorBoundary2, void 0, manifest), basename2 = (opts ? opts.basename : null) || "/";
  async function query(request, _temp2) {
    let {
      requestContext
    } = _temp2 === void 0 ? {} : _temp2, url = new URL(request.url), method = request.method, location = createLocation("", createPath(url), null, "default"), matches = matchRoutes(dataRoutes, location, basename2);
    if (!isValidMethod(method) && method !== "HEAD") {
      let error2 = getInternalRouterError(405, {
        method
      }), {
        matches: methodNotAllowedMatches,
        route
      } = getShortCircuitMatches(dataRoutes);
      return {
        basename: basename2,
        location,
        matches: methodNotAllowedMatches,
        loaderData: {},
        actionData: null,
        errors: {
          [route.id]: error2
        },
        statusCode: error2.status,
        loaderHeaders: {},
        actionHeaders: {},
        activeDeferreds: null
      };
    } else if (!matches) {
      let error2 = getInternalRouterError(404, {
        pathname: location.pathname
      }), {
        matches: notFoundMatches,
        route
      } = getShortCircuitMatches(dataRoutes);
      return {
        basename: basename2,
        location,
        matches: notFoundMatches,
        loaderData: {},
        actionData: null,
        errors: {
          [route.id]: error2
        },
        statusCode: error2.status,
        loaderHeaders: {},
        actionHeaders: {},
        activeDeferreds: null
      };
    }
    let result2 = await queryImpl(request, location, matches, requestContext);
    return isResponse(result2) ? result2 : _extends({
      location,
      basename: basename2
    }, result2);
  }
  async function queryRoute(request, _temp3) {
    let {
      routeId,
      requestContext
    } = _temp3 === void 0 ? {} : _temp3, url = new URL(request.url), method = request.method, location = createLocation("", createPath(url), null, "default"), matches = matchRoutes(dataRoutes, location, basename2);
    if (!isValidMethod(method) && method !== "HEAD" && method !== "OPTIONS")
      throw getInternalRouterError(405, {
        method
      });
    if (!matches)
      throw getInternalRouterError(404, {
        pathname: location.pathname
      });
    let match = routeId ? matches.find((m2) => m2.route.id === routeId) : getTargetMatch(matches, location);
    if (routeId && !match)
      throw getInternalRouterError(403, {
        pathname: location.pathname,
        routeId
      });
    if (!match)
      throw getInternalRouterError(404, {
        pathname: location.pathname
      });
    let result2 = await queryImpl(request, location, matches, requestContext, match);
    if (isResponse(result2))
      return result2;
    let error2 = result2.errors ? Object.values(result2.errors)[0] : void 0;
    if (error2 !== void 0)
      throw error2;
    if (result2.actionData)
      return Object.values(result2.actionData)[0];
    if (result2.loaderData) {
      var _result$activeDeferre;
      let data2 = Object.values(result2.loaderData)[0];
      return (_result$activeDeferre = result2.activeDeferreds) != null && _result$activeDeferre[match.route.id] && (data2[UNSAFE_DEFERRED_SYMBOL] = result2.activeDeferreds[match.route.id]), data2;
    }
  }
  async function queryImpl(request, location, matches, requestContext, routeMatch) {
    invariant(request.signal, "query()/queryRoute() requests must contain an AbortController signal");
    try {
      if (isMutationMethod(request.method.toLowerCase()))
        return await submit(request, matches, routeMatch || getTargetMatch(matches, location), requestContext, routeMatch != null);
      let result2 = await loadRouteData(request, matches, requestContext, routeMatch);
      return isResponse(result2) ? result2 : _extends({}, result2, {
        actionData: null,
        actionHeaders: {}
      });
    } catch (e3) {
      if (isQueryRouteResponse(e3)) {
        if (e3.type === ResultType.error && !isRedirectResponse(e3.response))
          throw e3.response;
        return e3.response;
      }
      if (isRedirectResponse(e3))
        return e3;
      throw e3;
    }
  }
  async function submit(request, matches, actionMatch, requestContext, isRouteRequest) {
    let result2;
    if (!actionMatch.route.action && !actionMatch.route.lazy) {
      let error2 = getInternalRouterError(405, {
        method: request.method,
        pathname: new URL(request.url).pathname,
        routeId: actionMatch.route.id
      });
      if (isRouteRequest)
        throw error2;
      result2 = {
        type: ResultType.error,
        error: error2
      };
    } else if (result2 = await callLoaderOrAction("action", request, actionMatch, matches, manifest, detectErrorBoundary2, basename2, !0, isRouteRequest, requestContext), request.signal.aborted) {
      let method = isRouteRequest ? "queryRoute" : "query";
      throw new Error(method + "() call aborted");
    }
    if (isRedirectResult(result2))
      throw new Response(null, {
        status: result2.status,
        headers: {
          Location: result2.location
        }
      });
    if (isDeferredResult(result2)) {
      let error2 = getInternalRouterError(400, {
        type: "defer-action"
      });
      if (isRouteRequest)
        throw error2;
      result2 = {
        type: ResultType.error,
        error: error2
      };
    }
    if (isRouteRequest) {
      if (isErrorResult(result2))
        throw result2.error;
      return {
        matches: [actionMatch],
        loaderData: {},
        actionData: {
          [actionMatch.route.id]: result2.data
        },
        errors: null,
        statusCode: 200,
        loaderHeaders: {},
        actionHeaders: {},
        activeDeferreds: null
      };
    }
    if (isErrorResult(result2)) {
      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id), context2 = await loadRouteData(request, matches, requestContext, void 0, {
        [boundaryMatch.route.id]: result2.error
      });
      return _extends({}, context2, {
        statusCode: isRouteErrorResponse(result2.error) ? result2.error.status : 500,
        actionData: null,
        actionHeaders: _extends({}, result2.headers ? {
          [actionMatch.route.id]: result2.headers
        } : {})
      });
    }
    let loaderRequest = new Request(request.url, {
      headers: request.headers,
      redirect: request.redirect,
      signal: request.signal
    }), context = await loadRouteData(loaderRequest, matches, requestContext);
    return _extends({}, context, result2.statusCode ? {
      statusCode: result2.statusCode
    } : {}, {
      actionData: {
        [actionMatch.route.id]: result2.data
      },
      actionHeaders: _extends({}, result2.headers ? {
        [actionMatch.route.id]: result2.headers
      } : {})
    });
  }
  async function loadRouteData(request, matches, requestContext, routeMatch, pendingActionError) {
    let isRouteRequest = routeMatch != null;
    if (isRouteRequest && !(routeMatch != null && routeMatch.route.loader) && !(routeMatch != null && routeMatch.route.lazy))
      throw getInternalRouterError(400, {
        method: request.method,
        pathname: new URL(request.url).pathname,
        routeId: routeMatch == null ? void 0 : routeMatch.route.id
      });
    let matchesToLoad = (routeMatch ? [routeMatch] : getLoaderMatchesUntilBoundary(matches, Object.keys(pendingActionError || {})[0])).filter((m2) => m2.route.loader || m2.route.lazy);
    if (matchesToLoad.length === 0)
      return {
        matches,
        loaderData: matches.reduce((acc, m2) => Object.assign(acc, {
          [m2.route.id]: null
        }), {}),
        errors: pendingActionError || null,
        statusCode: 200,
        loaderHeaders: {},
        activeDeferreds: null
      };
    let results2 = await Promise.all([...matchesToLoad.map((match) => callLoaderOrAction("loader", request, match, matches, manifest, detectErrorBoundary2, basename2, !0, isRouteRequest, requestContext))]);
    if (request.signal.aborted) {
      let method = isRouteRequest ? "queryRoute" : "query";
      throw new Error(method + "() call aborted");
    }
    let activeDeferreds = /* @__PURE__ */ new Map(), context = processRouteLoaderData(matches, matchesToLoad, results2, pendingActionError, activeDeferreds), executedLoaders = new Set(matchesToLoad.map((match) => match.route.id));
    return matches.forEach((match) => {
      executedLoaders.has(match.route.id) || (context.loaderData[match.route.id] = null);
    }), _extends({}, context, {
      matches,
      activeDeferreds: activeDeferreds.size > 0 ? Object.fromEntries(activeDeferreds.entries()) : null
    });
  }
  return {
    dataRoutes,
    query,
    queryRoute
  };
}
function getStaticContextFromError(routes2, context, error2) {
  return _extends({}, context, {
    statusCode: 500,
    errors: {
      [context._deepestRenderedBoundaryId || routes2[0].id]: error2
    }
  });
}
function isSubmissionNavigation(opts) {
  return opts != null && "formData" in opts;
}
function normalizeNavigateOptions(to, future2, opts, isFetcher) {
  isFetcher === void 0 && (isFetcher = !1);
  let path2 = typeof to == "string" ? to : createPath(to);
  if (!opts || !isSubmissionNavigation(opts))
    return {
      path: path2
    };
  if (opts.formMethod && !isValidMethod(opts.formMethod))
    return {
      path: path2,
      error: getInternalRouterError(405, {
        method: opts.formMethod
      })
    };
  let submission;
  if (opts.formData) {
    let formMethod = opts.formMethod || "get";
    if (submission = {
      formMethod: future2.v7_normalizeFormMethod ? formMethod.toUpperCase() : formMethod.toLowerCase(),
      formAction: stripHashFromPath(path2),
      formEncType: opts && opts.formEncType || "application/x-www-form-urlencoded",
      formData: opts.formData
    }, isMutationMethod(submission.formMethod))
      return {
        path: path2,
        submission
      };
  }
  let parsedPath = parsePath(path2), searchParams = convertFormDataToSearchParams(opts.formData);
  return isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search) && searchParams.append("index", ""), parsedPath.search = "?" + searchParams, {
    path: createPath(parsedPath),
    submission
  };
}
function getLoaderMatchesUntilBoundary(matches, boundaryId) {
  let boundaryMatches = matches;
  if (boundaryId) {
    let index2 = matches.findIndex((m2) => m2.route.id === boundaryId);
    index2 >= 0 && (boundaryMatches = matches.slice(0, index2));
  }
  return boundaryMatches;
}
function getMatchesToLoad(history, state, matches, submission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, fetchLoadMatches, routesToUse, basename2, pendingActionData, pendingError) {
  let actionResult = pendingError ? Object.values(pendingError)[0] : pendingActionData ? Object.values(pendingActionData)[0] : void 0, currentUrl = history.createURL(state.location), nextUrl = history.createURL(location), defaultShouldRevalidate = isRevalidationRequired || currentUrl.toString() === nextUrl.toString() || currentUrl.search !== nextUrl.search, boundaryId = pendingError ? Object.keys(pendingError)[0] : void 0, navigationMatches = getLoaderMatchesUntilBoundary(matches, boundaryId).filter((match, index2) => {
    if (match.route.lazy)
      return !0;
    if (match.route.loader == null)
      return !1;
    if (isNewLoader(state.loaderData, state.matches[index2], match) || cancelledDeferredRoutes.some((id4) => id4 === match.route.id))
      return !0;
    let currentRouteMatch = state.matches[index2], nextRouteMatch = match;
    return shouldRevalidateLoader(match, _extends({
      currentUrl,
      currentParams: currentRouteMatch.params,
      nextUrl,
      nextParams: nextRouteMatch.params
    }, submission, {
      actionResult,
      defaultShouldRevalidate: defaultShouldRevalidate || isNewRouteInstance(currentRouteMatch, nextRouteMatch)
    }));
  }), revalidatingFetchers = [];
  return fetchLoadMatches.forEach((f2, key2) => {
    if (!matches.some((m2) => m2.route.id === f2.routeId))
      return;
    let fetcherMatches = matchRoutes(routesToUse, f2.path, basename2);
    if (!fetcherMatches) {
      revalidatingFetchers.push(_extends({
        key: key2
      }, f2, {
        matches: null,
        match: null
      }));
      return;
    }
    let fetcherMatch = getTargetMatch(fetcherMatches, f2.path);
    if (cancelledFetcherLoads.includes(key2)) {
      revalidatingFetchers.push(_extends({
        key: key2,
        matches: fetcherMatches,
        match: fetcherMatch
      }, f2));
      return;
    }
    shouldRevalidateLoader(fetcherMatch, _extends({
      currentUrl,
      currentParams: state.matches[state.matches.length - 1].params,
      nextUrl,
      nextParams: matches[matches.length - 1].params
    }, submission, {
      actionResult,
      defaultShouldRevalidate
    })) && revalidatingFetchers.push(_extends({
      key: key2,
      matches: fetcherMatches,
      match: fetcherMatch
    }, f2));
  }), [navigationMatches, revalidatingFetchers];
}
function isNewLoader(currentLoaderData, currentMatch, match) {
  let isNew = !currentMatch || match.route.id !== currentMatch.route.id, isMissingData = currentLoaderData[match.route.id] === void 0;
  return isNew || isMissingData;
}
function isNewRouteInstance(currentMatch, match) {
  let currentPath = currentMatch.route.path;
  return currentMatch.pathname !== match.pathname || currentPath != null && currentPath.endsWith("*") && currentMatch.params["*"] !== match.params["*"];
}
function shouldRevalidateLoader(loaderMatch, arg) {
  if (loaderMatch.route.shouldRevalidate) {
    let routeChoice = loaderMatch.route.shouldRevalidate(arg);
    if (typeof routeChoice == "boolean")
      return routeChoice;
  }
  return arg.defaultShouldRevalidate;
}
async function loadLazyRouteModule(route, detectErrorBoundary2, manifest) {
  if (!route.lazy)
    return;
  let lazyRoute = await route.lazy();
  if (!route.lazy)
    return;
  let routeToUpdate = manifest[route.id];
  invariant(routeToUpdate, "No route found in manifest");
  let routeUpdates = {};
  for (let lazyRouteProperty in lazyRoute) {
    let isPropertyStaticallyDefined = routeToUpdate[lazyRouteProperty] !== void 0 && lazyRouteProperty !== "hasErrorBoundary";
    warning(!isPropertyStaticallyDefined, 'Route "' + routeToUpdate.id + '" has a static property "' + lazyRouteProperty + '" defined but its lazy function is also returning a value for this property. ' + ('The lazy route property "' + lazyRouteProperty + '" will be ignored.')), !isPropertyStaticallyDefined && !immutableRouteKeys.has(lazyRouteProperty) && (routeUpdates[lazyRouteProperty] = lazyRoute[lazyRouteProperty]);
  }
  Object.assign(routeToUpdate, routeUpdates), Object.assign(routeToUpdate, {
    hasErrorBoundary: detectErrorBoundary2(_extends({}, routeToUpdate)),
    lazy: void 0
  });
}
async function callLoaderOrAction(type2, request, match, matches, manifest, detectErrorBoundary2, basename2, isStaticRequest, isRouteRequest, requestContext) {
  basename2 === void 0 && (basename2 = "/"), isStaticRequest === void 0 && (isStaticRequest = !1), isRouteRequest === void 0 && (isRouteRequest = !1);
  let resultType, result2, onReject, runHandler = (handler) => {
    let reject, abortPromise = new Promise((_24, r3) => reject = r3);
    return onReject = () => reject(), request.signal.addEventListener("abort", onReject), Promise.race([handler({
      request,
      params: match.params,
      context: requestContext
    }), abortPromise]);
  };
  try {
    let handler = match.route[type2];
    if (match.route.lazy)
      if (handler)
        result2 = (await Promise.all([runHandler(handler), loadLazyRouteModule(match.route, detectErrorBoundary2, manifest)]))[0];
      else if (await loadLazyRouteModule(match.route, detectErrorBoundary2, manifest), handler = match.route[type2], handler)
        result2 = await runHandler(handler);
      else {
        if (type2 === "action")
          throw getInternalRouterError(405, {
            method: request.method,
            pathname: new URL(request.url).pathname,
            routeId: match.route.id
          });
        return {
          type: ResultType.data,
          data: void 0
        };
      }
    else
      invariant(handler, "Could not find the " + type2 + ' to run on the "' + match.route.id + '" route'), result2 = await runHandler(handler);
    invariant(result2 !== void 0, "You defined " + (type2 === "action" ? "an action" : "a loader") + " for route " + ('"' + match.route.id + "\" but didn't return anything from your `" + type2 + "` ") + "function. Please return a value or `null`.");
  } catch (e3) {
    resultType = ResultType.error, result2 = e3;
  } finally {
    onReject && request.signal.removeEventListener("abort", onReject);
  }
  if (isResponse(result2)) {
    let status = result2.status;
    if (redirectStatusCodes.has(status)) {
      let location = result2.headers.get("Location");
      if (invariant(location, "Redirects returned/thrown from loaders/actions must have a Location header"), ABSOLUTE_URL_REGEX.test(location)) {
        if (!isStaticRequest) {
          let currentUrl = new URL(request.url), url = location.startsWith("//") ? new URL(currentUrl.protocol + location) : new URL(location), isSameBasename = stripBasename(url.pathname, basename2) != null;
          url.origin === currentUrl.origin && isSameBasename && (location = url.pathname + url.search + url.hash);
        }
      } else {
        let activeMatches = matches.slice(0, matches.indexOf(match) + 1), routePathnames = getPathContributingMatches(activeMatches).map((match2) => match2.pathnameBase), resolvedLocation = resolveTo(location, routePathnames, new URL(request.url).pathname);
        if (invariant(createPath(resolvedLocation), "Unable to resolve redirect location: " + location), basename2) {
          let path2 = resolvedLocation.pathname;
          resolvedLocation.pathname = path2 === "/" ? basename2 : joinPaths([basename2, path2]);
        }
        location = createPath(resolvedLocation);
      }
      if (isStaticRequest)
        throw result2.headers.set("Location", location), result2;
      return {
        type: ResultType.redirect,
        status,
        location,
        revalidate: result2.headers.get("X-Remix-Revalidate") !== null
      };
    }
    if (isRouteRequest)
      throw {
        type: resultType || ResultType.data,
        response: result2
      };
    let data2, contentType = result2.headers.get("Content-Type");
    return contentType && /\bapplication\/json\b/.test(contentType) ? data2 = await result2.json() : data2 = await result2.text(), resultType === ResultType.error ? {
      type: resultType,
      error: new ErrorResponse(status, result2.statusText, data2),
      headers: result2.headers
    } : {
      type: ResultType.data,
      data: data2,
      statusCode: result2.status,
      headers: result2.headers
    };
  }
  if (resultType === ResultType.error)
    return {
      type: resultType,
      error: result2
    };
  if (isDeferredData(result2)) {
    var _result$init, _result$init2;
    return {
      type: ResultType.deferred,
      deferredData: result2,
      statusCode: (_result$init = result2.init) == null ? void 0 : _result$init.status,
      headers: ((_result$init2 = result2.init) == null ? void 0 : _result$init2.headers) && new Headers(result2.init.headers)
    };
  }
  return {
    type: ResultType.data,
    data: result2
  };
}
function createClientSideRequest(history, location, signal, submission) {
  let url = history.createURL(stripHashFromPath(location)).toString(), init4 = {
    signal
  };
  if (submission && isMutationMethod(submission.formMethod)) {
    let {
      formMethod,
      formEncType,
      formData
    } = submission;
    init4.method = formMethod.toUpperCase(), init4.body = formEncType === "application/x-www-form-urlencoded" ? convertFormDataToSearchParams(formData) : formData;
  }
  return new Request(url, init4);
}
function convertFormDataToSearchParams(formData) {
  let searchParams = new URLSearchParams();
  for (let [key2, value2] of formData.entries())
    searchParams.append(key2, value2 instanceof File ? value2.name : value2);
  return searchParams;
}
function processRouteLoaderData(matches, matchesToLoad, results2, pendingError, activeDeferreds) {
  let loaderData = {}, errors = null, statusCode, foundError = !1, loaderHeaders = {};
  return results2.forEach((result2, index2) => {
    let id4 = matchesToLoad[index2].route.id;
    if (invariant(!isRedirectResult(result2), "Cannot handle redirect results in processLoaderData"), isErrorResult(result2)) {
      let boundaryMatch = findNearestBoundary(matches, id4), error2 = result2.error;
      pendingError && (error2 = Object.values(pendingError)[0], pendingError = void 0), errors = errors || {}, errors[boundaryMatch.route.id] == null && (errors[boundaryMatch.route.id] = error2), loaderData[id4] = void 0, foundError || (foundError = !0, statusCode = isRouteErrorResponse(result2.error) ? result2.error.status : 500), result2.headers && (loaderHeaders[id4] = result2.headers);
    } else
      isDeferredResult(result2) ? (activeDeferreds.set(id4, result2.deferredData), loaderData[id4] = result2.deferredData.data) : loaderData[id4] = result2.data, result2.statusCode != null && result2.statusCode !== 200 && !foundError && (statusCode = result2.statusCode), result2.headers && (loaderHeaders[id4] = result2.headers);
  }), pendingError && (errors = pendingError, loaderData[Object.keys(pendingError)[0]] = void 0), {
    loaderData,
    errors,
    statusCode: statusCode || 200,
    loaderHeaders
  };
}
function processLoaderData(state, matches, matchesToLoad, results2, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds) {
  let {
    loaderData,
    errors
  } = processRouteLoaderData(matches, matchesToLoad, results2, pendingError, activeDeferreds);
  for (let index2 = 0; index2 < revalidatingFetchers.length; index2++) {
    let {
      key: key2,
      match
    } = revalidatingFetchers[index2];
    invariant(fetcherResults !== void 0 && fetcherResults[index2] !== void 0, "Did not find corresponding fetcher result");
    let result2 = fetcherResults[index2];
    if (isErrorResult(result2)) {
      let boundaryMatch = findNearestBoundary(state.matches, match == null ? void 0 : match.route.id);
      errors && errors[boundaryMatch.route.id] || (errors = _extends({}, errors, {
        [boundaryMatch.route.id]: result2.error
      })), state.fetchers.delete(key2);
    } else if (isRedirectResult(result2))
      invariant(!1, "Unhandled fetcher revalidation redirect");
    else if (isDeferredResult(result2))
      invariant(!1, "Unhandled fetcher deferred data");
    else {
      let doneFetcher = {
        state: "idle",
        data: result2.data,
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        " _hasFetcherDoneAnything ": !0
      };
      state.fetchers.set(key2, doneFetcher);
    }
  }
  return {
    loaderData,
    errors
  };
}
function mergeLoaderData(loaderData, newLoaderData, matches, errors) {
  let mergedLoaderData = _extends({}, newLoaderData);
  for (let match of matches) {
    let id4 = match.route.id;
    if (newLoaderData.hasOwnProperty(id4) ? newLoaderData[id4] !== void 0 && (mergedLoaderData[id4] = newLoaderData[id4]) : loaderData[id4] !== void 0 && match.route.loader && (mergedLoaderData[id4] = loaderData[id4]), errors && errors.hasOwnProperty(id4))
      break;
  }
  return mergedLoaderData;
}
function findNearestBoundary(matches, routeId) {
  return (routeId ? matches.slice(0, matches.findIndex((m2) => m2.route.id === routeId) + 1) : [...matches]).reverse().find((m2) => m2.route.hasErrorBoundary === !0) || matches[0];
}
function getShortCircuitMatches(routes2) {
  let route = routes2.find((r3) => r3.index || !r3.path || r3.path === "/") || {
    id: "__shim-error-route__"
  };
  return {
    matches: [{
      params: {},
      pathname: "",
      pathnameBase: "",
      route
    }],
    route
  };
}
function getInternalRouterError(status, _temp4) {
  let {
    pathname,
    routeId,
    method,
    type: type2
  } = _temp4 === void 0 ? {} : _temp4, statusText = "Unknown Server Error", errorMessage = "Unknown @remix-run/router error";
  return status === 400 ? (statusText = "Bad Request", method && pathname && routeId ? errorMessage = "You made a " + method + ' request to "' + pathname + '" but ' + ('did not provide a `loader` for route "' + routeId + '", ') + "so there is no way to handle the request." : type2 === "defer-action" && (errorMessage = "defer() is not supported in actions")) : status === 403 ? (statusText = "Forbidden", errorMessage = 'Route "' + routeId + '" does not match URL "' + pathname + '"') : status === 404 ? (statusText = "Not Found", errorMessage = 'No route matches URL "' + pathname + '"') : status === 405 && (statusText = "Method Not Allowed", method && pathname && routeId ? errorMessage = "You made a " + method.toUpperCase() + ' request to "' + pathname + '" but ' + ('did not provide an `action` for route "' + routeId + '", ') + "so there is no way to handle the request." : method && (errorMessage = 'Invalid request method "' + method.toUpperCase() + '"')), new ErrorResponse(status || 500, statusText, new Error(errorMessage), !0);
}
function findRedirect(results2) {
  for (let i3 = results2.length - 1; i3 >= 0; i3--) {
    let result2 = results2[i3];
    if (isRedirectResult(result2))
      return result2;
  }
}
function stripHashFromPath(path2) {
  let parsedPath = typeof path2 == "string" ? parsePath(path2) : path2;
  return createPath(_extends({}, parsedPath, {
    hash: ""
  }));
}
function isHashChangeOnly(a3, b2) {
  return a3.pathname === b2.pathname && a3.search === b2.search && a3.hash !== b2.hash;
}
function isDeferredResult(result2) {
  return result2.type === ResultType.deferred;
}
function isErrorResult(result2) {
  return result2.type === ResultType.error;
}
function isRedirectResult(result2) {
  return (result2 && result2.type) === ResultType.redirect;
}
function isDeferredData(value2) {
  let deferred = value2;
  return deferred && typeof deferred == "object" && typeof deferred.data == "object" && typeof deferred.subscribe == "function" && typeof deferred.cancel == "function" && typeof deferred.resolveData == "function";
}
function isResponse(value2) {
  return value2 != null && typeof value2.status == "number" && typeof value2.statusText == "string" && typeof value2.headers == "object" && typeof value2.body < "u";
}
function isRedirectResponse(result2) {
  if (!isResponse(result2))
    return !1;
  let status = result2.status, location = result2.headers.get("Location");
  return status >= 300 && status <= 399 && location != null;
}
function isQueryRouteResponse(obj) {
  return obj && isResponse(obj.response) && (obj.type === ResultType.data || ResultType.error);
}
function isValidMethod(method) {
  return validRequestMethods.has(method.toLowerCase());
}
function isMutationMethod(method) {
  return validMutationMethods.has(method.toLowerCase());
}
async function resolveDeferredResults(currentMatches, matchesToLoad, results2, signal, isFetcher, currentLoaderData) {
  for (let index2 = 0; index2 < results2.length; index2++) {
    let result2 = results2[index2], match = matchesToLoad[index2];
    if (!match)
      continue;
    let currentMatch = currentMatches.find((m2) => m2.route.id === match.route.id), isRevalidatingLoader = currentMatch != null && !isNewRouteInstance(currentMatch, match) && (currentLoaderData && currentLoaderData[match.route.id]) !== void 0;
    isDeferredResult(result2) && (isFetcher || isRevalidatingLoader) && await resolveDeferredData(result2, signal, isFetcher).then((result3) => {
      result3 && (results2[index2] = result3 || results2[index2]);
    });
  }
}
async function resolveDeferredData(result2, signal, unwrap) {
  if (unwrap === void 0 && (unwrap = !1), !await result2.deferredData.resolveData(signal)) {
    if (unwrap)
      try {
        return {
          type: ResultType.data,
          data: result2.deferredData.unwrappedData
        };
      } catch (e3) {
        return {
          type: ResultType.error,
          error: e3
        };
      }
    return {
      type: ResultType.data,
      data: result2.deferredData.data
    };
  }
}
function hasNakedIndexQuery(search) {
  return new URLSearchParams(search).getAll("index").some((v2) => v2 === "");
}
function createUseMatchesMatch(match, loaderData) {
  let {
    route,
    pathname,
    params
  } = match;
  return {
    id: route.id,
    pathname,
    params,
    data: loaderData[route.id],
    handle: route.handle
  };
}
function getTargetMatch(matches, location) {
  let search = typeof location == "string" ? parsePath(location).search : location.search;
  if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || ""))
    return matches[matches.length - 1];
  let pathMatches = getPathContributingMatches(matches);
  return pathMatches[pathMatches.length - 1];
}
var Action, PopStateEventType, ResultType, immutableRouteKeys, paramRe, dynamicSegmentValue, indexRouteValue, emptySegmentValue, staticSegmentValue, splatPenalty, isSplat, joinPaths, normalizePathname, normalizeSearch, normalizeHash, json, AbortedDeferredError, DeferredData, defer, redirect, ErrorResponse, validMutationMethodsArr, validMutationMethods, validRequestMethodsArr, validRequestMethods, redirectStatusCodes, redirectPreserveMethodStatusCodes, IDLE_NAVIGATION, IDLE_FETCHER, IDLE_BLOCKER, ABSOLUTE_URL_REGEX, isBrowser, isServer, defaultDetectErrorBoundary, UNSAFE_DEFERRED_SYMBOL, init_router = __esm({
  "node_modules/@remix-run/router/dist/router.js"() {
    (function(Action2) {
      Action2.Pop = "POP", Action2.Push = "PUSH", Action2.Replace = "REPLACE";
    })(Action || (Action = {}));
    PopStateEventType = "popstate";
    (function(ResultType2) {
      ResultType2.data = "data", ResultType2.deferred = "deferred", ResultType2.redirect = "redirect", ResultType2.error = "error";
    })(ResultType || (ResultType = {}));
    immutableRouteKeys = /* @__PURE__ */ new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]);
    paramRe = /^:\w+$/, dynamicSegmentValue = 3, indexRouteValue = 2, emptySegmentValue = 1, staticSegmentValue = 10, splatPenalty = -2, isSplat = (s3) => s3 === "*";
    joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/"), normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/"), normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search, normalizeHash = (hash) => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash, json = function(data2, init4) {
      init4 === void 0 && (init4 = {});
      let responseInit = typeof init4 == "number" ? {
        status: init4
      } : init4, headers = new Headers(responseInit.headers);
      return headers.has("Content-Type") || headers.set("Content-Type", "application/json; charset=utf-8"), new Response(JSON.stringify(data2), _extends({}, responseInit, {
        headers
      }));
    }, AbortedDeferredError = class extends Error {
    }, DeferredData = class {
      constructor(data2, responseInit) {
        this.pendingKeysSet = /* @__PURE__ */ new Set(), this.subscribers = /* @__PURE__ */ new Set(), this.deferredKeys = [], invariant(data2 && typeof data2 == "object" && !Array.isArray(data2), "defer() only accepts plain objects");
        let reject;
        this.abortPromise = new Promise((_24, r3) => reject = r3), this.controller = new AbortController();
        let onAbort = () => reject(new AbortedDeferredError("Deferred data aborted"));
        this.unlistenAbortSignal = () => this.controller.signal.removeEventListener("abort", onAbort), this.controller.signal.addEventListener("abort", onAbort), this.data = Object.entries(data2).reduce((acc, _ref) => {
          let [key2, value2] = _ref;
          return Object.assign(acc, {
            [key2]: this.trackPromise(key2, value2)
          });
        }, {}), this.done && this.unlistenAbortSignal(), this.init = responseInit;
      }
      trackPromise(key2, value2) {
        if (!(value2 instanceof Promise))
          return value2;
        this.deferredKeys.push(key2), this.pendingKeysSet.add(key2);
        let promise = Promise.race([value2, this.abortPromise]).then((data2) => this.onSettle(promise, key2, null, data2), (error2) => this.onSettle(promise, key2, error2));
        return promise.catch(() => {
        }), Object.defineProperty(promise, "_tracked", {
          get: () => !0
        }), promise;
      }
      onSettle(promise, key2, error2, data2) {
        return this.controller.signal.aborted && error2 instanceof AbortedDeferredError ? (this.unlistenAbortSignal(), Object.defineProperty(promise, "_error", {
          get: () => error2
        }), Promise.reject(error2)) : (this.pendingKeysSet.delete(key2), this.done && this.unlistenAbortSignal(), error2 ? (Object.defineProperty(promise, "_error", {
          get: () => error2
        }), this.emit(!1, key2), Promise.reject(error2)) : (Object.defineProperty(promise, "_data", {
          get: () => data2
        }), this.emit(!1, key2), data2));
      }
      emit(aborted, settledKey) {
        this.subscribers.forEach((subscriber) => subscriber(aborted, settledKey));
      }
      subscribe(fn) {
        return this.subscribers.add(fn), () => this.subscribers.delete(fn);
      }
      cancel() {
        this.controller.abort(), this.pendingKeysSet.forEach((v2, k2) => this.pendingKeysSet.delete(k2)), this.emit(!0);
      }
      async resolveData(signal) {
        let aborted = !1;
        if (!this.done) {
          let onAbort = () => this.cancel();
          signal.addEventListener("abort", onAbort), aborted = await new Promise((resolve2) => {
            this.subscribe((aborted2) => {
              signal.removeEventListener("abort", onAbort), (aborted2 || this.done) && resolve2(aborted2);
            });
          });
        }
        return aborted;
      }
      get done() {
        return this.pendingKeysSet.size === 0;
      }
      get unwrappedData() {
        return invariant(this.data !== null && this.done, "Can only unwrap data on initialized and settled deferreds"), Object.entries(this.data).reduce((acc, _ref2) => {
          let [key2, value2] = _ref2;
          return Object.assign(acc, {
            [key2]: unwrapTrackedPromise(value2)
          });
        }, {});
      }
      get pendingKeys() {
        return Array.from(this.pendingKeysSet);
      }
    };
    defer = function(data2, init4) {
      init4 === void 0 && (init4 = {});
      let responseInit = typeof init4 == "number" ? {
        status: init4
      } : init4;
      return new DeferredData(data2, responseInit);
    }, redirect = function(url, init4) {
      init4 === void 0 && (init4 = 302);
      let responseInit = init4;
      typeof responseInit == "number" ? responseInit = {
        status: responseInit
      } : typeof responseInit.status > "u" && (responseInit.status = 302);
      let headers = new Headers(responseInit.headers);
      return headers.set("Location", url), new Response(null, _extends({}, responseInit, {
        headers
      }));
    }, ErrorResponse = class {
      constructor(status, statusText, data2, internal) {
        internal === void 0 && (internal = !1), this.status = status, this.statusText = statusText || "", this.internal = internal, data2 instanceof Error ? (this.data = data2.toString(), this.error = data2) : this.data = data2;
      }
    };
    validMutationMethodsArr = ["post", "put", "patch", "delete"], validMutationMethods = new Set(validMutationMethodsArr), validRequestMethodsArr = ["get", ...validMutationMethodsArr], validRequestMethods = new Set(validRequestMethodsArr), redirectStatusCodes = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]), redirectPreserveMethodStatusCodes = /* @__PURE__ */ new Set([307, 308]), IDLE_NAVIGATION = {
      state: "idle",
      location: void 0,
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0
    }, IDLE_FETCHER = {
      state: "idle",
      data: void 0,
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0
    }, IDLE_BLOCKER = {
      state: "unblocked",
      proceed: void 0,
      reset: void 0,
      location: void 0
    }, ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, isBrowser = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", isServer = !isBrowser, defaultDetectErrorBoundary = (route) => Boolean(route.hasErrorBoundary);
    UNSAFE_DEFERRED_SYMBOL = Symbol("deferred");
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/mode.js
function isServerMode(value2) {
  return value2 === ServerMode.Development || value2 === ServerMode.Production || value2 === ServerMode.Test;
}
var ServerMode, init_mode = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/mode.js"() {
    (function(ServerMode2) {
      ServerMode2.Development = "development", ServerMode2.Production = "production", ServerMode2.Test = "test";
    })(ServerMode || (ServerMode = {}));
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/errors.js
function sanitizeError(error2, serverMode) {
  if (error2 instanceof Error && serverMode !== ServerMode.Development) {
    let sanitized = new Error("Unexpected Server Error");
    return sanitized.stack = void 0, sanitized;
  }
  return error2;
}
function sanitizeErrors(errors, serverMode) {
  return Object.entries(errors).reduce((acc, [routeId, error2]) => Object.assign(acc, {
    [routeId]: sanitizeError(error2, serverMode)
  }), {});
}
function serializeError(error2, serverMode) {
  let sanitized = sanitizeError(error2, serverMode);
  return {
    message: sanitized.message,
    stack: sanitized.stack
  };
}
function serializeErrors(errors, serverMode) {
  if (!errors)
    return null;
  let entries = Object.entries(errors), serialized = {};
  for (let [key2, val] of entries)
    if (isRouteErrorResponse(val))
      serialized[key2] = {
        ...val,
        __type: "RouteErrorResponse"
      };
    else if (val instanceof Error) {
      let sanitized = sanitizeError(val, serverMode);
      serialized[key2] = {
        message: sanitized.message,
        stack: sanitized.stack,
        __type: "Error"
      };
    } else
      serialized[key2] = val;
  return serialized;
}
var init_errors = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/errors.js"() {
    init_router();
    init_mode();
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/responses.js
function isDeferredData2(value2) {
  let deferred = value2;
  return deferred && typeof deferred == "object" && typeof deferred.data == "object" && typeof deferred.subscribe == "function" && typeof deferred.cancel == "function" && typeof deferred.resolveData == "function";
}
function isResponse2(value2) {
  return value2 != null && typeof value2.status == "number" && typeof value2.statusText == "string" && typeof value2.headers == "object" && typeof value2.body < "u";
}
function isRedirectStatusCode(statusCode) {
  return redirectStatusCodes2.has(statusCode);
}
function isRedirectResponse2(response) {
  return isRedirectStatusCode(response.status);
}
function isTrackedPromise2(value2) {
  return value2 != null && typeof value2.then == "function" && value2._tracked === !0;
}
function createDeferredReadableStream(deferredData, signal, serverMode) {
  let encoder = new TextEncoder();
  return new ReadableStream({
    async start(controller) {
      let criticalData = {}, preresolvedKeys = [];
      for (let [key2, value2] of Object.entries(deferredData.data))
        isTrackedPromise2(value2) ? (criticalData[key2] = `${DEFERRED_VALUE_PLACEHOLDER_PREFIX}${key2}`, (typeof value2._data < "u" || typeof value2._error < "u") && preresolvedKeys.push(key2)) : criticalData[key2] = value2;
      controller.enqueue(encoder.encode(JSON.stringify(criticalData) + `

`));
      for (let preresolvedKey of preresolvedKeys)
        enqueueTrackedPromise(controller, encoder, preresolvedKey, deferredData.data[preresolvedKey], serverMode);
      let unsubscribe = deferredData.subscribe((aborted, settledKey) => {
        settledKey && enqueueTrackedPromise(controller, encoder, settledKey, deferredData.data[settledKey], serverMode);
      });
      await deferredData.resolveData(signal), unsubscribe(), controller.close();
    }
  });
}
function enqueueTrackedPromise(controller, encoder, settledKey, promise, serverMode) {
  "_error" in promise ? controller.enqueue(encoder.encode("error:" + JSON.stringify({
    [settledKey]: promise._error instanceof Error ? serializeError(promise._error, serverMode) : promise._error
  }) + `

`)) : controller.enqueue(encoder.encode("data:" + JSON.stringify({
    [settledKey]: promise._data ?? null
  }) + `

`));
}
var json3, defer3, redirect3, redirectStatusCodes2, DEFERRED_VALUE_PLACEHOLDER_PREFIX, init_responses = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/responses.js"() {
    init_router();
    init_errors();
    json3 = (data2, init4 = {}) => json(data2, init4), defer3 = (data2, init4 = {}) => defer(data2, init4), redirect3 = (url, init4 = 302) => redirect(url, init4);
    redirectStatusCodes2 = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
    DEFERRED_VALUE_PLACEHOLDER_PREFIX = "__deferred_promise:";
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/entry.js
function createEntryRouteModules(manifest) {
  return Object.keys(manifest).reduce((memo13, routeId) => (memo13[routeId] = manifest[routeId].module, memo13), {});
}
var init_entry = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/entry.js"() {
  }
});

// node_modules/set-cookie-parser/lib/set-cookie.js
var require_set_cookie = __commonJS({
  "node_modules/set-cookie-parser/lib/set-cookie.js"(exports, module2) {
    "use strict";
    var defaultParseOptions = {
      decodeValues: !0,
      map: !1,
      silent: !1
    };
    function isNonEmptyString(str2) {
      return typeof str2 == "string" && !!str2.trim();
    }
    function parseString(setCookieValue, options2) {
      var parts = setCookieValue.split(";").filter(isNonEmptyString), nameValuePairStr = parts.shift(), parsed = parseNameValuePair(nameValuePairStr), name = parsed.name, value2 = parsed.value;
      options2 = options2 ? Object.assign({}, defaultParseOptions, options2) : defaultParseOptions;
      try {
        value2 = options2.decodeValues ? decodeURIComponent(value2) : value2;
      } catch (e3) {
        console.error(
          "set-cookie-parser encountered an error while decoding a cookie with value '" + value2 + "'. Set options.decodeValues to false to disable this feature.",
          e3
        );
      }
      var cookie = {
        name,
        value: value2
      };
      return parts.forEach(function(part) {
        var sides = part.split("="), key2 = sides.shift().trimLeft().toLowerCase(), value3 = sides.join("=");
        key2 === "expires" ? cookie.expires = new Date(value3) : key2 === "max-age" ? cookie.maxAge = parseInt(value3, 10) : key2 === "secure" ? cookie.secure = !0 : key2 === "httponly" ? cookie.httpOnly = !0 : key2 === "samesite" ? cookie.sameSite = value3 : cookie[key2] = value3;
      }), cookie;
    }
    function parseNameValuePair(nameValuePairStr) {
      var name = "", value2 = "", nameValueArr = nameValuePairStr.split("=");
      return nameValueArr.length > 1 ? (name = nameValueArr.shift(), value2 = nameValueArr.join("=")) : value2 = nameValuePairStr, { name, value: value2 };
    }
    function parse5(input, options2) {
      if (options2 = options2 ? Object.assign({}, defaultParseOptions, options2) : defaultParseOptions, !input)
        return options2.map ? {} : [];
      if (input.headers)
        if (typeof input.headers.getSetCookie == "function")
          input = input.headers.getSetCookie();
        else if (input.headers["set-cookie"])
          input = input.headers["set-cookie"];
        else {
          var sch = input.headers[Object.keys(input.headers).find(function(key2) {
            return key2.toLowerCase() === "set-cookie";
          })];
          !sch && input.headers.cookie && !options2.silent && console.warn(
            "Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning."
          ), input = sch;
        }
      if (Array.isArray(input) || (input = [input]), options2 = options2 ? Object.assign({}, defaultParseOptions, options2) : defaultParseOptions, options2.map) {
        var cookies = {};
        return input.filter(isNonEmptyString).reduce(function(cookies2, str2) {
          var cookie = parseString(str2, options2);
          return cookies2[cookie.name] = cookie, cookies2;
        }, cookies);
      } else
        return input.filter(isNonEmptyString).map(function(str2) {
          return parseString(str2, options2);
        });
    }
    function splitCookiesString2(cookiesString) {
      if (Array.isArray(cookiesString))
        return cookiesString;
      if (typeof cookiesString != "string")
        return [];
      var cookiesStrings = [], pos2 = 0, start3, ch, lastComma, nextStart, cookiesSeparatorFound;
      function skipWhitespace() {
        for (; pos2 < cookiesString.length && /\s/.test(cookiesString.charAt(pos2)); )
          pos2 += 1;
        return pos2 < cookiesString.length;
      }
      function notSpecialChar() {
        return ch = cookiesString.charAt(pos2), ch !== "=" && ch !== ";" && ch !== ",";
      }
      for (; pos2 < cookiesString.length; ) {
        for (start3 = pos2, cookiesSeparatorFound = !1; skipWhitespace(); )
          if (ch = cookiesString.charAt(pos2), ch === ",") {
            for (lastComma = pos2, pos2 += 1, skipWhitespace(), nextStart = pos2; pos2 < cookiesString.length && notSpecialChar(); )
              pos2 += 1;
            pos2 < cookiesString.length && cookiesString.charAt(pos2) === "=" ? (cookiesSeparatorFound = !0, pos2 = nextStart, cookiesStrings.push(cookiesString.substring(start3, lastComma)), start3 = pos2) : pos2 = lastComma + 1;
          } else
            pos2 += 1;
        (!cookiesSeparatorFound || pos2 >= cookiesString.length) && cookiesStrings.push(cookiesString.substring(start3, cookiesString.length));
      }
      return cookiesStrings;
    }
    module2.exports = parse5;
    module2.exports.parse = parse5;
    module2.exports.parseString = parseString;
    module2.exports.splitCookiesString = splitCookiesString2;
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/headers.js
function getDocumentHeadersRR(build, context) {
  return (context.errors ? context.matches.slice(0, context.matches.findIndex((m2) => context.errors[m2.route.id]) + 1) : context.matches).reduce((parentHeaders, match) => {
    let {
      id: id4
    } = match.route, routeModule = build.routes[id4].module, loaderHeaders = context.loaderHeaders[id4] || new Headers(), actionHeaders = context.actionHeaders[id4] || new Headers(), headers = new Headers(routeModule.headers ? typeof routeModule.headers == "function" ? routeModule.headers({
      loaderHeaders,
      parentHeaders,
      actionHeaders
    }) : routeModule.headers : void 0);
    return prependCookies(actionHeaders, headers), prependCookies(loaderHeaders, headers), prependCookies(parentHeaders, headers), headers;
  }, new Headers());
}
function prependCookies(parentHeaders, childHeaders) {
  let parentSetCookieString = parentHeaders.get("Set-Cookie");
  parentSetCookieString && (0, import_set_cookie_parser.splitCookiesString)(parentSetCookieString).forEach((cookie) => {
    childHeaders.append("Set-Cookie", cookie);
  });
}
var import_set_cookie_parser, init_headers = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/headers.js"() {
    import_set_cookie_parser = __toESM(require_set_cookie());
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/invariant.js
function invariant2(value2, message) {
  if (value2 === !1 || value2 === null || typeof value2 > "u")
    throw console.error("The following error is a bug in Remix; please open an issue! https://github.com/remix-run/remix/issues/new"), new Error(message);
}
var init_invariant = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/invariant.js"() {
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/routeMatching.js
function matchServerRoutes(routes2, pathname) {
  let matches = matchRoutes(routes2, pathname);
  return matches ? matches.map((match) => ({
    params: match.params,
    pathname: match.pathname,
    route: match.route
  })) : null;
}
var init_routeMatching = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/routeMatching.js"() {
    init_router();
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/data.js
async function callRouteActionRR({
  loadContext,
  action: action3,
  params,
  request,
  routeId
}) {
  let result2 = await action3({
    request: stripDataParam(stripIndexParam(request)),
    context: loadContext,
    params
  });
  if (result2 === void 0)
    throw new Error(`You defined an action for route "${routeId}" but didn't return anything from your \`action\` function. Please return a value or \`null\`.`);
  return isResponse2(result2) ? result2 : json3(result2);
}
async function callRouteLoaderRR({
  loadContext,
  loader: loader5,
  params,
  request,
  routeId
}) {
  let result2 = await loader5({
    request: stripDataParam(stripIndexParam(request)),
    context: loadContext,
    params
  });
  if (result2 === void 0)
    throw new Error(`You defined a loader for route "${routeId}" but didn't return anything from your \`loader\` function. Please return a value or \`null\`.`);
  return isDeferredData2(result2) ? result2.init && isRedirectStatusCode(result2.init.status || 200) ? redirect3(new Headers(result2.init.headers).get("Location"), result2.init) : result2 : isResponse2(result2) ? result2 : json3(result2);
}
function stripIndexParam(request) {
  let url = new URL(request.url), indexValues = url.searchParams.getAll("index");
  url.searchParams.delete("index");
  let indexValuesToKeep = [];
  for (let indexValue of indexValues)
    indexValue && indexValuesToKeep.push(indexValue);
  for (let toKeep of indexValuesToKeep)
    url.searchParams.append("index", toKeep);
  return new Request(url.href, request);
}
function stripDataParam(request) {
  let url = new URL(request.url);
  return url.searchParams.delete("_data"), new Request(url.href, request);
}
var init_data = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/data.js"() {
    init_responses();
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/routes.js
function groupRoutesByParentId(manifest) {
  let routes2 = {};
  return Object.values(manifest).forEach((route) => {
    let parentId = route.parentId || "";
    routes2[parentId] || (routes2[parentId] = []), routes2[parentId].push(route);
  }), routes2;
}
function createRoutes(manifest, parentId = "", routesByParentId = groupRoutesByParentId(manifest)) {
  return (routesByParentId[parentId] || []).map((route) => ({
    ...route,
    children: createRoutes(manifest, route.id, routesByParentId)
  }));
}
function createStaticHandlerDataRoutes(manifest, future2, parentId = "", routesByParentId = groupRoutesByParentId(manifest)) {
  return (routesByParentId[parentId] || []).map((route) => {
    let commonRoute = {
      hasErrorBoundary: future2.v2_errorBoundary === !0 ? route.id === "root" || route.module.ErrorBoundary != null : route.id === "root" || route.module.CatchBoundary != null || route.module.ErrorBoundary != null,
      id: route.id,
      path: route.path,
      loader: route.module.loader ? (args) => callRouteLoaderRR({
        request: args.request,
        params: args.params,
        loadContext: args.context,
        loader: route.module.loader,
        routeId: route.id
      }) : void 0,
      action: route.module.action ? (args) => callRouteActionRR({
        request: args.request,
        params: args.params,
        loadContext: args.context,
        action: route.module.action,
        routeId: route.id
      }) : void 0,
      handle: route.module.handle
    };
    return route.index ? {
      index: !0,
      ...commonRoute
    } : {
      caseSensitive: route.caseSensitive,
      children: createStaticHandlerDataRoutes(manifest, future2, route.id, routesByParentId),
      ...commonRoute
    };
  });
}
var init_routes = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/routes.js"() {
    init_data();
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/markup.js
function escapeHtml(html) {
  return html.replace(ESCAPE_REGEX, (match) => ESCAPE_LOOKUP[match]);
}
var ESCAPE_LOOKUP, ESCAPE_REGEX, init_markup = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/markup.js"() {
    ESCAPE_LOOKUP = {
      "&": "\\u0026",
      ">": "\\u003e",
      "<": "\\u003c",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    }, ESCAPE_REGEX = /[&><\u2028\u2029]/g;
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/serverHandoff.js
function createServerHandoffString(serverHandoff) {
  return escapeHtml(JSON.stringify(serverHandoff));
}
var init_serverHandoff = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/serverHandoff.js"() {
    init_markup();
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/server.js
async function handleDataRequestRR(serverMode, staticHandler, routeId, request, loadContext) {
  try {
    let response = await staticHandler.queryRoute(request, {
      routeId,
      requestContext: loadContext
    });
    if (isRedirectResponse2(response)) {
      let headers = new Headers(response.headers);
      return headers.set("X-Remix-Redirect", headers.get("Location")), headers.set("X-Remix-Status", response.status), headers.delete("Location"), response.headers.get("Set-Cookie") !== null && headers.set("X-Remix-Revalidate", "yes"), new Response(null, {
        status: 204,
        headers
      });
    }
    if (UNSAFE_DEFERRED_SYMBOL in response) {
      let deferredData = response[UNSAFE_DEFERRED_SYMBOL], body = createDeferredReadableStream(deferredData, request.signal, serverMode), init4 = deferredData.init || {}, headers = new Headers(init4.headers);
      return headers.set("Content-Type", "text/remix-deferred"), init4.headers = headers, new Response(body, init4);
    }
    return response;
  } catch (error2) {
    if (isResponse2(error2))
      return error2.headers.set("X-Remix-Catch", "yes"), error2;
    let status = isRouteErrorResponse(error2) ? error2.status : 500, errorInstance = isRouteErrorResponse(error2) && error2.error ? error2.error : error2 instanceof Error ? error2 : new Error("Unexpected Server Error");
    return logServerErrorIfNotAborted(errorInstance, request, serverMode), json3(serializeError(errorInstance, serverMode), {
      status,
      headers: {
        "X-Remix-Error": "yes"
      }
    });
  }
}
function findParentBoundary(routes2, routeId, error2) {
  let route = routes2[routeId] || routes2.root, isCatch = isRouteErrorResponse(error2) && (!error2.error || error2.status === 404);
  return isCatch && route.module.CatchBoundary || !isCatch && route.module.ErrorBoundary || !route.parentId ? route.id : findParentBoundary(routes2, route.parentId, error2);
}
function differentiateCatchVersusErrorBoundaries(build, context) {
  if (!context.errors)
    return;
  let errors = {};
  for (let routeId of Object.keys(context.errors)) {
    let error2 = context.errors[routeId], handlingRouteId = findParentBoundary(build.routes, routeId, error2);
    errors[handlingRouteId] = error2;
  }
  context.errors = errors;
}
async function handleDocumentRequestRR(serverMode, build, staticHandler, request, loadContext) {
  let context;
  try {
    context = await staticHandler.query(request, {
      requestContext: loadContext
    });
  } catch (error2) {
    return logServerErrorIfNotAborted(error2, request, serverMode), new Response(null, {
      status: 500
    });
  }
  if (isResponse2(context))
    return context;
  context.errors && (context.errors = sanitizeErrors(context.errors, serverMode)), build.future.v2_errorBoundary !== !0 && differentiateCatchVersusErrorBoundaries(build, context);
  let headers = getDocumentHeadersRR(build, context), entryContext = {
    manifest: build.assets,
    routeModules: createEntryRouteModules(build.routes),
    staticHandlerContext: context,
    serverHandoffString: createServerHandoffString({
      state: {
        loaderData: context.loaderData,
        actionData: context.actionData,
        errors: serializeErrors(context.errors, serverMode)
      },
      future: build.future,
      dev: build.dev
    }),
    future: build.future
  }, handleDocumentRequestFunction = build.entry.module.default;
  try {
    return await handleDocumentRequestFunction(request, context.statusCode, headers, entryContext);
  } catch (error2) {
    context = getStaticContextFromError(staticHandler.dataRoutes, context, error2), context.errors && (context.errors = sanitizeErrors(context.errors, serverMode)), build.future.v2_errorBoundary !== !0 && differentiateCatchVersusErrorBoundaries(build, context), entryContext = {
      ...entryContext,
      staticHandlerContext: context,
      serverHandoffString: createServerHandoffString({
        state: {
          loaderData: context.loaderData,
          actionData: context.actionData,
          errors: serializeErrors(context.errors, serverMode)
        },
        future: build.future
      })
    };
    try {
      return await handleDocumentRequestFunction(request, context.statusCode, headers, entryContext);
    } catch (error3) {
      return logServerErrorIfNotAborted(error3, request, serverMode), returnLastResortErrorResponse(error3, serverMode);
    }
  }
}
async function handleResourceRequestRR(serverMode, staticHandler, routeId, request, loadContext) {
  try {
    let response = await staticHandler.queryRoute(request, {
      routeId,
      requestContext: loadContext
    });
    return invariant2(isResponse2(response), "Expected a Response to be returned from queryRoute"), response;
  } catch (error2) {
    return isResponse2(error2) ? (error2.headers.set("X-Remix-Catch", "yes"), error2) : (logServerErrorIfNotAborted(error2, request, serverMode), returnLastResortErrorResponse(error2, serverMode));
  }
}
function logServerErrorIfNotAborted(error2, request, serverMode) {
  serverMode !== ServerMode.Test && !request.signal.aborted && console.error(error2);
}
function returnLastResortErrorResponse(error2, serverMode) {
  let message = "Unexpected Server Error";
  return serverMode !== ServerMode.Production && (message += `

${String(error2)}`), new Response(message, {
    status: 500,
    headers: {
      "Content-Type": "text/plain"
    }
  });
}
var createRequestHandler, init_server = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/server.js"() {
    init_router();
    init_entry();
    init_errors();
    init_headers();
    init_invariant();
    init_mode();
    init_routeMatching();
    init_routes();
    init_responses();
    init_serverHandoff();
    createRequestHandler = (build, mode) => {
      let routes2 = createRoutes(build.routes), dataRoutes = createStaticHandlerDataRoutes(build.routes, build.future), serverMode = isServerMode(mode) ? mode : ServerMode.Production, staticHandler = createStaticHandler(dataRoutes);
      return async function(request, loadContext = {}) {
        let url = new URL(request.url), {
          unstable_dev
        } = build.future;
        if (mode === "development" && unstable_dev !== !1 && url.pathname === (unstable_dev === !0 ? "/__REMIX_ASSETS_MANIFEST" : (unstable_dev.remixRequestHandlerPath ?? "") + "/__REMIX_ASSETS_MANIFEST"))
          return request.method !== "GET" ? new Response("Method not allowed", {
            status: 405
          }) : new Response(JSON.stringify(build.assets), {
            status: 200,
            headers: {
              "Content-Type": "application/json"
            }
          });
        let matches = matchServerRoutes(routes2, url.pathname), response;
        if (url.searchParams.has("_data")) {
          let routeId = url.searchParams.get("_data");
          if (response = await handleDataRequestRR(serverMode, staticHandler, routeId, request, loadContext), build.entry.module.handleDataRequest) {
            let match = matches.find((match2) => match2.route.id == routeId);
            response = await build.entry.module.handleDataRequest(response, {
              context: loadContext,
              params: match ? match.params : {},
              request
            });
          }
        } else
          matches && matches[matches.length - 1].route.module.default == null ? response = await handleResourceRequestRR(serverMode, staticHandler, matches.slice(-1)[0].route.id, request, loadContext) : response = await handleDocumentRequestRR(serverMode, build, staticHandler, request, loadContext);
        return request.method === "HEAD" ? new Response(null, {
          headers: response.headers,
          status: response.status,
          statusText: response.statusText
        }) : response;
      };
    };
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/sessions.js
function flash(name) {
  return `__flash_${name}__`;
}
function warnOnceAboutSigningSessionCookie(cookie) {
  warnOnce(cookie.isSigned, `The "${cookie.name}" cookie is not signed, but session cookies should be signed to prevent tampering on the client before they are sent back to the server. See https://remix.run/utils/cookies#signing-cookies for more information.`);
}
var createSession, isSession, createSessionStorageFactory, init_sessions = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/sessions.js"() {
    init_cookies();
    init_warnings();
    createSession = (initialData = {}, id4 = "") => {
      let map2 = new Map(Object.entries(initialData));
      return {
        get id() {
          return id4;
        },
        get data() {
          return Object.fromEntries(map2);
        },
        has(name) {
          return map2.has(name) || map2.has(flash(name));
        },
        get(name) {
          if (map2.has(name))
            return map2.get(name);
          let flashName = flash(name);
          if (map2.has(flashName)) {
            let value2 = map2.get(flashName);
            return map2.delete(flashName), value2;
          }
        },
        set(name, value2) {
          map2.set(name, value2);
        },
        flash(name, value2) {
          map2.set(flash(name), value2);
        },
        unset(name) {
          map2.delete(name);
        }
      };
    }, isSession = (object) => object != null && typeof object.id == "string" && typeof object.data < "u" && typeof object.has == "function" && typeof object.get == "function" && typeof object.set == "function" && typeof object.flash == "function" && typeof object.unset == "function", createSessionStorageFactory = (createCookie) => ({
      cookie: cookieArg,
      createData,
      readData,
      updateData,
      deleteData
    }) => {
      let cookie = isCookie(cookieArg) ? cookieArg : createCookie((cookieArg == null ? void 0 : cookieArg.name) || "__session", cookieArg);
      return warnOnceAboutSigningSessionCookie(cookie), {
        async getSession(cookieHeader, options2) {
          let id4 = cookieHeader && await cookie.parse(cookieHeader, options2), data2 = id4 && await readData(id4);
          return createSession(data2 || {}, id4 || "");
        },
        async commitSession(session, options2) {
          let {
            id: id4,
            data: data2
          } = session;
          return id4 ? await updateData(id4, data2, cookie.expires) : id4 = await createData(data2, cookie.expires), cookie.serialize(id4, options2);
        },
        async destroySession(session, options2) {
          return await deleteData(session.id), cookie.serialize("", {
            ...options2,
            expires: new Date(0)
          });
        }
      };
    };
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/sessions/cookieStorage.js
var createCookieSessionStorageFactory, init_cookieStorage = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/sessions/cookieStorage.js"() {
    init_cookies();
    init_sessions();
    createCookieSessionStorageFactory = (createCookie) => ({
      cookie: cookieArg
    } = {}) => {
      let cookie = isCookie(cookieArg) ? cookieArg : createCookie((cookieArg == null ? void 0 : cookieArg.name) || "__session", cookieArg);
      return warnOnceAboutSigningSessionCookie(cookie), {
        async getSession(cookieHeader, options2) {
          return createSession(cookieHeader && await cookie.parse(cookieHeader, options2) || {});
        },
        async commitSession(session, options2) {
          let serializedCookie = await cookie.serialize(session.data, options2);
          if (serializedCookie.length > 4096)
            throw new Error("Cookie length will exceed browser maximum. Length: " + serializedCookie.length);
          return serializedCookie;
        },
        async destroySession(_session, options2) {
          return cookie.serialize("", {
            ...options2,
            expires: new Date(0)
          });
        }
      };
    };
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/sessions/memoryStorage.js
var createMemorySessionStorageFactory, init_memoryStorage = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/sessions/memoryStorage.js"() {
    createMemorySessionStorageFactory = (createSessionStorage) => ({
      cookie
    } = {}) => {
      let uniqueId = 0, map2 = /* @__PURE__ */ new Map();
      return createSessionStorage({
        cookie,
        async createData(data2, expires) {
          let id4 = (++uniqueId).toString();
          return map2.set(id4, {
            data: data2,
            expires
          }), id4;
        },
        async readData(id4) {
          if (map2.has(id4)) {
            let {
              data: data2,
              expires
            } = map2.get(id4);
            if (!expires || expires > new Date())
              return data2;
            expires && map2.delete(id4);
          }
          return null;
        },
        async updateData(id4, data2, expires) {
          map2.set(id4, {
            data: data2,
            expires
          });
        },
        async deleteData(id4) {
          map2.delete(id4);
        }
      });
    };
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/upload/errors.js
var MaxPartSizeExceededError, init_errors2 = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/upload/errors.js"() {
    MaxPartSizeExceededError = class extends Error {
      constructor(field, maxBytes) {
        super(`Field "${field}" exceeded upload size of ${maxBytes} bytes.`), this.field = field, this.maxBytes = maxBytes;
      }
    };
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/upload/memoryUploadHandler.js
function createMemoryUploadHandler({
  filter: filter3,
  maxPartSize = 3e6
} = {}) {
  return async ({
    filename,
    contentType,
    name,
    data: data2
  }) => {
    if (filter3 && !await filter3({
      filename,
      contentType,
      name
    }))
      return;
    let size = 0, chunks = [];
    for await (let chunk of data2) {
      if (size += chunk.byteLength, size > maxPartSize)
        throw new MaxPartSizeExceededError(name, maxPartSize);
      chunks.push(chunk);
    }
    return typeof filename == "string" ? new File(chunks, filename, {
      type: contentType
    }) : await new Blob(chunks, {
      type: contentType
    }).text();
  };
}
var init_memoryUploadHandler = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/upload/memoryUploadHandler.js"() {
    init_errors2();
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  MaxPartSizeExceededError: () => MaxPartSizeExceededError,
  createCookieFactory: () => createCookieFactory,
  createCookieSessionStorageFactory: () => createCookieSessionStorageFactory,
  createMemorySessionStorageFactory: () => createMemorySessionStorageFactory,
  createRequestHandler: () => createRequestHandler,
  createSession: () => createSession,
  createSessionStorageFactory: () => createSessionStorageFactory,
  defer: () => defer3,
  isCookie: () => isCookie,
  isSession: () => isSession,
  json: () => json3,
  redirect: () => redirect3,
  unstable_composeUploadHandlers: () => composeUploadHandlers,
  unstable_createMemoryUploadHandler: () => createMemoryUploadHandler,
  unstable_parseMultipartFormData: () => parseMultipartFormData
});
var init_esm = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/index.js"() {
    init_cookies();
    init_formData();
    init_responses();
    init_server();
    init_sessions();
    init_cookieStorage();
    init_memoryStorage();
    init_memoryUploadHandler();
    init_errors2();
  }
});

// node_modules/@remix-run/cloudflare/dist/crypto.js
var require_crypto = __commonJS({
  "node_modules/@remix-run/cloudflare/dist/crypto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var encoder = new TextEncoder(), sign2 = async (value2, secret) => {
      let key2 = await createKey2(secret, ["sign"]), data2 = encoder.encode(value2), signature = await crypto.subtle.sign("HMAC", key2, data2), hash = btoa(String.fromCharCode(...new Uint8Array(signature))).replace(/=+$/, "");
      return value2 + "." + hash;
    }, unsign = async (signed, secret) => {
      let index2 = signed.lastIndexOf("."), value2 = signed.slice(0, index2), hash = signed.slice(index2 + 1), key2 = await createKey2(secret, ["verify"]), data2 = encoder.encode(value2), signature = byteStringToUint8Array(atob(hash));
      return await crypto.subtle.verify("HMAC", key2, signature, data2) ? value2 : !1;
    };
    async function createKey2(secret, usages) {
      return await crypto.subtle.importKey("raw", encoder.encode(secret), {
        name: "HMAC",
        hash: "SHA-256"
      }, !1, usages);
    }
    function byteStringToUint8Array(byteString) {
      let array = new Uint8Array(byteString.length);
      for (let i3 = 0; i3 < byteString.length; i3++)
        array[i3] = byteString.charCodeAt(i3);
      return array;
    }
    exports.sign = sign2;
    exports.unsign = unsign;
  }
});

// node_modules/@remix-run/cloudflare/dist/implementations.js
var require_implementations = __commonJS({
  "node_modules/@remix-run/cloudflare/dist/implementations.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var serverRuntime = (init_esm(), __toCommonJS(esm_exports)), crypto2 = require_crypto(), createCookie = serverRuntime.createCookieFactory({
      sign: crypto2.sign,
      unsign: crypto2.unsign
    }), createCookieSessionStorage2 = serverRuntime.createCookieSessionStorageFactory(createCookie), createSessionStorage = serverRuntime.createSessionStorageFactory(createCookie), createMemorySessionStorage = serverRuntime.createMemorySessionStorageFactory(createSessionStorage);
    exports.createCookie = createCookie;
    exports.createCookieSessionStorage = createCookieSessionStorage2;
    exports.createMemorySessionStorage = createMemorySessionStorage;
    exports.createSessionStorage = createSessionStorage;
  }
});

// node_modules/@remix-run/cloudflare/dist/sessions/workersKVStorage.js
var require_workersKVStorage = __commonJS({
  "node_modules/@remix-run/cloudflare/dist/sessions/workersKVStorage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var implementations = require_implementations();
    function createWorkersKVSessionStorage({
      cookie,
      kv
    }) {
      return implementations.createSessionStorage({
        cookie,
        async createData(data2, expires) {
          for (; ; ) {
            let randomBytes = new Uint8Array(8);
            crypto.getRandomValues(randomBytes);
            let id4 = [...randomBytes].map((x2) => x2.toString(16).padStart(2, "0")).join("");
            if (!await kv.get(id4, "json"))
              return await kv.put(id4, JSON.stringify(data2), {
                expiration: expires ? Math.round(expires.getTime() / 1e3) : void 0
              }), id4;
          }
        },
        async readData(id4) {
          let session = await kv.get(id4);
          return session ? JSON.parse(session) : null;
        },
        async updateData(id4, data2, expires) {
          await kv.put(id4, JSON.stringify(data2), {
            expiration: expires ? Math.round(expires.getTime() / 1e3) : void 0
          });
        },
        async deleteData(id4) {
          await kv.delete(id4);
        }
      });
    }
    exports.createWorkersKVSessionStorage = createWorkersKVSessionStorage;
  }
});

// node_modules/@remix-run/cloudflare/dist/index.js
var require_dist = __commonJS({
  "node_modules/@remix-run/cloudflare/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var workersKVStorage = require_workersKVStorage(), implementations = require_implementations(), serverRuntime = (init_esm(), __toCommonJS(esm_exports)), warn3 = (fn, message) => (...args) => (console.warn(message), fn(...args)), createCloudflareKVSessionStorage = warn3(workersKVStorage.createWorkersKVSessionStorage, "`createCloudflareKVSessionStorage` is deprecated. Please use `createWorkersKVSessionStorage` instead.");
    exports.createWorkersKVSessionStorage = workersKVStorage.createWorkersKVSessionStorage;
    exports.createCookie = implementations.createCookie;
    exports.createCookieSessionStorage = implementations.createCookieSessionStorage;
    exports.createMemorySessionStorage = implementations.createMemorySessionStorage;
    exports.createSessionStorage = implementations.createSessionStorage;
    Object.defineProperty(exports, "MaxPartSizeExceededError", {
      enumerable: !0,
      get: function() {
        return serverRuntime.MaxPartSizeExceededError;
      }
    });
    Object.defineProperty(exports, "createRequestHandler", {
      enumerable: !0,
      get: function() {
        return serverRuntime.createRequestHandler;
      }
    });
    Object.defineProperty(exports, "createSession", {
      enumerable: !0,
      get: function() {
        return serverRuntime.createSession;
      }
    });
    Object.defineProperty(exports, "defer", {
      enumerable: !0,
      get: function() {
        return serverRuntime.defer;
      }
    });
    Object.defineProperty(exports, "isCookie", {
      enumerable: !0,
      get: function() {
        return serverRuntime.isCookie;
      }
    });
    Object.defineProperty(exports, "isSession", {
      enumerable: !0,
      get: function() {
        return serverRuntime.isSession;
      }
    });
    Object.defineProperty(exports, "json", {
      enumerable: !0,
      get: function() {
        return serverRuntime.json;
      }
    });
    Object.defineProperty(exports, "redirect", {
      enumerable: !0,
      get: function() {
        return serverRuntime.redirect;
      }
    });
    Object.defineProperty(exports, "unstable_composeUploadHandlers", {
      enumerable: !0,
      get: function() {
        return serverRuntime.unstable_composeUploadHandlers;
      }
    });
    Object.defineProperty(exports, "unstable_createMemoryUploadHandler", {
      enumerable: !0,
      get: function() {
        return serverRuntime.unstable_createMemoryUploadHandler;
      }
    });
    Object.defineProperty(exports, "unstable_parseMultipartFormData", {
      enumerable: !0,
      get: function() {
        return serverRuntime.unstable_parseMultipartFormData;
      }
    });
    exports.createCloudflareKVSessionStorage = createCloudflareKVSessionStorage;
  }
});

// node_modules/react/cjs/react.development.js
var require_react_development = __commonJS({
  "node_modules/react/cjs/react.development.js"(exports, module2) {
    "use strict";
    (function() {
      "use strict";
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var ReactVersion = "18.2.0", REACT_ELEMENT_TYPE = Symbol.for("react.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_PROVIDER_TYPE = Symbol.for("react.provider"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable != "object")
          return null;
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        return typeof maybeIterator == "function" ? maybeIterator : null;
      }
      var ReactCurrentDispatcher = {
        current: null
      }, ReactCurrentBatchConfig = {
        transition: null
      }, ReactCurrentActQueue = {
        current: null,
        isBatchingLegacy: !1,
        didScheduleLegacyUpdate: !1
      }, ReactCurrentOwner = {
        current: null
      }, ReactDebugCurrentFrame = {}, currentExtraStackFrame = null;
      function setExtraStackFrame(stack2) {
        currentExtraStackFrame = stack2;
      }
      ReactDebugCurrentFrame.setExtraStackFrame = function(stack2) {
        currentExtraStackFrame = stack2;
      }, ReactDebugCurrentFrame.getCurrentStack = null, ReactDebugCurrentFrame.getStackAddendum = function() {
        var stack2 = "";
        currentExtraStackFrame && (stack2 += currentExtraStackFrame);
        var impl = ReactDebugCurrentFrame.getCurrentStack;
        return impl && (stack2 += impl() || ""), stack2;
      };
      var enableScopeAPI = !1, enableCacheElement = !1, enableTransitionTracing = !1, enableLegacyHidden = !1, enableDebugTracing = !1, ReactSharedInternals = {
        ReactCurrentDispatcher,
        ReactCurrentBatchConfig,
        ReactCurrentOwner
      };
      ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame, ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
      function warn3(format2) {
        {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
            args[_key - 1] = arguments[_key];
          printWarning("warn", format2, args);
        }
      }
      function error2(format2) {
        {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)
            args[_key2 - 1] = arguments[_key2];
          printWarning("error", format2, args);
        }
      }
      function printWarning(level, format2, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame, stack2 = ReactDebugCurrentFrame2.getStackAddendum();
          stack2 !== "" && (format2 += "%s", args = args.concat([stack2]));
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format2), Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      var didWarnStateUpdateForUnmountedComponent = {};
      function warnNoop(publicInstance, callerName) {
        {
          var _constructor = publicInstance.constructor, componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass", warningKey = componentName + "." + callerName;
          if (didWarnStateUpdateForUnmountedComponent[warningKey])
            return;
          error2("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName), didWarnStateUpdateForUnmountedComponent[warningKey] = !0;
        }
      }
      var ReactNoopUpdateQueue = {
        isMounted: function(publicInstance) {
          return !1;
        },
        enqueueForceUpdate: function(publicInstance, callback, callerName) {
          warnNoop(publicInstance, "forceUpdate");
        },
        enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
          warnNoop(publicInstance, "replaceState");
        },
        enqueueSetState: function(publicInstance, partialState, callback, callerName) {
          warnNoop(publicInstance, "setState");
        }
      }, assign = Object.assign, emptyObject = {};
      Object.freeze(emptyObject);
      function Component3(props, context, updater) {
        this.props = props, this.context = context, this.refs = emptyObject, this.updater = updater || ReactNoopUpdateQueue;
      }
      Component3.prototype.isReactComponent = {}, Component3.prototype.setState = function(partialState, callback) {
        if (typeof partialState != "object" && typeof partialState != "function" && partialState != null)
          throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, partialState, callback, "setState");
      }, Component3.prototype.forceUpdate = function(callback) {
        this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
      };
      {
        var deprecatedAPIs = {
          isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
          replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
        }, defineDeprecationWarning = function(methodName, info) {
          Object.defineProperty(Component3.prototype, methodName, {
            get: function() {
              warn3("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
            }
          });
        };
        for (var fnName in deprecatedAPIs)
          deprecatedAPIs.hasOwnProperty(fnName) && defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
      }
      function ComponentDummy() {
      }
      ComponentDummy.prototype = Component3.prototype;
      function PureComponent(props, context, updater) {
        this.props = props, this.context = context, this.refs = emptyObject, this.updater = updater || ReactNoopUpdateQueue;
      }
      var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
      pureComponentPrototype.constructor = PureComponent, assign(pureComponentPrototype, Component3.prototype), pureComponentPrototype.isPureReactComponent = !0;
      function createRef() {
        var refObject = {
          current: null
        };
        return Object.seal(refObject), refObject;
      }
      var isArrayImpl = Array.isArray;
      function isArray3(a3) {
        return isArrayImpl(a3);
      }
      function typeName(value2) {
        {
          var hasToStringTag = typeof Symbol == "function" && Symbol.toStringTag, type2 = hasToStringTag && value2[Symbol.toStringTag] || value2.constructor.name || "Object";
          return type2;
        }
      }
      function willCoercionThrow(value2) {
        try {
          return testStringCoercion(value2), !1;
        } catch {
          return !0;
        }
      }
      function testStringCoercion(value2) {
        return "" + value2;
      }
      function checkKeyStringCoercion(value2) {
        if (willCoercionThrow(value2))
          return error2("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value2)), testStringCoercion(value2);
      }
      function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName;
        if (displayName)
          return displayName;
        var functionName = innerType.displayName || innerType.name || "";
        return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
      }
      function getContextName(type2) {
        return type2.displayName || "Context";
      }
      function getComponentNameFromType(type2) {
        if (type2 == null)
          return null;
        if (typeof type2.tag == "number" && error2("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof type2 == "function")
          return type2.displayName || type2.name || null;
        if (typeof type2 == "string")
          return type2;
        switch (type2) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type2 == "object")
          switch (type2.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type2;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type2;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type2, type2.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              var outerName = type2.displayName || null;
              return outerName !== null ? outerName : getComponentNameFromType(type2.type) || "Memo";
            case REACT_LAZY_TYPE: {
              var lazyComponent = type2, payload = lazyComponent._payload, init4 = lazyComponent._init;
              try {
                return getComponentNameFromType(init4(payload));
              } catch {
                return null;
              }
            }
          }
        return null;
      }
      var hasOwnProperty2 = Object.prototype.hasOwnProperty, RESERVED_PROPS = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
      }, specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
      didWarnAboutStringRefs = {};
      function hasValidRef(config2) {
        if (hasOwnProperty2.call(config2, "ref")) {
          var getter = Object.getOwnPropertyDescriptor(config2, "ref").get;
          if (getter && getter.isReactWarning)
            return !1;
        }
        return config2.ref !== void 0;
      }
      function hasValidKey(config2) {
        if (hasOwnProperty2.call(config2, "key")) {
          var getter = Object.getOwnPropertyDescriptor(config2, "key").get;
          if (getter && getter.isReactWarning)
            return !1;
        }
        return config2.key !== void 0;
      }
      function defineKeyPropWarningGetter(props, displayName) {
        var warnAboutAccessingKey = function() {
          specialPropKeyWarningShown || (specialPropKeyWarningShown = !0, error2("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName));
        };
        warnAboutAccessingKey.isReactWarning = !0, Object.defineProperty(props, "key", {
          get: warnAboutAccessingKey,
          configurable: !0
        });
      }
      function defineRefPropWarningGetter(props, displayName) {
        var warnAboutAccessingRef = function() {
          specialPropRefWarningShown || (specialPropRefWarningShown = !0, error2("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName));
        };
        warnAboutAccessingRef.isReactWarning = !0, Object.defineProperty(props, "ref", {
          get: warnAboutAccessingRef,
          configurable: !0
        });
      }
      function warnIfStringRefCannotBeAutoConverted(config2) {
        if (typeof config2.ref == "string" && ReactCurrentOwner.current && config2.__self && ReactCurrentOwner.current.stateNode !== config2.__self) {
          var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
          didWarnAboutStringRefs[componentName] || (error2('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config2.ref), didWarnAboutStringRefs[componentName] = !0);
        }
      }
      var ReactElement = function(type2, key2, ref, self, source2, owner, props) {
        var element = {
          $$typeof: REACT_ELEMENT_TYPE,
          type: type2,
          key: key2,
          ref,
          props,
          _owner: owner
        };
        return element._store = {}, Object.defineProperty(element._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: !1
        }), Object.defineProperty(element, "_self", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: self
        }), Object.defineProperty(element, "_source", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: source2
        }), Object.freeze && (Object.freeze(element.props), Object.freeze(element)), element;
      };
      function createElement18(type2, config2, children) {
        var propName, props = {}, key2 = null, ref = null, self = null, source2 = null;
        if (config2 != null) {
          hasValidRef(config2) && (ref = config2.ref, warnIfStringRefCannotBeAutoConverted(config2)), hasValidKey(config2) && (checkKeyStringCoercion(config2.key), key2 = "" + config2.key), self = config2.__self === void 0 ? null : config2.__self, source2 = config2.__source === void 0 ? null : config2.__source;
          for (propName in config2)
            hasOwnProperty2.call(config2, propName) && !RESERVED_PROPS.hasOwnProperty(propName) && (props[propName] = config2[propName]);
        }
        var childrenLength = arguments.length - 2;
        if (childrenLength === 1)
          props.children = children;
        else if (childrenLength > 1) {
          for (var childArray = Array(childrenLength), i3 = 0; i3 < childrenLength; i3++)
            childArray[i3] = arguments[i3 + 2];
          Object.freeze && Object.freeze(childArray), props.children = childArray;
        }
        if (type2 && type2.defaultProps) {
          var defaultProps = type2.defaultProps;
          for (propName in defaultProps)
            props[propName] === void 0 && (props[propName] = defaultProps[propName]);
        }
        if (key2 || ref) {
          var displayName = typeof type2 == "function" ? type2.displayName || type2.name || "Unknown" : type2;
          key2 && defineKeyPropWarningGetter(props, displayName), ref && defineRefPropWarningGetter(props, displayName);
        }
        return ReactElement(type2, key2, ref, self, source2, ReactCurrentOwner.current, props);
      }
      function cloneAndReplaceKey(oldElement, newKey) {
        var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
        return newElement;
      }
      function cloneElement4(element, config2, children) {
        if (element == null)
          throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
        var propName, props = assign({}, element.props), key2 = element.key, ref = element.ref, self = element._self, source2 = element._source, owner = element._owner;
        if (config2 != null) {
          hasValidRef(config2) && (ref = config2.ref, owner = ReactCurrentOwner.current), hasValidKey(config2) && (checkKeyStringCoercion(config2.key), key2 = "" + config2.key);
          var defaultProps;
          element.type && element.type.defaultProps && (defaultProps = element.type.defaultProps);
          for (propName in config2)
            hasOwnProperty2.call(config2, propName) && !RESERVED_PROPS.hasOwnProperty(propName) && (config2[propName] === void 0 && defaultProps !== void 0 ? props[propName] = defaultProps[propName] : props[propName] = config2[propName]);
        }
        var childrenLength = arguments.length - 2;
        if (childrenLength === 1)
          props.children = children;
        else if (childrenLength > 1) {
          for (var childArray = Array(childrenLength), i3 = 0; i3 < childrenLength; i3++)
            childArray[i3] = arguments[i3 + 2];
          props.children = childArray;
        }
        return ReactElement(element.type, key2, ref, self, source2, owner, props);
      }
      function isValidElement4(object) {
        return typeof object == "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      var SEPARATOR = ".", SUBSEPARATOR = ":";
      function escape4(key2) {
        var escapeRegex = /[=:]/g, escaperLookup = {
          "=": "=0",
          ":": "=2"
        }, escapedString = key2.replace(escapeRegex, function(match) {
          return escaperLookup[match];
        });
        return "$" + escapedString;
      }
      var didWarnAboutMaps = !1, userProvidedKeyEscapeRegex = /\/+/g;
      function escapeUserProvidedKey(text) {
        return text.replace(userProvidedKeyEscapeRegex, "$&/");
      }
      function getElementKey(element, index2) {
        return typeof element == "object" && element !== null && element.key != null ? (checkKeyStringCoercion(element.key), escape4("" + element.key)) : index2.toString(36);
      }
      function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
        var type2 = typeof children;
        (type2 === "undefined" || type2 === "boolean") && (children = null);
        var invokeCallback = !1;
        if (children === null)
          invokeCallback = !0;
        else
          switch (type2) {
            case "string":
            case "number":
              invokeCallback = !0;
              break;
            case "object":
              switch (children.$$typeof) {
                case REACT_ELEMENT_TYPE:
                case REACT_PORTAL_TYPE:
                  invokeCallback = !0;
              }
          }
        if (invokeCallback) {
          var _child = children, mappedChild = callback(_child), childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
          if (isArray3(mappedChild)) {
            var escapedChildKey = "";
            childKey != null && (escapedChildKey = escapeUserProvidedKey(childKey) + "/"), mapIntoArray(mappedChild, array, escapedChildKey, "", function(c4) {
              return c4;
            });
          } else
            mappedChild != null && (isValidElement4(mappedChild) && (mappedChild.key && (!_child || _child.key !== mappedChild.key) && checkKeyStringCoercion(mappedChild.key), mappedChild = cloneAndReplaceKey(
              mappedChild,
              escapedPrefix + (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? escapeUserProvidedKey("" + mappedChild.key) + "/" : "") + childKey
            )), array.push(mappedChild));
          return 1;
        }
        var child, nextName, subtreeCount = 0, nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
        if (isArray3(children))
          for (var i3 = 0; i3 < children.length; i3++)
            child = children[i3], nextName = nextNamePrefix + getElementKey(child, i3), subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
        else {
          var iteratorFn = getIteratorFn(children);
          if (typeof iteratorFn == "function") {
            var iterableChildren = children;
            iteratorFn === iterableChildren.entries && (didWarnAboutMaps || warn3("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), didWarnAboutMaps = !0);
            for (var iterator = iteratorFn.call(iterableChildren), step, ii = 0; !(step = iterator.next()).done; )
              child = step.value, nextName = nextNamePrefix + getElementKey(child, ii++), subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
          } else if (type2 === "object") {
            var childrenString = String(children);
            throw new Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). If you meant to render a collection of children, use an array instead.");
          }
        }
        return subtreeCount;
      }
      function mapChildren(children, func, context) {
        if (children == null)
          return children;
        var result2 = [], count = 0;
        return mapIntoArray(children, result2, "", "", function(child) {
          return func.call(context, child, count++);
        }), result2;
      }
      function countChildren(children) {
        var n3 = 0;
        return mapChildren(children, function() {
          n3++;
        }), n3;
      }
      function forEachChildren(children, forEachFunc, forEachContext) {
        mapChildren(children, function() {
          forEachFunc.apply(this, arguments);
        }, forEachContext);
      }
      function toArray2(children) {
        return mapChildren(children, function(child) {
          return child;
        }) || [];
      }
      function onlyChild(children) {
        if (!isValidElement4(children))
          throw new Error("React.Children.only expected to receive a single React element child.");
        return children;
      }
      function createContext12(defaultValue) {
        var context = {
          $$typeof: REACT_CONTEXT_TYPE,
          _currentValue: defaultValue,
          _currentValue2: defaultValue,
          _threadCount: 0,
          Provider: null,
          Consumer: null,
          _defaultValue: null,
          _globalName: null
        };
        context.Provider = {
          $$typeof: REACT_PROVIDER_TYPE,
          _context: context
        };
        var hasWarnedAboutUsingNestedContextConsumers = !1, hasWarnedAboutUsingConsumerProvider = !1, hasWarnedAboutDisplayNameOnConsumer = !1;
        {
          var Consumer = {
            $$typeof: REACT_CONTEXT_TYPE,
            _context: context
          };
          Object.defineProperties(Consumer, {
            Provider: {
              get: function() {
                return hasWarnedAboutUsingConsumerProvider || (hasWarnedAboutUsingConsumerProvider = !0, error2("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?")), context.Provider;
              },
              set: function(_Provider) {
                context.Provider = _Provider;
              }
            },
            _currentValue: {
              get: function() {
                return context._currentValue;
              },
              set: function(_currentValue) {
                context._currentValue = _currentValue;
              }
            },
            _currentValue2: {
              get: function() {
                return context._currentValue2;
              },
              set: function(_currentValue2) {
                context._currentValue2 = _currentValue2;
              }
            },
            _threadCount: {
              get: function() {
                return context._threadCount;
              },
              set: function(_threadCount) {
                context._threadCount = _threadCount;
              }
            },
            Consumer: {
              get: function() {
                return hasWarnedAboutUsingNestedContextConsumers || (hasWarnedAboutUsingNestedContextConsumers = !0, error2("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?")), context.Consumer;
              }
            },
            displayName: {
              get: function() {
                return context.displayName;
              },
              set: function(displayName) {
                hasWarnedAboutDisplayNameOnConsumer || (warn3("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName), hasWarnedAboutDisplayNameOnConsumer = !0);
              }
            }
          }), context.Consumer = Consumer;
        }
        return context._currentRenderer = null, context._currentRenderer2 = null, context;
      }
      var Uninitialized = -1, Pending = 0, Resolved = 1, Rejected = 2;
      function lazyInitializer(payload) {
        if (payload._status === Uninitialized) {
          var ctor = payload._result, thenable = ctor();
          if (thenable.then(function(moduleObject2) {
            if (payload._status === Pending || payload._status === Uninitialized) {
              var resolved = payload;
              resolved._status = Resolved, resolved._result = moduleObject2;
            }
          }, function(error3) {
            if (payload._status === Pending || payload._status === Uninitialized) {
              var rejected = payload;
              rejected._status = Rejected, rejected._result = error3;
            }
          }), payload._status === Uninitialized) {
            var pending = payload;
            pending._status = Pending, pending._result = thenable;
          }
        }
        if (payload._status === Resolved) {
          var moduleObject = payload._result;
          return moduleObject === void 0 && error2(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`, moduleObject), "default" in moduleObject || error2(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`, moduleObject), moduleObject.default;
        } else
          throw payload._result;
      }
      function lazy(ctor) {
        var payload = {
          _status: Uninitialized,
          _result: ctor
        }, lazyType = {
          $$typeof: REACT_LAZY_TYPE,
          _payload: payload,
          _init: lazyInitializer
        };
        {
          var defaultProps, propTypes;
          Object.defineProperties(lazyType, {
            defaultProps: {
              configurable: !0,
              get: function() {
                return defaultProps;
              },
              set: function(newDefaultProps) {
                error2("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), defaultProps = newDefaultProps, Object.defineProperty(lazyType, "defaultProps", {
                  enumerable: !0
                });
              }
            },
            propTypes: {
              configurable: !0,
              get: function() {
                return propTypes;
              },
              set: function(newPropTypes) {
                error2("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), propTypes = newPropTypes, Object.defineProperty(lazyType, "propTypes", {
                  enumerable: !0
                });
              }
            }
          });
        }
        return lazyType;
      }
      function forwardRef6(render) {
        render != null && render.$$typeof === REACT_MEMO_TYPE ? error2("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).") : typeof render != "function" ? error2("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render) : render.length !== 0 && render.length !== 2 && error2("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."), render != null && (render.defaultProps != null || render.propTypes != null) && error2("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
        var elementType = {
          $$typeof: REACT_FORWARD_REF_TYPE,
          render
        };
        {
          var ownName;
          Object.defineProperty(elementType, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return ownName;
            },
            set: function(name) {
              ownName = name, !render.name && !render.displayName && (render.displayName = name);
            }
          });
        }
        return elementType;
      }
      var REACT_MODULE_REFERENCE;
      REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
      function isValidElementType(type2) {
        return !!(typeof type2 == "string" || typeof type2 == "function" || type2 === REACT_FRAGMENT_TYPE || type2 === REACT_PROFILER_TYPE || enableDebugTracing || type2 === REACT_STRICT_MODE_TYPE || type2 === REACT_SUSPENSE_TYPE || type2 === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type2 === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing || typeof type2 == "object" && type2 !== null && (type2.$$typeof === REACT_LAZY_TYPE || type2.$$typeof === REACT_MEMO_TYPE || type2.$$typeof === REACT_PROVIDER_TYPE || type2.$$typeof === REACT_CONTEXT_TYPE || type2.$$typeof === REACT_FORWARD_REF_TYPE || type2.$$typeof === REACT_MODULE_REFERENCE || type2.getModuleId !== void 0));
      }
      function memo13(type2, compare3) {
        isValidElementType(type2) || error2("memo: The first argument must be a component. Instead received: %s", type2 === null ? "null" : typeof type2);
        var elementType = {
          $$typeof: REACT_MEMO_TYPE,
          type: type2,
          compare: compare3 === void 0 ? null : compare3
        };
        {
          var ownName;
          Object.defineProperty(elementType, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return ownName;
            },
            set: function(name) {
              ownName = name, !type2.name && !type2.displayName && (type2.displayName = name);
            }
          });
        }
        return elementType;
      }
      function resolveDispatcher() {
        var dispatcher = ReactCurrentDispatcher.current;
        return dispatcher === null && error2(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`), dispatcher;
      }
      function useContext17(Context) {
        var dispatcher = resolveDispatcher();
        if (Context._context !== void 0) {
          var realContext = Context._context;
          realContext.Consumer === Context ? error2("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?") : realContext.Provider === Context && error2("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
        }
        return dispatcher.useContext(Context);
      }
      function useState14(initialState) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useState(initialState);
      }
      function useReducer(reducer, initialArg, init4) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useReducer(reducer, initialArg, init4);
      }
      function useRef14(initialValue) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useRef(initialValue);
      }
      function useEffect16(create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useEffect(create, deps);
      }
      function useInsertionEffect3(create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useInsertionEffect(create, deps);
      }
      function useLayoutEffect6(create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useLayoutEffect(create, deps);
      }
      function useCallback5(callback, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useCallback(callback, deps);
      }
      function useMemo11(create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useMemo(create, deps);
      }
      function useImperativeHandle(ref, create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useImperativeHandle(ref, create, deps);
      }
      function useDebugValue2(value2, formatterFn) {
        {
          var dispatcher = resolveDispatcher();
          return dispatcher.useDebugValue(value2, formatterFn);
        }
      }
      function useTransition2() {
        var dispatcher = resolveDispatcher();
        return dispatcher.useTransition();
      }
      function useDeferredValue(value2) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useDeferredValue(value2);
      }
      function useId4() {
        var dispatcher = resolveDispatcher();
        return dispatcher.useId();
      }
      function useSyncExternalStore3(subscribe, getSnapshot, getServerSnapshot) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      }
      var disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
      function disabledLog() {
      }
      disabledLog.__reactDisabledLog = !0;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log, prevInfo = console.info, prevWarn = console.warn, prevError = console.error, prevGroup = console.group, prevGroupCollapsed = console.groupCollapsed, prevGroupEnd = console.groupEnd;
            var props = {
              configurable: !0,
              enumerable: !0,
              value: disabledLog,
              writable: !0
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          if (disabledDepth--, disabledDepth === 0) {
            var props = {
              configurable: !0,
              enumerable: !0,
              writable: !0
            };
            Object.defineProperties(console, {
              log: assign({}, props, {
                value: prevLog
              }),
              info: assign({}, props, {
                value: prevInfo
              }),
              warn: assign({}, props, {
                value: prevWarn
              }),
              error: assign({}, props, {
                value: prevError
              }),
              group: assign({}, props, {
                value: prevGroup
              }),
              groupCollapsed: assign({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: assign({}, props, {
                value: prevGroupEnd
              })
            });
          }
          disabledDepth < 0 && error2("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
      }
      var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher, prefix;
      function describeBuiltInComponentFrame(name, source2, ownerFn) {
        {
          if (prefix === void 0)
            try {
              throw Error();
            } catch (x2) {
              var match = x2.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
            }
          return `
` + prefix + name;
        }
      }
      var reentry = !1, componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap == "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap();
      }
      function describeNativeComponentFrame(fn, construct4) {
        if (!fn || reentry)
          return "";
        {
          var frame = componentFrameCache.get(fn);
          if (frame !== void 0)
            return frame;
        }
        var control;
        reentry = !0;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var previousDispatcher;
        previousDispatcher = ReactCurrentDispatcher$1.current, ReactCurrentDispatcher$1.current = null, disableLogs();
        try {
          if (construct4) {
            var Fake = function() {
              throw Error();
            };
            if (Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x2) {
                control = x2;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x2) {
                control = x2;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x2) {
              control = x2;
            }
            fn();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack == "string") {
            for (var sampleLines = sample.stack.split(`
`), controlLines = control.stack.split(`
`), s3 = sampleLines.length - 1, c4 = controlLines.length - 1; s3 >= 1 && c4 >= 0 && sampleLines[s3] !== controlLines[c4]; )
              c4--;
            for (; s3 >= 1 && c4 >= 0; s3--, c4--)
              if (sampleLines[s3] !== controlLines[c4]) {
                if (s3 !== 1 || c4 !== 1)
                  do
                    if (s3--, c4--, c4 < 0 || sampleLines[s3] !== controlLines[c4]) {
                      var _frame = `
` + sampleLines[s3].replace(" at new ", " at ");
                      return fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName)), typeof fn == "function" && componentFrameCache.set(fn, _frame), _frame;
                    }
                  while (s3 >= 1 && c4 >= 0);
                break;
              }
          }
        } finally {
          reentry = !1, ReactCurrentDispatcher$1.current = previousDispatcher, reenableLogs(), Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name = fn ? fn.displayName || fn.name : "", syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
        return typeof fn == "function" && componentFrameCache.set(fn, syntheticFrame), syntheticFrame;
      }
      function describeFunctionComponentFrame(fn, source2, ownerFn) {
        return describeNativeComponentFrame(fn, !1);
      }
      function shouldConstruct(Component4) {
        var prototype = Component4.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type2, source2, ownerFn) {
        if (type2 == null)
          return "";
        if (typeof type2 == "function")
          return describeNativeComponentFrame(type2, shouldConstruct(type2));
        if (typeof type2 == "string")
          return describeBuiltInComponentFrame(type2);
        switch (type2) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type2 == "object")
          switch (type2.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type2.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type2.type, source2, ownerFn);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type2, payload = lazyComponent._payload, init4 = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init4(payload), source2, ownerFn);
              } catch {
              }
            }
          }
        return "";
      }
      var loggedTypeFailures = {}, ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        if (element) {
          var owner = element._owner, stack2 = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
          ReactDebugCurrentFrame$1.setExtraStackFrame(stack2);
        } else
          ReactDebugCurrentFrame$1.setExtraStackFrame(null);
      }
      function checkPropTypes(typeSpecs, values, location, componentName, element) {
        {
          var has = Function.call.bind(hasOwnProperty2);
          for (var typeSpecName in typeSpecs)
            if (has(typeSpecs, typeSpecName)) {
              var error$1 = void 0;
              try {
                if (typeof typeSpecs[typeSpecName] != "function") {
                  var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw err.name = "Invariant Violation", err;
                }
                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex) {
                error$1 = ex;
              }
              error$1 && !(error$1 instanceof Error) && (setCurrentlyValidatingElement(element), error2("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1), setCurrentlyValidatingElement(null)), error$1 instanceof Error && !(error$1.message in loggedTypeFailures) && (loggedTypeFailures[error$1.message] = !0, setCurrentlyValidatingElement(element), error2("Failed %s type: %s", location, error$1.message), setCurrentlyValidatingElement(null));
            }
        }
      }
      function setCurrentlyValidatingElement$1(element) {
        if (element) {
          var owner = element._owner, stack2 = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
          setExtraStackFrame(stack2);
        } else
          setExtraStackFrame(null);
      }
      var propTypesMisspellWarningShown;
      propTypesMisspellWarningShown = !1;
      function getDeclarationErrorAddendum() {
        if (ReactCurrentOwner.current) {
          var name = getComponentNameFromType(ReactCurrentOwner.current.type);
          if (name)
            return `

Check the render method of \`` + name + "`.";
        }
        return "";
      }
      function getSourceInfoErrorAddendum(source2) {
        if (source2 !== void 0) {
          var fileName = source2.fileName.replace(/^.*[\\\/]/, ""), lineNumber = source2.lineNumber;
          return `

Check your code at ` + fileName + ":" + lineNumber + ".";
        }
        return "";
      }
      function getSourceInfoErrorAddendumForProps(elementProps) {
        return elementProps != null ? getSourceInfoErrorAddendum(elementProps.__source) : "";
      }
      var ownerHasKeyUseWarning = {};
      function getCurrentComponentErrorInfo(parentType) {
        var info = getDeclarationErrorAddendum();
        if (!info) {
          var parentName = typeof parentType == "string" ? parentType : parentType.displayName || parentType.name;
          parentName && (info = `

Check the top-level render call using <` + parentName + ">.");
        }
        return info;
      }
      function validateExplicitKey(element, parentType) {
        if (!(!element._store || element._store.validated || element.key != null)) {
          element._store.validated = !0;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (!ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            ownerHasKeyUseWarning[currentComponentErrorInfo] = !0;
            var childOwner = "";
            element && element._owner && element._owner !== ReactCurrentOwner.current && (childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + "."), setCurrentlyValidatingElement$1(element), error2('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner), setCurrentlyValidatingElement$1(null);
          }
        }
      }
      function validateChildKeys(node, parentType) {
        if (typeof node == "object") {
          if (isArray3(node))
            for (var i3 = 0; i3 < node.length; i3++) {
              var child = node[i3];
              isValidElement4(child) && validateExplicitKey(child, parentType);
            }
          else if (isValidElement4(node))
            node._store && (node._store.validated = !0);
          else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn == "function" && iteratorFn !== node.entries)
              for (var iterator = iteratorFn.call(node), step; !(step = iterator.next()).done; )
                isValidElement4(step.value) && validateExplicitKey(step.value, parentType);
          }
        }
      }
      function validatePropTypes(element) {
        {
          var type2 = element.type;
          if (type2 == null || typeof type2 == "string")
            return;
          var propTypes;
          if (typeof type2 == "function")
            propTypes = type2.propTypes;
          else if (typeof type2 == "object" && (type2.$$typeof === REACT_FORWARD_REF_TYPE || type2.$$typeof === REACT_MEMO_TYPE))
            propTypes = type2.propTypes;
          else
            return;
          if (propTypes) {
            var name = getComponentNameFromType(type2);
            checkPropTypes(propTypes, element.props, "prop", name, element);
          } else if (type2.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
            propTypesMisspellWarningShown = !0;
            var _name = getComponentNameFromType(type2);
            error2("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
          }
          typeof type2.getDefaultProps == "function" && !type2.getDefaultProps.isReactClassApproved && error2("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
        }
      }
      function validateFragmentProps(fragment) {
        {
          for (var keys2 = Object.keys(fragment.props), i3 = 0; i3 < keys2.length; i3++) {
            var key2 = keys2[i3];
            if (key2 !== "children" && key2 !== "key") {
              setCurrentlyValidatingElement$1(fragment), error2("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key2), setCurrentlyValidatingElement$1(null);
              break;
            }
          }
          fragment.ref !== null && (setCurrentlyValidatingElement$1(fragment), error2("Invalid attribute `ref` supplied to `React.Fragment`."), setCurrentlyValidatingElement$1(null));
        }
      }
      function createElementWithValidation(type2, props, children) {
        var validType = isValidElementType(type2);
        if (!validType) {
          var info = "";
          (type2 === void 0 || typeof type2 == "object" && type2 !== null && Object.keys(type2).length === 0) && (info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var sourceInfo = getSourceInfoErrorAddendumForProps(props);
          sourceInfo ? info += sourceInfo : info += getDeclarationErrorAddendum();
          var typeString;
          type2 === null ? typeString = "null" : isArray3(type2) ? typeString = "array" : type2 !== void 0 && type2.$$typeof === REACT_ELEMENT_TYPE ? (typeString = "<" + (getComponentNameFromType(type2.type) || "Unknown") + " />", info = " Did you accidentally export a JSX literal instead of a component?") : typeString = typeof type2, error2("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
        }
        var element = createElement18.apply(this, arguments);
        if (element == null)
          return element;
        if (validType)
          for (var i3 = 2; i3 < arguments.length; i3++)
            validateChildKeys(arguments[i3], type2);
        return type2 === REACT_FRAGMENT_TYPE ? validateFragmentProps(element) : validatePropTypes(element), element;
      }
      var didWarnAboutDeprecatedCreateFactory = !1;
      function createFactoryWithValidation(type2) {
        var validatedFactory = createElementWithValidation.bind(null, type2);
        return validatedFactory.type = type2, didWarnAboutDeprecatedCreateFactory || (didWarnAboutDeprecatedCreateFactory = !0, warn3("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.")), Object.defineProperty(validatedFactory, "type", {
          enumerable: !1,
          get: function() {
            return warn3("Factory.type is deprecated. Access the class directly before passing it to createFactory."), Object.defineProperty(this, "type", {
              value: type2
            }), type2;
          }
        }), validatedFactory;
      }
      function cloneElementWithValidation(element, props, children) {
        for (var newElement = cloneElement4.apply(this, arguments), i3 = 2; i3 < arguments.length; i3++)
          validateChildKeys(arguments[i3], newElement.type);
        return validatePropTypes(newElement), newElement;
      }
      function startTransition(scope, options2) {
        var prevTransition = ReactCurrentBatchConfig.transition;
        ReactCurrentBatchConfig.transition = {};
        var currentTransition = ReactCurrentBatchConfig.transition;
        ReactCurrentBatchConfig.transition._updatedFibers = /* @__PURE__ */ new Set();
        try {
          scope();
        } finally {
          if (ReactCurrentBatchConfig.transition = prevTransition, prevTransition === null && currentTransition._updatedFibers) {
            var updatedFibersCount = currentTransition._updatedFibers.size;
            updatedFibersCount > 10 && warn3("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), currentTransition._updatedFibers.clear();
          }
        }
      }
      var didWarnAboutMessageChannel = !1, enqueueTaskImpl = null;
      function enqueueTask(task) {
        if (enqueueTaskImpl === null)
          try {
            var requireString = ("require" + Math.random()).slice(0, 7), nodeRequire = module2 && module2[requireString];
            enqueueTaskImpl = nodeRequire.call(module2, "timers").setImmediate;
          } catch {
            enqueueTaskImpl = function(callback) {
              didWarnAboutMessageChannel === !1 && (didWarnAboutMessageChannel = !0, typeof MessageChannel > "u" && error2("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));
              var channel = new MessageChannel();
              channel.port1.onmessage = callback, channel.port2.postMessage(void 0);
            };
          }
        return enqueueTaskImpl(task);
      }
      var actScopeDepth = 0, didWarnNoAwaitAct = !1;
      function act(callback) {
        {
          var prevActScopeDepth = actScopeDepth;
          actScopeDepth++, ReactCurrentActQueue.current === null && (ReactCurrentActQueue.current = []);
          var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy, result2;
          try {
            if (ReactCurrentActQueue.isBatchingLegacy = !0, result2 = callback(), !prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {
              var queue2 = ReactCurrentActQueue.current;
              queue2 !== null && (ReactCurrentActQueue.didScheduleLegacyUpdate = !1, flushActQueue(queue2));
            }
          } catch (error3) {
            throw popActScope(prevActScopeDepth), error3;
          } finally {
            ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
          }
          if (result2 !== null && typeof result2 == "object" && typeof result2.then == "function") {
            var thenableResult = result2, wasAwaited = !1, thenable = {
              then: function(resolve2, reject) {
                wasAwaited = !0, thenableResult.then(function(returnValue2) {
                  popActScope(prevActScopeDepth), actScopeDepth === 0 ? recursivelyFlushAsyncActWork(returnValue2, resolve2, reject) : resolve2(returnValue2);
                }, function(error3) {
                  popActScope(prevActScopeDepth), reject(error3);
                });
              }
            };
            return !didWarnNoAwaitAct && typeof Promise < "u" && Promise.resolve().then(function() {
            }).then(function() {
              wasAwaited || (didWarnNoAwaitAct = !0, error2("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"));
            }), thenable;
          } else {
            var returnValue = result2;
            if (popActScope(prevActScopeDepth), actScopeDepth === 0) {
              var _queue = ReactCurrentActQueue.current;
              _queue !== null && (flushActQueue(_queue), ReactCurrentActQueue.current = null);
              var _thenable = {
                then: function(resolve2, reject) {
                  ReactCurrentActQueue.current === null ? (ReactCurrentActQueue.current = [], recursivelyFlushAsyncActWork(returnValue, resolve2, reject)) : resolve2(returnValue);
                }
              };
              return _thenable;
            } else {
              var _thenable2 = {
                then: function(resolve2, reject) {
                  resolve2(returnValue);
                }
              };
              return _thenable2;
            }
          }
        }
      }
      function popActScope(prevActScopeDepth) {
        prevActScopeDepth !== actScopeDepth - 1 && error2("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "), actScopeDepth = prevActScopeDepth;
      }
      function recursivelyFlushAsyncActWork(returnValue, resolve2, reject) {
        {
          var queue2 = ReactCurrentActQueue.current;
          if (queue2 !== null)
            try {
              flushActQueue(queue2), enqueueTask(function() {
                queue2.length === 0 ? (ReactCurrentActQueue.current = null, resolve2(returnValue)) : recursivelyFlushAsyncActWork(returnValue, resolve2, reject);
              });
            } catch (error3) {
              reject(error3);
            }
          else
            resolve2(returnValue);
        }
      }
      var isFlushing = !1;
      function flushActQueue(queue2) {
        if (!isFlushing) {
          isFlushing = !0;
          var i3 = 0;
          try {
            for (; i3 < queue2.length; i3++) {
              var callback = queue2[i3];
              do
                callback = callback(!0);
              while (callback !== null);
            }
            queue2.length = 0;
          } catch (error3) {
            throw queue2 = queue2.slice(i3 + 1), error3;
          } finally {
            isFlushing = !1;
          }
        }
      }
      var createElement$1 = createElementWithValidation, cloneElement$1 = cloneElementWithValidation, createFactory = createFactoryWithValidation, Children3 = {
        map: mapChildren,
        forEach: forEachChildren,
        count: countChildren,
        toArray: toArray2,
        only: onlyChild
      };
      exports.Children = Children3, exports.Component = Component3, exports.Fragment = REACT_FRAGMENT_TYPE, exports.Profiler = REACT_PROFILER_TYPE, exports.PureComponent = PureComponent, exports.StrictMode = REACT_STRICT_MODE_TYPE, exports.Suspense = REACT_SUSPENSE_TYPE, exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals, exports.cloneElement = cloneElement$1, exports.createContext = createContext12, exports.createElement = createElement$1, exports.createFactory = createFactory, exports.createRef = createRef, exports.forwardRef = forwardRef6, exports.isValidElement = isValidElement4, exports.lazy = lazy, exports.memo = memo13, exports.startTransition = startTransition, exports.unstable_act = act, exports.useCallback = useCallback5, exports.useContext = useContext17, exports.useDebugValue = useDebugValue2, exports.useDeferredValue = useDeferredValue, exports.useEffect = useEffect16, exports.useId = useId4, exports.useImperativeHandle = useImperativeHandle, exports.useInsertionEffect = useInsertionEffect3, exports.useLayoutEffect = useLayoutEffect6, exports.useMemo = useMemo11, exports.useReducer = useReducer, exports.useRef = useRef14, exports.useState = useState14, exports.useSyncExternalStore = useSyncExternalStore3, exports.useTransition = useTransition2, exports.version = ReactVersion, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    })();
  }
});

// node_modules/react/index.js
var require_react = __commonJS({
  "node_modules/react/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_react_development();
  }
});

// node_modules/react-router/dist/index.js
function isPolyfill(x2, y2) {
  return x2 === y2 && (x2 !== 0 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
}
function useSyncExternalStore$2(subscribe, getSnapshot, getServerSnapshot) {
  didWarnOld18Alpha || "startTransition" in React && (didWarnOld18Alpha = !0, console.error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
  let value2 = getSnapshot();
  if (!didWarnUncachedGetSnapshot) {
    let cachedValue = getSnapshot();
    is(value2, cachedValue) || (console.error("The result of getSnapshot should be cached to avoid an infinite loop"), didWarnUncachedGetSnapshot = !0);
  }
  let [{
    inst
  }, forceUpdate] = useState2({
    inst: {
      value: value2,
      getSnapshot
    }
  });
  return useLayoutEffect2(() => {
    inst.value = value2, inst.getSnapshot = getSnapshot, checkIfSnapshotChanged(inst) && forceUpdate({
      inst
    });
  }, [subscribe, value2, getSnapshot]), useEffect2(() => (checkIfSnapshotChanged(inst) && forceUpdate({
    inst
  }), subscribe(() => {
    checkIfSnapshotChanged(inst) && forceUpdate({
      inst
    });
  })), [subscribe]), useDebugValue(value2), value2;
}
function checkIfSnapshotChanged(inst) {
  let latestGetSnapshot = inst.getSnapshot, prevValue = inst.value;
  try {
    let nextValue = latestGetSnapshot();
    return !is(prevValue, nextValue);
  } catch {
    return !0;
  }
}
function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
  return getSnapshot();
}
function _extends2() {
  return _extends2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source2 = arguments[i3];
      for (var key2 in source2)
        Object.prototype.hasOwnProperty.call(source2, key2) && (target[key2] = source2[key2]);
    }
    return target;
  }, _extends2.apply(this, arguments);
}
function useHref(to, _temp) {
  let {
    relative: relative2
  } = _temp === void 0 ? {} : _temp;
  useInRouterContext() || invariant(
    !1,
    "useHref() may be used only in the context of a <Router> component."
  );
  let {
    basename: basename2,
    navigator: navigator2
  } = React.useContext(NavigationContext), {
    hash,
    pathname,
    search
  } = useResolvedPath(to, {
    relative: relative2
  }), joinedPathname = pathname;
  return basename2 !== "/" && (joinedPathname = pathname === "/" ? basename2 : joinPaths([basename2, pathname])), navigator2.createHref({
    pathname: joinedPathname,
    search,
    hash
  });
}
function useInRouterContext() {
  return React.useContext(LocationContext) != null;
}
function useLocation() {
  return useInRouterContext() || invariant(
    !1,
    "useLocation() may be used only in the context of a <Router> component."
  ), React.useContext(LocationContext).location;
}
function useNavigationType() {
  return React.useContext(LocationContext).navigationType;
}
function useMatch(pattern) {
  useInRouterContext() || invariant(
    !1,
    "useMatch() may be used only in the context of a <Router> component."
  );
  let {
    pathname
  } = useLocation();
  return React.useMemo(() => matchPath(pattern, pathname), [pathname, pattern]);
}
function useNavigate() {
  useInRouterContext() || invariant(
    !1,
    "useNavigate() may be used only in the context of a <Router> component."
  );
  let {
    basename: basename2,
    navigator: navigator2
  } = React.useContext(NavigationContext), {
    matches
  } = React.useContext(RouteContext), {
    pathname: locationPathname
  } = useLocation(), routePathnamesJson = JSON.stringify(getPathContributingMatches(matches).map((match) => match.pathnameBase)), activeRef = React.useRef(!1);
  return React.useEffect(() => {
    activeRef.current = !0;
  }), React.useCallback(function(to, options2) {
    if (options2 === void 0 && (options2 = {}), warning(activeRef.current, "You should call navigate() in a React.useEffect(), not when your component is first rendered."), !activeRef.current)
      return;
    if (typeof to == "number") {
      navigator2.go(to);
      return;
    }
    let path2 = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options2.relative === "path");
    basename2 !== "/" && (path2.pathname = path2.pathname === "/" ? basename2 : joinPaths([basename2, path2.pathname])), (options2.replace ? navigator2.replace : navigator2.push)(path2, options2.state, options2);
  }, [basename2, navigator2, routePathnamesJson, locationPathname]);
}
function useOutletContext() {
  return React.useContext(OutletContext);
}
function useOutlet(context) {
  let outlet = React.useContext(RouteContext).outlet;
  return outlet && /* @__PURE__ */ React.createElement(OutletContext.Provider, {
    value: context
  }, outlet);
}
function useParams() {
  let {
    matches
  } = React.useContext(RouteContext), routeMatch = matches[matches.length - 1];
  return routeMatch ? routeMatch.params : {};
}
function useResolvedPath(to, _temp2) {
  let {
    relative: relative2
  } = _temp2 === void 0 ? {} : _temp2, {
    matches
  } = React.useContext(RouteContext), {
    pathname: locationPathname
  } = useLocation(), routePathnamesJson = JSON.stringify(getPathContributingMatches(matches).map((match) => match.pathnameBase));
  return React.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative2 === "path"), [to, routePathnamesJson, locationPathname, relative2]);
}
function useRoutes(routes2, locationArg) {
  useInRouterContext() || invariant(
    !1,
    "useRoutes() may be used only in the context of a <Router> component."
  );
  let {
    navigator: navigator2
  } = React.useContext(NavigationContext), dataRouterStateContext = React.useContext(DataRouterStateContext), {
    matches: parentMatches
  } = React.useContext(RouteContext), routeMatch = parentMatches[parentMatches.length - 1], parentParams = routeMatch ? routeMatch.params : {}, parentPathname = routeMatch ? routeMatch.pathname : "/", parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/", parentRoute = routeMatch && routeMatch.route;
  {
    let parentPath = parentRoute && parentRoute.path || "";
    warningOnce(parentPathname, !parentRoute || parentPath.endsWith("*"), "You rendered descendant <Routes> (or called `useRoutes()`) at " + ('"' + parentPathname + '" (under <Route path="' + parentPath + '">) but the ') + `parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

` + ('Please change the parent <Route path="' + parentPath + '"> to <Route ') + ('path="' + (parentPath === "/" ? "*" : parentPath + "/*") + '">.'));
  }
  let locationFromContext = useLocation(), location;
  if (locationArg) {
    var _parsedLocationArg$pa;
    let parsedLocationArg = typeof locationArg == "string" ? parsePath(locationArg) : locationArg;
    parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase)) || invariant(!1, "When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, the location pathname must begin with the portion of the URL pathname that was " + ('matched by all parent routes. The current pathname base is "' + parentPathnameBase + '" ') + ('but pathname "' + parsedLocationArg.pathname + '" was given in the `location` prop.')), location = parsedLocationArg;
  } else
    location = locationFromContext;
  let pathname = location.pathname || "/", remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/", matches = matchRoutes(routes2, {
    pathname: remainingPathname
  });
  warning(parentRoute || matches != null, 'No routes matched location "' + location.pathname + location.search + location.hash + '" '), warning(matches == null || matches[matches.length - 1].route.element !== void 0 || matches[matches.length - 1].route.Component !== void 0, 'Matched leaf route at location "' + location.pathname + location.search + location.hash + '" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.');
  let renderedMatches = _renderMatches(matches && matches.map((match) => Object.assign({}, match, {
    params: Object.assign({}, parentParams, match.params),
    pathname: joinPaths([
      parentPathnameBase,
      navigator2.encodeLocation ? navigator2.encodeLocation(match.pathname).pathname : match.pathname
    ]),
    pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([
      parentPathnameBase,
      navigator2.encodeLocation ? navigator2.encodeLocation(match.pathnameBase).pathname : match.pathnameBase
    ])
  })), parentMatches, dataRouterStateContext || void 0);
  return locationArg && renderedMatches ? /* @__PURE__ */ React.createElement(LocationContext.Provider, {
    value: {
      location: _extends2({
        pathname: "/",
        search: "",
        hash: "",
        state: null,
        key: "default"
      }, location),
      navigationType: Action.Pop
    }
  }, renderedMatches) : renderedMatches;
}
function DefaultErrorComponent() {
  let error2 = useRouteError(), message = isRouteErrorResponse(error2) ? error2.status + " " + error2.statusText : error2 instanceof Error ? error2.message : JSON.stringify(error2), stack2 = error2 instanceof Error ? error2.stack : null, lightgrey = "rgba(200,200,200, 0.5)", preStyles = {
    padding: "0.5rem",
    backgroundColor: lightgrey
  }, codeStyles = {
    padding: "2px 4px",
    backgroundColor: lightgrey
  }, devInfo = null;
  return devInfo = /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("p", null, "\u{1F4BF} Hey developer \u{1F44B}"), /* @__PURE__ */ React.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own\xA0", /* @__PURE__ */ React.createElement("code", {
    style: codeStyles
  }, "ErrorBoundary"), " prop on\xA0", /* @__PURE__ */ React.createElement("code", {
    style: codeStyles
  }, "<Route>"))), /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ React.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, message), stack2 ? /* @__PURE__ */ React.createElement("pre", {
    style: preStyles
  }, stack2) : null, devInfo);
}
function RenderedRoute(_ref) {
  let {
    routeContext,
    match,
    children
  } = _ref, dataRouterContext = React.useContext(DataRouterContext);
  return dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary) && (dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id), /* @__PURE__ */ React.createElement(RouteContext.Provider, {
    value: routeContext
  }, children);
}
function _renderMatches(matches, parentMatches, dataRouterState) {
  if (parentMatches === void 0 && (parentMatches = []), matches == null)
    if (dataRouterState != null && dataRouterState.errors)
      matches = dataRouterState.matches;
    else
      return null;
  let renderedMatches = matches, errors = dataRouterState == null ? void 0 : dataRouterState.errors;
  if (errors != null) {
    let errorIndex = renderedMatches.findIndex((m2) => m2.route.id && (errors == null ? void 0 : errors[m2.route.id]));
    errorIndex >= 0 || invariant(!1, "Could not find a matching route for the current errors: " + errors), renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
  }
  return renderedMatches.reduceRight((outlet, match, index2) => {
    let error2 = match.route.id ? errors == null ? void 0 : errors[match.route.id] : null, errorElement = null;
    dataRouterState && (match.route.ErrorBoundary ? errorElement = /* @__PURE__ */ React.createElement(match.route.ErrorBoundary, null) : match.route.errorElement ? errorElement = match.route.errorElement : errorElement = /* @__PURE__ */ React.createElement(DefaultErrorComponent, null));
    let matches2 = parentMatches.concat(renderedMatches.slice(0, index2 + 1)), getChildren3 = () => {
      let children = outlet;
      return error2 ? children = errorElement : match.route.Component ? children = /* @__PURE__ */ React.createElement(match.route.Component, null) : match.route.element && (children = match.route.element), /* @__PURE__ */ React.createElement(RenderedRoute, {
        match,
        routeContext: {
          outlet,
          matches: matches2
        },
        children
      });
    };
    return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index2 === 0) ? /* @__PURE__ */ React.createElement(RenderErrorBoundary, {
      location: dataRouterState.location,
      component: errorElement,
      error: error2,
      children: getChildren3(),
      routeContext: {
        outlet: null,
        matches: matches2
      }
    }) : getChildren3();
  }, null);
}
function getDataRouterConsoleError(hookName) {
  return hookName + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
}
function useDataRouterContext(hookName) {
  let ctx = React.useContext(DataRouterContext);
  return ctx || invariant(!1, getDataRouterConsoleError(hookName)), ctx;
}
function useDataRouterState(hookName) {
  let state = React.useContext(DataRouterStateContext);
  return state || invariant(!1, getDataRouterConsoleError(hookName)), state;
}
function useRouteContext(hookName) {
  let route = React.useContext(RouteContext);
  return route || invariant(!1, getDataRouterConsoleError(hookName)), route;
}
function useCurrentRouteId(hookName) {
  let route = useRouteContext(hookName), thisRoute = route.matches[route.matches.length - 1];
  return thisRoute.route.id || invariant(!1, hookName + ' can only be used on routes that contain a unique "id"'), thisRoute.route.id;
}
function useNavigation() {
  return useDataRouterState(DataRouterStateHook.UseNavigation).navigation;
}
function useRevalidator() {
  let dataRouterContext = useDataRouterContext(DataRouterHook.UseRevalidator), state = useDataRouterState(DataRouterStateHook.UseRevalidator);
  return {
    revalidate: dataRouterContext.router.revalidate,
    state: state.revalidation
  };
}
function useMatches() {
  let {
    matches,
    loaderData
  } = useDataRouterState(DataRouterStateHook.UseMatches);
  return React.useMemo(() => matches.map((match) => {
    let {
      pathname,
      params
    } = match;
    return {
      id: match.route.id,
      pathname,
      params,
      data: loaderData[match.route.id],
      handle: match.route.handle
    };
  }), [matches, loaderData]);
}
function useLoaderData() {
  let state = useDataRouterState(DataRouterStateHook.UseLoaderData), routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);
  if (state.errors && state.errors[routeId] != null) {
    console.error("You cannot `useLoaderData` in an errorElement (routeId: " + routeId + ")");
    return;
  }
  return state.loaderData[routeId];
}
function useRouteLoaderData(routeId) {
  return useDataRouterState(DataRouterStateHook.UseRouteLoaderData).loaderData[routeId];
}
function useActionData() {
  let state = useDataRouterState(DataRouterStateHook.UseActionData);
  return React.useContext(RouteContext) || invariant(!1, "useActionData must be used inside a RouteContext"), Object.values((state == null ? void 0 : state.actionData) || {})[0];
}
function useRouteError() {
  var _state$errors;
  let error2 = React.useContext(RouteErrorContext), state = useDataRouterState(DataRouterStateHook.UseRouteError), routeId = useCurrentRouteId(DataRouterStateHook.UseRouteError);
  return error2 || ((_state$errors = state.errors) == null ? void 0 : _state$errors[routeId]);
}
function useAsyncValue() {
  let value2 = React.useContext(AwaitContext);
  return value2 == null ? void 0 : value2._data;
}
function useAsyncError() {
  let value2 = React.useContext(AwaitContext);
  return value2 == null ? void 0 : value2._error;
}
function useBlocker(shouldBlock) {
  let {
    router: router2
  } = useDataRouterContext(DataRouterHook.UseBlocker), state = useDataRouterState(DataRouterStateHook.UseBlocker), [blockerKey] = React.useState(() => String(++blockerId)), blockerFunction = React.useCallback((args) => typeof shouldBlock == "function" ? !!shouldBlock(args) : !!shouldBlock, [shouldBlock]), blocker = router2.getBlocker(blockerKey, blockerFunction);
  return React.useEffect(() => () => router2.deleteBlocker(blockerKey), [router2, blockerKey]), state.blockers.get(blockerKey) || blocker;
}
function warningOnce(key2, cond, message) {
  !cond && !alreadyWarned2[key2] && (alreadyWarned2[key2] = !0, warning(!1, message));
}
function RouterProvider(_ref) {
  let {
    fallbackElement,
    router: router2
  } = _ref, getState = React.useCallback(() => router2.state, [router2]), state = useSyncExternalStore(
    router2.subscribe,
    getState,
    getState
  ), navigator2 = React.useMemo(() => ({
    createHref: router2.createHref,
    encodeLocation: router2.encodeLocation,
    go: (n3) => router2.navigate(n3),
    push: (to, state2, opts) => router2.navigate(to, {
      state: state2,
      preventScrollReset: opts == null ? void 0 : opts.preventScrollReset
    }),
    replace: (to, state2, opts) => router2.navigate(to, {
      replace: !0,
      state: state2,
      preventScrollReset: opts == null ? void 0 : opts.preventScrollReset
    })
  }), [router2]), basename2 = router2.basename || "/", dataRouterContext = React.useMemo(() => ({
    router: router2,
    navigator: navigator2,
    static: !1,
    basename: basename2
  }), [router2, navigator2, basename2]);
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(DataRouterContext.Provider, {
    value: dataRouterContext
  }, /* @__PURE__ */ React.createElement(DataRouterStateContext.Provider, {
    value: state
  }, /* @__PURE__ */ React.createElement(Router, {
    basename: router2.basename,
    location: router2.state.location,
    navigationType: router2.state.historyAction,
    navigator: navigator2
  }, router2.state.initialized ? /* @__PURE__ */ React.createElement(Routes, null) : fallbackElement))), null);
}
function MemoryRouter(_ref2) {
  let {
    basename: basename2,
    children,
    initialEntries,
    initialIndex
  } = _ref2, historyRef = React.useRef();
  historyRef.current == null && (historyRef.current = createMemoryHistory({
    initialEntries,
    initialIndex,
    v5Compat: !0
  }));
  let history = historyRef.current, [state, setState] = React.useState({
    action: history.action,
    location: history.location
  });
  return React.useLayoutEffect(() => history.listen(setState), [history]), /* @__PURE__ */ React.createElement(Router, {
    basename: basename2,
    children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
function Navigate(_ref3) {
  let {
    to,
    replace,
    state,
    relative: relative2
  } = _ref3;
  useInRouterContext() || invariant(
    !1,
    "<Navigate> may be used only in the context of a <Router> component."
  ), warning(!React.useContext(NavigationContext).static, "<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.");
  let dataRouterState = React.useContext(DataRouterStateContext), navigate = useNavigate();
  return React.useEffect(() => {
    dataRouterState && dataRouterState.navigation.state !== "idle" || navigate(to, {
      replace,
      state,
      relative: relative2
    });
  }), null;
}
function Outlet(props) {
  return useOutlet(props.context);
}
function Route(_props) {
  invariant(!1, "A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.");
}
function Router(_ref4) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = Action.Pop,
    navigator: navigator2,
    static: staticProp = !1
  } = _ref4;
  useInRouterContext() && invariant(!1, "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.");
  let basename2 = basenameProp.replace(/^\/*/, "/"), navigationContext = React.useMemo(() => ({
    basename: basename2,
    navigator: navigator2,
    static: staticProp
  }), [basename2, navigator2, staticProp]);
  typeof locationProp == "string" && (locationProp = parsePath(locationProp));
  let {
    pathname = "/",
    search = "",
    hash = "",
    state = null,
    key: key2 = "default"
  } = locationProp, locationContext = React.useMemo(() => {
    let trailingPathname = stripBasename(pathname, basename2);
    return trailingPathname == null ? null : {
      location: {
        pathname: trailingPathname,
        search,
        hash,
        state,
        key: key2
      },
      navigationType
    };
  }, [basename2, pathname, search, hash, state, key2, navigationType]);
  return warning(locationContext != null, '<Router basename="' + basename2 + '"> is not able to match the URL ' + ('"' + pathname + search + hash + '" because it does not start with the ') + "basename, so the <Router> won't render anything."), locationContext == null ? null : /* @__PURE__ */ React.createElement(NavigationContext.Provider, {
    value: navigationContext
  }, /* @__PURE__ */ React.createElement(LocationContext.Provider, {
    children,
    value: locationContext
  }));
}
function Routes(_ref5) {
  let {
    children,
    location
  } = _ref5, dataRouterContext = React.useContext(DataRouterContext), routes2 = dataRouterContext && !children ? dataRouterContext.router.routes : createRoutesFromChildren(children);
  return useRoutes(routes2, location);
}
function Await(_ref6) {
  let {
    children,
    errorElement,
    resolve: resolve2
  } = _ref6;
  return /* @__PURE__ */ React.createElement(AwaitErrorBoundary, {
    resolve: resolve2,
    errorElement
  }, /* @__PURE__ */ React.createElement(ResolveAwait, null, children));
}
function ResolveAwait(_ref7) {
  let {
    children
  } = _ref7, data2 = useAsyncValue(), toRender = typeof children == "function" ? children(data2) : children;
  return /* @__PURE__ */ React.createElement(React.Fragment, null, toRender);
}
function createRoutesFromChildren(children, parentPath) {
  parentPath === void 0 && (parentPath = []);
  let routes2 = [];
  return React.Children.forEach(children, (element, index2) => {
    if (!/* @__PURE__ */ React.isValidElement(element))
      return;
    let treePath = [...parentPath, index2];
    if (element.type === React.Fragment) {
      routes2.push.apply(routes2, createRoutesFromChildren(element.props.children, treePath));
      return;
    }
    element.type !== Route && invariant(!1, "[" + (typeof element.type == "string" ? element.type : element.type.name) + "] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>"), !element.props.index || !element.props.children || invariant(!1, "An index route cannot have child routes.");
    let route = {
      id: element.props.id || treePath.join("-"),
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      Component: element.props.Component,
      index: element.props.index,
      path: element.props.path,
      loader: element.props.loader,
      action: element.props.action,
      errorElement: element.props.errorElement,
      ErrorBoundary: element.props.ErrorBoundary,
      hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,
      shouldRevalidate: element.props.shouldRevalidate,
      handle: element.props.handle,
      lazy: element.props.lazy
    };
    element.props.children && (route.children = createRoutesFromChildren(element.props.children, treePath)), routes2.push(route);
  }), routes2;
}
function renderMatches(matches) {
  return _renderMatches(matches);
}
function detectErrorBoundary(route) {
  return route.Component && route.element && warning(!1, "You should not include both `Component` and `element` on your route - `element` will be ignored."), route.ErrorBoundary && route.errorElement && warning(!1, "You should not include both `ErrorBoundary` and `errorElement` on your route - `errorElement` will be ignored."), Boolean(route.ErrorBoundary) || Boolean(route.errorElement);
}
function createMemoryRouter(routes2, opts) {
  return createRouter({
    basename: opts == null ? void 0 : opts.basename,
    future: opts == null ? void 0 : opts.future,
    history: createMemoryHistory({
      initialEntries: opts == null ? void 0 : opts.initialEntries,
      initialIndex: opts == null ? void 0 : opts.initialIndex
    }),
    hydrationData: opts == null ? void 0 : opts.hydrationData,
    routes: routes2,
    detectErrorBoundary
  }).initialize();
}
var React, is, useState2, useEffect2, useLayoutEffect2, useDebugValue, didWarnOld18Alpha, didWarnUncachedGetSnapshot, canUseDOM, isServerEnvironment, shim, useSyncExternalStore, DataRouterContext, DataRouterStateContext, AwaitContext, NavigationContext, LocationContext, RouteContext, RouteErrorContext, OutletContext, RenderErrorBoundary, DataRouterHook, DataRouterStateHook, blockerId, alreadyWarned2, AwaitRenderStatus, neverSettledPromise, AwaitErrorBoundary, init_dist = __esm({
  "node_modules/react-router/dist/index.js"() {
    init_router();
    init_router();
    React = __toESM(require_react());
    is = typeof Object.is == "function" ? Object.is : isPolyfill, {
      useState: useState2,
      useEffect: useEffect2,
      useLayoutEffect: useLayoutEffect2,
      useDebugValue
    } = React, didWarnOld18Alpha = !1, didWarnUncachedGetSnapshot = !1;
    canUseDOM = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", isServerEnvironment = !canUseDOM, shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore$2, useSyncExternalStore = "useSyncExternalStore" in React ? ((module2) => module2.useSyncExternalStore)(React) : shim, DataRouterContext = /* @__PURE__ */ React.createContext(null);
    DataRouterContext.displayName = "DataRouter";
    DataRouterStateContext = /* @__PURE__ */ React.createContext(null);
    DataRouterStateContext.displayName = "DataRouterState";
    AwaitContext = /* @__PURE__ */ React.createContext(null);
    AwaitContext.displayName = "Await";
    NavigationContext = /* @__PURE__ */ React.createContext(null);
    NavigationContext.displayName = "Navigation";
    LocationContext = /* @__PURE__ */ React.createContext(null);
    LocationContext.displayName = "Location";
    RouteContext = /* @__PURE__ */ React.createContext({
      outlet: null,
      matches: []
    });
    RouteContext.displayName = "Route";
    RouteErrorContext = /* @__PURE__ */ React.createContext(null);
    RouteErrorContext.displayName = "RouteError";
    OutletContext = /* @__PURE__ */ React.createContext(null);
    RenderErrorBoundary = class extends React.Component {
      constructor(props) {
        super(props), this.state = {
          location: props.location,
          error: props.error
        };
      }
      static getDerivedStateFromError(error2) {
        return {
          error: error2
        };
      }
      static getDerivedStateFromProps(props, state) {
        return state.location !== props.location ? {
          error: props.error,
          location: props.location
        } : {
          error: props.error || state.error,
          location: state.location
        };
      }
      componentDidCatch(error2, errorInfo) {
        console.error("React Router caught the following error during render", error2, errorInfo);
      }
      render() {
        return this.state.error ? /* @__PURE__ */ React.createElement(RouteContext.Provider, {
          value: this.props.routeContext
        }, /* @__PURE__ */ React.createElement(RouteErrorContext.Provider, {
          value: this.state.error,
          children: this.props.component
        })) : this.props.children;
      }
    };
    (function(DataRouterHook3) {
      DataRouterHook3.UseBlocker = "useBlocker", DataRouterHook3.UseRevalidator = "useRevalidator";
    })(DataRouterHook || (DataRouterHook = {}));
    (function(DataRouterStateHook3) {
      DataRouterStateHook3.UseBlocker = "useBlocker", DataRouterStateHook3.UseLoaderData = "useLoaderData", DataRouterStateHook3.UseActionData = "useActionData", DataRouterStateHook3.UseRouteError = "useRouteError", DataRouterStateHook3.UseNavigation = "useNavigation", DataRouterStateHook3.UseRouteLoaderData = "useRouteLoaderData", DataRouterStateHook3.UseMatches = "useMatches", DataRouterStateHook3.UseRevalidator = "useRevalidator";
    })(DataRouterStateHook || (DataRouterStateHook = {}));
    blockerId = 0;
    alreadyWarned2 = {};
    (function(AwaitRenderStatus2) {
      AwaitRenderStatus2[AwaitRenderStatus2.pending = 0] = "pending", AwaitRenderStatus2[AwaitRenderStatus2.success = 1] = "success", AwaitRenderStatus2[AwaitRenderStatus2.error = 2] = "error";
    })(AwaitRenderStatus || (AwaitRenderStatus = {}));
    neverSettledPromise = new Promise(() => {
    }), AwaitErrorBoundary = class extends React.Component {
      constructor(props) {
        super(props), this.state = {
          error: null
        };
      }
      static getDerivedStateFromError(error2) {
        return {
          error: error2
        };
      }
      componentDidCatch(error2, errorInfo) {
        console.error("<Await> caught the following error during render", error2, errorInfo);
      }
      render() {
        let {
          children,
          errorElement,
          resolve: resolve2
        } = this.props, promise = null, status = AwaitRenderStatus.pending;
        if (!(resolve2 instanceof Promise))
          status = AwaitRenderStatus.success, promise = Promise.resolve(), Object.defineProperty(promise, "_tracked", {
            get: () => !0
          }), Object.defineProperty(promise, "_data", {
            get: () => resolve2
          });
        else if (this.state.error) {
          status = AwaitRenderStatus.error;
          let renderError = this.state.error;
          promise = Promise.reject().catch(() => {
          }), Object.defineProperty(promise, "_tracked", {
            get: () => !0
          }), Object.defineProperty(promise, "_error", {
            get: () => renderError
          });
        } else
          resolve2._tracked ? (promise = resolve2, status = promise._error !== void 0 ? AwaitRenderStatus.error : promise._data !== void 0 ? AwaitRenderStatus.success : AwaitRenderStatus.pending) : (status = AwaitRenderStatus.pending, Object.defineProperty(resolve2, "_tracked", {
            get: () => !0
          }), promise = resolve2.then((data2) => Object.defineProperty(resolve2, "_data", {
            get: () => data2
          }), (error2) => Object.defineProperty(resolve2, "_error", {
            get: () => error2
          })));
        if (status === AwaitRenderStatus.error && promise._error instanceof AbortedDeferredError)
          throw neverSettledPromise;
        if (status === AwaitRenderStatus.error && !errorElement)
          throw promise._error;
        if (status === AwaitRenderStatus.error)
          return /* @__PURE__ */ React.createElement(AwaitContext.Provider, {
            value: promise,
            children: errorElement
          });
        if (status === AwaitRenderStatus.success)
          return /* @__PURE__ */ React.createElement(AwaitContext.Provider, {
            value: promise,
            children
          });
        throw promise;
      }
    };
  }
});

// node_modules/react-router-dom/dist/index.js
var dist_exports = {};
__export(dist_exports, {
  AbortedDeferredError: () => AbortedDeferredError,
  Await: () => Await,
  BrowserRouter: () => BrowserRouter,
  Form: () => Form,
  HashRouter: () => HashRouter,
  Link: () => Link,
  MemoryRouter: () => MemoryRouter,
  NavLink: () => NavLink,
  Navigate: () => Navigate,
  NavigationType: () => Action,
  Outlet: () => Outlet,
  Route: () => Route,
  Router: () => Router,
  RouterProvider: () => RouterProvider,
  Routes: () => Routes,
  ScrollRestoration: () => ScrollRestoration,
  UNSAFE_DataRouterContext: () => DataRouterContext,
  UNSAFE_DataRouterStateContext: () => DataRouterStateContext,
  UNSAFE_LocationContext: () => LocationContext,
  UNSAFE_NavigationContext: () => NavigationContext,
  UNSAFE_RouteContext: () => RouteContext,
  UNSAFE_useScrollRestoration: () => useScrollRestoration,
  createBrowserRouter: () => createBrowserRouter,
  createHashRouter: () => createHashRouter,
  createMemoryRouter: () => createMemoryRouter,
  createPath: () => createPath,
  createRoutesFromChildren: () => createRoutesFromChildren,
  createRoutesFromElements: () => createRoutesFromChildren,
  createSearchParams: () => createSearchParams,
  defer: () => defer,
  generatePath: () => generatePath,
  isRouteErrorResponse: () => isRouteErrorResponse,
  json: () => json,
  matchPath: () => matchPath,
  matchRoutes: () => matchRoutes,
  parsePath: () => parsePath,
  redirect: () => redirect,
  renderMatches: () => renderMatches,
  resolvePath: () => resolvePath,
  unstable_HistoryRouter: () => HistoryRouter,
  unstable_useBlocker: () => useBlocker,
  unstable_usePrompt: () => usePrompt,
  useActionData: () => useActionData,
  useAsyncError: () => useAsyncError,
  useAsyncValue: () => useAsyncValue,
  useBeforeUnload: () => useBeforeUnload,
  useFetcher: () => useFetcher,
  useFetchers: () => useFetchers,
  useFormAction: () => useFormAction,
  useHref: () => useHref,
  useInRouterContext: () => useInRouterContext,
  useLinkClickHandler: () => useLinkClickHandler,
  useLoaderData: () => useLoaderData,
  useLocation: () => useLocation,
  useMatch: () => useMatch,
  useMatches: () => useMatches,
  useNavigate: () => useNavigate,
  useNavigation: () => useNavigation,
  useNavigationType: () => useNavigationType,
  useOutlet: () => useOutlet,
  useOutletContext: () => useOutletContext,
  useParams: () => useParams,
  useResolvedPath: () => useResolvedPath,
  useRevalidator: () => useRevalidator,
  useRouteError: () => useRouteError,
  useRouteLoaderData: () => useRouteLoaderData,
  useRoutes: () => useRoutes,
  useSearchParams: () => useSearchParams,
  useSubmit: () => useSubmit
});
function _extends3() {
  return _extends3 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source2 = arguments[i3];
      for (var key2 in source2)
        Object.prototype.hasOwnProperty.call(source2, key2) && (target[key2] = source2[key2]);
    }
    return target;
  }, _extends3.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source2, excluded) {
  if (source2 == null)
    return {};
  var target = {}, sourceKeys = Object.keys(source2), key2, i3;
  for (i3 = 0; i3 < sourceKeys.length; i3++)
    key2 = sourceKeys[i3], !(excluded.indexOf(key2) >= 0) && (target[key2] = source2[key2]);
  return target;
}
function isHtmlElement(object) {
  return object != null && typeof object.tagName == "string";
}
function isButtonElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "button";
}
function isFormElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "form";
}
function isInputElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "input";
}
function isModifiedEvent(event2) {
  return !!(event2.metaKey || event2.altKey || event2.ctrlKey || event2.shiftKey);
}
function shouldProcessLinkClick(event2, target) {
  return event2.button === 0 && (!target || target === "_self") && !isModifiedEvent(event2);
}
function createSearchParams(init4) {
  return init4 === void 0 && (init4 = ""), new URLSearchParams(typeof init4 == "string" || Array.isArray(init4) || init4 instanceof URLSearchParams ? init4 : Object.keys(init4).reduce((memo13, key2) => {
    let value2 = init4[key2];
    return memo13.concat(Array.isArray(value2) ? value2.map((v2) => [key2, v2]) : [[key2, value2]]);
  }, []));
}
function getSearchParamsForLocation(locationSearch, defaultSearchParams) {
  let searchParams = createSearchParams(locationSearch);
  if (defaultSearchParams)
    for (let key2 of defaultSearchParams.keys())
      searchParams.has(key2) || defaultSearchParams.getAll(key2).forEach((value2) => {
        searchParams.append(key2, value2);
      });
  return searchParams;
}
function getFormSubmissionInfo(target, defaultAction, options2) {
  let method, action3, encType, formData;
  if (isFormElement(target)) {
    let submissionTrigger = options2.submissionTrigger;
    method = options2.method || target.getAttribute("method") || defaultMethod, action3 = options2.action || target.getAttribute("action") || defaultAction, encType = options2.encType || target.getAttribute("enctype") || defaultEncType, formData = new FormData(target), submissionTrigger && submissionTrigger.name && formData.append(submissionTrigger.name, submissionTrigger.value);
  } else if (isButtonElement(target) || isInputElement(target) && (target.type === "submit" || target.type === "image")) {
    let form = target.form;
    if (form == null)
      throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');
    method = options2.method || target.getAttribute("formmethod") || form.getAttribute("method") || defaultMethod, action3 = options2.action || target.getAttribute("formaction") || form.getAttribute("action") || defaultAction, encType = options2.encType || target.getAttribute("formenctype") || form.getAttribute("enctype") || defaultEncType, formData = new FormData(form), target.name && formData.append(target.name, target.value);
  } else {
    if (isHtmlElement(target))
      throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
    if (method = options2.method || defaultMethod, action3 = options2.action || defaultAction, encType = options2.encType || defaultEncType, target instanceof FormData)
      formData = target;
    else if (formData = new FormData(), target instanceof URLSearchParams)
      for (let [name, value2] of target)
        formData.append(name, value2);
    else if (target != null)
      for (let name of Object.keys(target))
        formData.append(name, target[name]);
  }
  let {
    protocol,
    host
  } = window.location;
  return {
    url: new URL(action3, protocol + "//" + host),
    method: method.toLowerCase(),
    encType,
    formData
  };
}
function createBrowserRouter(routes2, opts) {
  return createRouter({
    basename: opts == null ? void 0 : opts.basename,
    future: opts == null ? void 0 : opts.future,
    history: createBrowserHistory({
      window: opts == null ? void 0 : opts.window
    }),
    hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),
    routes: routes2,
    detectErrorBoundary
  }).initialize();
}
function createHashRouter(routes2, opts) {
  return createRouter({
    basename: opts == null ? void 0 : opts.basename,
    future: opts == null ? void 0 : opts.future,
    history: createHashHistory({
      window: opts == null ? void 0 : opts.window
    }),
    hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),
    routes: routes2,
    detectErrorBoundary
  }).initialize();
}
function parseHydrationData() {
  var _window;
  let state = (_window = window) == null ? void 0 : _window.__staticRouterHydrationData;
  return state && state.errors && (state = _extends3({}, state, {
    errors: deserializeErrors(state.errors)
  })), state;
}
function deserializeErrors(errors) {
  if (!errors)
    return null;
  let entries = Object.entries(errors), serialized = {};
  for (let [key2, val] of entries)
    if (val && val.__type === "RouteErrorResponse")
      serialized[key2] = new ErrorResponse(val.status, val.statusText, val.data, val.internal === !0);
    else if (val && val.__type === "Error") {
      let error2 = new Error(val.message);
      error2.stack = "", serialized[key2] = error2;
    } else
      serialized[key2] = val;
  return serialized;
}
function BrowserRouter(_ref) {
  let {
    basename: basename2,
    children,
    window: window2
  } = _ref, historyRef = React2.useRef();
  historyRef.current == null && (historyRef.current = createBrowserHistory({
    window: window2,
    v5Compat: !0
  }));
  let history = historyRef.current, [state, setState] = React2.useState({
    action: history.action,
    location: history.location
  });
  return React2.useLayoutEffect(() => history.listen(setState), [history]), /* @__PURE__ */ React2.createElement(Router, {
    basename: basename2,
    children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
function HashRouter(_ref2) {
  let {
    basename: basename2,
    children,
    window: window2
  } = _ref2, historyRef = React2.useRef();
  historyRef.current == null && (historyRef.current = createHashHistory({
    window: window2,
    v5Compat: !0
  }));
  let history = historyRef.current, [state, setState] = React2.useState({
    action: history.action,
    location: history.location
  });
  return React2.useLayoutEffect(() => history.listen(setState), [history]), /* @__PURE__ */ React2.createElement(Router, {
    basename: basename2,
    children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
function HistoryRouter(_ref3) {
  let {
    basename: basename2,
    children,
    history
  } = _ref3, [state, setState] = React2.useState({
    action: history.action,
    location: history.location
  });
  return React2.useLayoutEffect(() => history.listen(setState), [history]), /* @__PURE__ */ React2.createElement(Router, {
    basename: basename2,
    children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
function ScrollRestoration(_ref7) {
  let {
    getKey,
    storageKey
  } = _ref7;
  return useScrollRestoration({
    getKey,
    storageKey
  }), null;
}
function getDataRouterConsoleError2(hookName) {
  return hookName + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
}
function useDataRouterContext2(hookName) {
  let ctx = React2.useContext(DataRouterContext);
  return ctx || invariant(!1, getDataRouterConsoleError2(hookName)), ctx;
}
function useDataRouterState2(hookName) {
  let state = React2.useContext(DataRouterStateContext);
  return state || invariant(!1, getDataRouterConsoleError2(hookName)), state;
}
function useLinkClickHandler(to, _temp) {
  let {
    target,
    replace: replaceProp,
    state,
    preventScrollReset,
    relative: relative2
  } = _temp === void 0 ? {} : _temp, navigate = useNavigate(), location = useLocation(), path2 = useResolvedPath(to, {
    relative: relative2
  });
  return React2.useCallback((event2) => {
    if (shouldProcessLinkClick(event2, target)) {
      event2.preventDefault();
      let replace = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path2);
      navigate(to, {
        replace,
        state,
        preventScrollReset,
        relative: relative2
      });
    }
  }, [location, navigate, path2, replaceProp, state, target, to, preventScrollReset, relative2]);
}
function useSearchParams(defaultInit) {
  warning(typeof URLSearchParams < "u", "You cannot use the `useSearchParams` hook in a browser that does not support the URLSearchParams API. If you need to support Internet Explorer 11, we recommend you load a polyfill such as https://github.com/ungap/url-search-params\n\nIf you're unsure how to load polyfills, we recommend you check out https://polyfill.io/v3/ which provides some recommendations about how to load polyfills only for users that need them, instead of for every user.");
  let defaultSearchParamsRef = React2.useRef(createSearchParams(defaultInit)), hasSetSearchParamsRef = React2.useRef(!1), location = useLocation(), searchParams = React2.useMemo(() => getSearchParamsForLocation(location.search, hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current), [location.search]), navigate = useNavigate(), setSearchParams = React2.useCallback((nextInit, navigateOptions) => {
    let newSearchParams = createSearchParams(typeof nextInit == "function" ? nextInit(searchParams) : nextInit);
    hasSetSearchParamsRef.current = !0, navigate("?" + newSearchParams, navigateOptions);
  }, [navigate, searchParams]);
  return [searchParams, setSearchParams];
}
function useSubmit() {
  return useSubmitImpl();
}
function useSubmitImpl(fetcherKey, routeId) {
  let {
    router: router2
  } = useDataRouterContext2(DataRouterHook2.UseSubmitImpl), defaultAction = useFormAction();
  return React2.useCallback(function(target, options2) {
    if (options2 === void 0 && (options2 = {}), typeof document > "u")
      throw new Error("You are calling submit during the server render. Try calling submit within a `useEffect` or callback instead.");
    let {
      method,
      encType,
      formData,
      url
    } = getFormSubmissionInfo(target, defaultAction, options2), href = url.pathname + url.search, opts = {
      replace: options2.replace,
      preventScrollReset: options2.preventScrollReset,
      formData,
      formMethod: method,
      formEncType: encType
    };
    fetcherKey ? (routeId == null && invariant(!1, "No routeId available for useFetcher()"), router2.fetch(fetcherKey, routeId, href, opts)) : router2.navigate(href, opts);
  }, [defaultAction, router2, fetcherKey, routeId]);
}
function useFormAction(action3, _temp2) {
  let {
    relative: relative2
  } = _temp2 === void 0 ? {} : _temp2, {
    basename: basename2
  } = React2.useContext(NavigationContext), routeContext = React2.useContext(RouteContext);
  routeContext || invariant(!1, "useFormAction must be used inside a RouteContext");
  let [match] = routeContext.matches.slice(-1), path2 = _extends3({}, useResolvedPath(action3 || ".", {
    relative: relative2
  })), location = useLocation();
  if (action3 == null && (path2.search = location.search, path2.hash = location.hash, match.route.index)) {
    let params = new URLSearchParams(path2.search);
    params.delete("index"), path2.search = params.toString() ? "?" + params.toString() : "";
  }
  return (!action3 || action3 === ".") && match.route.index && (path2.search = path2.search ? path2.search.replace(/^\?/, "?index&") : "?index"), basename2 !== "/" && (path2.pathname = path2.pathname === "/" ? basename2 : joinPaths([basename2, path2.pathname])), createPath(path2);
}
function createFetcherForm(fetcherKey, routeId) {
  let FetcherForm = /* @__PURE__ */ React2.forwardRef((props, ref) => /* @__PURE__ */ React2.createElement(FormImpl, _extends3({}, props, {
    ref,
    fetcherKey,
    routeId
  })));
  return FetcherForm.displayName = "fetcher.Form", FetcherForm;
}
function useFetcher() {
  var _route$matches;
  let {
    router: router2
  } = useDataRouterContext2(DataRouterHook2.UseFetcher), route = React2.useContext(RouteContext);
  route || invariant(!1, "useFetcher must be used inside a RouteContext");
  let routeId = (_route$matches = route.matches[route.matches.length - 1]) == null ? void 0 : _route$matches.route.id;
  routeId == null && invariant(!1, 'useFetcher can only be used on routes that contain a unique "id"');
  let [fetcherKey] = React2.useState(() => String(++fetcherId)), [Form3] = React2.useState(() => (routeId || invariant(!1, "No routeId available for fetcher.Form()"), createFetcherForm(fetcherKey, routeId))), [load2] = React2.useState(() => (href) => {
    router2 || invariant(!1, "No router available for fetcher.load()"), routeId || invariant(!1, "No routeId available for fetcher.load()"), router2.fetch(fetcherKey, routeId, href);
  }), submit = useSubmitImpl(fetcherKey, routeId), fetcher = router2.getFetcher(fetcherKey), fetcherWithComponents = React2.useMemo(() => _extends3({
    Form: Form3,
    submit,
    load: load2
  }, fetcher), [fetcher, Form3, submit, load2]);
  return React2.useEffect(() => () => {
    if (!router2) {
      console.warn("No fetcher available to clean up from useFetcher()");
      return;
    }
    router2.deleteFetcher(fetcherKey);
  }, [router2, fetcherKey]), fetcherWithComponents;
}
function useFetchers() {
  return [...useDataRouterState2(DataRouterStateHook2.UseFetchers).fetchers.values()];
}
function useScrollRestoration(_temp3) {
  let {
    getKey,
    storageKey
  } = _temp3 === void 0 ? {} : _temp3, {
    router: router2
  } = useDataRouterContext2(DataRouterHook2.UseScrollRestoration), {
    restoreScrollPosition,
    preventScrollReset
  } = useDataRouterState2(DataRouterStateHook2.UseScrollRestoration), location = useLocation(), matches = useMatches(), navigation = useNavigation();
  React2.useEffect(() => (window.history.scrollRestoration = "manual", () => {
    window.history.scrollRestoration = "auto";
  }), []), usePageHide(React2.useCallback(() => {
    if (navigation.state === "idle") {
      let key2 = (getKey ? getKey(location, matches) : null) || location.key;
      savedScrollPositions[key2] = window.scrollY;
    }
    sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions)), window.history.scrollRestoration = "auto";
  }, [storageKey, getKey, navigation.state, location, matches])), typeof document < "u" && (React2.useLayoutEffect(() => {
    try {
      let sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);
      sessionPositions && (savedScrollPositions = JSON.parse(sessionPositions));
    } catch {
    }
  }, [storageKey]), React2.useLayoutEffect(() => {
    let disableScrollRestoration = router2 == null ? void 0 : router2.enableScrollRestoration(savedScrollPositions, () => window.scrollY, getKey);
    return () => disableScrollRestoration && disableScrollRestoration();
  }, [router2, getKey]), React2.useLayoutEffect(() => {
    if (restoreScrollPosition !== !1) {
      if (typeof restoreScrollPosition == "number") {
        window.scrollTo(0, restoreScrollPosition);
        return;
      }
      if (location.hash) {
        let el = document.getElementById(location.hash.slice(1));
        if (el) {
          el.scrollIntoView();
          return;
        }
      }
      preventScrollReset !== !0 && window.scrollTo(0, 0);
    }
  }, [location, restoreScrollPosition, preventScrollReset]));
}
function useBeforeUnload(callback, options2) {
  let {
    capture
  } = options2 || {};
  React2.useEffect(() => {
    let opts = capture != null ? {
      capture
    } : void 0;
    return window.addEventListener("beforeunload", callback, opts), () => {
      window.removeEventListener("beforeunload", callback, opts);
    };
  }, [callback, capture]);
}
function usePageHide(callback, options2) {
  let {
    capture
  } = options2 || {};
  React2.useEffect(() => {
    let opts = capture != null ? {
      capture
    } : void 0;
    return window.addEventListener("pagehide", callback, opts), () => {
      window.removeEventListener("pagehide", callback, opts);
    };
  }, [callback, capture]);
}
function usePrompt(_ref8) {
  let {
    when,
    message
  } = _ref8, blocker = useBlocker(when);
  React2.useEffect(() => {
    blocker.state === "blocked" && !when && blocker.reset();
  }, [blocker, when]), React2.useEffect(() => {
    blocker.state === "blocked" && (window.confirm(message) ? setTimeout(blocker.proceed, 0) : blocker.reset());
  }, [blocker, message]);
}
var React2, defaultMethod, defaultEncType, _excluded, _excluded2, _excluded3, isBrowser2, ABSOLUTE_URL_REGEX2, Link, NavLink, Form, FormImpl, DataRouterHook2, DataRouterStateHook2, fetcherId, SCROLL_RESTORATION_STORAGE_KEY, savedScrollPositions, init_dist2 = __esm({
  "node_modules/react-router-dom/dist/index.js"() {
    React2 = __toESM(require_react());
    init_dist();
    init_dist();
    init_router();
    defaultMethod = "get", defaultEncType = "application/x-www-form-urlencoded";
    _excluded = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset"], _excluded2 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "children"], _excluded3 = ["reloadDocument", "replace", "method", "action", "onSubmit", "fetcherKey", "routeId", "relative", "preventScrollReset"];
    HistoryRouter.displayName = "unstable_HistoryRouter";
    isBrowser2 = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", ABSOLUTE_URL_REGEX2 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, Link = /* @__PURE__ */ React2.forwardRef(function(_ref4, ref) {
      let {
        onClick: onClick2,
        relative: relative2,
        reloadDocument,
        replace,
        state,
        target,
        to,
        preventScrollReset
      } = _ref4, rest = _objectWithoutPropertiesLoose(_ref4, _excluded), {
        basename: basename2
      } = React2.useContext(NavigationContext), absoluteHref, isExternal = !1;
      if (typeof to == "string" && ABSOLUTE_URL_REGEX2.test(to) && (absoluteHref = to, isBrowser2)) {
        let currentUrl = new URL(window.location.href), targetUrl = to.startsWith("//") ? new URL(currentUrl.protocol + to) : new URL(to), path2 = stripBasename(targetUrl.pathname, basename2);
        targetUrl.origin === currentUrl.origin && path2 != null ? to = path2 + targetUrl.search + targetUrl.hash : isExternal = !0;
      }
      let href = useHref(to, {
        relative: relative2
      }), internalOnClick = useLinkClickHandler(to, {
        replace,
        state,
        target,
        preventScrollReset,
        relative: relative2
      });
      function handleClick(event2) {
        onClick2 && onClick2(event2), event2.defaultPrevented || internalOnClick(event2);
      }
      return /* @__PURE__ */ React2.createElement("a", _extends3({}, rest, {
        href: absoluteHref || href,
        onClick: isExternal || reloadDocument ? onClick2 : handleClick,
        ref,
        target
      }));
    });
    Link.displayName = "Link";
    NavLink = /* @__PURE__ */ React2.forwardRef(function(_ref5, ref) {
      let {
        "aria-current": ariaCurrentProp = "page",
        caseSensitive = !1,
        className: classNameProp = "",
        end: end3 = !1,
        style: styleProp,
        to,
        children
      } = _ref5, rest = _objectWithoutPropertiesLoose(_ref5, _excluded2), path2 = useResolvedPath(to, {
        relative: rest.relative
      }), location = useLocation(), routerState = React2.useContext(DataRouterStateContext), {
        navigator: navigator2
      } = React2.useContext(NavigationContext), toPathname = navigator2.encodeLocation ? navigator2.encodeLocation(path2).pathname : path2.pathname, locationPathname = location.pathname, nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
      caseSensitive || (locationPathname = locationPathname.toLowerCase(), nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null, toPathname = toPathname.toLowerCase());
      let isActive = locationPathname === toPathname || !end3 && locationPathname.startsWith(toPathname) && locationPathname.charAt(toPathname.length) === "/", isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end3 && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/"), ariaCurrent = isActive ? ariaCurrentProp : void 0, className;
      typeof classNameProp == "function" ? className = classNameProp({
        isActive,
        isPending
      }) : className = [classNameProp, isActive ? "active" : null, isPending ? "pending" : null].filter(Boolean).join(" ");
      let style = typeof styleProp == "function" ? styleProp({
        isActive,
        isPending
      }) : styleProp;
      return /* @__PURE__ */ React2.createElement(Link, _extends3({}, rest, {
        "aria-current": ariaCurrent,
        className,
        ref,
        style,
        to
      }), typeof children == "function" ? children({
        isActive,
        isPending
      }) : children);
    });
    NavLink.displayName = "NavLink";
    Form = /* @__PURE__ */ React2.forwardRef((props, ref) => /* @__PURE__ */ React2.createElement(FormImpl, _extends3({}, props, {
      ref
    })));
    Form.displayName = "Form";
    FormImpl = /* @__PURE__ */ React2.forwardRef((_ref6, forwardedRef) => {
      let {
        reloadDocument,
        replace,
        method = defaultMethod,
        action: action3,
        onSubmit,
        fetcherKey,
        routeId,
        relative: relative2,
        preventScrollReset
      } = _ref6, props = _objectWithoutPropertiesLoose(_ref6, _excluded3), submit = useSubmitImpl(fetcherKey, routeId), formMethod = method.toLowerCase() === "get" ? "get" : "post", formAction = useFormAction(action3, {
        relative: relative2
      });
      return /* @__PURE__ */ React2.createElement("form", _extends3({
        ref: forwardedRef,
        method: formMethod,
        action: formAction,
        onSubmit: reloadDocument ? onSubmit : (event2) => {
          if (onSubmit && onSubmit(event2), event2.defaultPrevented)
            return;
          event2.preventDefault();
          let submitter = event2.nativeEvent.submitter, submitMethod = (submitter == null ? void 0 : submitter.getAttribute("formmethod")) || method;
          submit(submitter || event2.currentTarget, {
            method: submitMethod,
            replace,
            relative: relative2,
            preventScrollReset
          });
        }
      }, props));
    });
    FormImpl.displayName = "FormImpl";
    ScrollRestoration.displayName = "ScrollRestoration";
    (function(DataRouterHook3) {
      DataRouterHook3.UseScrollRestoration = "useScrollRestoration", DataRouterHook3.UseSubmitImpl = "useSubmitImpl", DataRouterHook3.UseFetcher = "useFetcher";
    })(DataRouterHook2 || (DataRouterHook2 = {}));
    (function(DataRouterStateHook3) {
      DataRouterStateHook3.UseFetchers = "useFetchers", DataRouterStateHook3.UseScrollRestoration = "useScrollRestoration";
    })(DataRouterStateHook2 || (DataRouterStateHook2 = {}));
    fetcherId = 0;
    SCROLL_RESTORATION_STORAGE_KEY = "react-router-scroll-positions", savedScrollPositions = {};
  }
});

// node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
var require_use_sync_external_store_shim_development = __commonJS({
  "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports) {
    "use strict";
    (function() {
      "use strict";
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var React17 = require_react(), ReactSharedInternals = React17.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function error2(format2) {
        {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)
            args[_key2 - 1] = arguments[_key2];
          printWarning("error", format2, args);
        }
      }
      function printWarning(level, format2, args) {
        {
          var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame, stack2 = ReactDebugCurrentFrame.getStackAddendum();
          stack2 !== "" && (format2 += "%s", args = args.concat([stack2]));
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format2), Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      function is2(x2, y2) {
        return x2 === y2 && (x2 !== 0 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
      }
      var objectIs = typeof Object.is == "function" ? Object.is : is2, useState14 = React17.useState, useEffect16 = React17.useEffect, useLayoutEffect6 = React17.useLayoutEffect, useDebugValue2 = React17.useDebugValue, didWarnOld18Alpha2 = !1, didWarnUncachedGetSnapshot2 = !1;
      function useSyncExternalStore3(subscribe, getSnapshot, getServerSnapshot) {
        didWarnOld18Alpha2 || React17.startTransition !== void 0 && (didWarnOld18Alpha2 = !0, error2("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
        var value2 = getSnapshot();
        if (!didWarnUncachedGetSnapshot2) {
          var cachedValue = getSnapshot();
          objectIs(value2, cachedValue) || (error2("The result of getSnapshot should be cached to avoid an infinite loop"), didWarnUncachedGetSnapshot2 = !0);
        }
        var _useState = useState14({
          inst: {
            value: value2,
            getSnapshot
          }
        }), inst = _useState[0].inst, forceUpdate = _useState[1];
        return useLayoutEffect6(function() {
          inst.value = value2, inst.getSnapshot = getSnapshot, checkIfSnapshotChanged2(inst) && forceUpdate({
            inst
          });
        }, [subscribe, value2, getSnapshot]), useEffect16(function() {
          checkIfSnapshotChanged2(inst) && forceUpdate({
            inst
          });
          var handleStoreChange = function() {
            checkIfSnapshotChanged2(inst) && forceUpdate({
              inst
            });
          };
          return subscribe(handleStoreChange);
        }, [subscribe]), useDebugValue2(value2), value2;
      }
      function checkIfSnapshotChanged2(inst) {
        var latestGetSnapshot = inst.getSnapshot, prevValue = inst.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(prevValue, nextValue);
        } catch {
          return !0;
        }
      }
      function useSyncExternalStore$12(subscribe, getSnapshot, getServerSnapshot) {
        return getSnapshot();
      }
      var canUseDOM2 = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", isServerEnvironment2 = !canUseDOM2, shim2 = isServerEnvironment2 ? useSyncExternalStore$12 : useSyncExternalStore3, useSyncExternalStore$22 = React17.useSyncExternalStore !== void 0 ? React17.useSyncExternalStore : shim2;
      exports.useSyncExternalStore = useSyncExternalStore$22, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    })();
  }
});

// node_modules/use-sync-external-store/shim/index.js
var require_shim = __commonJS({
  "node_modules/use-sync-external-store/shim/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_use_sync_external_store_shim_development();
  }
});

// node_modules/@remix-run/react/dist/esm/_virtual/_rollupPluginBabelHelpers.js
function _extends4() {
  return _extends4 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source2 = arguments[i3];
      for (var key2 in source2)
        Object.prototype.hasOwnProperty.call(source2, key2) && (target[key2] = source2[key2]);
    }
    return target;
  }, _extends4.apply(this, arguments);
}
var init_rollupPluginBabelHelpers = __esm({
  "node_modules/@remix-run/react/dist/esm/_virtual/_rollupPluginBabelHelpers.js"() {
  }
});

// node_modules/@remix-run/react/dist/esm/errorBoundaries.js
function RemixRootDefaultErrorBoundary({
  error: error2
}) {
  return console.error(error2), /* @__PURE__ */ import_react.default.createElement("html", {
    lang: "en"
  }, /* @__PURE__ */ import_react.default.createElement("head", null, /* @__PURE__ */ import_react.default.createElement("meta", {
    charSet: "utf-8"
  }), /* @__PURE__ */ import_react.default.createElement("meta", {
    name: "viewport",
    content: "width=device-width,initial-scale=1,viewport-fit=cover"
  }), /* @__PURE__ */ import_react.default.createElement("title", null, "Application Error!")), /* @__PURE__ */ import_react.default.createElement("body", null, /* @__PURE__ */ import_react.default.createElement("main", {
    style: {
      fontFamily: "system-ui, sans-serif",
      padding: "2rem"
    }
  }, /* @__PURE__ */ import_react.default.createElement("h1", {
    style: {
      fontSize: "24px"
    }
  }, "Application Error"), /* @__PURE__ */ import_react.default.createElement("pre", {
    style: {
      padding: "2rem",
      background: "hsla(10, 50%, 50%, 0.1)",
      color: "red",
      overflow: "auto"
    }
  }, error2.stack)), /* @__PURE__ */ import_react.default.createElement("script", {
    dangerouslySetInnerHTML: {
      __html: `
              console.log(
                "\u{1F4BF} Hey developer\u{1F44B}. You can provide a way better UX than this when your app throws errors. Check out https://remix.run/guides/errors for more information."
              );
            `
    }
  })));
}
function V2_RemixRootDefaultErrorBoundary() {
  let error2 = useRouteError();
  if (isRouteErrorResponse(error2))
    return /* @__PURE__ */ import_react.default.createElement(RemixRootDefaultCatchBoundaryImpl, {
      caught: error2
    });
  if (error2 instanceof Error)
    return /* @__PURE__ */ import_react.default.createElement(RemixRootDefaultErrorBoundary, {
      error: error2
    });
  {
    let errorString = error2 == null ? "Unknown Error" : typeof error2 == "object" && "toString" in error2 ? error2.toString() : JSON.stringify(error2);
    return /* @__PURE__ */ import_react.default.createElement(RemixRootDefaultErrorBoundary, {
      error: new Error(errorString)
    });
  }
}
function useCatch() {
  return (0, import_react.useContext)(RemixCatchContext);
}
function RemixCatchBoundary({
  catch: catchVal,
  component: Component3,
  children
}) {
  return catchVal ? /* @__PURE__ */ import_react.default.createElement(RemixCatchContext.Provider, {
    value: catchVal
  }, /* @__PURE__ */ import_react.default.createElement(Component3, null)) : /* @__PURE__ */ import_react.default.createElement(import_react.default.Fragment, null, children);
}
function RemixRootDefaultCatchBoundary() {
  let caught = useCatch();
  return /* @__PURE__ */ import_react.default.createElement(RemixRootDefaultCatchBoundaryImpl, {
    caught
  });
}
function RemixRootDefaultCatchBoundaryImpl({
  caught
}) {
  return /* @__PURE__ */ import_react.default.createElement("html", {
    lang: "en"
  }, /* @__PURE__ */ import_react.default.createElement("head", null, /* @__PURE__ */ import_react.default.createElement("meta", {
    charSet: "utf-8"
  }), /* @__PURE__ */ import_react.default.createElement("meta", {
    name: "viewport",
    content: "width=device-width,initial-scale=1,viewport-fit=cover"
  }), /* @__PURE__ */ import_react.default.createElement("title", null, "Unhandled Thrown Response!")), /* @__PURE__ */ import_react.default.createElement("body", null, /* @__PURE__ */ import_react.default.createElement("h1", {
    style: {
      fontFamily: "system-ui, sans-serif",
      padding: "2rem"
    }
  }, caught.status, " ", caught.statusText), /* @__PURE__ */ import_react.default.createElement("script", {
    dangerouslySetInnerHTML: {
      __html: `
              console.log(
                "\u{1F4BF} Hey developer\u{1F44B}. You can provide a way better UX than this when your app throws 404s (and other responses). Check out https://remix.run/guides/not-found for more information."
              );
            `
    }
  })));
}
var import_react, RemixErrorBoundary, RemixCatchContext, init_errorBoundaries = __esm({
  "node_modules/@remix-run/react/dist/esm/errorBoundaries.js"() {
    import_react = __toESM(require_react());
    init_dist2();
    RemixErrorBoundary = class extends import_react.default.Component {
      constructor(props) {
        super(props), this.state = {
          error: props.error || null,
          location: props.location
        };
      }
      static getDerivedStateFromError(error2) {
        return {
          error: error2
        };
      }
      static getDerivedStateFromProps(props, state) {
        return state.location !== props.location ? {
          error: props.error || null,
          location: props.location
        } : {
          error: props.error || state.error,
          location: state.location
        };
      }
      render() {
        return this.state.error ? /* @__PURE__ */ import_react.default.createElement(this.props.component, {
          error: this.state.error
        }) : this.props.children;
      }
    };
    RemixCatchContext = /* @__PURE__ */ import_react.default.createContext(void 0);
  }
});

// node_modules/@remix-run/react/dist/esm/invariant.js
function invariant3(value2, message) {
  if (value2 === !1 || value2 === null || typeof value2 > "u")
    throw new Error(message);
}
var init_invariant2 = __esm({
  "node_modules/@remix-run/react/dist/esm/invariant.js"() {
  }
});

// node_modules/@remix-run/react/dist/esm/routeModules.js
async function loadRouteModule(route, routeModulesCache) {
  if (route.id in routeModulesCache)
    return routeModulesCache[route.id];
  try {
    let routeModule = await import(
      /* webpackIgnore: true */
      route.module
    );
    return routeModulesCache[route.id] = routeModule, routeModule;
  } catch {
    return window.location.reload(), new Promise(() => {
    });
  }
}
var init_routeModules = __esm({
  "node_modules/@remix-run/react/dist/esm/routeModules.js"() {
  }
});

// node_modules/@remix-run/react/dist/esm/links.js
function getLinksForMatches(matches, routeModules, manifest) {
  let descriptors = matches.map((match) => {
    var _module$links;
    let module2 = routeModules[match.route.id];
    return ((_module$links = module2.links) === null || _module$links === void 0 ? void 0 : _module$links.call(module2)) || [];
  }).flat(1), preloads = getCurrentPageModulePreloadHrefs(matches, manifest);
  return dedupe(descriptors, preloads);
}
async function prefetchStyleLinks(routeModule) {
  if (!routeModule.links)
    return;
  let descriptors = routeModule.links();
  if (!descriptors)
    return;
  let styleLinks = [];
  for (let descriptor of descriptors)
    !isPageLinkDescriptor(descriptor) && descriptor.rel === "stylesheet" && styleLinks.push({
      ...descriptor,
      rel: "preload",
      as: "style"
    });
  let matchingLinks = styleLinks.filter((link) => !link.media || window.matchMedia(link.media).matches);
  await Promise.all(matchingLinks.map(prefetchStyleLink));
}
async function prefetchStyleLink(descriptor) {
  return new Promise((resolve2) => {
    let link = document.createElement("link");
    Object.assign(link, descriptor);
    function removeLink() {
      document.head.contains(link) && document.head.removeChild(link);
    }
    link.onload = () => {
      removeLink(), resolve2();
    }, link.onerror = () => {
      removeLink(), resolve2();
    }, document.head.appendChild(link);
  });
}
function isPageLinkDescriptor(object) {
  return object != null && typeof object.page == "string";
}
function isHtmlLinkDescriptor(object) {
  return object == null ? !1 : object.href == null ? object.rel === "preload" && (typeof object.imageSrcSet == "string" || typeof object.imagesrcset == "string") && (typeof object.imageSizes == "string" || typeof object.imagesizes == "string") : typeof object.rel == "string" && typeof object.href == "string";
}
async function getStylesheetPrefetchLinks(matches, manifest, routeModules) {
  return (await Promise.all(matches.map(async (match) => {
    let mod = await loadRouteModule(manifest.routes[match.route.id], routeModules);
    return mod.links ? mod.links() : [];
  }))).flat(1).filter(isHtmlLinkDescriptor).filter((link) => link.rel === "stylesheet" || link.rel === "preload").map((link) => link.rel === "preload" ? {
    ...link,
    rel: "prefetch"
  } : {
    ...link,
    rel: "prefetch",
    as: "style"
  });
}
function getNewMatchesForLinks(page, nextMatches, currentMatches, manifest, location, mode) {
  let path2 = parsePathPatch(page), isNew = (match, index2) => currentMatches[index2] ? match.route.id !== currentMatches[index2].route.id : !0, matchPathChanged = (match, index2) => {
    var _currentMatches$index;
    return currentMatches[index2].pathname !== match.pathname || ((_currentMatches$index = currentMatches[index2].route.path) === null || _currentMatches$index === void 0 ? void 0 : _currentMatches$index.endsWith("*")) && currentMatches[index2].params["*"] !== match.params["*"];
  };
  return mode === "data" && location.search !== path2.search ? nextMatches.filter((match, index2) => {
    if (!manifest.routes[match.route.id].hasLoader)
      return !1;
    if (isNew(match, index2) || matchPathChanged(match, index2))
      return !0;
    if (match.route.shouldRevalidate) {
      var _currentMatches$;
      let routeChoice = match.route.shouldRevalidate({
        currentUrl: new URL(location.pathname + location.search + location.hash, window.origin),
        currentParams: ((_currentMatches$ = currentMatches[0]) === null || _currentMatches$ === void 0 ? void 0 : _currentMatches$.params) || {},
        nextUrl: new URL(page, window.origin),
        nextParams: match.params,
        defaultShouldRevalidate: !0
      });
      if (typeof routeChoice == "boolean")
        return routeChoice;
    }
    return !0;
  }) : nextMatches.filter((match, index2) => {
    let manifestRoute = manifest.routes[match.route.id];
    return (mode === "assets" || manifestRoute.hasLoader) && (isNew(match, index2) || matchPathChanged(match, index2));
  });
}
function getDataLinkHrefs(page, matches, manifest) {
  let path2 = parsePathPatch(page);
  return dedupeHrefs(matches.filter((match) => manifest.routes[match.route.id].hasLoader).map((match) => {
    let {
      pathname,
      search
    } = path2, searchParams = new URLSearchParams(search);
    return searchParams.set("_data", match.route.id), `${pathname}?${searchParams}`;
  }));
}
function getModuleLinkHrefs(matches, manifestPatch) {
  return dedupeHrefs(matches.map((match) => {
    let route = manifestPatch.routes[match.route.id], hrefs = [route.module];
    return route.imports && (hrefs = hrefs.concat(route.imports)), hrefs;
  }).flat(1));
}
function getCurrentPageModulePreloadHrefs(matches, manifest) {
  return dedupeHrefs(matches.map((match) => {
    let route = manifest.routes[match.route.id], hrefs = [route.module];
    return route.imports && (hrefs = hrefs.concat(route.imports)), hrefs;
  }).flat(1));
}
function dedupeHrefs(hrefs) {
  return [...new Set(hrefs)];
}
function dedupe(descriptors, preloads) {
  let set2 = /* @__PURE__ */ new Set(), preloadsSet = new Set(preloads);
  return descriptors.reduce((deduped, descriptor) => {
    if (!isPageLinkDescriptor(descriptor) && descriptor.as === "script" && descriptor.href && preloadsSet.has(descriptor.href))
      return deduped;
    let str2 = JSON.stringify(descriptor);
    return set2.has(str2) || (set2.add(str2), deduped.push(descriptor)), deduped;
  }, []);
}
function parsePathPatch(href) {
  let path2 = parsePath(href);
  return path2.search === void 0 && (path2.search = ""), path2;
}
var init_links = __esm({
  "node_modules/@remix-run/react/dist/esm/links.js"() {
    init_dist2();
    init_routeModules();
  }
});

// node_modules/@remix-run/react/dist/esm/markup.js
function escapeHtml2(html) {
  return html.replace(ESCAPE_REGEX2, (match) => ESCAPE_LOOKUP2[match]);
}
function createHtml(html) {
  return {
    __html: html
  };
}
var ESCAPE_LOOKUP2, ESCAPE_REGEX2, init_markup2 = __esm({
  "node_modules/@remix-run/react/dist/esm/markup.js"() {
    ESCAPE_LOOKUP2 = {
      "&": "\\u0026",
      ">": "\\u003e",
      "<": "\\u003c",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    }, ESCAPE_REGEX2 = /[&><\u2028\u2029]/g;
  }
});

// node_modules/@remix-run/react/dist/esm/transition.js
var IDLE_TRANSITION, IDLE_FETCHER2, init_transition = __esm({
  "node_modules/@remix-run/react/dist/esm/transition.js"() {
    IDLE_TRANSITION = {
      state: "idle",
      submission: void 0,
      location: void 0,
      type: "idle"
    }, IDLE_FETCHER2 = {
      state: "idle",
      type: "init",
      data: void 0,
      formMethod: void 0,
      formAction: void 0,
      formData: void 0,
      formEncType: void 0,
      submission: void 0
    };
  }
});

// node_modules/@remix-run/react/dist/esm/warnings.js
function logDeprecationOnce(message, key2 = message) {
  alreadyWarned3[key2] || (alreadyWarned3[key2] = !0, console.warn(message));
}
var alreadyWarned3, init_warnings2 = __esm({
  "node_modules/@remix-run/react/dist/esm/warnings.js"() {
    alreadyWarned3 = {};
  }
});

// node_modules/@remix-run/react/dist/esm/components.js
function useDataRouterContext3() {
  let context = React3.useContext(DataRouterContext);
  return invariant3(context, "You must render this element inside a <DataRouterContext.Provider> element"), context;
}
function useDataRouterStateContext() {
  let context = React3.useContext(DataRouterStateContext);
  return invariant3(context, "You must render this element inside a <DataRouterStateContext.Provider> element"), context;
}
function useRemixContext() {
  let context = React3.useContext(RemixContext);
  return invariant3(context, "You must render this element inside a <Remix> element"), context;
}
function RemixRoute({
  id: id4
}) {
  let {
    routeModules
  } = useRemixContext();
  invariant3(routeModules, `Cannot initialize 'routeModules'. This normally occurs when you have server code in your client modules.
Check this link for more details:
https://remix.run/pages/gotchas#server-code-in-client-bundles`);
  let {
    default: Component3
  } = routeModules[id4];
  return invariant3(Component3, `Route "${id4}" has no component! Please go add a \`default\` export in the route module file.
If you were trying to navigate or submit to a resource route, use \`<a>\` instead of \`<Link>\` or \`<Form reloadDocument>\`.`), /* @__PURE__ */ React3.createElement(Component3, null);
}
function RemixRouteError({
  id: id4
}) {
  let {
    future: future2,
    routeModules
  } = useRemixContext();
  invariant3(routeModules, `Cannot initialize 'routeModules'. This normally occurs when you have server code in your client modules.
Check this link for more details:
https://remix.run/pages/gotchas#server-code-in-client-bundles`);
  let error2 = useRouteError(), {
    CatchBoundary,
    ErrorBoundary
  } = routeModules[id4];
  if (future2.v2_errorBoundary) {
    if (id4 === "root" && (ErrorBoundary || (ErrorBoundary = V2_RemixRootDefaultErrorBoundary)), ErrorBoundary)
      return /* @__PURE__ */ React3.createElement(ErrorBoundary, null);
    throw error2;
  }
  if (id4 === "root" && (CatchBoundary || (CatchBoundary = RemixRootDefaultCatchBoundary), ErrorBoundary || (ErrorBoundary = RemixRootDefaultErrorBoundary)), isRouteErrorResponse(error2)) {
    let tError = error2;
    if ((tError == null ? void 0 : tError.error) instanceof Error && tError.status !== 404 && ErrorBoundary)
      return /* @__PURE__ */ React3.createElement(ErrorBoundary, {
        error: tError.error
      });
    if (CatchBoundary)
      return /* @__PURE__ */ React3.createElement(RemixCatchBoundary, {
        component: CatchBoundary,
        catch: error2
      });
  }
  if (error2 instanceof Error && ErrorBoundary)
    return /* @__PURE__ */ React3.createElement(ErrorBoundary, {
      error: error2
    });
  throw error2;
}
function usePrefetchBehavior(prefetch, theirElementProps) {
  let [maybePrefetch, setMaybePrefetch] = React3.useState(!1), [shouldPrefetch, setShouldPrefetch] = React3.useState(!1), {
    onFocus,
    onBlur,
    onMouseEnter,
    onMouseLeave,
    onTouchStart: onTouchStart2
  } = theirElementProps;
  React3.useEffect(() => {
    prefetch === "render" && setShouldPrefetch(!0);
  }, [prefetch]);
  let setIntent = () => {
    prefetch === "intent" && setMaybePrefetch(!0);
  }, cancelIntent = () => {
    prefetch === "intent" && (setMaybePrefetch(!1), setShouldPrefetch(!1));
  };
  return React3.useEffect(() => {
    if (maybePrefetch) {
      let id4 = setTimeout(() => {
        setShouldPrefetch(!0);
      }, 100);
      return () => {
        clearTimeout(id4);
      };
    }
  }, [maybePrefetch]), [shouldPrefetch, {
    onFocus: composeEventHandlers(onFocus, setIntent),
    onBlur: composeEventHandlers(onBlur, cancelIntent),
    onMouseEnter: composeEventHandlers(onMouseEnter, setIntent),
    onMouseLeave: composeEventHandlers(onMouseLeave, cancelIntent),
    onTouchStart: composeEventHandlers(onTouchStart2, setIntent)
  }];
}
function composeEventHandlers(theirHandler, ourHandler) {
  return (event2) => {
    theirHandler && theirHandler(event2), event2.defaultPrevented || ourHandler(event2);
  };
}
function Links() {
  let {
    manifest,
    routeModules
  } = useRemixContext(), {
    matches
  } = useDataRouterStateContext(), links2 = React3.useMemo(() => getLinksForMatches(matches, routeModules, manifest), [matches, routeModules, manifest]);
  return React3.useEffect(() => {
    links2.some((link) => "imagesizes" in link || "imagesrcset" in link) && logDeprecationOnce(linksWarning);
  }, [links2]), /* @__PURE__ */ React3.createElement(React3.Fragment, null, links2.map((link) => {
    if (isPageLinkDescriptor(link))
      return /* @__PURE__ */ React3.createElement(PrefetchPageLinks, _extends4({
        key: link.page
      }, link));
    let imageSrcSet = null;
    return "useId" in React3 ? (link.imagesrcset && (link.imageSrcSet = imageSrcSet = link.imagesrcset, delete link.imagesrcset), link.imagesizes && (link.imageSizes = link.imagesizes, delete link.imagesizes)) : (link.imageSrcSet && (link.imagesrcset = imageSrcSet = link.imageSrcSet, delete link.imageSrcSet), link.imageSizes && (link.imagesizes = link.imageSizes, delete link.imageSizes)), /* @__PURE__ */ React3.createElement("link", _extends4({
      key: link.rel + (link.href || "") + (imageSrcSet || "")
    }, link));
  }));
}
function PrefetchPageLinks({
  page,
  ...dataLinkProps
}) {
  let {
    router: router2
  } = useDataRouterContext3(), matches = React3.useMemo(() => matchRoutes(router2.routes, page), [router2.routes, page]);
  return matches ? /* @__PURE__ */ React3.createElement(PrefetchPageLinksImpl, _extends4({
    page,
    matches
  }, dataLinkProps)) : (console.warn(`Tried to prefetch ${page} but no routes matched.`), null);
}
function usePrefetchedStylesheets(matches) {
  let {
    manifest,
    routeModules
  } = useRemixContext(), [styleLinks, setStyleLinks] = React3.useState([]);
  return React3.useEffect(() => {
    let interrupted = !1;
    return getStylesheetPrefetchLinks(matches, manifest, routeModules).then((links2) => {
      interrupted || setStyleLinks(links2);
    }), () => {
      interrupted = !0;
    };
  }, [matches, manifest, routeModules]), styleLinks;
}
function PrefetchPageLinksImpl({
  page,
  matches: nextMatches,
  ...linkProps
}) {
  let location = useLocation(), {
    manifest
  } = useRemixContext(), {
    matches
  } = useDataRouterStateContext(), newMatchesForData = React3.useMemo(() => getNewMatchesForLinks(page, nextMatches, matches, manifest, location, "data"), [page, nextMatches, matches, manifest, location]), newMatchesForAssets = React3.useMemo(() => getNewMatchesForLinks(page, nextMatches, matches, manifest, location, "assets"), [page, nextMatches, matches, manifest, location]), dataHrefs = React3.useMemo(() => getDataLinkHrefs(page, newMatchesForData, manifest), [newMatchesForData, page, manifest]), moduleHrefs = React3.useMemo(() => getModuleLinkHrefs(newMatchesForAssets, manifest), [newMatchesForAssets, manifest]), styleLinks = usePrefetchedStylesheets(newMatchesForAssets);
  return /* @__PURE__ */ React3.createElement(React3.Fragment, null, dataHrefs.map((href) => /* @__PURE__ */ React3.createElement("link", _extends4({
    key: href,
    rel: "prefetch",
    as: "fetch",
    href
  }, linkProps))), moduleHrefs.map((href) => /* @__PURE__ */ React3.createElement("link", _extends4({
    key: href,
    rel: "modulepreload",
    href
  }, linkProps))), styleLinks.map((link) => /* @__PURE__ */ React3.createElement("link", _extends4({
    key: link.href
  }, link))));
}
function V1Meta() {
  let {
    routeModules
  } = useRemixContext(), {
    matches,
    loaderData
  } = useDataRouterStateContext(), location = useLocation(), meta2 = {}, parentsData = {};
  for (let match of matches) {
    let routeId = match.route.id, data2 = loaderData[routeId], params = match.params, routeModule = routeModules[routeId];
    if (routeModule.meta) {
      let routeMeta = typeof routeModule.meta == "function" ? routeModule.meta({
        data: data2,
        parentsData,
        params,
        location
      }) : routeModule.meta;
      if (routeMeta && Array.isArray(routeMeta))
        throw new Error(
          "The route at " + match.route.path + " returns an array. This is only supported with the `v2_meta` future flag in the Remix config. Either set the flag to `true` or update the route's meta function to return an object.\n\nTo reference the v1 meta function API, see https://remix.run/route/meta"
        );
      Object.assign(meta2, routeMeta);
    }
    parentsData[routeId] = data2;
  }
  return /* @__PURE__ */ React3.createElement(React3.Fragment, null, Object.entries(meta2).map(([name, value2]) => {
    if (!value2)
      return null;
    if (["charset", "charSet"].includes(name))
      return /* @__PURE__ */ React3.createElement("meta", {
        key: "charSet",
        charSet: value2
      });
    if (name === "title")
      return /* @__PURE__ */ React3.createElement("title", {
        key: "title"
      }, String(value2));
    let isOpenGraphTag = /^(og|music|video|article|book|profile|fb):.+$/.test(name);
    return [value2].flat().map((content) => isOpenGraphTag ? /* @__PURE__ */ React3.createElement("meta", {
      property: name,
      content,
      key: name + content
    }) : typeof content == "string" ? /* @__PURE__ */ React3.createElement("meta", {
      name,
      content,
      key: name + content
    }) : /* @__PURE__ */ React3.createElement("meta", _extends4({
      key: name + JSON.stringify(content)
    }, content)));
  }));
}
function V2Meta() {
  let {
    routeModules
  } = useRemixContext(), {
    matches: _matches,
    loaderData
  } = useDataRouterStateContext(), location = useLocation(), meta2 = [], leafMeta = null, matches = [];
  for (let i3 = 0; i3 < _matches.length; i3++) {
    let _match = _matches[i3], routeId = _match.route.id, data2 = loaderData[routeId], params = _match.params, routeModule = routeModules[routeId], routeMeta = [], match = {
      id: routeId,
      data: data2,
      meta: [],
      params: _match.params,
      pathname: _match.pathname,
      handle: _match.route.handle,
      get route() {
        return console.warn("The meta function in " + _match.route.path + " accesses the `route` property on `matches`. This is deprecated and will be removed in Remix version 2. See"), _match.route;
      }
    };
    if (matches[i3] = match, routeModule != null && routeModule.meta ? routeMeta = typeof routeModule.meta == "function" ? routeModule.meta({
      data: data2,
      params,
      location,
      matches
    }) : Array.isArray(routeModule.meta) ? [...routeModule.meta] : routeModule.meta : leafMeta && (routeMeta = [...leafMeta]), routeMeta = routeMeta || [], !Array.isArray(routeMeta))
      throw new Error("The `v2_meta` API is enabled in the Remix config, but the route at " + _match.route.path + ` returns an invalid value. In v2, all route meta functions must return an array of meta objects.

To reference the v1 meta function API, see https://remix.run/route/meta`);
    match.meta = routeMeta, matches[i3] = match, meta2 = [...routeMeta], leafMeta = meta2;
  }
  return /* @__PURE__ */ React3.createElement(React3.Fragment, null, meta2.flat().map((metaProps) => {
    if (!metaProps)
      return null;
    if ("tagName" in metaProps) {
      let tagName = metaProps.tagName;
      return delete metaProps.tagName, isValidMetaTag(tagName) ? /* @__PURE__ */ React3.createElement(tagName, _extends4({
        key: JSON.stringify(metaProps)
      }, metaProps)) : (console.warn(`A meta object uses an invalid tagName: ${tagName}. Expected either 'link' or 'meta'`), null);
    }
    if ("title" in metaProps)
      return /* @__PURE__ */ React3.createElement("title", {
        key: "title"
      }, String(metaProps.title));
    if ("charset" in metaProps && (metaProps.charSet ?? (metaProps.charSet = metaProps.charset), delete metaProps.charset), "charSet" in metaProps && metaProps.charSet != null)
      return typeof metaProps.charSet == "string" ? /* @__PURE__ */ React3.createElement("meta", {
        key: "charSet",
        charSet: metaProps.charSet
      }) : null;
    if ("script:ld+json" in metaProps) {
      let json9 = null;
      try {
        json9 = JSON.stringify(metaProps["script:ld+json"]);
      } catch {
      }
      return json9 != null && /* @__PURE__ */ React3.createElement("script", {
        key: "script:ld+json",
        type: "application/ld+json",
        dangerouslySetInnerHTML: {
          __html: JSON.stringify(metaProps["script:ld+json"])
        }
      });
    }
    return /* @__PURE__ */ React3.createElement("meta", _extends4({
      key: JSON.stringify(metaProps)
    }, metaProps));
  }));
}
function isValidMetaTag(tagName) {
  return typeof tagName == "string" && /^(meta|link)$/.test(tagName);
}
function Meta() {
  let {
    future: future2
  } = useRemixContext();
  return future2 != null && future2.v2_meta ? /* @__PURE__ */ React3.createElement(V2Meta, null) : /* @__PURE__ */ React3.createElement(V1Meta, null);
}
function Await2(props) {
  return /* @__PURE__ */ React3.createElement(Await, props);
}
function Scripts(props) {
  let {
    manifest,
    serverHandoffString,
    abortDelay
  } = useRemixContext(), {
    router: router2,
    static: isStatic,
    staticContext
  } = useDataRouterContext3(), {
    matches
  } = useDataRouterStateContext(), navigation = useNavigation();
  React3.useEffect(() => {
    isHydrated = !0;
  }, []);
  let deferredScripts = [], initialScripts = React3.useMemo(() => {
    var _manifest$hmr;
    let contextScript = staticContext ? `window.__remixContext = ${serverHandoffString};` : " ", activeDeferreds = staticContext == null ? void 0 : staticContext.activeDeferreds;
    contextScript += activeDeferreds ? ["__remixContext.p = function(v,e,p,x) {", "  if (typeof e !== 'undefined') {", `    x=new Error(e.message);
    x.stack=e.stack;`, "    p=Promise.reject(x);", "  } else {", "    p=Promise.resolve(v);", "  }", "  return p;", "};", "__remixContext.n = function(i,k) {", "  __remixContext.t = __remixContext.t || {};", "  __remixContext.t[i] = __remixContext.t[i] || {};", "  let p = new Promise((r, e) => {__remixContext.t[i][k] = {r:(v)=>{r(v);},e:(v)=>{e(v);}};});", typeof abortDelay == "number" ? `setTimeout(() => {if(typeof p._error !== "undefined" || typeof p._data !== "undefined"){return;} __remixContext.t[i][k].e(new Error("Server timeout."))}, ${abortDelay});` : "", "  return p;", "};", "__remixContext.r = function(i,k,v,e,p,x) {", "  p = __remixContext.t[i][k];", "  if (typeof e !== 'undefined') {", `    x=new Error(e.message);
    x.stack=e.stack;`, "    p.e(x);", "  } else {", "    p.r(v);", "  }", "};"].join(`
`) + Object.entries(activeDeferreds).map(([routeId, deferredData]) => {
      let pendingKeys = new Set(deferredData.pendingKeys), promiseKeyValues = deferredData.deferredKeys.map((key2) => {
        if (pendingKeys.has(key2))
          return deferredScripts.push(/* @__PURE__ */ React3.createElement(DeferredHydrationScript, {
            key: `${routeId} | ${key2}`,
            deferredData,
            routeId,
            dataKey: key2
          })), `${JSON.stringify(key2)}:__remixContext.n(${JSON.stringify(routeId)}, ${JSON.stringify(key2)})`;
        {
          let trackedPromise = deferredData.data[key2];
          if (typeof trackedPromise._error < "u") {
            let toSerialize = {
              message: trackedPromise._error.message,
              stack: trackedPromise._error.stack
            };
            return `${JSON.stringify(key2)}:__remixContext.p(!1, ${escapeHtml2(JSON.stringify(toSerialize))})`;
          } else {
            if (typeof trackedPromise._data > "u")
              throw new Error(`The deferred data for ${key2} was not resolved, did you forget to return data from a deferred promise?`);
            return `${JSON.stringify(key2)}:__remixContext.p(${escapeHtml2(JSON.stringify(trackedPromise._data))})`;
          }
        }
      }).join(`,
`);
      return `Object.assign(__remixContext.state.loaderData[${JSON.stringify(routeId)}], {${promiseKeyValues}});`;
    }).join(`
`) + (deferredScripts.length > 0 ? `__remixContext.a=${deferredScripts.length};` : "") : "";
    let routeModulesScript = isStatic ? `${(_manifest$hmr = manifest.hmr) !== null && _manifest$hmr !== void 0 && _manifest$hmr.runtime ? `import ${JSON.stringify(manifest.hmr.runtime)};` : ""}import ${JSON.stringify(manifest.url)};
${matches.map((match, index2) => `import * as route${index2} from ${JSON.stringify(manifest.routes[match.route.id].module)};`).join(`
`)}
window.__remixRouteModules = {${matches.map((match, index2) => `${JSON.stringify(match.route.id)}:route${index2}`).join(",")}};

import(${JSON.stringify(manifest.entry.module)});` : " ";
    return /* @__PURE__ */ React3.createElement(React3.Fragment, null, /* @__PURE__ */ React3.createElement("script", _extends4({}, props, {
      suppressHydrationWarning: !0,
      dangerouslySetInnerHTML: createHtml(contextScript),
      type: void 0
    })), /* @__PURE__ */ React3.createElement("script", _extends4({}, props, {
      suppressHydrationWarning: !0,
      dangerouslySetInnerHTML: createHtml(routeModulesScript),
      type: "module",
      async: !0
    })));
  }, []);
  if (!isStatic && typeof __remixContext == "object" && __remixContext.a)
    for (let i3 = 0; i3 < __remixContext.a; i3++)
      deferredScripts.push(/* @__PURE__ */ React3.createElement(DeferredHydrationScript, {
        key: i3
      }));
  let nextMatches = React3.useMemo(() => {
    if (navigation.location) {
      let matches2 = matchRoutes(router2.routes, navigation.location);
      return invariant3(matches2, `No routes match path "${navigation.location.pathname}"`), matches2;
    }
    return [];
  }, [navigation.location, router2.routes]), routePreloads = matches.concat(nextMatches).map((match) => {
    let route = manifest.routes[match.route.id];
    return (route.imports || []).concat([route.module]);
  }).flat(1), preloads = isHydrated ? [] : manifest.entry.imports.concat(routePreloads);
  return /* @__PURE__ */ React3.createElement(React3.Fragment, null, /* @__PURE__ */ React3.createElement("link", {
    rel: "modulepreload",
    href: manifest.url,
    crossOrigin: props.crossOrigin
  }), /* @__PURE__ */ React3.createElement("link", {
    rel: "modulepreload",
    href: manifest.entry.module,
    crossOrigin: props.crossOrigin
  }), dedupe2(preloads).map((path2) => /* @__PURE__ */ React3.createElement("link", {
    key: path2,
    rel: "modulepreload",
    href: path2,
    crossOrigin: props.crossOrigin
  })), !isHydrated && initialScripts, !isHydrated && deferredScripts);
}
function DeferredHydrationScript({
  dataKey,
  deferredData,
  routeId
}) {
  return typeof document > "u" && deferredData && dataKey && routeId && invariant3(deferredData.pendingKeys.includes(dataKey), `Deferred data for route ${routeId} with key ${dataKey} was not pending but tried to render a script for it.`), /* @__PURE__ */ React3.createElement(React3.Suspense, {
    fallback: typeof document > "u" && deferredData && dataKey && routeId ? null : /* @__PURE__ */ React3.createElement("script", {
      async: !0,
      suppressHydrationWarning: !0,
      dangerouslySetInnerHTML: {
        __html: " "
      }
    })
  }, typeof document > "u" && deferredData && dataKey && routeId ? /* @__PURE__ */ React3.createElement(Await2, {
    resolve: deferredData.data[dataKey],
    errorElement: /* @__PURE__ */ React3.createElement(ErrorDeferredHydrationScript, {
      dataKey,
      routeId
    }),
    children: (data2) => /* @__PURE__ */ React3.createElement("script", {
      async: !0,
      suppressHydrationWarning: !0,
      dangerouslySetInnerHTML: {
        __html: `__remixContext.r(${JSON.stringify(routeId)}, ${JSON.stringify(dataKey)}, ${escapeHtml2(JSON.stringify(data2))});`
      }
    })
  }) : /* @__PURE__ */ React3.createElement("script", {
    async: !0,
    suppressHydrationWarning: !0,
    dangerouslySetInnerHTML: {
      __html: " "
    }
  }));
}
function ErrorDeferredHydrationScript({
  dataKey,
  routeId
}) {
  let error2 = useAsyncError(), toSerialize = {
    message: error2.message,
    stack: error2.stack
  };
  return /* @__PURE__ */ React3.createElement("script", {
    suppressHydrationWarning: !0,
    dangerouslySetInnerHTML: {
      __html: `__remixContext.r(${JSON.stringify(routeId)}, ${JSON.stringify(dataKey)}, !1, ${escapeHtml2(JSON.stringify(toSerialize))});`
    }
  });
}
function dedupe2(array) {
  return [...new Set(array)];
}
function useMatches2() {
  let {
    routeModules
  } = useRemixContext(), matches = useMatches();
  return React3.useMemo(() => matches.map((match) => ({
    id: match.id,
    pathname: match.pathname,
    params: match.params,
    data: match.data,
    handle: routeModules[match.id].handle
  })), [matches, routeModules]);
}
function useLoaderData2() {
  return useLoaderData();
}
function useActionData2() {
  return useActionData();
}
function useTransition() {
  let navigation = useNavigation();
  return React3.useEffect(() => {
    logDeprecationOnce(useTransitionWarning);
  }, []), React3.useMemo(() => convertNavigationToTransition(navigation), [navigation]);
}
function convertNavigationToTransition(navigation) {
  let {
    location,
    state,
    formMethod,
    formAction,
    formEncType,
    formData
  } = navigation;
  if (!location)
    return IDLE_TRANSITION;
  let isActionSubmission = formMethod != null && ["POST", "PUT", "PATCH", "DELETE"].includes(formMethod.toUpperCase());
  if (state === "submitting" && formMethod && formAction && formEncType && formData) {
    if (isActionSubmission)
      return {
        location,
        state,
        submission: {
          method: formMethod.toUpperCase(),
          action: formAction,
          encType: formEncType,
          formData,
          key: ""
        },
        type: "actionSubmission"
      };
    invariant3(!1, "Encountered an unexpected navigation scenario in useTransition()");
  }
  if (state === "loading") {
    let {
      _isRedirect,
      _isFetchActionRedirect
    } = location.state || {};
    if (formMethod && formAction && formEncType && formData) {
      if (_isRedirect)
        return isActionSubmission ? {
          location,
          state,
          submission: {
            method: formMethod.toUpperCase(),
            action: formAction,
            encType: formEncType,
            formData,
            key: ""
          },
          type: "actionRedirect"
        } : {
          location,
          state,
          submission: {
            method: formMethod.toUpperCase(),
            action: formAction,
            encType: formEncType,
            formData,
            key: ""
          },
          type: "loaderSubmissionRedirect"
        };
      if (isActionSubmission)
        return {
          location,
          state,
          submission: {
            method: formMethod.toUpperCase(),
            action: formAction,
            encType: formEncType,
            formData,
            key: ""
          },
          type: "actionReload"
        };
      {
        let url = new URL(formAction, window.location.origin);
        return url.search = new URLSearchParams(formData.entries()).toString(), {
          location,
          state: "submitting",
          submission: {
            method: formMethod.toUpperCase(),
            action: url.pathname + url.search,
            encType: formEncType,
            formData,
            key: ""
          },
          type: "loaderSubmission"
        };
      }
    } else if (_isRedirect)
      return _isFetchActionRedirect ? {
        location,
        state,
        submission: void 0,
        type: "fetchActionRedirect"
      } : {
        location,
        state,
        submission: void 0,
        type: "normalRedirect"
      };
  }
  return {
    location,
    state: "loading",
    submission: void 0,
    type: "normalLoad"
  };
}
function useFetchers2() {
  return useFetchers().map((f2) => {
    let fetcher = convertRouterFetcherToRemixFetcher({
      state: f2.state,
      data: f2.data,
      formMethod: f2.formMethod,
      formAction: f2.formAction,
      formData: f2.formData,
      formEncType: f2.formEncType,
      " _hasFetcherDoneAnything ": f2[" _hasFetcherDoneAnything "]
    });
    return addFetcherDeprecationWarnings(fetcher), fetcher;
  });
}
function useFetcher2() {
  let fetcherRR = useFetcher();
  return React3.useMemo(() => {
    let fetcherWithComponents = {
      ...convertRouterFetcherToRemixFetcher({
        state: fetcherRR.state,
        data: fetcherRR.data,
        formMethod: fetcherRR.formMethod,
        formAction: fetcherRR.formAction,
        formData: fetcherRR.formData,
        formEncType: fetcherRR.formEncType,
        " _hasFetcherDoneAnything ": fetcherRR[" _hasFetcherDoneAnything "]
      }),
      load: fetcherRR.load,
      submit: fetcherRR.submit,
      Form: fetcherRR.Form
    };
    return addFetcherDeprecationWarnings(fetcherWithComponents), fetcherWithComponents;
  }, [fetcherRR]);
}
function addFetcherDeprecationWarnings(fetcher) {
  let type2 = fetcher.type;
  Object.defineProperty(fetcher, "type", {
    get() {
      return logDeprecationOnce(fetcherTypeWarning), type2;
    },
    set(value2) {
      type2 = value2;
    },
    configurable: !0,
    enumerable: !0
  });
  let submission = fetcher.submission;
  Object.defineProperty(fetcher, "submission", {
    get() {
      return logDeprecationOnce(fetcherSubmissionWarning), submission;
    },
    set(value2) {
      submission = value2;
    },
    configurable: !0,
    enumerable: !0
  });
}
function convertRouterFetcherToRemixFetcher(fetcherRR) {
  let {
    state,
    formMethod,
    formAction,
    formEncType,
    formData,
    data: data2
  } = fetcherRR, isActionSubmission = formMethod != null && ["POST", "PUT", "PATCH", "DELETE"].includes(formMethod.toUpperCase());
  if (state === "idle")
    return fetcherRR[" _hasFetcherDoneAnything "] === !0 ? {
      state: "idle",
      type: "done",
      formMethod: void 0,
      formAction: void 0,
      formData: void 0,
      formEncType: void 0,
      submission: void 0,
      data: data2
    } : IDLE_FETCHER2;
  if (state === "submitting" && formMethod && formAction && formEncType && formData) {
    if (isActionSubmission)
      return {
        state,
        type: "actionSubmission",
        formMethod: formMethod.toUpperCase(),
        formAction,
        formEncType,
        formData,
        submission: {
          method: formMethod.toUpperCase(),
          action: formAction,
          encType: formEncType,
          formData,
          key: ""
        },
        data: data2
      };
    invariant3(!1, "Encountered an unexpected fetcher scenario in useFetcher()");
  }
  if (state === "loading" && formMethod && formAction && formEncType && formData) {
    if (isActionSubmission)
      return data2 ? {
        state,
        type: "actionReload",
        formMethod: formMethod.toUpperCase(),
        formAction,
        formEncType,
        formData,
        submission: {
          method: formMethod.toUpperCase(),
          action: formAction,
          encType: formEncType,
          formData,
          key: ""
        },
        data: data2
      } : {
        state,
        type: "actionRedirect",
        formMethod: formMethod.toUpperCase(),
        formAction,
        formEncType,
        formData,
        submission: {
          method: formMethod.toUpperCase(),
          action: formAction,
          encType: formEncType,
          formData,
          key: ""
        },
        data: void 0
      };
    {
      let url = new URL(formAction, window.location.origin);
      return url.search = new URLSearchParams(formData.entries()).toString(), {
        state: "submitting",
        type: "loaderSubmission",
        formMethod: formMethod.toUpperCase(),
        formAction,
        formEncType,
        formData,
        submission: {
          method: formMethod.toUpperCase(),
          action: url.pathname + url.search,
          encType: formEncType,
          formData,
          key: ""
        },
        data: data2
      };
    }
  }
  return {
    state: "loading",
    type: "normalLoad",
    formMethod: void 0,
    formAction: void 0,
    formData: void 0,
    formEncType: void 0,
    submission: void 0,
    data: data2
  };
}
var React3, RemixContext, ABSOLUTE_URL_REGEX3, NavLink2, Link2, linksWarning, useTransitionWarning, fetcherTypeWarning, fetcherSubmissionWarning, isHydrated, LiveReload, init_components = __esm({
  "node_modules/@remix-run/react/dist/esm/components.js"() {
    init_rollupPluginBabelHelpers();
    React3 = __toESM(require_react());
    init_dist2();
    init_errorBoundaries();
    init_invariant2();
    init_links();
    init_markup2();
    init_transition();
    init_warnings2();
    RemixContext = /* @__PURE__ */ React3.createContext(void 0);
    RemixContext.displayName = "Remix";
    ABSOLUTE_URL_REGEX3 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, NavLink2 = /* @__PURE__ */ React3.forwardRef(({
      to,
      prefetch = "none",
      ...props
    }, forwardedRef) => {
      let isAbsolute2 = typeof to == "string" && ABSOLUTE_URL_REGEX3.test(to), href = useHref(to), [shouldPrefetch, prefetchHandlers] = usePrefetchBehavior(prefetch, props);
      return /* @__PURE__ */ React3.createElement(React3.Fragment, null, /* @__PURE__ */ React3.createElement(NavLink, _extends4({
        ref: forwardedRef,
        to
      }, props, prefetchHandlers)), shouldPrefetch && !isAbsolute2 ? /* @__PURE__ */ React3.createElement(PrefetchPageLinks, {
        page: href
      }) : null);
    });
    NavLink2.displayName = "NavLink";
    Link2 = /* @__PURE__ */ React3.forwardRef(({
      to,
      prefetch = "none",
      ...props
    }, forwardedRef) => {
      let isAbsolute2 = typeof to == "string" && ABSOLUTE_URL_REGEX3.test(to), href = useHref(to), [shouldPrefetch, prefetchHandlers] = usePrefetchBehavior(prefetch, props);
      return /* @__PURE__ */ React3.createElement(React3.Fragment, null, /* @__PURE__ */ React3.createElement(Link, _extends4({
        ref: forwardedRef,
        to
      }, props, prefetchHandlers)), shouldPrefetch && !isAbsolute2 ? /* @__PURE__ */ React3.createElement(PrefetchPageLinks, {
        page: href
      }) : null);
    });
    Link2.displayName = "Link";
    linksWarning = "\u26A0\uFE0F REMIX FUTURE CHANGE: The behavior of links `imagesizes` and `imagesrcset` will be changing in v2. Only the React camel case versions will be valid. Please change to `imageSizes` and `imageSrcSet`.For instructions on making this change see https://remix.run/docs/en/v1.15.0/pages/v2#links-imagesizes-and-imagesrcset", useTransitionWarning = "\u26A0\uFE0F REMIX FUTURE CHANGE: `useTransition` will be removed in v2 in favor of `useNavigation`. You can prepare for this change at your convenience by updating to `useNavigation`.For instructions on making this change see https://remix.run/docs/en/v1.15.0/pages/v2#usetransition", fetcherTypeWarning = "\u26A0\uFE0F REMIX FUTURE CHANGE: `fetcher.type` will be removed in v2. Please use `fetcher.state`, `fetcher.formData`, and `fetcher.data` to achieve the same UX.For instructions on making this change see https://remix.run/docs/en/v1.15.0/pages/v2#usefetcher", fetcherSubmissionWarning = "\u26A0\uFE0F REMIX FUTURE CHANGE : `fetcher.submission` will be removed in v2. The submission fields are now part of the fetcher object itself (`fetcher.formData`). For instructions on making this change see https://remix.run/docs/en/v1.15.0/pages/v2#usefetcher";
    isHydrated = !1;
    LiveReload = function({
      port = Number(8002),
      timeoutMs = 1e3,
      nonce = void 0
    }) {
      let js = String.raw;
      return /* @__PURE__ */ React3.createElement("script", {
        nonce,
        suppressHydrationWarning: !0,
        dangerouslySetInnerHTML: {
          __html: js`
                function remixLiveReloadConnect(config) {
                  let protocol = location.protocol === "https:" ? "wss:" : "ws:";
                  let host = location.hostname;
                  let port = (window.__remixContext && window.__remixContext.dev && window.__remixContext.dev.liveReloadPort) || ${String(port)};
                  let socketPath = protocol + "//" + host + ":" + port + "/socket";
                  let ws = new WebSocket(socketPath);
                  ws.onmessage = async (message) => {
                    let event = JSON.parse(message.data);
                    if (event.type === "LOG") {
                      console.log(event.message);
                    }
                    if (event.type === "RELOAD") {
                      console.log(" Reloading window ...");
                      window.location.reload();
                    }
                    if (event.type === "HMR") {
                      if (!window.__hmr__ || !window.__hmr__.contexts) {
                        console.log(" [HMR] No HMR context, reloading window ...");
                        window.location.reload();
                        return;
                      }
                      if (!event.updates || !event.updates.length) return;
                      let updateAccepted = false;
                      for (let update of event.updates) {
                        console.log("[HMR] " + update.reason + " [" + update.id +"]")
                        if (update.revalidate) {
                          console.log("[HMR] Revalidating [" + update.id + "]");
                        }
                        let imported = await import(update.url +  '?t=' + event.assetsManifest.hmr.timestamp);
                        if (window.__hmr__.contexts[update.id]) {
                          let accepted = window.__hmr__.contexts[update.id].emit(
                            imported
                          );
                          if (accepted) {
                            console.log("[HMR] Updated accepted by", update.id);
                            updateAccepted = true;
                          }
                        }
                      }
                      if (event.assetsManifest && window.__hmr__.contexts["remix:manifest"]) {
                        let accepted = window.__hmr__.contexts["remix:manifest"].emit(
                          event.assetsManifest
                        );
                        if (accepted) {
                          console.log("[HMR] Updated accepted by", "remix:manifest");
                          updateAccepted = true;
                        }
                      }
                      if (!updateAccepted) {
                        console.log("[HMR] Updated rejected, reloading...");
                        window.location.reload();
                      }
                    }
                  };
                  ws.onopen = () => {
                    if (config && typeof config.onOpen === "function") {
                      config.onOpen();
                    }
                  };
                  ws.onclose = (event) => {
                    if (event.code === 1006) {
                      console.log("Remix dev asset server web socket closed. Reconnecting...");
                      setTimeout(
                        () =>
                          remixLiveReloadConnect({
                            onOpen: () => window.location.reload(),
                          }),
                      ${String(timeoutMs)}
                      );
                    }
                  };
                  ws.onerror = (error) => {
                    console.log("Remix dev asset server web socket error:");
                    console.error(error);
                  };
                }
                remixLiveReloadConnect();
              `
        }
      });
    };
  }
});

// node_modules/@remix-run/react/dist/esm/errors.js
function deserializeErrors2(errors) {
  if (!errors)
    return null;
  let entries = Object.entries(errors), serialized = {};
  for (let [key2, val] of entries)
    if (val && val.__type === "RouteErrorResponse")
      serialized[key2] = new ErrorResponse(val.status, val.statusText, val.data, val.internal === !0);
    else if (val && val.__type === "Error") {
      let error2 = new Error(val.message);
      error2.stack = val.stack, serialized[key2] = error2;
    } else
      serialized[key2] = val;
  return serialized;
}
var init_errors3 = __esm({
  "node_modules/@remix-run/react/dist/esm/errors.js"() {
    init_router();
  }
});

// node_modules/@remix-run/react/dist/esm/data.js
function isCatchResponse(response) {
  return response instanceof Response && response.headers.get("X-Remix-Catch") != null;
}
function isErrorResponse(response) {
  return response instanceof Response && response.headers.get("X-Remix-Error") != null;
}
function isRedirectResponse3(response) {
  return response instanceof Response && response.headers.get("X-Remix-Redirect") != null;
}
function isDeferredResponse(response) {
  var _response$headers$get;
  return response instanceof Response && !!((_response$headers$get = response.headers.get("Content-Type")) !== null && _response$headers$get !== void 0 && _response$headers$get.match(/text\/remix-deferred/));
}
async function fetchData(request, routeId) {
  let url = new URL(request.url);
  url.searchParams.set("_data", routeId);
  let init4 = {
    signal: request.signal
  };
  if (request.method !== "GET") {
    init4.method = request.method;
    let contentType = request.headers.get("Content-Type");
    init4.body = contentType && /\bapplication\/x-www-form-urlencoded\b/.test(contentType) ? new URLSearchParams(await request.text()) : await request.formData();
  }
  let response = await fetch(url.href, init4);
  if (isErrorResponse(response)) {
    let data2 = await response.json(), error2 = new Error(data2.message);
    return error2.stack = data2.stack, error2;
  }
  return response;
}
async function parseDeferredReadableStream(stream) {
  if (!stream)
    throw new Error("parseDeferredReadableStream requires stream argument");
  let deferredData, deferredResolvers = {};
  try {
    let sectionReader = readStreamSections(stream), initialSection = (await sectionReader.next()).value;
    if (!initialSection)
      throw new Error("no critical data");
    let criticalData = JSON.parse(initialSection);
    if (typeof criticalData == "object" && criticalData !== null)
      for (let [eventKey, value2] of Object.entries(criticalData))
        typeof value2 != "string" || !value2.startsWith(DEFERRED_VALUE_PLACEHOLDER_PREFIX2) || (deferredData = deferredData || {}, deferredData[eventKey] = new Promise((resolve2, reject) => {
          deferredResolvers[eventKey] = {
            resolve: (value3) => {
              resolve2(value3), delete deferredResolvers[eventKey];
            },
            reject: (error2) => {
              reject(error2), delete deferredResolvers[eventKey];
            }
          };
        }));
    return (async () => {
      try {
        for await (let section of sectionReader) {
          let [event2, ...sectionDataStrings] = section.split(":"), sectionDataString = sectionDataStrings.join(":"), data2 = JSON.parse(sectionDataString);
          if (event2 === "data")
            for (let [key2, value2] of Object.entries(data2))
              deferredResolvers[key2] && deferredResolvers[key2].resolve(value2);
          else if (event2 === "error")
            for (let [key2, value2] of Object.entries(data2)) {
              let err = new Error(value2.message);
              err.stack = value2.stack, deferredResolvers[key2] && deferredResolvers[key2].reject(err);
            }
        }
        for (let [key2, resolver] of Object.entries(deferredResolvers))
          resolver.reject(new AbortedDeferredError(`Deferred ${key2} will never be resolved`));
      } catch (error2) {
        for (let resolver of Object.values(deferredResolvers))
          resolver.reject(error2);
      }
    })(), new DeferredData({
      ...criticalData,
      ...deferredData
    });
  } catch (error2) {
    for (let resolver of Object.values(deferredResolvers))
      resolver.reject(error2);
    throw error2;
  }
}
async function* readStreamSections(stream) {
  let reader = stream.getReader(), buffer2 = [], sections = [], closed = !1, encoder = new TextEncoder(), decoder = new TextDecoder(), readStreamSection = async () => {
    if (sections.length > 0)
      return sections.shift();
    for (; !closed && sections.length === 0; ) {
      let chunk = await reader.read();
      if (chunk.done) {
        closed = !0;
        break;
      }
      buffer2.push(chunk.value);
      try {
        let splitSections = decoder.decode(mergeArrays3(...buffer2)).split(`

`);
        if (splitSections.length >= 2 && (sections.push(...splitSections.slice(0, -1)), buffer2 = [encoder.encode(splitSections.slice(-1).join(`

`))]), sections.length > 0)
          break;
      } catch {
        continue;
      }
    }
    return sections.length > 0 || buffer2.length > 0 && (sections = decoder.decode(mergeArrays3(...buffer2)).split(`

`).filter((s3) => s3), buffer2 = []), sections.shift();
  }, section = await readStreamSection();
  for (; section; )
    yield section, section = await readStreamSection();
}
function mergeArrays3(...arrays) {
  let out = new Uint8Array(arrays.reduce((total, arr2) => total + arr2.length, 0)), offset = 0;
  for (let arr2 of arrays)
    out.set(arr2, offset), offset += arr2.length;
  return out;
}
var DEFERRED_VALUE_PLACEHOLDER_PREFIX2, init_data2 = __esm({
  "node_modules/@remix-run/react/dist/esm/data.js"() {
    init_router();
    DEFERRED_VALUE_PLACEHOLDER_PREFIX2 = "__deferred_promise:";
  }
});

// node_modules/@remix-run/react/dist/esm/routes.js
function groupRoutesByParentId2(manifest) {
  let routes2 = {};
  return Object.values(manifest).forEach((route) => {
    let parentId = route.parentId || "";
    routes2[parentId] || (routes2[parentId] = []), routes2[parentId].push(route);
  }), routes2;
}
function createServerRoutes(manifest, routeModules, future2, parentId = "", routesByParentId = groupRoutesByParentId2(manifest)) {
  return (routesByParentId[parentId] || []).map((route) => {
    let hasErrorBoundary = future2.v2_errorBoundary === !0 ? route.id === "root" || route.hasErrorBoundary : route.id === "root" || route.hasCatchBoundary || route.hasErrorBoundary, dataRoute = {
      caseSensitive: route.caseSensitive,
      element: /* @__PURE__ */ React4.createElement(RemixRoute, {
        id: route.id
      }),
      errorElement: hasErrorBoundary ? /* @__PURE__ */ React4.createElement(RemixRouteError, {
        id: route.id
      }) : void 0,
      id: route.id,
      index: route.index,
      path: route.path,
      handle: routeModules[route.id].handle
    }, children = createServerRoutes(manifest, routeModules, future2, route.id, routesByParentId);
    return children.length > 0 && (dataRoute.children = children), dataRoute;
  });
}
function createClientRoutes(manifest, routeModulesCache, future2, parentId = "", routesByParentId = groupRoutesByParentId2(manifest)) {
  return (routesByParentId[parentId] || []).map((route) => {
    let hasErrorBoundary = future2.v2_errorBoundary === !0 ? route.id === "root" || route.hasErrorBoundary : route.id === "root" || route.hasCatchBoundary || route.hasErrorBoundary, dataRoute = {
      caseSensitive: route.caseSensitive,
      element: /* @__PURE__ */ React4.createElement(RemixRoute, {
        id: route.id
      }),
      errorElement: hasErrorBoundary ? /* @__PURE__ */ React4.createElement(RemixRouteError, {
        id: route.id
      }) : void 0,
      id: route.id,
      index: route.index,
      path: route.path,
      handle: void 0,
      loader: createDataFunction(route, routeModulesCache, !1),
      action: createDataFunction(route, routeModulesCache, !0),
      shouldRevalidate: createShouldRevalidate(route, routeModulesCache)
    }, children = createClientRoutes(manifest, routeModulesCache, future2, route.id);
    return children.length > 0 && (dataRoute.children = children), dataRoute;
  });
}
function createShouldRevalidate(route, routeModules) {
  return function(arg) {
    let module2 = routeModules[route.id];
    return invariant3(module2, `Expected route module to be loaded for ${route.id}`), module2.shouldRevalidate ? module2.shouldRevalidate(arg) : arg.defaultShouldRevalidate;
  };
}
async function loadRouteModuleWithBlockingLinks(route, routeModules) {
  let routeModule = await loadRouteModule(route, routeModules);
  return await prefetchStyleLinks(routeModule), routeModule;
}
function createDataFunction(route, routeModules, isAction) {
  return async ({
    request
  }) => {
    let routeModulePromise = loadRouteModuleWithBlockingLinks(route, routeModules);
    try {
      if (isAction && !route.hasAction) {
        let msg = `Route "${route.id}" does not have an action, but you are trying to submit to it. To fix this, please add an \`action\` function to the route`;
        throw console.error(msg), new Error(msg);
      } else if (!isAction && !route.hasLoader)
        return null;
      let result2 = await fetchData(request, route.id);
      if (result2 instanceof Error)
        throw result2;
      if (isRedirectResponse3(result2))
        throw getRedirect(result2);
      if (isCatchResponse(result2))
        throw result2;
      return isDeferredResponse(result2) && result2.body ? await parseDeferredReadableStream(result2.body) : result2;
    } finally {
      await routeModulePromise;
    }
  };
}
function getRedirect(response) {
  let status = parseInt(response.headers.get("X-Remix-Status"), 10) || 302, url = response.headers.get("X-Remix-Redirect"), headers = {}, revalidate = response.headers.get("X-Remix-Revalidate");
  return revalidate && (headers["X-Remix-Revalidate"] = revalidate), redirect(url, {
    status,
    headers
  });
}
var React4, init_routes2 = __esm({
  "node_modules/@remix-run/react/dist/esm/routes.js"() {
    React4 = __toESM(require_react());
    init_dist2();
    init_routeModules();
    init_data2();
    init_links();
    init_invariant2();
    init_components();
  }
});

// node_modules/@remix-run/react/dist/esm/browser.js
function RemixBrowser(_props) {
  if (!router) {
    let routes2 = createClientRoutes(window.__remixManifest.routes, window.__remixRouteModules, window.__remixContext.future), hydrationData = window.__remixContext.state;
    hydrationData && hydrationData.errors && (hydrationData = {
      ...hydrationData,
      errors: deserializeErrors2(hydrationData.errors)
    }), router = createBrowserRouter(routes2, {
      hydrationData,
      future: {
        v7_normalizeFormMethod: window.__remixContext.future.v2_normalizeFormMethod
      }
    });
  }
  let location = (0, import_shim.useSyncExternalStore)(router.subscribe, () => router.state.location, () => router.state.location);
  return /* @__PURE__ */ React5.createElement(RemixContext.Provider, {
    value: {
      manifest: window.__remixManifest,
      routeModules: window.__remixRouteModules,
      future: window.__remixContext.future
    }
  }, /* @__PURE__ */ React5.createElement(RemixErrorBoundary, {
    location,
    component: RemixRootDefaultErrorBoundary
  }, /* @__PURE__ */ React5.createElement(RouterProvider, {
    router,
    fallbackElement: null
  })));
}
var React5, import_shim, router, hmrAbortController, init_browser = __esm({
  "node_modules/@remix-run/react/dist/esm/browser.js"() {
    React5 = __toESM(require_react());
    init_dist2();
    import_shim = __toESM(require_shim());
    init_components();
    init_errorBoundaries();
    init_errors3();
    init_routes2();
    import.meta && import.meta.hot && import.meta.hot.accept("remix:manifest", async (newManifest) => {
      let routeIds = [...new Set(router.state.matches.map((m2) => m2.route.id).concat(Object.keys(window.__remixRouteModules)))], newRouteModules = Object.assign({}, window.__remixRouteModules, Object.fromEntries((await Promise.all(routeIds.map(async (id4) => {
        var _newManifest$hmr, _window$__remixRouteM, _window$__remixRouteM2, _window$__remixRouteM3;
        if (!newManifest.routes[id4])
          return null;
        let imported = await import(newManifest.routes[id4].module + `?t=${(_newManifest$hmr = newManifest.hmr) === null || _newManifest$hmr === void 0 ? void 0 : _newManifest$hmr.timestamp}`);
        return [id4, {
          ...imported,
          default: imported.default ? ((_window$__remixRouteM = window.__remixRouteModules[id4]) === null || _window$__remixRouteM === void 0 ? void 0 : _window$__remixRouteM.default) ?? imported.default : imported.default,
          CatchBoundary: imported.CatchBoundary ? ((_window$__remixRouteM2 = window.__remixRouteModules[id4]) === null || _window$__remixRouteM2 === void 0 ? void 0 : _window$__remixRouteM2.CatchBoundary) ?? imported.CatchBoundary : imported.CatchBoundary,
          ErrorBoundary: imported.ErrorBoundary ? ((_window$__remixRouteM3 = window.__remixRouteModules[id4]) === null || _window$__remixRouteM3 === void 0 ? void 0 : _window$__remixRouteM3.ErrorBoundary) ?? imported.ErrorBoundary : imported.ErrorBoundary
        }];
      }))).filter(Boolean)));
      Object.assign(window.__remixRouteModules, newRouteModules);
      let routes2 = createClientRoutes(newManifest.routes, window.__remixRouteModules, window.__remixContext.future);
      router._internalSetRoutes(routes2), hmrAbortController && hmrAbortController.abort(), hmrAbortController = new AbortController();
      let signal = hmrAbortController.signal, unsub = router.subscribe((state) => {
        state.revalidation === "idle" && !signal.aborted && (unsub(), Object.assign(window.__remixManifest, newManifest), window.$RefreshRuntime$.performReactRefresh());
      });
      router.revalidate();
    });
  }
});

// node_modules/@remix-run/react/dist/esm/scroll-restoration.js
function ScrollRestoration2({
  getKey,
  ...props
}) {
  let location = useLocation(), matches = useMatches2();
  useScrollRestoration({
    getKey,
    storageKey: STORAGE_KEY
  });
  let key2 = React6.useMemo(
    () => {
      if (!getKey)
        return null;
      let userKey = getKey(location, matches);
      return userKey !== location.key ? userKey : null;
    },
    []
  ), restoreScroll = ((STORAGE_KEY2, restoreKey) => {
    if (!window.history.state || !window.history.state.key) {
      let key3 = Math.random().toString(32).slice(2);
      window.history.replaceState({
        key: key3
      }, "");
    }
    try {
      let storedY = JSON.parse(sessionStorage.getItem(STORAGE_KEY2) || "{}")[restoreKey || window.history.state.key];
      typeof storedY == "number" && window.scrollTo(0, storedY);
    } catch (error2) {
      console.error(error2), sessionStorage.removeItem(STORAGE_KEY2);
    }
  }).toString();
  return /* @__PURE__ */ React6.createElement("script", _extends4({}, props, {
    suppressHydrationWarning: !0,
    dangerouslySetInnerHTML: {
      __html: `(${restoreScroll})(${JSON.stringify(STORAGE_KEY)}, ${JSON.stringify(key2)})`
    }
  }));
}
var React6, STORAGE_KEY, init_scroll_restoration = __esm({
  "node_modules/@remix-run/react/dist/esm/scroll-restoration.js"() {
    init_rollupPluginBabelHelpers();
    React6 = __toESM(require_react());
    init_dist2();
    init_components();
    STORAGE_KEY = "positions";
  }
});

// node_modules/react-router-dom/server.js
var require_server = __commonJS({
  "node_modules/react-router-dom/server.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var React17 = require_react(), router2 = (init_router(), __toCommonJS(router_exports)), reactRouterDom = (init_dist2(), __toCommonJS(dist_exports));
    function _interopNamespace(e3) {
      if (e3 && e3.__esModule)
        return e3;
      var n3 = /* @__PURE__ */ Object.create(null);
      return e3 && Object.keys(e3).forEach(function(k2) {
        if (k2 !== "default") {
          var d2 = Object.getOwnPropertyDescriptor(e3, k2);
          Object.defineProperty(n3, k2, d2.get ? d2 : {
            enumerable: !0,
            get: function() {
              return e3[k2];
            }
          });
        }
      }), n3.default = e3, Object.freeze(n3);
    }
    var React__namespace = /* @__PURE__ */ _interopNamespace(React17);
    function StaticRouter({
      basename: basename2,
      children,
      location: locationProp = "/"
    }) {
      typeof locationProp == "string" && (locationProp = reactRouterDom.parsePath(locationProp));
      let action3 = router2.Action.Pop, location = {
        pathname: locationProp.pathname || "/",
        search: locationProp.search || "",
        hash: locationProp.hash || "",
        state: locationProp.state || null,
        key: locationProp.key || "default"
      }, staticNavigator = getStatelessNavigator();
      return /* @__PURE__ */ React__namespace.createElement(reactRouterDom.Router, {
        basename: basename2,
        children,
        location,
        navigationType: action3,
        navigator: staticNavigator,
        static: !0
      });
    }
    function StaticRouterProvider2({
      context,
      router: router$1,
      hydrate = !0,
      nonce
    }) {
      router$1 && context || router2.UNSAFE_invariant(!1, "You must provide `router` and `context` to <StaticRouterProvider>");
      let dataRouterContext = {
        router: router$1,
        navigator: getStatelessNavigator(),
        static: !0,
        staticContext: context,
        basename: context.basename || "/"
      }, hydrateScript = "";
      if (hydrate !== !1) {
        let data2 = {
          loaderData: context.loaderData,
          actionData: context.actionData,
          errors: serializeErrors2(context.errors)
        };
        hydrateScript = `window.__staticRouterHydrationData = JSON.parse(${htmlEscape(JSON.stringify(JSON.stringify(data2)))});`;
      }
      return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(reactRouterDom.UNSAFE_DataRouterContext.Provider, {
        value: dataRouterContext
      }, /* @__PURE__ */ React__namespace.createElement(reactRouterDom.UNSAFE_DataRouterStateContext.Provider, {
        value: dataRouterContext.router.state
      }, /* @__PURE__ */ React__namespace.createElement(reactRouterDom.Router, {
        basename: dataRouterContext.basename,
        location: dataRouterContext.router.state.location,
        navigationType: dataRouterContext.router.state.historyAction,
        navigator: dataRouterContext.navigator
      }, /* @__PURE__ */ React__namespace.createElement(reactRouterDom.Routes, null)))), hydrateScript ? /* @__PURE__ */ React__namespace.createElement("script", {
        suppressHydrationWarning: !0,
        nonce,
        dangerouslySetInnerHTML: {
          __html: hydrateScript
        }
      }) : null);
    }
    function serializeErrors2(errors) {
      if (!errors)
        return null;
      let entries = Object.entries(errors), serialized = {};
      for (let [key2, val] of entries)
        router2.isRouteErrorResponse(val) ? serialized[key2] = {
          ...val,
          __type: "RouteErrorResponse"
        } : val instanceof Error ? serialized[key2] = {
          message: val.message,
          __type: "Error"
        } : serialized[key2] = val;
      return serialized;
    }
    function getStatelessNavigator() {
      return {
        createHref,
        encodeLocation,
        push(to) {
          throw new Error(`You cannot use navigator.push() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${JSON.stringify(to)})\` somewhere in your app.`);
        },
        replace(to) {
          throw new Error(`You cannot use navigator.replace() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${JSON.stringify(to)}, { replace: true })\` somewhere in your app.`);
        },
        go(delta) {
          throw new Error(`You cannot use navigator.go() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${delta})\` somewhere in your app.`);
        },
        back() {
          throw new Error("You cannot use navigator.back() on the server because it is a stateless environment.");
        },
        forward() {
          throw new Error("You cannot use navigator.forward() on the server because it is a stateless environment.");
        }
      };
    }
    var detectErrorBoundary2 = (route) => Boolean(route.ErrorBoundary) || Boolean(route.errorElement);
    function createStaticHandler2(routes2, opts) {
      return router2.createStaticHandler(routes2, {
        ...opts,
        detectErrorBoundary: detectErrorBoundary2
      });
    }
    function createStaticRouter2(routes2, context) {
      let manifest = {}, dataRoutes = router2.UNSAFE_convertRoutesToDataRoutes(routes2, detectErrorBoundary2, void 0, manifest), matches = context.matches.map((match) => {
        let route = manifest[match.route.id] || match.route;
        return {
          ...match,
          route
        };
      }), msg = (method) => `You cannot use router.${method}() on the server because it is a stateless environment`;
      return {
        get basename() {
          return context.basename;
        },
        get state() {
          return {
            historyAction: router2.Action.Pop,
            location: context.location,
            matches,
            loaderData: context.loaderData,
            actionData: context.actionData,
            errors: context.errors,
            initialized: !0,
            navigation: router2.IDLE_NAVIGATION,
            restoreScrollPosition: null,
            preventScrollReset: !1,
            revalidation: "idle",
            fetchers: /* @__PURE__ */ new Map(),
            blockers: /* @__PURE__ */ new Map()
          };
        },
        get routes() {
          return dataRoutes;
        },
        initialize() {
          throw msg("initialize");
        },
        subscribe() {
          throw msg("subscribe");
        },
        enableScrollRestoration() {
          throw msg("enableScrollRestoration");
        },
        navigate() {
          throw msg("navigate");
        },
        fetch() {
          throw msg("fetch");
        },
        revalidate() {
          throw msg("revalidate");
        },
        createHref,
        encodeLocation,
        getFetcher() {
          return router2.IDLE_FETCHER;
        },
        deleteFetcher() {
          throw msg("deleteFetcher");
        },
        dispose() {
          throw msg("dispose");
        },
        getBlocker() {
          return router2.IDLE_BLOCKER;
        },
        deleteBlocker() {
          throw msg("deleteBlocker");
        },
        _internalFetchControllers: /* @__PURE__ */ new Map(),
        _internalActiveDeferreds: /* @__PURE__ */ new Map(),
        _internalSetRoutes() {
          throw msg("_internalSetRoutes");
        }
      };
    }
    function createHref(to) {
      return typeof to == "string" ? to : reactRouterDom.createPath(to);
    }
    function encodeLocation(to) {
      let path2 = typeof to == "string" ? reactRouterDom.parsePath(to) : to;
      return {
        pathname: path2.pathname || "",
        search: path2.search || "",
        hash: path2.hash || ""
      };
    }
    var ESCAPE_LOOKUP3 = {
      "&": "\\u0026",
      ">": "\\u003e",
      "<": "\\u003c",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    }, ESCAPE_REGEX3 = /[&><\u2028\u2029]/g;
    function htmlEscape(str2) {
      return str2.replace(ESCAPE_REGEX3, (match) => ESCAPE_LOOKUP3[match]);
    }
    exports.StaticRouter = StaticRouter;
    exports.StaticRouterProvider = StaticRouterProvider2;
    exports.createStaticHandler = createStaticHandler2;
    exports.createStaticRouter = createStaticRouter2;
  }
});

// node_modules/@remix-run/react/dist/esm/server.js
function RemixServer({
  context,
  url,
  abortDelay
}) {
  typeof url == "string" && (url = new URL(url));
  let {
    manifest,
    routeModules,
    serverHandoffString
  } = context, routes2 = createServerRoutes(manifest.routes, routeModules, context.future), router2 = (0, import_server2.createStaticRouter)(routes2, context.staticHandlerContext);
  return /* @__PURE__ */ React7.createElement(RemixContext.Provider, {
    value: {
      manifest,
      routeModules,
      serverHandoffString,
      future: context.future,
      abortDelay
    }
  }, /* @__PURE__ */ React7.createElement(RemixErrorBoundary, {
    location: router2.state.location,
    component: RemixRootDefaultErrorBoundary
  }, /* @__PURE__ */ React7.createElement(import_server2.StaticRouterProvider, {
    router: router2,
    context: context.staticHandlerContext,
    hydrate: !1
  })));
}
var React7, import_server2, init_server2 = __esm({
  "node_modules/@remix-run/react/dist/esm/server.js"() {
    React7 = __toESM(require_react()), import_server2 = __toESM(require_server());
    init_components();
    init_errorBoundaries();
    init_routes2();
  }
});

// node_modules/@remix-run/react/dist/esm/index.js
var esm_exports2 = {};
__export(esm_exports2, {
  Await: () => Await2,
  Form: () => Form,
  Link: () => Link2,
  Links: () => Links,
  LiveReload: () => LiveReload,
  Meta: () => Meta,
  NavLink: () => NavLink2,
  Outlet: () => Outlet,
  PrefetchPageLinks: () => PrefetchPageLinks,
  RemixBrowser: () => RemixBrowser,
  RemixServer: () => RemixServer,
  Scripts: () => Scripts,
  ScrollRestoration: () => ScrollRestoration2,
  UNSAFE_RemixContext: () => RemixContext,
  isRouteErrorResponse: () => isRouteErrorResponse,
  unstable_useBlocker: () => useBlocker,
  unstable_usePrompt: () => usePrompt,
  useActionData: () => useActionData2,
  useAsyncError: () => useAsyncError,
  useAsyncValue: () => useAsyncValue,
  useBeforeUnload: () => useBeforeUnload,
  useCatch: () => useCatch,
  useFetcher: () => useFetcher2,
  useFetchers: () => useFetchers2,
  useFormAction: () => useFormAction,
  useHref: () => useHref,
  useLoaderData: () => useLoaderData2,
  useLocation: () => useLocation,
  useMatches: () => useMatches2,
  useNavigate: () => useNavigate,
  useNavigation: () => useNavigation,
  useNavigationType: () => useNavigationType,
  useOutlet: () => useOutlet,
  useOutletContext: () => useOutletContext,
  useParams: () => useParams,
  useResolvedPath: () => useResolvedPath,
  useRevalidator: () => useRevalidator,
  useRouteError: () => useRouteError,
  useRouteLoaderData: () => useRouteLoaderData,
  useSearchParams: () => useSearchParams,
  useSubmit: () => useSubmit,
  useTransition: () => useTransition
});
var init_esm2 = __esm({
  "node_modules/@remix-run/react/dist/esm/index.js"() {
    init_browser();
    init_dist2();
    init_components();
    init_errorBoundaries();
    init_scroll_restoration();
    init_server2();
  }
});

// node-modules-polyfills:fs
var fs_exports = {};
__export(fs_exports, {
  default: () => fs_default
});
var fs_default, init_fs = __esm({
  "node-modules-polyfills:fs"() {
    fs_default = {};
  }
});

// node-modules-polyfills-commonjs:fs
var require_fs = __commonJS({
  "node-modules-polyfills-commonjs:fs"(exports, module2) {
    var polyfill = (init_fs(), __toCommonJS(fs_exports));
    if (polyfill && polyfill.default) {
      module2.exports = polyfill.default;
      for (let k2 in polyfill)
        module2.exports[k2] = polyfill[k2];
    } else
      polyfill && (module2.exports = polyfill);
  }
});

// node_modules/i18next-fs-backend/esm/fs.cjs
var require_fs2 = __commonJS({
  "node_modules/i18next-fs-backend/esm/fs.cjs"(exports, module2) {
    typeof __require < "u" && (f2 = require_fs(), f2.default && (f2 = f2.default), exports.default = f2, module2.exports = exports.default);
    var f2;
  }
});

// node-modules-polyfills:path
var path_exports = {};
__export(path_exports, {
  basename: () => basename,
  default: () => path_default,
  delimiter: () => delimiter,
  dirname: () => dirname,
  extname: () => extname,
  isAbsolute: () => isAbsolute,
  join: () => join,
  normalize: () => normalize,
  relative: () => relative,
  resolve: () => resolve,
  sep: () => sep
});
function normalizeArray(parts, allowAboveRoot) {
  for (var up = 0, i3 = parts.length - 1; i3 >= 0; i3--) {
    var last = parts[i3];
    last === "." ? parts.splice(i3, 1) : last === ".." ? (parts.splice(i3, 1), up++) : up && (parts.splice(i3, 1), up--);
  }
  if (allowAboveRoot)
    for (; up--; up)
      parts.unshift("..");
  return parts;
}
function resolve() {
  for (var resolvedPath = "", resolvedAbsolute = !1, i3 = arguments.length - 1; i3 >= -1 && !resolvedAbsolute; i3--) {
    var path2 = i3 >= 0 ? arguments[i3] : "/";
    if (typeof path2 != "string")
      throw new TypeError("Arguments to path.resolve must be strings");
    if (!path2)
      continue;
    resolvedPath = path2 + "/" + resolvedPath, resolvedAbsolute = path2.charAt(0) === "/";
  }
  return resolvedPath = normalizeArray(filter(resolvedPath.split("/"), function(p) {
    return !!p;
  }), !resolvedAbsolute).join("/"), (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
}
function normalize(path2) {
  var isPathAbsolute = isAbsolute(path2), trailingSlash = substr(path2, -1) === "/";
  return path2 = normalizeArray(filter(path2.split("/"), function(p) {
    return !!p;
  }), !isPathAbsolute).join("/"), !path2 && !isPathAbsolute && (path2 = "."), path2 && trailingSlash && (path2 += "/"), (isPathAbsolute ? "/" : "") + path2;
}
function isAbsolute(path2) {
  return path2.charAt(0) === "/";
}
function join() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return normalize(filter(paths, function(p, index2) {
    if (typeof p != "string")
      throw new TypeError("Arguments to path.join must be strings");
    return p;
  }).join("/"));
}
function relative(from2, to) {
  from2 = resolve(from2).substr(1), to = resolve(to).substr(1);
  function trim(arr2) {
    for (var start3 = 0; start3 < arr2.length && arr2[start3] === ""; start3++)
      ;
    for (var end3 = arr2.length - 1; end3 >= 0 && arr2[end3] === ""; end3--)
      ;
    return start3 > end3 ? [] : arr2.slice(start3, end3 - start3 + 1);
  }
  for (var fromParts = trim(from2.split("/")), toParts = trim(to.split("/")), length = Math.min(fromParts.length, toParts.length), samePartsLength = length, i3 = 0; i3 < length; i3++)
    if (fromParts[i3] !== toParts[i3]) {
      samePartsLength = i3;
      break;
    }
  for (var outputParts = [], i3 = samePartsLength; i3 < fromParts.length; i3++)
    outputParts.push("..");
  return outputParts = outputParts.concat(toParts.slice(samePartsLength)), outputParts.join("/");
}
function dirname(path2) {
  var result2 = splitPath(path2), root2 = result2[0], dir = result2[1];
  return !root2 && !dir ? "." : (dir && (dir = dir.substr(0, dir.length - 1)), root2 + dir);
}
function basename(path2, ext) {
  var f2 = splitPath(path2)[2];
  return ext && f2.substr(-1 * ext.length) === ext && (f2 = f2.substr(0, f2.length - ext.length)), f2;
}
function extname(path2) {
  return splitPath(path2)[3];
}
function filter(xs, f2) {
  if (xs.filter)
    return xs.filter(f2);
  for (var res = [], i3 = 0; i3 < xs.length; i3++)
    f2(xs[i3], i3, xs) && res.push(xs[i3]);
  return res;
}
var splitPathRe, splitPath, sep, delimiter, path_default, substr, init_path = __esm({
  "node-modules-polyfills:path"() {
    splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, splitPath = function(filename) {
      return splitPathRe.exec(filename).slice(1);
    };
    sep = "/", delimiter = ":";
    path_default = {
      extname,
      basename,
      dirname,
      sep,
      delimiter,
      relative,
      join,
      isAbsolute,
      normalize,
      resolve
    };
    substr = "ab".substr(-1) === "b" ? function(str2, start3, len) {
      return str2.substr(start3, len);
    } : function(str2, start3, len) {
      return start3 < 0 && (start3 = str2.length + start3), str2.substr(start3, len);
    };
  }
});

// node-modules-polyfills-commonjs:path
var require_path = __commonJS({
  "node-modules-polyfills-commonjs:path"(exports, module2) {
    var polyfill = (init_path(), __toCommonJS(path_exports));
    if (polyfill && polyfill.default) {
      module2.exports = polyfill.default;
      for (let k2 in polyfill)
        module2.exports[k2] = polyfill[k2];
    } else
      polyfill && (module2.exports = polyfill);
  }
});

// node_modules/i18next-fs-backend/esm/path.cjs
var require_path2 = __commonJS({
  "node_modules/i18next-fs-backend/esm/path.cjs"(exports, module2) {
    typeof __require < "u" && (path2 = require_path(), path2.default && (path2 = path2.default), exports.default = path2, module2.exports = exports.default);
    var path2;
  }
});

// node_modules/react-dom/cjs/react-dom-server-legacy.browser.development.js
var require_react_dom_server_legacy_browser_development = __commonJS({
  "node_modules/react-dom/cjs/react-dom-server-legacy.browser.development.js"(exports) {
    "use strict";
    (function() {
      "use strict";
      var React17 = require_react(), ReactVersion = "18.2.0", ReactSharedInternals = React17.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function warn3(format2) {
        {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
            args[_key - 1] = arguments[_key];
          printWarning("warn", format2, args);
        }
      }
      function error2(format2) {
        {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)
            args[_key2 - 1] = arguments[_key2];
          printWarning("error", format2, args);
        }
      }
      function printWarning(level, format2, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame, stack2 = ReactDebugCurrentFrame2.getStackAddendum();
          stack2 !== "" && (format2 += "%s", args = args.concat([stack2]));
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format2), Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      function scheduleWork(callback) {
        callback();
      }
      function beginWriting(destination) {
      }
      function writeChunk(destination, chunk) {
        writeChunkAndReturn(destination, chunk);
      }
      function writeChunkAndReturn(destination, chunk) {
        return destination.push(chunk);
      }
      function completeWriting(destination) {
      }
      function close(destination) {
        destination.push(null);
      }
      function stringToChunk(content) {
        return content;
      }
      function stringToPrecomputedChunk(content) {
        return content;
      }
      function closeWithError(destination, error3) {
        destination.destroy(error3);
      }
      function typeName(value2) {
        {
          var hasToStringTag = typeof Symbol == "function" && Symbol.toStringTag, type2 = hasToStringTag && value2[Symbol.toStringTag] || value2.constructor.name || "Object";
          return type2;
        }
      }
      function willCoercionThrow(value2) {
        try {
          return testStringCoercion(value2), !1;
        } catch {
          return !0;
        }
      }
      function testStringCoercion(value2) {
        return "" + value2;
      }
      function checkAttributeStringCoercion(value2, attributeName) {
        if (willCoercionThrow(value2))
          return error2("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", attributeName, typeName(value2)), testStringCoercion(value2);
      }
      function checkCSSPropertyStringCoercion(value2, propName) {
        if (willCoercionThrow(value2))
          return error2("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value2)), testStringCoercion(value2);
      }
      function checkHtmlStringCoercion(value2) {
        if (willCoercionThrow(value2))
          return error2("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value2)), testStringCoercion(value2);
      }
      var hasOwnProperty2 = Object.prototype.hasOwnProperty, RESERVED = 0, STRING = 1, BOOLEANISH_STRING = 2, BOOLEAN = 3, OVERLOADED_BOOLEAN = 4, NUMERIC = 5, POSITIVE_NUMERIC = 6, ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$"), illegalAttributeNameCache = {}, validatedAttributeNameCache = {};
      function isAttributeNameSafe(attributeName) {
        return hasOwnProperty2.call(validatedAttributeNameCache, attributeName) ? !0 : hasOwnProperty2.call(illegalAttributeNameCache, attributeName) ? !1 : VALID_ATTRIBUTE_NAME_REGEX.test(attributeName) ? (validatedAttributeNameCache[attributeName] = !0, !0) : (illegalAttributeNameCache[attributeName] = !0, error2("Invalid attribute name: `%s`", attributeName), !1);
      }
      function shouldRemoveAttributeWithWarning(name, value2, propertyInfo, isCustomComponentTag) {
        if (propertyInfo !== null && propertyInfo.type === RESERVED)
          return !1;
        switch (typeof value2) {
          case "function":
          case "symbol":
            return !0;
          case "boolean": {
            if (isCustomComponentTag)
              return !1;
            if (propertyInfo !== null)
              return !propertyInfo.acceptsBooleans;
            var prefix2 = name.toLowerCase().slice(0, 5);
            return prefix2 !== "data-" && prefix2 !== "aria-";
          }
          default:
            return !1;
        }
      }
      function getPropertyInfo(name) {
        return properties.hasOwnProperty(name) ? properties[name] : null;
      }
      function PropertyInfoRecord(name, type2, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
        this.acceptsBooleans = type2 === BOOLEANISH_STRING || type2 === BOOLEAN || type2 === OVERLOADED_BOOLEAN, this.attributeName = attributeName, this.attributeNamespace = attributeNamespace, this.mustUseProperty = mustUseProperty, this.propertyName = name, this.type = type2, this.sanitizeURL = sanitizeURL2, this.removeEmptyString = removeEmptyString;
      }
      var properties = {}, reservedProps = [
        "children",
        "dangerouslySetInnerHTML",
        "defaultValue",
        "defaultChecked",
        "innerHTML",
        "suppressContentEditableWarning",
        "suppressHydrationWarning",
        "style"
      ];
      reservedProps.forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          RESERVED,
          !1,
          name,
          null,
          !1,
          !1
        );
      }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
        var name = _ref[0], attributeName = _ref[1];
        properties[name] = new PropertyInfoRecord(
          name,
          STRING,
          !1,
          attributeName,
          null,
          !1,
          !1
        );
      }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          BOOLEANISH_STRING,
          !1,
          name.toLowerCase(),
          null,
          !1,
          !1
        );
      }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          BOOLEANISH_STRING,
          !1,
          name,
          null,
          !1,
          !1
        );
      }), [
        "allowFullScreen",
        "async",
        "autoFocus",
        "autoPlay",
        "controls",
        "default",
        "defer",
        "disabled",
        "disablePictureInPicture",
        "disableRemotePlayback",
        "formNoValidate",
        "hidden",
        "loop",
        "noModule",
        "noValidate",
        "open",
        "playsInline",
        "readOnly",
        "required",
        "reversed",
        "scoped",
        "seamless",
        "itemScope"
      ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          BOOLEAN,
          !1,
          name.toLowerCase(),
          null,
          !1,
          !1
        );
      }), [
        "checked",
        "multiple",
        "muted",
        "selected"
      ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          BOOLEAN,
          !0,
          name,
          null,
          !1,
          !1
        );
      }), [
        "capture",
        "download"
      ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          OVERLOADED_BOOLEAN,
          !1,
          name,
          null,
          !1,
          !1
        );
      }), [
        "cols",
        "rows",
        "size",
        "span"
      ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          POSITIVE_NUMERIC,
          !1,
          name,
          null,
          !1,
          !1
        );
      }), ["rowSpan", "start"].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          NUMERIC,
          !1,
          name.toLowerCase(),
          null,
          !1,
          !1
        );
      });
      var CAMELIZE = /[\-\:]([a-z])/g, capitalize2 = function(token2) {
        return token2[1].toUpperCase();
      };
      [
        "accent-height",
        "alignment-baseline",
        "arabic-form",
        "baseline-shift",
        "cap-height",
        "clip-path",
        "clip-rule",
        "color-interpolation",
        "color-interpolation-filters",
        "color-profile",
        "color-rendering",
        "dominant-baseline",
        "enable-background",
        "fill-opacity",
        "fill-rule",
        "flood-color",
        "flood-opacity",
        "font-family",
        "font-size",
        "font-size-adjust",
        "font-stretch",
        "font-style",
        "font-variant",
        "font-weight",
        "glyph-name",
        "glyph-orientation-horizontal",
        "glyph-orientation-vertical",
        "horiz-adv-x",
        "horiz-origin-x",
        "image-rendering",
        "letter-spacing",
        "lighting-color",
        "marker-end",
        "marker-mid",
        "marker-start",
        "overline-position",
        "overline-thickness",
        "paint-order",
        "panose-1",
        "pointer-events",
        "rendering-intent",
        "shape-rendering",
        "stop-color",
        "stop-opacity",
        "strikethrough-position",
        "strikethrough-thickness",
        "stroke-dasharray",
        "stroke-dashoffset",
        "stroke-linecap",
        "stroke-linejoin",
        "stroke-miterlimit",
        "stroke-opacity",
        "stroke-width",
        "text-anchor",
        "text-decoration",
        "text-rendering",
        "underline-position",
        "underline-thickness",
        "unicode-bidi",
        "unicode-range",
        "units-per-em",
        "v-alphabetic",
        "v-hanging",
        "v-ideographic",
        "v-mathematical",
        "vector-effect",
        "vert-adv-y",
        "vert-origin-x",
        "vert-origin-y",
        "word-spacing",
        "writing-mode",
        "xmlns:xlink",
        "x-height"
      ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize2);
        properties[name] = new PropertyInfoRecord(
          name,
          STRING,
          !1,
          attributeName,
          null,
          !1,
          !1
        );
      }), [
        "xlink:actuate",
        "xlink:arcrole",
        "xlink:role",
        "xlink:show",
        "xlink:title",
        "xlink:type"
      ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize2);
        properties[name] = new PropertyInfoRecord(
          name,
          STRING,
          !1,
          attributeName,
          "http://www.w3.org/1999/xlink",
          !1,
          !1
        );
      }), [
        "xml:base",
        "xml:lang",
        "xml:space"
      ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize2);
        properties[name] = new PropertyInfoRecord(
          name,
          STRING,
          !1,
          attributeName,
          "http://www.w3.org/XML/1998/namespace",
          !1,
          !1
        );
      }), ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
        properties[attributeName] = new PropertyInfoRecord(
          attributeName,
          STRING,
          !1,
          attributeName.toLowerCase(),
          null,
          !1,
          !1
        );
      });
      var xlinkHref = "xlinkHref";
      properties[xlinkHref] = new PropertyInfoRecord(
        "xlinkHref",
        STRING,
        !1,
        "xlink:href",
        "http://www.w3.org/1999/xlink",
        !0,
        !1
      ), ["src", "href", "action", "formAction"].forEach(function(attributeName) {
        properties[attributeName] = new PropertyInfoRecord(
          attributeName,
          STRING,
          !1,
          attributeName.toLowerCase(),
          null,
          !0,
          !0
        );
      });
      var isUnitlessNumber = {
        animationIterationCount: !0,
        aspectRatio: !0,
        borderImageOutset: !0,
        borderImageSlice: !0,
        borderImageWidth: !0,
        boxFlex: !0,
        boxFlexGroup: !0,
        boxOrdinalGroup: !0,
        columnCount: !0,
        columns: !0,
        flex: !0,
        flexGrow: !0,
        flexPositive: !0,
        flexShrink: !0,
        flexNegative: !0,
        flexOrder: !0,
        gridArea: !0,
        gridRow: !0,
        gridRowEnd: !0,
        gridRowSpan: !0,
        gridRowStart: !0,
        gridColumn: !0,
        gridColumnEnd: !0,
        gridColumnSpan: !0,
        gridColumnStart: !0,
        fontWeight: !0,
        lineClamp: !0,
        lineHeight: !0,
        opacity: !0,
        order: !0,
        orphans: !0,
        tabSize: !0,
        widows: !0,
        zIndex: !0,
        zoom: !0,
        fillOpacity: !0,
        floodOpacity: !0,
        stopOpacity: !0,
        strokeDasharray: !0,
        strokeDashoffset: !0,
        strokeMiterlimit: !0,
        strokeOpacity: !0,
        strokeWidth: !0
      };
      function prefixKey(prefix2, key2) {
        return prefix2 + key2.charAt(0).toUpperCase() + key2.substring(1);
      }
      var prefixes = ["Webkit", "ms", "Moz", "O"];
      Object.keys(isUnitlessNumber).forEach(function(prop) {
        prefixes.forEach(function(prefix2) {
          isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];
        });
      });
      var hasReadOnlyValue = {
        button: !0,
        checkbox: !0,
        image: !0,
        hidden: !0,
        radio: !0,
        reset: !0,
        submit: !0
      };
      function checkControlledValueProps(tagName, props) {
        hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null || error2("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), props.onChange || props.readOnly || props.disabled || props.checked == null || error2("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
      }
      function isCustomComponent(tagName, props) {
        if (tagName.indexOf("-") === -1)
          return typeof props.is == "string";
        switch (tagName) {
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return !1;
          default:
            return !0;
        }
      }
      var ariaProperties = {
        "aria-current": 0,
        "aria-description": 0,
        "aria-details": 0,
        "aria-disabled": 0,
        "aria-hidden": 0,
        "aria-invalid": 0,
        "aria-keyshortcuts": 0,
        "aria-label": 0,
        "aria-roledescription": 0,
        "aria-autocomplete": 0,
        "aria-checked": 0,
        "aria-expanded": 0,
        "aria-haspopup": 0,
        "aria-level": 0,
        "aria-modal": 0,
        "aria-multiline": 0,
        "aria-multiselectable": 0,
        "aria-orientation": 0,
        "aria-placeholder": 0,
        "aria-pressed": 0,
        "aria-readonly": 0,
        "aria-required": 0,
        "aria-selected": 0,
        "aria-sort": 0,
        "aria-valuemax": 0,
        "aria-valuemin": 0,
        "aria-valuenow": 0,
        "aria-valuetext": 0,
        "aria-atomic": 0,
        "aria-busy": 0,
        "aria-live": 0,
        "aria-relevant": 0,
        "aria-dropeffect": 0,
        "aria-grabbed": 0,
        "aria-activedescendant": 0,
        "aria-colcount": 0,
        "aria-colindex": 0,
        "aria-colspan": 0,
        "aria-controls": 0,
        "aria-describedby": 0,
        "aria-errormessage": 0,
        "aria-flowto": 0,
        "aria-labelledby": 0,
        "aria-owns": 0,
        "aria-posinset": 0,
        "aria-rowcount": 0,
        "aria-rowindex": 0,
        "aria-rowspan": 0,
        "aria-setsize": 0
      }, warnedProperties = {}, rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$"), rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
      function validateProperty(tagName, name) {
        {
          if (hasOwnProperty2.call(warnedProperties, name) && warnedProperties[name])
            return !0;
          if (rARIACamel.test(name)) {
            var ariaName = "aria-" + name.slice(4).toLowerCase(), correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
            if (correctName == null)
              return error2("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name), warnedProperties[name] = !0, !0;
            if (name !== correctName)
              return error2("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, correctName), warnedProperties[name] = !0, !0;
          }
          if (rARIA.test(name)) {
            var lowerCasedName = name.toLowerCase(), standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
            if (standardName == null)
              return warnedProperties[name] = !0, !1;
            if (name !== standardName)
              return error2("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, standardName), warnedProperties[name] = !0, !0;
          }
        }
        return !0;
      }
      function warnInvalidARIAProps(type2, props) {
        {
          var invalidProps = [];
          for (var key2 in props) {
            var isValid = validateProperty(type2, key2);
            isValid || invalidProps.push(key2);
          }
          var unknownPropString = invalidProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          invalidProps.length === 1 ? error2("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type2) : invalidProps.length > 1 && error2("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type2);
        }
      }
      function validateProperties(type2, props) {
        isCustomComponent(type2, props) || warnInvalidARIAProps(type2, props);
      }
      var didWarnValueNull = !1;
      function validateProperties$1(type2, props) {
        {
          if (type2 !== "input" && type2 !== "textarea" && type2 !== "select")
            return;
          props != null && props.value === null && !didWarnValueNull && (didWarnValueNull = !0, type2 === "select" && props.multiple ? error2("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type2) : error2("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type2));
        }
      }
      var possibleStandardNames = {
        accept: "accept",
        acceptcharset: "acceptCharset",
        "accept-charset": "acceptCharset",
        accesskey: "accessKey",
        action: "action",
        allowfullscreen: "allowFullScreen",
        alt: "alt",
        as: "as",
        async: "async",
        autocapitalize: "autoCapitalize",
        autocomplete: "autoComplete",
        autocorrect: "autoCorrect",
        autofocus: "autoFocus",
        autoplay: "autoPlay",
        autosave: "autoSave",
        capture: "capture",
        cellpadding: "cellPadding",
        cellspacing: "cellSpacing",
        challenge: "challenge",
        charset: "charSet",
        checked: "checked",
        children: "children",
        cite: "cite",
        class: "className",
        classid: "classID",
        classname: "className",
        cols: "cols",
        colspan: "colSpan",
        content: "content",
        contenteditable: "contentEditable",
        contextmenu: "contextMenu",
        controls: "controls",
        controlslist: "controlsList",
        coords: "coords",
        crossorigin: "crossOrigin",
        dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
        data: "data",
        datetime: "dateTime",
        default: "default",
        defaultchecked: "defaultChecked",
        defaultvalue: "defaultValue",
        defer: "defer",
        dir: "dir",
        disabled: "disabled",
        disablepictureinpicture: "disablePictureInPicture",
        disableremoteplayback: "disableRemotePlayback",
        download: "download",
        draggable: "draggable",
        enctype: "encType",
        enterkeyhint: "enterKeyHint",
        for: "htmlFor",
        form: "form",
        formmethod: "formMethod",
        formaction: "formAction",
        formenctype: "formEncType",
        formnovalidate: "formNoValidate",
        formtarget: "formTarget",
        frameborder: "frameBorder",
        headers: "headers",
        height: "height",
        hidden: "hidden",
        high: "high",
        href: "href",
        hreflang: "hrefLang",
        htmlfor: "htmlFor",
        httpequiv: "httpEquiv",
        "http-equiv": "httpEquiv",
        icon: "icon",
        id: "id",
        imagesizes: "imageSizes",
        imagesrcset: "imageSrcSet",
        innerhtml: "innerHTML",
        inputmode: "inputMode",
        integrity: "integrity",
        is: "is",
        itemid: "itemID",
        itemprop: "itemProp",
        itemref: "itemRef",
        itemscope: "itemScope",
        itemtype: "itemType",
        keyparams: "keyParams",
        keytype: "keyType",
        kind: "kind",
        label: "label",
        lang: "lang",
        list: "list",
        loop: "loop",
        low: "low",
        manifest: "manifest",
        marginwidth: "marginWidth",
        marginheight: "marginHeight",
        max: "max",
        maxlength: "maxLength",
        media: "media",
        mediagroup: "mediaGroup",
        method: "method",
        min: "min",
        minlength: "minLength",
        multiple: "multiple",
        muted: "muted",
        name: "name",
        nomodule: "noModule",
        nonce: "nonce",
        novalidate: "noValidate",
        open: "open",
        optimum: "optimum",
        pattern: "pattern",
        placeholder: "placeholder",
        playsinline: "playsInline",
        poster: "poster",
        preload: "preload",
        profile: "profile",
        radiogroup: "radioGroup",
        readonly: "readOnly",
        referrerpolicy: "referrerPolicy",
        rel: "rel",
        required: "required",
        reversed: "reversed",
        role: "role",
        rows: "rows",
        rowspan: "rowSpan",
        sandbox: "sandbox",
        scope: "scope",
        scoped: "scoped",
        scrolling: "scrolling",
        seamless: "seamless",
        selected: "selected",
        shape: "shape",
        size: "size",
        sizes: "sizes",
        span: "span",
        spellcheck: "spellCheck",
        src: "src",
        srcdoc: "srcDoc",
        srclang: "srcLang",
        srcset: "srcSet",
        start: "start",
        step: "step",
        style: "style",
        summary: "summary",
        tabindex: "tabIndex",
        target: "target",
        title: "title",
        type: "type",
        usemap: "useMap",
        value: "value",
        width: "width",
        wmode: "wmode",
        wrap: "wrap",
        about: "about",
        accentheight: "accentHeight",
        "accent-height": "accentHeight",
        accumulate: "accumulate",
        additive: "additive",
        alignmentbaseline: "alignmentBaseline",
        "alignment-baseline": "alignmentBaseline",
        allowreorder: "allowReorder",
        alphabetic: "alphabetic",
        amplitude: "amplitude",
        arabicform: "arabicForm",
        "arabic-form": "arabicForm",
        ascent: "ascent",
        attributename: "attributeName",
        attributetype: "attributeType",
        autoreverse: "autoReverse",
        azimuth: "azimuth",
        basefrequency: "baseFrequency",
        baselineshift: "baselineShift",
        "baseline-shift": "baselineShift",
        baseprofile: "baseProfile",
        bbox: "bbox",
        begin: "begin",
        bias: "bias",
        by: "by",
        calcmode: "calcMode",
        capheight: "capHeight",
        "cap-height": "capHeight",
        clip: "clip",
        clippath: "clipPath",
        "clip-path": "clipPath",
        clippathunits: "clipPathUnits",
        cliprule: "clipRule",
        "clip-rule": "clipRule",
        color: "color",
        colorinterpolation: "colorInterpolation",
        "color-interpolation": "colorInterpolation",
        colorinterpolationfilters: "colorInterpolationFilters",
        "color-interpolation-filters": "colorInterpolationFilters",
        colorprofile: "colorProfile",
        "color-profile": "colorProfile",
        colorrendering: "colorRendering",
        "color-rendering": "colorRendering",
        contentscripttype: "contentScriptType",
        contentstyletype: "contentStyleType",
        cursor: "cursor",
        cx: "cx",
        cy: "cy",
        d: "d",
        datatype: "datatype",
        decelerate: "decelerate",
        descent: "descent",
        diffuseconstant: "diffuseConstant",
        direction: "direction",
        display: "display",
        divisor: "divisor",
        dominantbaseline: "dominantBaseline",
        "dominant-baseline": "dominantBaseline",
        dur: "dur",
        dx: "dx",
        dy: "dy",
        edgemode: "edgeMode",
        elevation: "elevation",
        enablebackground: "enableBackground",
        "enable-background": "enableBackground",
        end: "end",
        exponent: "exponent",
        externalresourcesrequired: "externalResourcesRequired",
        fill: "fill",
        fillopacity: "fillOpacity",
        "fill-opacity": "fillOpacity",
        fillrule: "fillRule",
        "fill-rule": "fillRule",
        filter: "filter",
        filterres: "filterRes",
        filterunits: "filterUnits",
        floodopacity: "floodOpacity",
        "flood-opacity": "floodOpacity",
        floodcolor: "floodColor",
        "flood-color": "floodColor",
        focusable: "focusable",
        fontfamily: "fontFamily",
        "font-family": "fontFamily",
        fontsize: "fontSize",
        "font-size": "fontSize",
        fontsizeadjust: "fontSizeAdjust",
        "font-size-adjust": "fontSizeAdjust",
        fontstretch: "fontStretch",
        "font-stretch": "fontStretch",
        fontstyle: "fontStyle",
        "font-style": "fontStyle",
        fontvariant: "fontVariant",
        "font-variant": "fontVariant",
        fontweight: "fontWeight",
        "font-weight": "fontWeight",
        format: "format",
        from: "from",
        fx: "fx",
        fy: "fy",
        g1: "g1",
        g2: "g2",
        glyphname: "glyphName",
        "glyph-name": "glyphName",
        glyphorientationhorizontal: "glyphOrientationHorizontal",
        "glyph-orientation-horizontal": "glyphOrientationHorizontal",
        glyphorientationvertical: "glyphOrientationVertical",
        "glyph-orientation-vertical": "glyphOrientationVertical",
        glyphref: "glyphRef",
        gradienttransform: "gradientTransform",
        gradientunits: "gradientUnits",
        hanging: "hanging",
        horizadvx: "horizAdvX",
        "horiz-adv-x": "horizAdvX",
        horizoriginx: "horizOriginX",
        "horiz-origin-x": "horizOriginX",
        ideographic: "ideographic",
        imagerendering: "imageRendering",
        "image-rendering": "imageRendering",
        in2: "in2",
        in: "in",
        inlist: "inlist",
        intercept: "intercept",
        k1: "k1",
        k2: "k2",
        k3: "k3",
        k4: "k4",
        k: "k",
        kernelmatrix: "kernelMatrix",
        kernelunitlength: "kernelUnitLength",
        kerning: "kerning",
        keypoints: "keyPoints",
        keysplines: "keySplines",
        keytimes: "keyTimes",
        lengthadjust: "lengthAdjust",
        letterspacing: "letterSpacing",
        "letter-spacing": "letterSpacing",
        lightingcolor: "lightingColor",
        "lighting-color": "lightingColor",
        limitingconeangle: "limitingConeAngle",
        local: "local",
        markerend: "markerEnd",
        "marker-end": "markerEnd",
        markerheight: "markerHeight",
        markermid: "markerMid",
        "marker-mid": "markerMid",
        markerstart: "markerStart",
        "marker-start": "markerStart",
        markerunits: "markerUnits",
        markerwidth: "markerWidth",
        mask: "mask",
        maskcontentunits: "maskContentUnits",
        maskunits: "maskUnits",
        mathematical: "mathematical",
        mode: "mode",
        numoctaves: "numOctaves",
        offset: "offset",
        opacity: "opacity",
        operator: "operator",
        order: "order",
        orient: "orient",
        orientation: "orientation",
        origin: "origin",
        overflow: "overflow",
        overlineposition: "overlinePosition",
        "overline-position": "overlinePosition",
        overlinethickness: "overlineThickness",
        "overline-thickness": "overlineThickness",
        paintorder: "paintOrder",
        "paint-order": "paintOrder",
        panose1: "panose1",
        "panose-1": "panose1",
        pathlength: "pathLength",
        patterncontentunits: "patternContentUnits",
        patterntransform: "patternTransform",
        patternunits: "patternUnits",
        pointerevents: "pointerEvents",
        "pointer-events": "pointerEvents",
        points: "points",
        pointsatx: "pointsAtX",
        pointsaty: "pointsAtY",
        pointsatz: "pointsAtZ",
        prefix: "prefix",
        preservealpha: "preserveAlpha",
        preserveaspectratio: "preserveAspectRatio",
        primitiveunits: "primitiveUnits",
        property: "property",
        r: "r",
        radius: "radius",
        refx: "refX",
        refy: "refY",
        renderingintent: "renderingIntent",
        "rendering-intent": "renderingIntent",
        repeatcount: "repeatCount",
        repeatdur: "repeatDur",
        requiredextensions: "requiredExtensions",
        requiredfeatures: "requiredFeatures",
        resource: "resource",
        restart: "restart",
        result: "result",
        results: "results",
        rotate: "rotate",
        rx: "rx",
        ry: "ry",
        scale: "scale",
        security: "security",
        seed: "seed",
        shaperendering: "shapeRendering",
        "shape-rendering": "shapeRendering",
        slope: "slope",
        spacing: "spacing",
        specularconstant: "specularConstant",
        specularexponent: "specularExponent",
        speed: "speed",
        spreadmethod: "spreadMethod",
        startoffset: "startOffset",
        stddeviation: "stdDeviation",
        stemh: "stemh",
        stemv: "stemv",
        stitchtiles: "stitchTiles",
        stopcolor: "stopColor",
        "stop-color": "stopColor",
        stopopacity: "stopOpacity",
        "stop-opacity": "stopOpacity",
        strikethroughposition: "strikethroughPosition",
        "strikethrough-position": "strikethroughPosition",
        strikethroughthickness: "strikethroughThickness",
        "strikethrough-thickness": "strikethroughThickness",
        string: "string",
        stroke: "stroke",
        strokedasharray: "strokeDasharray",
        "stroke-dasharray": "strokeDasharray",
        strokedashoffset: "strokeDashoffset",
        "stroke-dashoffset": "strokeDashoffset",
        strokelinecap: "strokeLinecap",
        "stroke-linecap": "strokeLinecap",
        strokelinejoin: "strokeLinejoin",
        "stroke-linejoin": "strokeLinejoin",
        strokemiterlimit: "strokeMiterlimit",
        "stroke-miterlimit": "strokeMiterlimit",
        strokewidth: "strokeWidth",
        "stroke-width": "strokeWidth",
        strokeopacity: "strokeOpacity",
        "stroke-opacity": "strokeOpacity",
        suppresscontenteditablewarning: "suppressContentEditableWarning",
        suppresshydrationwarning: "suppressHydrationWarning",
        surfacescale: "surfaceScale",
        systemlanguage: "systemLanguage",
        tablevalues: "tableValues",
        targetx: "targetX",
        targety: "targetY",
        textanchor: "textAnchor",
        "text-anchor": "textAnchor",
        textdecoration: "textDecoration",
        "text-decoration": "textDecoration",
        textlength: "textLength",
        textrendering: "textRendering",
        "text-rendering": "textRendering",
        to: "to",
        transform: "transform",
        typeof: "typeof",
        u1: "u1",
        u2: "u2",
        underlineposition: "underlinePosition",
        "underline-position": "underlinePosition",
        underlinethickness: "underlineThickness",
        "underline-thickness": "underlineThickness",
        unicode: "unicode",
        unicodebidi: "unicodeBidi",
        "unicode-bidi": "unicodeBidi",
        unicoderange: "unicodeRange",
        "unicode-range": "unicodeRange",
        unitsperem: "unitsPerEm",
        "units-per-em": "unitsPerEm",
        unselectable: "unselectable",
        valphabetic: "vAlphabetic",
        "v-alphabetic": "vAlphabetic",
        values: "values",
        vectoreffect: "vectorEffect",
        "vector-effect": "vectorEffect",
        version: "version",
        vertadvy: "vertAdvY",
        "vert-adv-y": "vertAdvY",
        vertoriginx: "vertOriginX",
        "vert-origin-x": "vertOriginX",
        vertoriginy: "vertOriginY",
        "vert-origin-y": "vertOriginY",
        vhanging: "vHanging",
        "v-hanging": "vHanging",
        videographic: "vIdeographic",
        "v-ideographic": "vIdeographic",
        viewbox: "viewBox",
        viewtarget: "viewTarget",
        visibility: "visibility",
        vmathematical: "vMathematical",
        "v-mathematical": "vMathematical",
        vocab: "vocab",
        widths: "widths",
        wordspacing: "wordSpacing",
        "word-spacing": "wordSpacing",
        writingmode: "writingMode",
        "writing-mode": "writingMode",
        x1: "x1",
        x2: "x2",
        x: "x",
        xchannelselector: "xChannelSelector",
        xheight: "xHeight",
        "x-height": "xHeight",
        xlinkactuate: "xlinkActuate",
        "xlink:actuate": "xlinkActuate",
        xlinkarcrole: "xlinkArcrole",
        "xlink:arcrole": "xlinkArcrole",
        xlinkhref: "xlinkHref",
        "xlink:href": "xlinkHref",
        xlinkrole: "xlinkRole",
        "xlink:role": "xlinkRole",
        xlinkshow: "xlinkShow",
        "xlink:show": "xlinkShow",
        xlinktitle: "xlinkTitle",
        "xlink:title": "xlinkTitle",
        xlinktype: "xlinkType",
        "xlink:type": "xlinkType",
        xmlbase: "xmlBase",
        "xml:base": "xmlBase",
        xmllang: "xmlLang",
        "xml:lang": "xmlLang",
        xmlns: "xmlns",
        "xml:space": "xmlSpace",
        xmlnsxlink: "xmlnsXlink",
        "xmlns:xlink": "xmlnsXlink",
        xmlspace: "xmlSpace",
        y1: "y1",
        y2: "y2",
        y: "y",
        ychannelselector: "yChannelSelector",
        z: "z",
        zoomandpan: "zoomAndPan"
      }, validateProperty$1 = function() {
      };
      {
        var warnedProperties$1 = {}, EVENT_NAME_REGEX = /^on./, INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/, rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$"), rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
        validateProperty$1 = function(tagName, name, value2, eventRegistry) {
          if (hasOwnProperty2.call(warnedProperties$1, name) && warnedProperties$1[name])
            return !0;
          var lowerCasedName = name.toLowerCase();
          if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout")
            return error2("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), warnedProperties$1[name] = !0, !0;
          if (eventRegistry != null) {
            var registrationNameDependencies = eventRegistry.registrationNameDependencies, possibleRegistrationNames = eventRegistry.possibleRegistrationNames;
            if (registrationNameDependencies.hasOwnProperty(name))
              return !0;
            var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
            if (registrationName != null)
              return error2("Invalid event handler property `%s`. Did you mean `%s`?", name, registrationName), warnedProperties$1[name] = !0, !0;
            if (EVENT_NAME_REGEX.test(name))
              return error2("Unknown event handler property `%s`. It will be ignored.", name), warnedProperties$1[name] = !0, !0;
          } else if (EVENT_NAME_REGEX.test(name))
            return INVALID_EVENT_NAME_REGEX.test(name) && error2("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name), warnedProperties$1[name] = !0, !0;
          if (rARIA$1.test(name) || rARIACamel$1.test(name))
            return !0;
          if (lowerCasedName === "innerhtml")
            return error2("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), warnedProperties$1[name] = !0, !0;
          if (lowerCasedName === "aria")
            return error2("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), warnedProperties$1[name] = !0, !0;
          if (lowerCasedName === "is" && value2 !== null && value2 !== void 0 && typeof value2 != "string")
            return error2("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value2), warnedProperties$1[name] = !0, !0;
          if (typeof value2 == "number" && isNaN(value2))
            return error2("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name), warnedProperties$1[name] = !0, !0;
          var propertyInfo = getPropertyInfo(name), isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
          if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
            var standardName = possibleStandardNames[lowerCasedName];
            if (standardName !== name)
              return error2("Invalid DOM property `%s`. Did you mean `%s`?", name, standardName), warnedProperties$1[name] = !0, !0;
          } else if (!isReserved && name !== lowerCasedName)
            return error2("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName), warnedProperties$1[name] = !0, !0;
          return typeof value2 == "boolean" && shouldRemoveAttributeWithWarning(name, value2, propertyInfo, !1) ? (value2 ? error2('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value2, name, name, value2, name) : error2('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value2, name, name, value2, name, name, name), warnedProperties$1[name] = !0, !0) : isReserved ? !0 : shouldRemoveAttributeWithWarning(name, value2, propertyInfo, !1) ? (warnedProperties$1[name] = !0, !1) : ((value2 === "false" || value2 === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN && (error2("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value2, name, value2 === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value2), warnedProperties$1[name] = !0), !0);
        };
      }
      var warnUnknownProperties = function(type2, props, eventRegistry) {
        {
          var unknownProps = [];
          for (var key2 in props) {
            var isValid = validateProperty$1(type2, key2, props[key2], eventRegistry);
            isValid || unknownProps.push(key2);
          }
          var unknownPropString = unknownProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          unknownProps.length === 1 ? error2("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type2) : unknownProps.length > 1 && error2("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type2);
        }
      };
      function validateProperties$2(type2, props, eventRegistry) {
        isCustomComponent(type2, props) || warnUnknownProperties(type2, props, eventRegistry);
      }
      var warnValidStyle = function() {
      };
      {
        var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/, msPattern = /^-ms-/, hyphenPattern = /-(.)/g, badStyleValueWithSemicolonPattern = /;\s*$/, warnedStyleNames = {}, warnedStyleValues = {}, warnedForNaNValue = !1, warnedForInfinityValue = !1, camelize = function(string2) {
          return string2.replace(hyphenPattern, function(_24, character) {
            return character.toUpperCase();
          });
        }, warnHyphenatedStyleName = function(name) {
          warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name] || (warnedStyleNames[name] = !0, error2(
            "Unsupported style property %s. Did you mean %s?",
            name,
            camelize(name.replace(msPattern, "ms-"))
          ));
        }, warnBadVendoredStyleName = function(name) {
          warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name] || (warnedStyleNames[name] = !0, error2("Unsupported vendor-prefixed style property %s. Did you mean %s?", name, name.charAt(0).toUpperCase() + name.slice(1)));
        }, warnStyleValueWithSemicolon = function(name, value2) {
          warnedStyleValues.hasOwnProperty(value2) && warnedStyleValues[value2] || (warnedStyleValues[value2] = !0, error2(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name, value2.replace(badStyleValueWithSemicolonPattern, "")));
        }, warnStyleValueIsNaN = function(name, value2) {
          warnedForNaNValue || (warnedForNaNValue = !0, error2("`NaN` is an invalid value for the `%s` css style property.", name));
        }, warnStyleValueIsInfinity = function(name, value2) {
          warnedForInfinityValue || (warnedForInfinityValue = !0, error2("`Infinity` is an invalid value for the `%s` css style property.", name));
        };
        warnValidStyle = function(name, value2) {
          name.indexOf("-") > -1 ? warnHyphenatedStyleName(name) : badVendoredStyleNamePattern.test(name) ? warnBadVendoredStyleName(name) : badStyleValueWithSemicolonPattern.test(value2) && warnStyleValueWithSemicolon(name, value2), typeof value2 == "number" && (isNaN(value2) ? warnStyleValueIsNaN(name, value2) : isFinite(value2) || warnStyleValueIsInfinity(name, value2));
        };
      }
      var warnValidStyle$1 = warnValidStyle, matchHtmlRegExp = /["'&<>]/;
      function escapeHtml3(string2) {
        checkHtmlStringCoercion(string2);
        var str2 = "" + string2, match = matchHtmlRegExp.exec(str2);
        if (!match)
          return str2;
        var escape4, html = "", index2, lastIndex = 0;
        for (index2 = match.index; index2 < str2.length; index2++) {
          switch (str2.charCodeAt(index2)) {
            case 34:
              escape4 = "&quot;";
              break;
            case 38:
              escape4 = "&amp;";
              break;
            case 39:
              escape4 = "&#x27;";
              break;
            case 60:
              escape4 = "&lt;";
              break;
            case 62:
              escape4 = "&gt;";
              break;
            default:
              continue;
          }
          lastIndex !== index2 && (html += str2.substring(lastIndex, index2)), lastIndex = index2 + 1, html += escape4;
        }
        return lastIndex !== index2 ? html + str2.substring(lastIndex, index2) : html;
      }
      function escapeTextForBrowser(text) {
        return typeof text == "boolean" || typeof text == "number" ? "" + text : escapeHtml3(text);
      }
      var uppercasePattern = /([A-Z])/g, msPattern$1 = /^ms-/;
      function hyphenateStyleName(name) {
        return name.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-");
      }
      var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, didWarn = !1;
      function sanitizeURL(url) {
        !didWarn && isJavaScriptProtocol.test(url) && (didWarn = !0, error2("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url)));
      }
      var isArrayImpl = Array.isArray;
      function isArray3(a3) {
        return isArrayImpl(a3);
      }
      var startInlineScript = "<script>", endInlineScript = "</script>", startScriptSrc = '<script src="', startModuleSrc = '<script type="module" src="', endAsyncScript = '" async=""></script>';
      function escapeBootstrapScriptContent(scriptText) {
        return checkHtmlStringCoercion(scriptText), ("" + scriptText).replace(scriptRegex, scriptReplacer);
      }
      var scriptRegex = /(<\/|<)(s)(cript)/gi, scriptReplacer = function(match, prefix2, s3, suffix) {
        return "" + prefix2 + (s3 === "s" ? "\\u0073" : "\\u0053") + suffix;
      };
      function createResponseState(identifierPrefix, nonce, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {
        var idPrefix = identifierPrefix === void 0 ? "" : identifierPrefix, inlineScriptWithNonce = nonce === void 0 ? startInlineScript : '<script nonce="' + escapeTextForBrowser(nonce) + '">', bootstrapChunks = [];
        if (bootstrapScriptContent !== void 0 && bootstrapChunks.push(inlineScriptWithNonce, escapeBootstrapScriptContent(bootstrapScriptContent), endInlineScript), bootstrapScripts !== void 0)
          for (var i3 = 0; i3 < bootstrapScripts.length; i3++)
            bootstrapChunks.push(startScriptSrc, escapeTextForBrowser(bootstrapScripts[i3]), endAsyncScript);
        if (bootstrapModules !== void 0)
          for (var _i = 0; _i < bootstrapModules.length; _i++)
            bootstrapChunks.push(startModuleSrc, escapeTextForBrowser(bootstrapModules[_i]), endAsyncScript);
        return {
          bootstrapChunks,
          startInlineScript: inlineScriptWithNonce,
          placeholderPrefix: idPrefix + "P:",
          segmentPrefix: idPrefix + "S:",
          boundaryPrefix: idPrefix + "B:",
          idPrefix,
          nextSuspenseID: 0,
          sentCompleteSegmentFunction: !1,
          sentCompleteBoundaryFunction: !1,
          sentClientRenderFunction: !1
        };
      }
      var ROOT_HTML_MODE = 0, HTML_MODE = 1, SVG_MODE = 2, MATHML_MODE = 3, HTML_TABLE_MODE = 4, HTML_TABLE_BODY_MODE = 5, HTML_TABLE_ROW_MODE = 6, HTML_COLGROUP_MODE = 7;
      function createFormatContext(insertionMode, selectedValue) {
        return {
          insertionMode,
          selectedValue
        };
      }
      function getChildFormatContext(parentContext, type2, props) {
        switch (type2) {
          case "select":
            return createFormatContext(HTML_MODE, props.value != null ? props.value : props.defaultValue);
          case "svg":
            return createFormatContext(SVG_MODE, null);
          case "math":
            return createFormatContext(MATHML_MODE, null);
          case "foreignObject":
            return createFormatContext(HTML_MODE, null);
          case "table":
            return createFormatContext(HTML_TABLE_MODE, null);
          case "thead":
          case "tbody":
          case "tfoot":
            return createFormatContext(HTML_TABLE_BODY_MODE, null);
          case "colgroup":
            return createFormatContext(HTML_COLGROUP_MODE, null);
          case "tr":
            return createFormatContext(HTML_TABLE_ROW_MODE, null);
        }
        return parentContext.insertionMode >= HTML_TABLE_MODE || parentContext.insertionMode === ROOT_HTML_MODE ? createFormatContext(HTML_MODE, null) : parentContext;
      }
      var UNINITIALIZED_SUSPENSE_BOUNDARY_ID = null;
      function assignSuspenseBoundaryID(responseState) {
        var generatedID = responseState.nextSuspenseID++;
        return responseState.boundaryPrefix + generatedID.toString(16);
      }
      function makeId(responseState, treeId, localId) {
        var idPrefix = responseState.idPrefix, id4 = ":" + idPrefix + "R" + treeId;
        return localId > 0 && (id4 += "H" + localId.toString(32)), id4 + ":";
      }
      function encodeHTMLTextNode(text) {
        return escapeTextForBrowser(text);
      }
      var textSeparator = "<!-- -->";
      function pushTextInstance(target, text, responseState, textEmbedded) {
        return text === "" ? textEmbedded : (textEmbedded && target.push(textSeparator), target.push(encodeHTMLTextNode(text)), !0);
      }
      function pushSegmentFinale(target, responseState, lastPushedText, textEmbedded) {
        lastPushedText && textEmbedded && target.push(textSeparator);
      }
      var styleNameCache = /* @__PURE__ */ new Map();
      function processStyleName(styleName) {
        var chunk = styleNameCache.get(styleName);
        if (chunk !== void 0)
          return chunk;
        var result2 = escapeTextForBrowser(hyphenateStyleName(styleName));
        return styleNameCache.set(styleName, result2), result2;
      }
      var styleAttributeStart = ' style="', styleAssign = ":", styleSeparator = ";";
      function pushStyle(target, responseState, style) {
        if (typeof style != "object")
          throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
        var isFirst = !0;
        for (var styleName in style)
          if (!!hasOwnProperty2.call(style, styleName)) {
            var styleValue = style[styleName];
            if (!(styleValue == null || typeof styleValue == "boolean" || styleValue === "")) {
              var nameChunk = void 0, valueChunk = void 0, isCustomProperty = styleName.indexOf("--") === 0;
              isCustomProperty ? (nameChunk = escapeTextForBrowser(styleName), checkCSSPropertyStringCoercion(styleValue, styleName), valueChunk = escapeTextForBrowser(("" + styleValue).trim())) : (warnValidStyle$1(styleName, styleValue), nameChunk = processStyleName(styleName), typeof styleValue == "number" ? styleValue !== 0 && !hasOwnProperty2.call(isUnitlessNumber, styleName) ? valueChunk = styleValue + "px" : valueChunk = "" + styleValue : (checkCSSPropertyStringCoercion(styleValue, styleName), valueChunk = escapeTextForBrowser(("" + styleValue).trim()))), isFirst ? (isFirst = !1, target.push(styleAttributeStart, nameChunk, styleAssign, valueChunk)) : target.push(styleSeparator, nameChunk, styleAssign, valueChunk);
            }
          }
        isFirst || target.push(attributeEnd);
      }
      var attributeSeparator = " ", attributeAssign = '="', attributeEnd = '"', attributeEmptyString = '=""';
      function pushAttribute(target, responseState, name, value2) {
        switch (name) {
          case "style": {
            pushStyle(target, responseState, value2);
            return;
          }
          case "defaultValue":
          case "defaultChecked":
          case "innerHTML":
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
            return;
        }
        if (!(name.length > 2 && (name[0] === "o" || name[0] === "O") && (name[1] === "n" || name[1] === "N"))) {
          var propertyInfo = getPropertyInfo(name);
          if (propertyInfo !== null) {
            switch (typeof value2) {
              case "function":
              case "symbol":
                return;
              case "boolean":
                if (!propertyInfo.acceptsBooleans)
                  return;
            }
            var attributeName = propertyInfo.attributeName, attributeNameChunk = attributeName;
            switch (propertyInfo.type) {
              case BOOLEAN:
                value2 && target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
                return;
              case OVERLOADED_BOOLEAN:
                value2 === !0 ? target.push(attributeSeparator, attributeNameChunk, attributeEmptyString) : value2 === !1 || target.push(attributeSeparator, attributeNameChunk, attributeAssign, escapeTextForBrowser(value2), attributeEnd);
                return;
              case NUMERIC:
                isNaN(value2) || target.push(attributeSeparator, attributeNameChunk, attributeAssign, escapeTextForBrowser(value2), attributeEnd);
                break;
              case POSITIVE_NUMERIC:
                !isNaN(value2) && value2 >= 1 && target.push(attributeSeparator, attributeNameChunk, attributeAssign, escapeTextForBrowser(value2), attributeEnd);
                break;
              default:
                propertyInfo.sanitizeURL && (checkAttributeStringCoercion(value2, attributeName), value2 = "" + value2, sanitizeURL(value2)), target.push(attributeSeparator, attributeNameChunk, attributeAssign, escapeTextForBrowser(value2), attributeEnd);
            }
          } else if (isAttributeNameSafe(name)) {
            switch (typeof value2) {
              case "function":
              case "symbol":
                return;
              case "boolean": {
                var prefix2 = name.toLowerCase().slice(0, 5);
                if (prefix2 !== "data-" && prefix2 !== "aria-")
                  return;
              }
            }
            target.push(attributeSeparator, name, attributeAssign, escapeTextForBrowser(value2), attributeEnd);
          }
        }
      }
      var endOfStartTag = ">", endOfStartTagSelfClosing = "/>";
      function pushInnerHTML(target, innerHTML, children) {
        if (innerHTML != null) {
          if (children != null)
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          if (typeof innerHTML != "object" || !("__html" in innerHTML))
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
          var html = innerHTML.__html;
          html != null && (checkHtmlStringCoercion(html), target.push("" + html));
        }
      }
      var didWarnDefaultInputValue = !1, didWarnDefaultChecked = !1, didWarnDefaultSelectValue = !1, didWarnDefaultTextareaValue = !1, didWarnInvalidOptionChildren = !1, didWarnInvalidOptionInnerHTML = !1, didWarnSelectedSetOnOption = !1;
      function checkSelectProp(props, propName) {
        {
          var value2 = props[propName];
          if (value2 != null) {
            var array = isArray3(value2);
            props.multiple && !array ? error2("The `%s` prop supplied to <select> must be an array if `multiple` is true.", propName) : !props.multiple && array && error2("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", propName);
          }
        }
      }
      function pushStartSelect(target, props, responseState) {
        checkControlledValueProps("select", props), checkSelectProp(props, "value"), checkSelectProp(props, "defaultValue"), props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultSelectValue && (error2("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), didWarnDefaultSelectValue = !0), target.push(startChunkForTag("select"));
        var children = null, innerHTML = null;
        for (var propKey in props)
          if (hasOwnProperty2.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null)
              continue;
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              case "defaultValue":
              case "value":
                break;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        return target.push(endOfStartTag), pushInnerHTML(target, innerHTML, children), children;
      }
      function flattenOptionChildren(children) {
        var content = "";
        return React17.Children.forEach(children, function(child) {
          child != null && (content += child, !didWarnInvalidOptionChildren && typeof child != "string" && typeof child != "number" && (didWarnInvalidOptionChildren = !0, error2("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
        }), content;
      }
      var selectedMarkerAttribute = ' selected=""';
      function pushStartOption(target, props, responseState, formatContext) {
        var selectedValue = formatContext.selectedValue;
        target.push(startChunkForTag("option"));
        var children = null, value2 = null, selected = null, innerHTML = null;
        for (var propKey in props)
          if (hasOwnProperty2.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null)
              continue;
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "selected":
                selected = propValue, didWarnSelectedSetOnOption || (error2("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), didWarnSelectedSetOnOption = !0);
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              case "value":
                value2 = propValue;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        if (selectedValue != null) {
          var stringValue;
          if (value2 !== null ? (checkAttributeStringCoercion(value2, "value"), stringValue = "" + value2) : (innerHTML !== null && (didWarnInvalidOptionInnerHTML || (didWarnInvalidOptionInnerHTML = !0, error2("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."))), stringValue = flattenOptionChildren(children)), isArray3(selectedValue))
            for (var i3 = 0; i3 < selectedValue.length; i3++) {
              checkAttributeStringCoercion(selectedValue[i3], "value");
              var v2 = "" + selectedValue[i3];
              if (v2 === stringValue) {
                target.push(selectedMarkerAttribute);
                break;
              }
            }
          else
            checkAttributeStringCoercion(selectedValue, "select.value"), "" + selectedValue === stringValue && target.push(selectedMarkerAttribute);
        } else
          selected && target.push(selectedMarkerAttribute);
        return target.push(endOfStartTag), pushInnerHTML(target, innerHTML, children), children;
      }
      function pushInput(target, props, responseState) {
        checkControlledValueProps("input", props), props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnDefaultChecked && (error2("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type), didWarnDefaultChecked = !0), props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultInputValue && (error2("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type), didWarnDefaultInputValue = !0), target.push(startChunkForTag("input"));
        var value2 = null, defaultValue = null, checked2 = null, defaultChecked = null;
        for (var propKey in props)
          if (hasOwnProperty2.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null)
              continue;
            switch (propKey) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              case "defaultChecked":
                defaultChecked = propValue;
                break;
              case "defaultValue":
                defaultValue = propValue;
                break;
              case "checked":
                checked2 = propValue;
                break;
              case "value":
                value2 = propValue;
                break;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        return checked2 !== null ? pushAttribute(target, responseState, "checked", checked2) : defaultChecked !== null && pushAttribute(target, responseState, "checked", defaultChecked), value2 !== null ? pushAttribute(target, responseState, "value", value2) : defaultValue !== null && pushAttribute(target, responseState, "value", defaultValue), target.push(endOfStartTagSelfClosing), null;
      }
      function pushStartTextArea(target, props, responseState) {
        checkControlledValueProps("textarea", props), props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultTextareaValue && (error2("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components"), didWarnDefaultTextareaValue = !0), target.push(startChunkForTag("textarea"));
        var value2 = null, defaultValue = null, children = null;
        for (var propKey in props)
          if (hasOwnProperty2.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null)
              continue;
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "value":
                value2 = propValue;
                break;
              case "defaultValue":
                defaultValue = propValue;
                break;
              case "dangerouslySetInnerHTML":
                throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        if (value2 === null && defaultValue !== null && (value2 = defaultValue), target.push(endOfStartTag), children != null) {
          if (error2("Use the `defaultValue` or `value` props instead of setting children on <textarea>."), value2 != null)
            throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
          if (isArray3(children)) {
            if (children.length > 1)
              throw new Error("<textarea> can only have at most one child.");
            checkHtmlStringCoercion(children[0]), value2 = "" + children[0];
          }
          checkHtmlStringCoercion(children), value2 = "" + children;
        }
        return typeof value2 == "string" && value2[0] === `
` && target.push(leadingNewline), value2 !== null && (checkAttributeStringCoercion(value2, "value"), target.push(encodeHTMLTextNode("" + value2))), null;
      }
      function pushSelfClosing(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        for (var propKey in props)
          if (hasOwnProperty2.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null)
              continue;
            switch (propKey) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw new Error(tag + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        return target.push(endOfStartTagSelfClosing), null;
      }
      function pushStartMenuItem(target, props, responseState) {
        target.push(startChunkForTag("menuitem"));
        for (var propKey in props)
          if (hasOwnProperty2.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null)
              continue;
            switch (propKey) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        return target.push(endOfStartTag), null;
      }
      function pushStartTitle(target, props, responseState) {
        target.push(startChunkForTag("title"));
        var children = null;
        for (var propKey in props)
          if (hasOwnProperty2.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null)
              continue;
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        target.push(endOfStartTag);
        {
          var child = Array.isArray(children) && children.length < 2 ? children[0] || null : children;
          Array.isArray(children) && children.length > 1 ? error2("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : child != null && child.$$typeof != null ? error2("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : child != null && typeof child != "string" && typeof child != "number" && error2("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
        }
        return children;
      }
      function pushStartGenericElement(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        var children = null, innerHTML = null;
        for (var propKey in props)
          if (hasOwnProperty2.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null)
              continue;
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        return target.push(endOfStartTag), pushInnerHTML(target, innerHTML, children), typeof children == "string" ? (target.push(encodeHTMLTextNode(children)), null) : children;
      }
      function pushStartCustomElement(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        var children = null, innerHTML = null;
        for (var propKey in props)
          if (hasOwnProperty2.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null)
              continue;
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              case "style":
                pushStyle(target, responseState, propValue);
                break;
              case "suppressContentEditableWarning":
              case "suppressHydrationWarning":
                break;
              default:
                isAttributeNameSafe(propKey) && typeof propValue != "function" && typeof propValue != "symbol" && target.push(attributeSeparator, propKey, attributeAssign, escapeTextForBrowser(propValue), attributeEnd);
                break;
            }
          }
        return target.push(endOfStartTag), pushInnerHTML(target, innerHTML, children), children;
      }
      var leadingNewline = `
`;
      function pushStartPreformattedElement(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        var children = null, innerHTML = null;
        for (var propKey in props)
          if (hasOwnProperty2.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null)
              continue;
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        if (target.push(endOfStartTag), innerHTML != null) {
          if (children != null)
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          if (typeof innerHTML != "object" || !("__html" in innerHTML))
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
          var html = innerHTML.__html;
          html != null && (typeof html == "string" && html.length > 0 && html[0] === `
` ? target.push(leadingNewline, html) : (checkHtmlStringCoercion(html), target.push("" + html)));
        }
        return typeof children == "string" && children[0] === `
` && target.push(leadingNewline), children;
      }
      var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, validatedTagCache = /* @__PURE__ */ new Map();
      function startChunkForTag(tag) {
        var tagStartChunk = validatedTagCache.get(tag);
        if (tagStartChunk === void 0) {
          if (!VALID_TAG_REGEX.test(tag))
            throw new Error("Invalid tag: " + tag);
          tagStartChunk = "<" + tag, validatedTagCache.set(tag, tagStartChunk);
        }
        return tagStartChunk;
      }
      var DOCTYPE = "<!DOCTYPE html>";
      function pushStartInstance(target, type2, props, responseState, formatContext) {
        switch (validateProperties(type2, props), validateProperties$1(type2, props), validateProperties$2(type2, props, null), !props.suppressContentEditableWarning && props.contentEditable && props.children != null && error2("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), formatContext.insertionMode !== SVG_MODE && formatContext.insertionMode !== MATHML_MODE && type2.indexOf("-") === -1 && typeof props.is != "string" && type2.toLowerCase() !== type2 && error2("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type2), type2) {
          case "select":
            return pushStartSelect(target, props, responseState);
          case "option":
            return pushStartOption(target, props, responseState, formatContext);
          case "textarea":
            return pushStartTextArea(target, props, responseState);
          case "input":
            return pushInput(target, props, responseState);
          case "menuitem":
            return pushStartMenuItem(target, props, responseState);
          case "title":
            return pushStartTitle(target, props, responseState);
          case "listing":
          case "pre":
            return pushStartPreformattedElement(target, props, type2, responseState);
          case "area":
          case "base":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "img":
          case "keygen":
          case "link":
          case "meta":
          case "param":
          case "source":
          case "track":
          case "wbr":
            return pushSelfClosing(target, props, type2, responseState);
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return pushStartGenericElement(target, props, type2, responseState);
          case "html":
            return formatContext.insertionMode === ROOT_HTML_MODE && target.push(DOCTYPE), pushStartGenericElement(target, props, type2, responseState);
          default:
            return type2.indexOf("-") === -1 && typeof props.is != "string" ? pushStartGenericElement(target, props, type2, responseState) : pushStartCustomElement(target, props, type2, responseState);
        }
      }
      var endTag1 = "</", endTag2 = ">";
      function pushEndInstance(target, type2, props) {
        switch (type2) {
          case "area":
          case "base":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "img":
          case "input":
          case "keygen":
          case "link":
          case "meta":
          case "param":
          case "source":
          case "track":
          case "wbr":
            break;
          default:
            target.push(endTag1, type2, endTag2);
        }
      }
      function writeCompletedRoot(destination, responseState) {
        for (var bootstrapChunks = responseState.bootstrapChunks, i3 = 0; i3 < bootstrapChunks.length - 1; i3++)
          writeChunk(destination, bootstrapChunks[i3]);
        return i3 < bootstrapChunks.length ? writeChunkAndReturn(destination, bootstrapChunks[i3]) : !0;
      }
      var placeholder1 = '<template id="', placeholder2 = '"></template>';
      function writePlaceholder(destination, responseState, id4) {
        writeChunk(destination, placeholder1), writeChunk(destination, responseState.placeholderPrefix);
        var formattedID = id4.toString(16);
        return writeChunk(destination, formattedID), writeChunkAndReturn(destination, placeholder2);
      }
      var startCompletedSuspenseBoundary = "<!--$-->", startPendingSuspenseBoundary1 = '<!--$?--><template id="', startPendingSuspenseBoundary2 = '"></template>', startClientRenderedSuspenseBoundary = "<!--$!-->", endSuspenseBoundary = "<!--/$-->", clientRenderedSuspenseBoundaryError1 = "<template", clientRenderedSuspenseBoundaryErrorAttrInterstitial = '"', clientRenderedSuspenseBoundaryError1A = ' data-dgst="', clientRenderedSuspenseBoundaryError1B = ' data-msg="', clientRenderedSuspenseBoundaryError1C = ' data-stck="', clientRenderedSuspenseBoundaryError2 = "></template>";
      function writeStartCompletedSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, startCompletedSuspenseBoundary);
      }
      function writeStartPendingSuspenseBoundary(destination, responseState, id4) {
        if (writeChunk(destination, startPendingSuspenseBoundary1), id4 === null)
          throw new Error("An ID must have been assigned before we can complete the boundary.");
        return writeChunk(destination, id4), writeChunkAndReturn(destination, startPendingSuspenseBoundary2);
      }
      function writeStartClientRenderedSuspenseBoundary(destination, responseState, errorDigest, errorMesssage, errorComponentStack) {
        var result2;
        return result2 = writeChunkAndReturn(destination, startClientRenderedSuspenseBoundary), writeChunk(destination, clientRenderedSuspenseBoundaryError1), errorDigest && (writeChunk(destination, clientRenderedSuspenseBoundaryError1A), writeChunk(destination, escapeTextForBrowser(errorDigest)), writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial)), errorMesssage && (writeChunk(destination, clientRenderedSuspenseBoundaryError1B), writeChunk(destination, escapeTextForBrowser(errorMesssage)), writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial)), errorComponentStack && (writeChunk(destination, clientRenderedSuspenseBoundaryError1C), writeChunk(destination, escapeTextForBrowser(errorComponentStack)), writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial)), result2 = writeChunkAndReturn(destination, clientRenderedSuspenseBoundaryError2), result2;
      }
      function writeEndCompletedSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, endSuspenseBoundary);
      }
      function writeEndPendingSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, endSuspenseBoundary);
      }
      function writeEndClientRenderedSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, endSuspenseBoundary);
      }
      var startSegmentHTML = '<div hidden id="', startSegmentHTML2 = '">', endSegmentHTML = "</div>", startSegmentSVG = '<svg aria-hidden="true" style="display:none" id="', startSegmentSVG2 = '">', endSegmentSVG = "</svg>", startSegmentMathML = '<math aria-hidden="true" style="display:none" id="', startSegmentMathML2 = '">', endSegmentMathML = "</math>", startSegmentTable = '<table hidden id="', startSegmentTable2 = '">', endSegmentTable = "</table>", startSegmentTableBody = '<table hidden><tbody id="', startSegmentTableBody2 = '">', endSegmentTableBody = "</tbody></table>", startSegmentTableRow = '<table hidden><tr id="', startSegmentTableRow2 = '">', endSegmentTableRow = "</tr></table>", startSegmentColGroup = '<table hidden><colgroup id="', startSegmentColGroup2 = '">', endSegmentColGroup = "</colgroup></table>";
      function writeStartSegment(destination, responseState, formatContext, id4) {
        switch (formatContext.insertionMode) {
          case ROOT_HTML_MODE:
          case HTML_MODE:
            return writeChunk(destination, startSegmentHTML), writeChunk(destination, responseState.segmentPrefix), writeChunk(destination, id4.toString(16)), writeChunkAndReturn(destination, startSegmentHTML2);
          case SVG_MODE:
            return writeChunk(destination, startSegmentSVG), writeChunk(destination, responseState.segmentPrefix), writeChunk(destination, id4.toString(16)), writeChunkAndReturn(destination, startSegmentSVG2);
          case MATHML_MODE:
            return writeChunk(destination, startSegmentMathML), writeChunk(destination, responseState.segmentPrefix), writeChunk(destination, id4.toString(16)), writeChunkAndReturn(destination, startSegmentMathML2);
          case HTML_TABLE_MODE:
            return writeChunk(destination, startSegmentTable), writeChunk(destination, responseState.segmentPrefix), writeChunk(destination, id4.toString(16)), writeChunkAndReturn(destination, startSegmentTable2);
          case HTML_TABLE_BODY_MODE:
            return writeChunk(destination, startSegmentTableBody), writeChunk(destination, responseState.segmentPrefix), writeChunk(destination, id4.toString(16)), writeChunkAndReturn(destination, startSegmentTableBody2);
          case HTML_TABLE_ROW_MODE:
            return writeChunk(destination, startSegmentTableRow), writeChunk(destination, responseState.segmentPrefix), writeChunk(destination, id4.toString(16)), writeChunkAndReturn(destination, startSegmentTableRow2);
          case HTML_COLGROUP_MODE:
            return writeChunk(destination, startSegmentColGroup), writeChunk(destination, responseState.segmentPrefix), writeChunk(destination, id4.toString(16)), writeChunkAndReturn(destination, startSegmentColGroup2);
          default:
            throw new Error("Unknown insertion mode. This is a bug in React.");
        }
      }
      function writeEndSegment(destination, formatContext) {
        switch (formatContext.insertionMode) {
          case ROOT_HTML_MODE:
          case HTML_MODE:
            return writeChunkAndReturn(destination, endSegmentHTML);
          case SVG_MODE:
            return writeChunkAndReturn(destination, endSegmentSVG);
          case MATHML_MODE:
            return writeChunkAndReturn(destination, endSegmentMathML);
          case HTML_TABLE_MODE:
            return writeChunkAndReturn(destination, endSegmentTable);
          case HTML_TABLE_BODY_MODE:
            return writeChunkAndReturn(destination, endSegmentTableBody);
          case HTML_TABLE_ROW_MODE:
            return writeChunkAndReturn(destination, endSegmentTableRow);
          case HTML_COLGROUP_MODE:
            return writeChunkAndReturn(destination, endSegmentColGroup);
          default:
            throw new Error("Unknown insertion mode. This is a bug in React.");
        }
      }
      var completeSegmentFunction = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}", completeBoundaryFunction = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}', clientRenderFunction = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}', completeSegmentScript1Full = completeSegmentFunction + ';$RS("', completeSegmentScript1Partial = '$RS("', completeSegmentScript2 = '","', completeSegmentScript3 = '")</script>';
      function writeCompletedSegmentInstruction(destination, responseState, contentSegmentID) {
        writeChunk(destination, responseState.startInlineScript), responseState.sentCompleteSegmentFunction ? writeChunk(destination, completeSegmentScript1Partial) : (responseState.sentCompleteSegmentFunction = !0, writeChunk(destination, completeSegmentScript1Full)), writeChunk(destination, responseState.segmentPrefix);
        var formattedID = contentSegmentID.toString(16);
        return writeChunk(destination, formattedID), writeChunk(destination, completeSegmentScript2), writeChunk(destination, responseState.placeholderPrefix), writeChunk(destination, formattedID), writeChunkAndReturn(destination, completeSegmentScript3);
      }
      var completeBoundaryScript1Full = completeBoundaryFunction + ';$RC("', completeBoundaryScript1Partial = '$RC("', completeBoundaryScript2 = '","', completeBoundaryScript3 = '")</script>';
      function writeCompletedBoundaryInstruction(destination, responseState, boundaryID, contentSegmentID) {
        if (writeChunk(destination, responseState.startInlineScript), responseState.sentCompleteBoundaryFunction ? writeChunk(destination, completeBoundaryScript1Partial) : (responseState.sentCompleteBoundaryFunction = !0, writeChunk(destination, completeBoundaryScript1Full)), boundaryID === null)
          throw new Error("An ID must have been assigned before we can complete the boundary.");
        var formattedContentID = contentSegmentID.toString(16);
        return writeChunk(destination, boundaryID), writeChunk(destination, completeBoundaryScript2), writeChunk(destination, responseState.segmentPrefix), writeChunk(destination, formattedContentID), writeChunkAndReturn(destination, completeBoundaryScript3);
      }
      var clientRenderScript1Full = clientRenderFunction + ';$RX("', clientRenderScript1Partial = '$RX("', clientRenderScript1A = '"', clientRenderScript2 = ")</script>", clientRenderErrorScriptArgInterstitial = ",";
      function writeClientRenderBoundaryInstruction(destination, responseState, boundaryID, errorDigest, errorMessage, errorComponentStack) {
        if (writeChunk(destination, responseState.startInlineScript), responseState.sentClientRenderFunction ? writeChunk(destination, clientRenderScript1Partial) : (responseState.sentClientRenderFunction = !0, writeChunk(destination, clientRenderScript1Full)), boundaryID === null)
          throw new Error("An ID must have been assigned before we can complete the boundary.");
        return writeChunk(destination, boundaryID), writeChunk(destination, clientRenderScript1A), (errorDigest || errorMessage || errorComponentStack) && (writeChunk(destination, clientRenderErrorScriptArgInterstitial), writeChunk(destination, escapeJSStringsForInstructionScripts(errorDigest || ""))), (errorMessage || errorComponentStack) && (writeChunk(destination, clientRenderErrorScriptArgInterstitial), writeChunk(destination, escapeJSStringsForInstructionScripts(errorMessage || ""))), errorComponentStack && (writeChunk(destination, clientRenderErrorScriptArgInterstitial), writeChunk(destination, escapeJSStringsForInstructionScripts(errorComponentStack))), writeChunkAndReturn(destination, clientRenderScript2);
      }
      var regexForJSStringsInScripts = /[<\u2028\u2029]/g;
      function escapeJSStringsForInstructionScripts(input) {
        var escaped = JSON.stringify(input);
        return escaped.replace(regexForJSStringsInScripts, function(match) {
          switch (match) {
            case "<":
              return "\\u003c";
            case "\u2028":
              return "\\u2028";
            case "\u2029":
              return "\\u2029";
            default:
              throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
          }
        });
      }
      function createResponseState$1(generateStaticMarkup, identifierPrefix) {
        var responseState = createResponseState(identifierPrefix, void 0);
        return {
          bootstrapChunks: responseState.bootstrapChunks,
          startInlineScript: responseState.startInlineScript,
          placeholderPrefix: responseState.placeholderPrefix,
          segmentPrefix: responseState.segmentPrefix,
          boundaryPrefix: responseState.boundaryPrefix,
          idPrefix: responseState.idPrefix,
          nextSuspenseID: responseState.nextSuspenseID,
          sentCompleteSegmentFunction: responseState.sentCompleteSegmentFunction,
          sentCompleteBoundaryFunction: responseState.sentCompleteBoundaryFunction,
          sentClientRenderFunction: responseState.sentClientRenderFunction,
          generateStaticMarkup
        };
      }
      function createRootFormatContext() {
        return {
          insertionMode: HTML_MODE,
          selectedValue: null
        };
      }
      function pushTextInstance$1(target, text, responseState, textEmbedded) {
        return responseState.generateStaticMarkup ? (target.push(escapeTextForBrowser(text)), !1) : pushTextInstance(target, text, responseState, textEmbedded);
      }
      function pushSegmentFinale$1(target, responseState, lastPushedText, textEmbedded) {
        if (!responseState.generateStaticMarkup)
          return pushSegmentFinale(target, responseState, lastPushedText, textEmbedded);
      }
      function writeStartCompletedSuspenseBoundary$1(destination, responseState) {
        return responseState.generateStaticMarkup ? !0 : writeStartCompletedSuspenseBoundary(destination);
      }
      function writeStartClientRenderedSuspenseBoundary$1(destination, responseState, errorDigest, errorMessage, errorComponentStack) {
        return responseState.generateStaticMarkup ? !0 : writeStartClientRenderedSuspenseBoundary(destination, responseState, errorDigest, errorMessage, errorComponentStack);
      }
      function writeEndCompletedSuspenseBoundary$1(destination, responseState) {
        return responseState.generateStaticMarkup ? !0 : writeEndCompletedSuspenseBoundary(destination);
      }
      function writeEndClientRenderedSuspenseBoundary$1(destination, responseState) {
        return responseState.generateStaticMarkup ? !0 : writeEndClientRenderedSuspenseBoundary(destination);
      }
      var assign = Object.assign, REACT_ELEMENT_TYPE = Symbol.for("react.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_PROVIDER_TYPE = Symbol.for("react.provider"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_SCOPE_TYPE = Symbol.for("react.scope"), REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for("react.debug_trace_mode"), REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden"), REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for("react.default_value"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable != "object")
          return null;
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        return typeof maybeIterator == "function" ? maybeIterator : null;
      }
      function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName;
        if (displayName)
          return displayName;
        var functionName = innerType.displayName || innerType.name || "";
        return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
      }
      function getContextName(type2) {
        return type2.displayName || "Context";
      }
      function getComponentNameFromType(type2) {
        if (type2 == null)
          return null;
        if (typeof type2.tag == "number" && error2("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof type2 == "function")
          return type2.displayName || type2.name || null;
        if (typeof type2 == "string")
          return type2;
        switch (type2) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type2 == "object")
          switch (type2.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type2;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type2;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type2, type2.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              var outerName = type2.displayName || null;
              return outerName !== null ? outerName : getComponentNameFromType(type2.type) || "Memo";
            case REACT_LAZY_TYPE: {
              var lazyComponent = type2, payload = lazyComponent._payload, init4 = lazyComponent._init;
              try {
                return getComponentNameFromType(init4(payload));
              } catch {
                return null;
              }
            }
          }
        return null;
      }
      var disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
      function disabledLog() {
      }
      disabledLog.__reactDisabledLog = !0;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log, prevInfo = console.info, prevWarn = console.warn, prevError = console.error, prevGroup = console.group, prevGroupCollapsed = console.groupCollapsed, prevGroupEnd = console.groupEnd;
            var props = {
              configurable: !0,
              enumerable: !0,
              value: disabledLog,
              writable: !0
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          if (disabledDepth--, disabledDepth === 0) {
            var props = {
              configurable: !0,
              enumerable: !0,
              writable: !0
            };
            Object.defineProperties(console, {
              log: assign({}, props, {
                value: prevLog
              }),
              info: assign({}, props, {
                value: prevInfo
              }),
              warn: assign({}, props, {
                value: prevWarn
              }),
              error: assign({}, props, {
                value: prevError
              }),
              group: assign({}, props, {
                value: prevGroup
              }),
              groupCollapsed: assign({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: assign({}, props, {
                value: prevGroupEnd
              })
            });
          }
          disabledDepth < 0 && error2("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
      }
      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher, prefix;
      function describeBuiltInComponentFrame(name, source2, ownerFn) {
        {
          if (prefix === void 0)
            try {
              throw Error();
            } catch (x2) {
              var match = x2.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
            }
          return `
` + prefix + name;
        }
      }
      var reentry = !1, componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap == "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap();
      }
      function describeNativeComponentFrame(fn, construct4) {
        if (!fn || reentry)
          return "";
        {
          var frame = componentFrameCache.get(fn);
          if (frame !== void 0)
            return frame;
        }
        var control;
        reentry = !0;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var previousDispatcher;
        previousDispatcher = ReactCurrentDispatcher.current, ReactCurrentDispatcher.current = null, disableLogs();
        try {
          if (construct4) {
            var Fake = function() {
              throw Error();
            };
            if (Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x2) {
                control = x2;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x2) {
                control = x2;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x2) {
              control = x2;
            }
            fn();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack == "string") {
            for (var sampleLines = sample.stack.split(`
`), controlLines = control.stack.split(`
`), s3 = sampleLines.length - 1, c4 = controlLines.length - 1; s3 >= 1 && c4 >= 0 && sampleLines[s3] !== controlLines[c4]; )
              c4--;
            for (; s3 >= 1 && c4 >= 0; s3--, c4--)
              if (sampleLines[s3] !== controlLines[c4]) {
                if (s3 !== 1 || c4 !== 1)
                  do
                    if (s3--, c4--, c4 < 0 || sampleLines[s3] !== controlLines[c4]) {
                      var _frame = `
` + sampleLines[s3].replace(" at new ", " at ");
                      return fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName)), typeof fn == "function" && componentFrameCache.set(fn, _frame), _frame;
                    }
                  while (s3 >= 1 && c4 >= 0);
                break;
              }
          }
        } finally {
          reentry = !1, ReactCurrentDispatcher.current = previousDispatcher, reenableLogs(), Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name = fn ? fn.displayName || fn.name : "", syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
        return typeof fn == "function" && componentFrameCache.set(fn, syntheticFrame), syntheticFrame;
      }
      function describeClassComponentFrame(ctor, source2, ownerFn) {
        return describeNativeComponentFrame(ctor, !0);
      }
      function describeFunctionComponentFrame(fn, source2, ownerFn) {
        return describeNativeComponentFrame(fn, !1);
      }
      function shouldConstruct(Component3) {
        var prototype = Component3.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type2, source2, ownerFn) {
        if (type2 == null)
          return "";
        if (typeof type2 == "function")
          return describeNativeComponentFrame(type2, shouldConstruct(type2));
        if (typeof type2 == "string")
          return describeBuiltInComponentFrame(type2);
        switch (type2) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type2 == "object")
          switch (type2.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type2.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type2.type, source2, ownerFn);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type2, payload = lazyComponent._payload, init4 = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init4(payload), source2, ownerFn);
              } catch {
              }
            }
          }
        return "";
      }
      var loggedTypeFailures = {}, ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        if (element) {
          var owner = element._owner, stack2 = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
          ReactDebugCurrentFrame.setExtraStackFrame(stack2);
        } else
          ReactDebugCurrentFrame.setExtraStackFrame(null);
      }
      function checkPropTypes(typeSpecs, values, location, componentName, element) {
        {
          var has = Function.call.bind(hasOwnProperty2);
          for (var typeSpecName in typeSpecs)
            if (has(typeSpecs, typeSpecName)) {
              var error$1 = void 0;
              try {
                if (typeof typeSpecs[typeSpecName] != "function") {
                  var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw err.name = "Invariant Violation", err;
                }
                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex) {
                error$1 = ex;
              }
              error$1 && !(error$1 instanceof Error) && (setCurrentlyValidatingElement(element), error2("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1), setCurrentlyValidatingElement(null)), error$1 instanceof Error && !(error$1.message in loggedTypeFailures) && (loggedTypeFailures[error$1.message] = !0, setCurrentlyValidatingElement(element), error2("Failed %s type: %s", location, error$1.message), setCurrentlyValidatingElement(null));
            }
        }
      }
      var warnedAboutMissingGetChildContext;
      warnedAboutMissingGetChildContext = {};
      var emptyContextObject = {};
      Object.freeze(emptyContextObject);
      function getMaskedContext(type2, unmaskedContext) {
        {
          var contextTypes = type2.contextTypes;
          if (!contextTypes)
            return emptyContextObject;
          var context = {};
          for (var key2 in contextTypes)
            context[key2] = unmaskedContext[key2];
          {
            var name = getComponentNameFromType(type2) || "Unknown";
            checkPropTypes(contextTypes, context, "context", name);
          }
          return context;
        }
      }
      function processChildContext(instance2, type2, parentContext, childContextTypes) {
        {
          if (typeof instance2.getChildContext != "function") {
            {
              var componentName = getComponentNameFromType(type2) || "Unknown";
              warnedAboutMissingGetChildContext[componentName] || (warnedAboutMissingGetChildContext[componentName] = !0, error2("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName));
            }
            return parentContext;
          }
          var childContext = instance2.getChildContext();
          for (var contextKey in childContext)
            if (!(contextKey in childContextTypes))
              throw new Error((getComponentNameFromType(type2) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
          {
            var name = getComponentNameFromType(type2) || "Unknown";
            checkPropTypes(childContextTypes, childContext, "child context", name);
          }
          return assign({}, parentContext, childContext);
        }
      }
      var rendererSigil;
      rendererSigil = {};
      var rootContextSnapshot = null, currentActiveSnapshot = null;
      function popNode(prev) {
        prev.context._currentValue2 = prev.parentValue;
      }
      function pushNode(next) {
        next.context._currentValue2 = next.value;
      }
      function popToNearestCommonAncestor(prev, next) {
        if (prev !== next) {
          popNode(prev);
          var parentPrev = prev.parent, parentNext = next.parent;
          if (parentPrev === null) {
            if (parentNext !== null)
              throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
          } else {
            if (parentNext === null)
              throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
            popToNearestCommonAncestor(parentPrev, parentNext);
          }
          pushNode(next);
        }
      }
      function popAllPrevious(prev) {
        popNode(prev);
        var parentPrev = prev.parent;
        parentPrev !== null && popAllPrevious(parentPrev);
      }
      function pushAllNext(next) {
        var parentNext = next.parent;
        parentNext !== null && pushAllNext(parentNext), pushNode(next);
      }
      function popPreviousToCommonLevel(prev, next) {
        popNode(prev);
        var parentPrev = prev.parent;
        if (parentPrev === null)
          throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
        parentPrev.depth === next.depth ? popToNearestCommonAncestor(parentPrev, next) : popPreviousToCommonLevel(parentPrev, next);
      }
      function popNextToCommonLevel(prev, next) {
        var parentNext = next.parent;
        if (parentNext === null)
          throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
        prev.depth === parentNext.depth ? popToNearestCommonAncestor(prev, parentNext) : popNextToCommonLevel(prev, parentNext), pushNode(next);
      }
      function switchContext(newSnapshot) {
        var prev = currentActiveSnapshot, next = newSnapshot;
        prev !== next && (prev === null ? pushAllNext(next) : next === null ? popAllPrevious(prev) : prev.depth === next.depth ? popToNearestCommonAncestor(prev, next) : prev.depth > next.depth ? popPreviousToCommonLevel(prev, next) : popNextToCommonLevel(prev, next), currentActiveSnapshot = next);
      }
      function pushProvider(context, nextValue) {
        var prevValue;
        prevValue = context._currentValue2, context._currentValue2 = nextValue, context._currentRenderer2 !== void 0 && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil && error2("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), context._currentRenderer2 = rendererSigil;
        var prevNode = currentActiveSnapshot, newNode = {
          parent: prevNode,
          depth: prevNode === null ? 0 : prevNode.depth + 1,
          context,
          parentValue: prevValue,
          value: nextValue
        };
        return currentActiveSnapshot = newNode, newNode;
      }
      function popProvider(context) {
        var prevSnapshot = currentActiveSnapshot;
        if (prevSnapshot === null)
          throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
        prevSnapshot.context !== context && error2("The parent context is not the expected context. This is probably a bug in React.");
        {
          var _value = prevSnapshot.parentValue;
          _value === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED ? prevSnapshot.context._currentValue2 = prevSnapshot.context._defaultValue : prevSnapshot.context._currentValue2 = _value, context._currentRenderer2 !== void 0 && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil && error2("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), context._currentRenderer2 = rendererSigil;
        }
        return currentActiveSnapshot = prevSnapshot.parent;
      }
      function getActiveContext() {
        return currentActiveSnapshot;
      }
      function readContext(context) {
        var value2 = context._currentValue2;
        return value2;
      }
      function get2(key2) {
        return key2._reactInternals;
      }
      function set2(key2, value2) {
        key2._reactInternals = value2;
      }
      var didWarnAboutNoopUpdateForComponent = {}, didWarnAboutDeprecatedWillMount = {}, didWarnAboutUninitializedState, didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate, didWarnAboutLegacyLifecyclesAndDerivedState, didWarnAboutUndefinedDerivedState, warnOnUndefinedDerivedState, warnOnInvalidCallback, didWarnAboutDirectlyAssigningPropsToState, didWarnAboutContextTypeAndContextTypes, didWarnAboutInvalidateContextType;
      {
        didWarnAboutUninitializedState = /* @__PURE__ */ new Set(), didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set(), didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set(), didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set(), didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set(), didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set(), didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
        var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
        warnOnInvalidCallback = function(callback, callerName) {
          if (!(callback === null || typeof callback == "function")) {
            var key2 = callerName + "_" + callback;
            didWarnOnInvalidCallback.has(key2) || (didWarnOnInvalidCallback.add(key2), error2("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback));
          }
        }, warnOnUndefinedDerivedState = function(type2, partialState) {
          if (partialState === void 0) {
            var componentName = getComponentNameFromType(type2) || "Component";
            didWarnAboutUndefinedDerivedState.has(componentName) || (didWarnAboutUndefinedDerivedState.add(componentName), error2("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName));
          }
        };
      }
      function warnNoop(publicInstance, callerName) {
        {
          var _constructor = publicInstance.constructor, componentName = _constructor && getComponentNameFromType(_constructor) || "ReactClass", warningKey = componentName + "." + callerName;
          if (didWarnAboutNoopUpdateForComponent[warningKey])
            return;
          error2(`%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.

Please check the code for the %s component.`, callerName, callerName, componentName), didWarnAboutNoopUpdateForComponent[warningKey] = !0;
        }
      }
      var classComponentUpdater = {
        isMounted: function(inst) {
          return !1;
        },
        enqueueSetState: function(inst, payload, callback) {
          var internals = get2(inst);
          internals.queue === null ? warnNoop(inst, "setState") : (internals.queue.push(payload), callback != null && warnOnInvalidCallback(callback, "setState"));
        },
        enqueueReplaceState: function(inst, payload, callback) {
          var internals = get2(inst);
          internals.replace = !0, internals.queue = [payload], callback != null && warnOnInvalidCallback(callback, "setState");
        },
        enqueueForceUpdate: function(inst, callback) {
          var internals = get2(inst);
          internals.queue === null ? warnNoop(inst, "forceUpdate") : callback != null && warnOnInvalidCallback(callback, "setState");
        }
      };
      function applyDerivedStateFromProps(instance2, ctor, getDerivedStateFromProps, prevState, nextProps) {
        var partialState = getDerivedStateFromProps(nextProps, prevState);
        warnOnUndefinedDerivedState(ctor, partialState);
        var newState = partialState == null ? prevState : assign({}, prevState, partialState);
        return newState;
      }
      function constructClassInstance(ctor, props, maskedLegacyContext) {
        var context = emptyContextObject, contextType = ctor.contextType;
        if ("contextType" in ctor) {
          var isValid = contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0;
          if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
            didWarnAboutInvalidateContextType.add(ctor);
            var addendum = "";
            contextType === void 0 ? addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof contextType != "object" ? addendum = " However, it is set to a " + typeof contextType + "." : contextType.$$typeof === REACT_PROVIDER_TYPE ? addendum = " Did you accidentally pass the Context.Provider instead?" : contextType._context !== void 0 ? addendum = " Did you accidentally pass the Context.Consumer instead?" : addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.", error2("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || "Component", addendum);
          }
        }
        typeof contextType == "object" && contextType !== null ? context = readContext(contextType) : context = maskedLegacyContext;
        var instance2 = new ctor(props, context);
        {
          if (typeof ctor.getDerivedStateFromProps == "function" && (instance2.state === null || instance2.state === void 0)) {
            var componentName = getComponentNameFromType(ctor) || "Component";
            didWarnAboutUninitializedState.has(componentName) || (didWarnAboutUninitializedState.add(componentName), error2("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance2.state === null ? "null" : "undefined", componentName));
          }
          if (typeof ctor.getDerivedStateFromProps == "function" || typeof instance2.getSnapshotBeforeUpdate == "function") {
            var foundWillMountName = null, foundWillReceivePropsName = null, foundWillUpdateName = null;
            if (typeof instance2.componentWillMount == "function" && instance2.componentWillMount.__suppressDeprecationWarning !== !0 ? foundWillMountName = "componentWillMount" : typeof instance2.UNSAFE_componentWillMount == "function" && (foundWillMountName = "UNSAFE_componentWillMount"), typeof instance2.componentWillReceiveProps == "function" && instance2.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? foundWillReceivePropsName = "componentWillReceiveProps" : typeof instance2.UNSAFE_componentWillReceiveProps == "function" && (foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps"), typeof instance2.componentWillUpdate == "function" && instance2.componentWillUpdate.__suppressDeprecationWarning !== !0 ? foundWillUpdateName = "componentWillUpdate" : typeof instance2.UNSAFE_componentWillUpdate == "function" && (foundWillUpdateName = "UNSAFE_componentWillUpdate"), foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
              var _componentName = getComponentNameFromType(ctor) || "Component", newApiName = typeof ctor.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
              didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName) || (didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName), error2(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, _componentName, newApiName, foundWillMountName !== null ? `
  ` + foundWillMountName : "", foundWillReceivePropsName !== null ? `
  ` + foundWillReceivePropsName : "", foundWillUpdateName !== null ? `
  ` + foundWillUpdateName : ""));
            }
          }
        }
        return instance2;
      }
      function checkClassInstance(instance2, ctor, newProps) {
        {
          var name = getComponentNameFromType(ctor) || "Component", renderPresent = instance2.render;
          renderPresent || (ctor.prototype && typeof ctor.prototype.render == "function" ? error2("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name) : error2("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name)), instance2.getInitialState && !instance2.getInitialState.isReactClassApproved && !instance2.state && error2("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name), instance2.getDefaultProps && !instance2.getDefaultProps.isReactClassApproved && error2("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name), instance2.propTypes && error2("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name), instance2.contextType && error2("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name), instance2.contextTypes && error2("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name), ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor) && (didWarnAboutContextTypeAndContextTypes.add(ctor), error2("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name)), typeof instance2.componentShouldUpdate == "function" && error2("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name), ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance2.shouldComponentUpdate < "u" && error2("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || "A pure component"), typeof instance2.componentDidUnmount == "function" && error2("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name), typeof instance2.componentDidReceiveProps == "function" && error2("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name), typeof instance2.componentWillRecieveProps == "function" && error2("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name), typeof instance2.UNSAFE_componentWillRecieveProps == "function" && error2("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name);
          var hasMutatedProps = instance2.props !== newProps;
          instance2.props !== void 0 && hasMutatedProps && error2("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name, name), instance2.defaultProps && error2("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name, name), typeof instance2.getSnapshotBeforeUpdate == "function" && typeof instance2.componentDidUpdate != "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor) && (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor), error2("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor))), typeof instance2.getDerivedStateFromProps == "function" && error2("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name), typeof instance2.getDerivedStateFromError == "function" && error2("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name), typeof ctor.getSnapshotBeforeUpdate == "function" && error2("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name);
          var _state = instance2.state;
          _state && (typeof _state != "object" || isArray3(_state)) && error2("%s.state: must be set to an object or null", name), typeof instance2.getChildContext == "function" && typeof ctor.childContextTypes != "object" && error2("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name);
        }
      }
      function callComponentWillMount(type2, instance2) {
        var oldState = instance2.state;
        if (typeof instance2.componentWillMount == "function") {
          if (instance2.componentWillMount.__suppressDeprecationWarning !== !0) {
            var componentName = getComponentNameFromType(type2) || "Unknown";
            didWarnAboutDeprecatedWillMount[componentName] || (warn3(
              `componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.

Please update the following components: %s`,
              componentName
            ), didWarnAboutDeprecatedWillMount[componentName] = !0);
          }
          instance2.componentWillMount();
        }
        typeof instance2.UNSAFE_componentWillMount == "function" && instance2.UNSAFE_componentWillMount(), oldState !== instance2.state && (error2("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromType(type2) || "Component"), classComponentUpdater.enqueueReplaceState(instance2, instance2.state, null));
      }
      function processUpdateQueue(internalInstance, inst, props, maskedLegacyContext) {
        if (internalInstance.queue !== null && internalInstance.queue.length > 0) {
          var oldQueue = internalInstance.queue, oldReplace = internalInstance.replace;
          if (internalInstance.queue = null, internalInstance.replace = !1, oldReplace && oldQueue.length === 1)
            inst.state = oldQueue[0];
          else {
            for (var nextState = oldReplace ? oldQueue[0] : inst.state, dontMutate = !0, i3 = oldReplace ? 1 : 0; i3 < oldQueue.length; i3++) {
              var partial = oldQueue[i3], partialState = typeof partial == "function" ? partial.call(inst, nextState, props, maskedLegacyContext) : partial;
              partialState != null && (dontMutate ? (dontMutate = !1, nextState = assign({}, nextState, partialState)) : assign(nextState, partialState));
            }
            inst.state = nextState;
          }
        } else
          internalInstance.queue = null;
      }
      function mountClassInstance(instance2, ctor, newProps, maskedLegacyContext) {
        checkClassInstance(instance2, ctor, newProps);
        var initialState = instance2.state !== void 0 ? instance2.state : null;
        instance2.updater = classComponentUpdater, instance2.props = newProps, instance2.state = initialState;
        var internalInstance = {
          queue: [],
          replace: !1
        };
        set2(instance2, internalInstance);
        var contextType = ctor.contextType;
        if (typeof contextType == "object" && contextType !== null ? instance2.context = readContext(contextType) : instance2.context = maskedLegacyContext, instance2.state === newProps) {
          var componentName = getComponentNameFromType(ctor) || "Component";
          didWarnAboutDirectlyAssigningPropsToState.has(componentName) || (didWarnAboutDirectlyAssigningPropsToState.add(componentName), error2("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName));
        }
        var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
        typeof getDerivedStateFromProps == "function" && (instance2.state = applyDerivedStateFromProps(instance2, ctor, getDerivedStateFromProps, initialState, newProps)), typeof ctor.getDerivedStateFromProps != "function" && typeof instance2.getSnapshotBeforeUpdate != "function" && (typeof instance2.UNSAFE_componentWillMount == "function" || typeof instance2.componentWillMount == "function") && (callComponentWillMount(ctor, instance2), processUpdateQueue(internalInstance, instance2, newProps, maskedLegacyContext));
      }
      var emptyTreeContext = {
        id: 1,
        overflow: ""
      };
      function getTreeId(context) {
        var overflow = context.overflow, idWithLeadingBit = context.id, id4 = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
        return id4.toString(32) + overflow;
      }
      function pushTreeContext(baseContext, totalChildren, index2) {
        var baseIdWithLeadingBit = baseContext.id, baseOverflow = baseContext.overflow, baseLength = getBitLength(baseIdWithLeadingBit) - 1, baseId = baseIdWithLeadingBit & ~(1 << baseLength), slot = index2 + 1, length = getBitLength(totalChildren) + baseLength;
        if (length > 30) {
          var numberOfOverflowBits = baseLength - baseLength % 5, newOverflowBits = (1 << numberOfOverflowBits) - 1, newOverflow = (baseId & newOverflowBits).toString(32), restOfBaseId = baseId >> numberOfOverflowBits, restOfBaseLength = baseLength - numberOfOverflowBits, restOfLength = getBitLength(totalChildren) + restOfBaseLength, restOfNewBits = slot << restOfBaseLength, id4 = restOfNewBits | restOfBaseId, overflow = newOverflow + baseOverflow;
          return {
            id: 1 << restOfLength | id4,
            overflow
          };
        } else {
          var newBits = slot << baseLength, _id = newBits | baseId, _overflow = baseOverflow;
          return {
            id: 1 << length | _id,
            overflow: _overflow
          };
        }
      }
      function getBitLength(number4) {
        return 32 - clz32(number4);
      }
      function getLeadingBit(id4) {
        return 1 << getBitLength(id4) - 1;
      }
      var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log2 = Math.log, LN2 = Math.LN2;
      function clz32Fallback(x2) {
        var asUint = x2 >>> 0;
        return asUint === 0 ? 32 : 31 - (log2(asUint) / LN2 | 0) | 0;
      }
      function is2(x2, y2) {
        return x2 === y2 && (x2 !== 0 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
      }
      var objectIs = typeof Object.is == "function" ? Object.is : is2, currentlyRenderingComponent = null, currentlyRenderingTask = null, firstWorkInProgressHook = null, workInProgressHook = null, isReRender = !1, didScheduleRenderPhaseUpdate = !1, localIdCounter = 0, renderPhaseUpdates = null, numberOfReRenders = 0, RE_RENDER_LIMIT = 25, isInHookUserCodeInDev = !1, currentHookNameInDev;
      function resolveCurrentlyRenderingComponent() {
        if (currentlyRenderingComponent === null)
          throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
        return isInHookUserCodeInDev && error2("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks"), currentlyRenderingComponent;
      }
      function areHookInputsEqual(nextDeps, prevDeps) {
        if (prevDeps === null)
          return error2("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev), !1;
        nextDeps.length !== prevDeps.length && error2(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, currentHookNameInDev, "[" + nextDeps.join(", ") + "]", "[" + prevDeps.join(", ") + "]");
        for (var i3 = 0; i3 < prevDeps.length && i3 < nextDeps.length; i3++)
          if (!objectIs(nextDeps[i3], prevDeps[i3]))
            return !1;
        return !0;
      }
      function createHook() {
        if (numberOfReRenders > 0)
          throw new Error("Rendered more hooks than during the previous render");
        return {
          memoizedState: null,
          queue: null,
          next: null
        };
      }
      function createWorkInProgressHook() {
        return workInProgressHook === null ? firstWorkInProgressHook === null ? (isReRender = !1, firstWorkInProgressHook = workInProgressHook = createHook()) : (isReRender = !0, workInProgressHook = firstWorkInProgressHook) : workInProgressHook.next === null ? (isReRender = !1, workInProgressHook = workInProgressHook.next = createHook()) : (isReRender = !0, workInProgressHook = workInProgressHook.next), workInProgressHook;
      }
      function prepareToUseHooks(task, componentIdentity) {
        currentlyRenderingComponent = componentIdentity, currentlyRenderingTask = task, isInHookUserCodeInDev = !1, localIdCounter = 0;
      }
      function finishHooks(Component3, props, children, refOrContext) {
        for (; didScheduleRenderPhaseUpdate; )
          didScheduleRenderPhaseUpdate = !1, localIdCounter = 0, numberOfReRenders += 1, workInProgressHook = null, children = Component3(props, refOrContext);
        return resetHooksState(), children;
      }
      function checkDidRenderIdHook() {
        var didRenderIdHook = localIdCounter !== 0;
        return didRenderIdHook;
      }
      function resetHooksState() {
        isInHookUserCodeInDev = !1, currentlyRenderingComponent = null, currentlyRenderingTask = null, didScheduleRenderPhaseUpdate = !1, firstWorkInProgressHook = null, numberOfReRenders = 0, renderPhaseUpdates = null, workInProgressHook = null;
      }
      function readContext$1(context) {
        return isInHookUserCodeInDev && error2("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."), readContext(context);
      }
      function useContext17(context) {
        return currentHookNameInDev = "useContext", resolveCurrentlyRenderingComponent(), readContext(context);
      }
      function basicStateReducer(state, action3) {
        return typeof action3 == "function" ? action3(state) : action3;
      }
      function useState14(initialState) {
        return currentHookNameInDev = "useState", useReducer(
          basicStateReducer,
          initialState
        );
      }
      function useReducer(reducer, initialArg, init4) {
        if (reducer !== basicStateReducer && (currentHookNameInDev = "useReducer"), currentlyRenderingComponent = resolveCurrentlyRenderingComponent(), workInProgressHook = createWorkInProgressHook(), isReRender) {
          var queue2 = workInProgressHook.queue, dispatch = queue2.dispatch;
          if (renderPhaseUpdates !== null) {
            var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue2);
            if (firstRenderPhaseUpdate !== void 0) {
              renderPhaseUpdates.delete(queue2);
              var newState = workInProgressHook.memoizedState, update = firstRenderPhaseUpdate;
              do {
                var action3 = update.action;
                isInHookUserCodeInDev = !0, newState = reducer(newState, action3), isInHookUserCodeInDev = !1, update = update.next;
              } while (update !== null);
              return workInProgressHook.memoizedState = newState, [newState, dispatch];
            }
          }
          return [workInProgressHook.memoizedState, dispatch];
        } else {
          isInHookUserCodeInDev = !0;
          var initialState;
          reducer === basicStateReducer ? initialState = typeof initialArg == "function" ? initialArg() : initialArg : initialState = init4 !== void 0 ? init4(initialArg) : initialArg, isInHookUserCodeInDev = !1, workInProgressHook.memoizedState = initialState;
          var _queue = workInProgressHook.queue = {
            last: null,
            dispatch: null
          }, _dispatch = _queue.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, _queue);
          return [workInProgressHook.memoizedState, _dispatch];
        }
      }
      function useMemo11(nextCreate, deps) {
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent(), workInProgressHook = createWorkInProgressHook();
        var nextDeps = deps === void 0 ? null : deps;
        if (workInProgressHook !== null) {
          var prevState = workInProgressHook.memoizedState;
          if (prevState !== null && nextDeps !== null) {
            var prevDeps = prevState[1];
            if (areHookInputsEqual(nextDeps, prevDeps))
              return prevState[0];
          }
        }
        isInHookUserCodeInDev = !0;
        var nextValue = nextCreate();
        return isInHookUserCodeInDev = !1, workInProgressHook.memoizedState = [nextValue, nextDeps], nextValue;
      }
      function useRef14(initialValue) {
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent(), workInProgressHook = createWorkInProgressHook();
        var previousRef = workInProgressHook.memoizedState;
        if (previousRef === null) {
          var ref = {
            current: initialValue
          };
          return Object.seal(ref), workInProgressHook.memoizedState = ref, ref;
        } else
          return previousRef;
      }
      function useLayoutEffect6(create, inputs) {
        currentHookNameInDev = "useLayoutEffect", error2("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
      }
      function dispatchAction(componentIdentity, queue2, action3) {
        if (numberOfReRenders >= RE_RENDER_LIMIT)
          throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
        if (componentIdentity === currentlyRenderingComponent) {
          didScheduleRenderPhaseUpdate = !0;
          var update = {
            action: action3,
            next: null
          };
          renderPhaseUpdates === null && (renderPhaseUpdates = /* @__PURE__ */ new Map());
          var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue2);
          if (firstRenderPhaseUpdate === void 0)
            renderPhaseUpdates.set(queue2, update);
          else {
            for (var lastRenderPhaseUpdate = firstRenderPhaseUpdate; lastRenderPhaseUpdate.next !== null; )
              lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
            lastRenderPhaseUpdate.next = update;
          }
        }
      }
      function useCallback5(callback, deps) {
        return useMemo11(function() {
          return callback;
        }, deps);
      }
      function useMutableSource(source2, getSnapshot, subscribe) {
        return resolveCurrentlyRenderingComponent(), getSnapshot(source2._source);
      }
      function useSyncExternalStore3(subscribe, getSnapshot, getServerSnapshot) {
        if (getServerSnapshot === void 0)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        return getServerSnapshot();
      }
      function useDeferredValue(value2) {
        return resolveCurrentlyRenderingComponent(), value2;
      }
      function unsupportedStartTransition() {
        throw new Error("startTransition cannot be called during server rendering.");
      }
      function useTransition2() {
        return resolveCurrentlyRenderingComponent(), [!1, unsupportedStartTransition];
      }
      function useId4() {
        var task = currentlyRenderingTask, treeId = getTreeId(task.treeContext), responseState = currentResponseState;
        if (responseState === null)
          throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
        var localId = localIdCounter++;
        return makeId(responseState, treeId, localId);
      }
      function noop4() {
      }
      var Dispatcher = {
        readContext: readContext$1,
        useContext: useContext17,
        useMemo: useMemo11,
        useReducer,
        useRef: useRef14,
        useState: useState14,
        useInsertionEffect: noop4,
        useLayoutEffect: useLayoutEffect6,
        useCallback: useCallback5,
        useImperativeHandle: noop4,
        useEffect: noop4,
        useDebugValue: noop4,
        useDeferredValue,
        useTransition: useTransition2,
        useId: useId4,
        useMutableSource,
        useSyncExternalStore: useSyncExternalStore3
      }, currentResponseState = null;
      function setCurrentResponseState(responseState) {
        currentResponseState = responseState;
      }
      function getStackByComponentStackNode(componentStack) {
        try {
          var info = "", node = componentStack;
          do {
            switch (node.tag) {
              case 0:
                info += describeBuiltInComponentFrame(node.type, null, null);
                break;
              case 1:
                info += describeFunctionComponentFrame(node.type, null, null);
                break;
              case 2:
                info += describeClassComponentFrame(node.type, null, null);
                break;
            }
            node = node.parent;
          } while (node);
          return info;
        } catch (x2) {
          return `
Error generating stack: ` + x2.message + `
` + x2.stack;
        }
      }
      var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher, ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame, PENDING = 0, COMPLETED = 1, FLUSHED = 2, ABORTED = 3, ERRORED = 4, OPEN = 0, CLOSING = 1, CLOSED = 2, DEFAULT_PROGRESSIVE_CHUNK_SIZE = 12800;
      function defaultErrorHandler(error3) {
        return console.error(error3), null;
      }
      function noop$1() {
      }
      function createRequest(children, responseState, rootFormatContext, progressiveChunkSize, onError2, onAllReady, onShellReady, onShellError, onFatalError) {
        var pingedTasks = [], abortSet = /* @__PURE__ */ new Set(), request = {
          destination: null,
          responseState,
          progressiveChunkSize: progressiveChunkSize === void 0 ? DEFAULT_PROGRESSIVE_CHUNK_SIZE : progressiveChunkSize,
          status: OPEN,
          fatalError: null,
          nextSegmentId: 0,
          allPendingTasks: 0,
          pendingRootTasks: 0,
          completedRootSegment: null,
          abortableTasks: abortSet,
          pingedTasks,
          clientRenderedBoundaries: [],
          completedBoundaries: [],
          partialBoundaries: [],
          onError: onError2 === void 0 ? defaultErrorHandler : onError2,
          onAllReady: onAllReady === void 0 ? noop$1 : onAllReady,
          onShellReady: onShellReady === void 0 ? noop$1 : onShellReady,
          onShellError: onShellError === void 0 ? noop$1 : onShellError,
          onFatalError: onFatalError === void 0 ? noop$1 : onFatalError
        }, rootSegment = createPendingSegment(
          request,
          0,
          null,
          rootFormatContext,
          !1,
          !1
        );
        rootSegment.parentFlushed = !0;
        var rootTask = createTask(request, children, null, rootSegment, abortSet, emptyContextObject, rootContextSnapshot, emptyTreeContext);
        return pingedTasks.push(rootTask), request;
      }
      function pingTask(request, task) {
        var pingedTasks = request.pingedTasks;
        pingedTasks.push(task), pingedTasks.length === 1 && scheduleWork(function() {
          return performWork(request);
        });
      }
      function createSuspenseBoundary(request, fallbackAbortableTasks) {
        return {
          id: UNINITIALIZED_SUSPENSE_BOUNDARY_ID,
          rootSegmentID: -1,
          parentFlushed: !1,
          pendingTasks: 0,
          forceClientRender: !1,
          completedSegments: [],
          byteSize: 0,
          fallbackAbortableTasks,
          errorDigest: null
        };
      }
      function createTask(request, node, blockedBoundary, blockedSegment, abortSet, legacyContext, context, treeContext) {
        request.allPendingTasks++, blockedBoundary === null ? request.pendingRootTasks++ : blockedBoundary.pendingTasks++;
        var task = {
          node,
          ping: function() {
            return pingTask(request, task);
          },
          blockedBoundary,
          blockedSegment,
          abortSet,
          legacyContext,
          context,
          treeContext
        };
        return task.componentStack = null, abortSet.add(task), task;
      }
      function createPendingSegment(request, index2, boundary, formatContext, lastPushedText, textEmbedded) {
        return {
          status: PENDING,
          id: -1,
          index: index2,
          parentFlushed: !1,
          chunks: [],
          children: [],
          formatContext,
          boundary,
          lastPushedText,
          textEmbedded
        };
      }
      var currentTaskInDEV = null;
      function getCurrentStackInDEV() {
        return currentTaskInDEV === null || currentTaskInDEV.componentStack === null ? "" : getStackByComponentStackNode(currentTaskInDEV.componentStack);
      }
      function pushBuiltInComponentStackInDEV(task, type2) {
        task.componentStack = {
          tag: 0,
          parent: task.componentStack,
          type: type2
        };
      }
      function pushFunctionComponentStackInDEV(task, type2) {
        task.componentStack = {
          tag: 1,
          parent: task.componentStack,
          type: type2
        };
      }
      function pushClassComponentStackInDEV(task, type2) {
        task.componentStack = {
          tag: 2,
          parent: task.componentStack,
          type: type2
        };
      }
      function popComponentStackInDEV(task) {
        task.componentStack === null ? error2("Unexpectedly popped too many stack frames. This is a bug in React.") : task.componentStack = task.componentStack.parent;
      }
      var lastBoundaryErrorComponentStackDev = null;
      function captureBoundaryErrorDetailsDev(boundary, error3) {
        {
          var errorMessage;
          typeof error3 == "string" ? errorMessage = error3 : error3 && typeof error3.message == "string" ? errorMessage = error3.message : errorMessage = String(error3);
          var errorComponentStack = lastBoundaryErrorComponentStackDev || getCurrentStackInDEV();
          lastBoundaryErrorComponentStackDev = null, boundary.errorMessage = errorMessage, boundary.errorComponentStack = errorComponentStack;
        }
      }
      function logRecoverableError(request, error3) {
        var errorDigest = request.onError(error3);
        if (errorDigest != null && typeof errorDigest != "string")
          throw new Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof errorDigest + '" instead');
        return errorDigest;
      }
      function fatalError(request, error3) {
        var onShellError = request.onShellError;
        onShellError(error3);
        var onFatalError = request.onFatalError;
        onFatalError(error3), request.destination !== null ? (request.status = CLOSED, closeWithError(request.destination, error3)) : (request.status = CLOSING, request.fatalError = error3);
      }
      function renderSuspenseBoundary(request, task, props) {
        pushBuiltInComponentStackInDEV(task, "Suspense");
        var parentBoundary = task.blockedBoundary, parentSegment = task.blockedSegment, fallback = props.fallback, content = props.children, fallbackAbortSet = /* @__PURE__ */ new Set(), newBoundary = createSuspenseBoundary(request, fallbackAbortSet), insertionIndex = parentSegment.chunks.length, boundarySegment = createPendingSegment(
          request,
          insertionIndex,
          newBoundary,
          parentSegment.formatContext,
          !1,
          !1
        );
        parentSegment.children.push(boundarySegment), parentSegment.lastPushedText = !1;
        var contentRootSegment = createPendingSegment(
          request,
          0,
          null,
          parentSegment.formatContext,
          !1,
          !1
        );
        contentRootSegment.parentFlushed = !0, task.blockedBoundary = newBoundary, task.blockedSegment = contentRootSegment;
        try {
          if (renderNode(request, task, content), pushSegmentFinale$1(contentRootSegment.chunks, request.responseState, contentRootSegment.lastPushedText, contentRootSegment.textEmbedded), contentRootSegment.status = COMPLETED, queueCompletedSegment(newBoundary, contentRootSegment), newBoundary.pendingTasks === 0) {
            popComponentStackInDEV(task);
            return;
          }
        } catch (error3) {
          contentRootSegment.status = ERRORED, newBoundary.forceClientRender = !0, newBoundary.errorDigest = logRecoverableError(request, error3), captureBoundaryErrorDetailsDev(newBoundary, error3);
        } finally {
          task.blockedBoundary = parentBoundary, task.blockedSegment = parentSegment;
        }
        var suspendedFallbackTask = createTask(request, fallback, parentBoundary, boundarySegment, fallbackAbortSet, task.legacyContext, task.context, task.treeContext);
        suspendedFallbackTask.componentStack = task.componentStack, request.pingedTasks.push(suspendedFallbackTask), popComponentStackInDEV(task);
      }
      function renderHostElement(request, task, type2, props) {
        pushBuiltInComponentStackInDEV(task, type2);
        var segment = task.blockedSegment, children = pushStartInstance(segment.chunks, type2, props, request.responseState, segment.formatContext);
        segment.lastPushedText = !1;
        var prevContext = segment.formatContext;
        segment.formatContext = getChildFormatContext(prevContext, type2, props), renderNode(request, task, children), segment.formatContext = prevContext, pushEndInstance(segment.chunks, type2), segment.lastPushedText = !1, popComponentStackInDEV(task);
      }
      function shouldConstruct$1(Component3) {
        return Component3.prototype && Component3.prototype.isReactComponent;
      }
      function renderWithHooks(request, task, Component3, props, secondArg) {
        var componentIdentity = {};
        prepareToUseHooks(task, componentIdentity);
        var result2 = Component3(props, secondArg);
        return finishHooks(Component3, props, result2, secondArg);
      }
      function finishClassComponent(request, task, instance2, Component3, props) {
        var nextChildren = instance2.render();
        instance2.props !== props && (didWarnAboutReassigningProps || error2("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromType(Component3) || "a component"), didWarnAboutReassigningProps = !0);
        {
          var childContextTypes = Component3.childContextTypes;
          if (childContextTypes != null) {
            var previousContext = task.legacyContext, mergedContext = processChildContext(instance2, Component3, previousContext, childContextTypes);
            task.legacyContext = mergedContext, renderNodeDestructive(request, task, nextChildren), task.legacyContext = previousContext;
            return;
          }
        }
        renderNodeDestructive(request, task, nextChildren);
      }
      function renderClassComponent(request, task, Component3, props) {
        pushClassComponentStackInDEV(task, Component3);
        var maskedContext = getMaskedContext(Component3, task.legacyContext), instance2 = constructClassInstance(Component3, props, maskedContext);
        mountClassInstance(instance2, Component3, props, maskedContext), finishClassComponent(request, task, instance2, Component3, props), popComponentStackInDEV(task);
      }
      var didWarnAboutBadClass = {}, didWarnAboutModulePatternComponent = {}, didWarnAboutContextTypeOnFunctionComponent = {}, didWarnAboutGetDerivedStateOnFunctionComponent = {}, didWarnAboutReassigningProps = !1, didWarnAboutGenerators = !1, didWarnAboutMaps = !1, hasWarnedAboutUsingContextAsConsumer = !1;
      function renderIndeterminateComponent(request, task, Component3, props) {
        var legacyContext;
        if (legacyContext = getMaskedContext(Component3, task.legacyContext), pushFunctionComponentStackInDEV(task, Component3), Component3.prototype && typeof Component3.prototype.render == "function") {
          var componentName = getComponentNameFromType(Component3) || "Unknown";
          didWarnAboutBadClass[componentName] || (error2("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName), didWarnAboutBadClass[componentName] = !0);
        }
        var value2 = renderWithHooks(request, task, Component3, props, legacyContext), hasId = checkDidRenderIdHook();
        if (typeof value2 == "object" && value2 !== null && typeof value2.render == "function" && value2.$$typeof === void 0) {
          var _componentName = getComponentNameFromType(Component3) || "Unknown";
          didWarnAboutModulePatternComponent[_componentName] || (error2("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName), didWarnAboutModulePatternComponent[_componentName] = !0);
        }
        if (typeof value2 == "object" && value2 !== null && typeof value2.render == "function" && value2.$$typeof === void 0) {
          {
            var _componentName2 = getComponentNameFromType(Component3) || "Unknown";
            didWarnAboutModulePatternComponent[_componentName2] || (error2("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2), didWarnAboutModulePatternComponent[_componentName2] = !0);
          }
          mountClassInstance(value2, Component3, props, legacyContext), finishClassComponent(request, task, value2, Component3, props);
        } else if (validateFunctionComponentInDev(Component3), hasId) {
          var prevTreeContext = task.treeContext, totalChildren = 1, index2 = 0;
          task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index2);
          try {
            renderNodeDestructive(request, task, value2);
          } finally {
            task.treeContext = prevTreeContext;
          }
        } else
          renderNodeDestructive(request, task, value2);
        popComponentStackInDEV(task);
      }
      function validateFunctionComponentInDev(Component3) {
        {
          if (Component3 && Component3.childContextTypes && error2("%s(...): childContextTypes cannot be defined on a function component.", Component3.displayName || Component3.name || "Component"), typeof Component3.getDerivedStateFromProps == "function") {
            var _componentName3 = getComponentNameFromType(Component3) || "Unknown";
            didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] || (error2("%s: Function components do not support getDerivedStateFromProps.", _componentName3), didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = !0);
          }
          if (typeof Component3.contextType == "object" && Component3.contextType !== null) {
            var _componentName4 = getComponentNameFromType(Component3) || "Unknown";
            didWarnAboutContextTypeOnFunctionComponent[_componentName4] || (error2("%s: Function components do not support contextType.", _componentName4), didWarnAboutContextTypeOnFunctionComponent[_componentName4] = !0);
          }
        }
      }
      function resolveDefaultProps(Component3, baseProps) {
        if (Component3 && Component3.defaultProps) {
          var props = assign({}, baseProps), defaultProps = Component3.defaultProps;
          for (var propName in defaultProps)
            props[propName] === void 0 && (props[propName] = defaultProps[propName]);
          return props;
        }
        return baseProps;
      }
      function renderForwardRef(request, task, type2, props, ref) {
        pushFunctionComponentStackInDEV(task, type2.render);
        var children = renderWithHooks(request, task, type2.render, props, ref), hasId = checkDidRenderIdHook();
        if (hasId) {
          var prevTreeContext = task.treeContext, totalChildren = 1, index2 = 0;
          task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index2);
          try {
            renderNodeDestructive(request, task, children);
          } finally {
            task.treeContext = prevTreeContext;
          }
        } else
          renderNodeDestructive(request, task, children);
        popComponentStackInDEV(task);
      }
      function renderMemo(request, task, type2, props, ref) {
        var innerType = type2.type, resolvedProps = resolveDefaultProps(innerType, props);
        renderElement(request, task, innerType, resolvedProps, ref);
      }
      function renderContextConsumer(request, task, context, props) {
        context._context === void 0 ? context !== context.Consumer && (hasWarnedAboutUsingContextAsConsumer || (hasWarnedAboutUsingContextAsConsumer = !0, error2("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : context = context._context;
        var render = props.children;
        typeof render != "function" && error2("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
        var newValue = readContext(context), newChildren = render(newValue);
        renderNodeDestructive(request, task, newChildren);
      }
      function renderContextProvider(request, task, type2, props) {
        var context = type2._context, value2 = props.value, children = props.children, prevSnapshot;
        prevSnapshot = task.context, task.context = pushProvider(context, value2), renderNodeDestructive(request, task, children), task.context = popProvider(context), prevSnapshot !== task.context && error2("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
      }
      function renderLazyComponent(request, task, lazyComponent, props, ref) {
        pushBuiltInComponentStackInDEV(task, "Lazy");
        var payload = lazyComponent._payload, init4 = lazyComponent._init, Component3 = init4(payload), resolvedProps = resolveDefaultProps(Component3, props);
        renderElement(request, task, Component3, resolvedProps, ref), popComponentStackInDEV(task);
      }
      function renderElement(request, task, type2, props, ref) {
        if (typeof type2 == "function")
          if (shouldConstruct$1(type2)) {
            renderClassComponent(request, task, type2, props);
            return;
          } else {
            renderIndeterminateComponent(request, task, type2, props);
            return;
          }
        if (typeof type2 == "string") {
          renderHostElement(request, task, type2, props);
          return;
        }
        switch (type2) {
          case REACT_LEGACY_HIDDEN_TYPE:
          case REACT_DEBUG_TRACING_MODE_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_FRAGMENT_TYPE: {
            renderNodeDestructive(request, task, props.children);
            return;
          }
          case REACT_SUSPENSE_LIST_TYPE: {
            pushBuiltInComponentStackInDEV(task, "SuspenseList"), renderNodeDestructive(request, task, props.children), popComponentStackInDEV(task);
            return;
          }
          case REACT_SCOPE_TYPE:
            throw new Error("ReactDOMServer does not yet support scope components.");
          case REACT_SUSPENSE_TYPE: {
            renderSuspenseBoundary(request, task, props);
            return;
          }
        }
        if (typeof type2 == "object" && type2 !== null)
          switch (type2.$$typeof) {
            case REACT_FORWARD_REF_TYPE: {
              renderForwardRef(request, task, type2, props, ref);
              return;
            }
            case REACT_MEMO_TYPE: {
              renderMemo(request, task, type2, props, ref);
              return;
            }
            case REACT_PROVIDER_TYPE: {
              renderContextProvider(request, task, type2, props);
              return;
            }
            case REACT_CONTEXT_TYPE: {
              renderContextConsumer(request, task, type2, props);
              return;
            }
            case REACT_LAZY_TYPE: {
              renderLazyComponent(request, task, type2, props);
              return;
            }
          }
        var info = "";
        throw (type2 === void 0 || typeof type2 == "object" && type2 !== null && Object.keys(type2).length === 0) && (info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."), new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (type2 == null ? type2 : typeof type2) + "." + info));
      }
      function validateIterable(iterable, iteratorFn) {
        typeof Symbol == "function" && iterable[Symbol.toStringTag] === "Generator" && (didWarnAboutGenerators || error2("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), didWarnAboutGenerators = !0), iterable.entries === iteratorFn && (didWarnAboutMaps || error2("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), didWarnAboutMaps = !0);
      }
      function renderNodeDestructive(request, task, node) {
        try {
          return renderNodeDestructiveImpl(request, task, node);
        } catch (x2) {
          throw typeof x2 == "object" && x2 !== null && typeof x2.then == "function" || (lastBoundaryErrorComponentStackDev = lastBoundaryErrorComponentStackDev !== null ? lastBoundaryErrorComponentStackDev : getCurrentStackInDEV()), x2;
        }
      }
      function renderNodeDestructiveImpl(request, task, node) {
        if (task.node = node, typeof node == "object" && node !== null) {
          switch (node.$$typeof) {
            case REACT_ELEMENT_TYPE: {
              var element = node, type2 = element.type, props = element.props, ref = element.ref;
              renderElement(request, task, type2, props, ref);
              return;
            }
            case REACT_PORTAL_TYPE:
              throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
            case REACT_LAZY_TYPE: {
              var lazyNode = node, payload = lazyNode._payload, init4 = lazyNode._init, resolvedNode;
              try {
                resolvedNode = init4(payload);
              } catch (x2) {
                throw typeof x2 == "object" && x2 !== null && typeof x2.then == "function" && pushBuiltInComponentStackInDEV(task, "Lazy"), x2;
              }
              renderNodeDestructive(request, task, resolvedNode);
              return;
            }
          }
          if (isArray3(node)) {
            renderChildrenArray(request, task, node);
            return;
          }
          var iteratorFn = getIteratorFn(node);
          if (iteratorFn) {
            validateIterable(node, iteratorFn);
            var iterator = iteratorFn.call(node);
            if (iterator) {
              var step = iterator.next();
              if (!step.done) {
                var children = [];
                do
                  children.push(step.value), step = iterator.next();
                while (!step.done);
                renderChildrenArray(request, task, children);
                return;
              }
              return;
            }
          }
          var childString = Object.prototype.toString.call(node);
          throw new Error("Objects are not valid as a React child (found: " + (childString === "[object Object]" ? "object with keys {" + Object.keys(node).join(", ") + "}" : childString) + "). If you meant to render a collection of children, use an array instead.");
        }
        if (typeof node == "string") {
          var segment = task.blockedSegment;
          segment.lastPushedText = pushTextInstance$1(task.blockedSegment.chunks, node, request.responseState, segment.lastPushedText);
          return;
        }
        if (typeof node == "number") {
          var _segment = task.blockedSegment;
          _segment.lastPushedText = pushTextInstance$1(task.blockedSegment.chunks, "" + node, request.responseState, _segment.lastPushedText);
          return;
        }
        typeof node == "function" && error2("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
      }
      function renderChildrenArray(request, task, children) {
        for (var totalChildren = children.length, i3 = 0; i3 < totalChildren; i3++) {
          var prevTreeContext = task.treeContext;
          task.treeContext = pushTreeContext(prevTreeContext, totalChildren, i3);
          try {
            renderNode(request, task, children[i3]);
          } finally {
            task.treeContext = prevTreeContext;
          }
        }
      }
      function spawnNewSuspendedTask(request, task, x2) {
        var segment = task.blockedSegment, insertionIndex = segment.chunks.length, newSegment = createPendingSegment(
          request,
          insertionIndex,
          null,
          segment.formatContext,
          segment.lastPushedText,
          !0
        );
        segment.children.push(newSegment), segment.lastPushedText = !1;
        var newTask = createTask(request, task.node, task.blockedBoundary, newSegment, task.abortSet, task.legacyContext, task.context, task.treeContext);
        task.componentStack !== null && (newTask.componentStack = task.componentStack.parent);
        var ping = newTask.ping;
        x2.then(ping, ping);
      }
      function renderNode(request, task, node) {
        var previousFormatContext = task.blockedSegment.formatContext, previousLegacyContext = task.legacyContext, previousContext = task.context, previousComponentStack = null;
        previousComponentStack = task.componentStack;
        try {
          return renderNodeDestructive(request, task, node);
        } catch (x2) {
          if (resetHooksState(), typeof x2 == "object" && x2 !== null && typeof x2.then == "function") {
            spawnNewSuspendedTask(request, task, x2), task.blockedSegment.formatContext = previousFormatContext, task.legacyContext = previousLegacyContext, task.context = previousContext, switchContext(previousContext), task.componentStack = previousComponentStack;
            return;
          } else
            throw task.blockedSegment.formatContext = previousFormatContext, task.legacyContext = previousLegacyContext, task.context = previousContext, switchContext(previousContext), task.componentStack = previousComponentStack, x2;
        }
      }
      function erroredTask(request, boundary, segment, error3) {
        var errorDigest = logRecoverableError(request, error3);
        if (boundary === null ? fatalError(request, error3) : (boundary.pendingTasks--, boundary.forceClientRender || (boundary.forceClientRender = !0, boundary.errorDigest = errorDigest, captureBoundaryErrorDetailsDev(boundary, error3), boundary.parentFlushed && request.clientRenderedBoundaries.push(boundary))), request.allPendingTasks--, request.allPendingTasks === 0) {
          var onAllReady = request.onAllReady;
          onAllReady();
        }
      }
      function abortTaskSoft(task) {
        var request = this, boundary = task.blockedBoundary, segment = task.blockedSegment;
        segment.status = ABORTED, finishedTask(request, boundary, segment);
      }
      function abortTask(task, request, reason) {
        var boundary = task.blockedBoundary, segment = task.blockedSegment;
        if (segment.status = ABORTED, boundary === null)
          request.allPendingTasks--, request.status !== CLOSED && (request.status = CLOSED, request.destination !== null && close(request.destination));
        else {
          if (boundary.pendingTasks--, !boundary.forceClientRender) {
            boundary.forceClientRender = !0;
            var _error = reason === void 0 ? new Error("The render was aborted by the server without a reason.") : reason;
            boundary.errorDigest = request.onError(_error);
            {
              var errorPrefix = "The server did not finish this Suspense boundary: ";
              _error && typeof _error.message == "string" ? _error = errorPrefix + _error.message : _error = errorPrefix + String(_error);
              var previousTaskInDev = currentTaskInDEV;
              currentTaskInDEV = task;
              try {
                captureBoundaryErrorDetailsDev(boundary, _error);
              } finally {
                currentTaskInDEV = previousTaskInDev;
              }
            }
            boundary.parentFlushed && request.clientRenderedBoundaries.push(boundary);
          }
          if (boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
            return abortTask(fallbackTask, request, reason);
          }), boundary.fallbackAbortableTasks.clear(), request.allPendingTasks--, request.allPendingTasks === 0) {
            var onAllReady = request.onAllReady;
            onAllReady();
          }
        }
      }
      function queueCompletedSegment(boundary, segment) {
        if (segment.chunks.length === 0 && segment.children.length === 1 && segment.children[0].boundary === null) {
          var childSegment = segment.children[0];
          childSegment.id = segment.id, childSegment.parentFlushed = !0, childSegment.status === COMPLETED && queueCompletedSegment(boundary, childSegment);
        } else {
          var completedSegments = boundary.completedSegments;
          completedSegments.push(segment);
        }
      }
      function finishedTask(request, boundary, segment) {
        if (boundary === null) {
          if (segment.parentFlushed) {
            if (request.completedRootSegment !== null)
              throw new Error("There can only be one root segment. This is a bug in React.");
            request.completedRootSegment = segment;
          }
          if (request.pendingRootTasks--, request.pendingRootTasks === 0) {
            request.onShellError = noop$1;
            var onShellReady = request.onShellReady;
            onShellReady();
          }
        } else if (boundary.pendingTasks--, !boundary.forceClientRender) {
          if (boundary.pendingTasks === 0)
            segment.parentFlushed && segment.status === COMPLETED && queueCompletedSegment(boundary, segment), boundary.parentFlushed && request.completedBoundaries.push(boundary), boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request), boundary.fallbackAbortableTasks.clear();
          else if (segment.parentFlushed && segment.status === COMPLETED) {
            queueCompletedSegment(boundary, segment);
            var completedSegments = boundary.completedSegments;
            completedSegments.length === 1 && boundary.parentFlushed && request.partialBoundaries.push(boundary);
          }
        }
        if (request.allPendingTasks--, request.allPendingTasks === 0) {
          var onAllReady = request.onAllReady;
          onAllReady();
        }
      }
      function retryTask(request, task) {
        var segment = task.blockedSegment;
        if (segment.status === PENDING) {
          switchContext(task.context);
          var prevTaskInDEV = null;
          prevTaskInDEV = currentTaskInDEV, currentTaskInDEV = task;
          try {
            renderNodeDestructive(request, task, task.node), pushSegmentFinale$1(segment.chunks, request.responseState, segment.lastPushedText, segment.textEmbedded), task.abortSet.delete(task), segment.status = COMPLETED, finishedTask(request, task.blockedBoundary, segment);
          } catch (x2) {
            if (resetHooksState(), typeof x2 == "object" && x2 !== null && typeof x2.then == "function") {
              var ping = task.ping;
              x2.then(ping, ping);
            } else
              task.abortSet.delete(task), segment.status = ERRORED, erroredTask(request, task.blockedBoundary, segment, x2);
          } finally {
            currentTaskInDEV = prevTaskInDEV;
          }
        }
      }
      function performWork(request) {
        if (request.status !== CLOSED) {
          var prevContext = getActiveContext(), prevDispatcher = ReactCurrentDispatcher$1.current;
          ReactCurrentDispatcher$1.current = Dispatcher;
          var prevGetCurrentStackImpl;
          prevGetCurrentStackImpl = ReactDebugCurrentFrame$1.getCurrentStack, ReactDebugCurrentFrame$1.getCurrentStack = getCurrentStackInDEV;
          var prevResponseState = currentResponseState;
          setCurrentResponseState(request.responseState);
          try {
            var pingedTasks = request.pingedTasks, i3;
            for (i3 = 0; i3 < pingedTasks.length; i3++) {
              var task = pingedTasks[i3];
              retryTask(request, task);
            }
            pingedTasks.splice(0, i3), request.destination !== null && flushCompletedQueues(request, request.destination);
          } catch (error3) {
            logRecoverableError(request, error3), fatalError(request, error3);
          } finally {
            setCurrentResponseState(prevResponseState), ReactCurrentDispatcher$1.current = prevDispatcher, ReactDebugCurrentFrame$1.getCurrentStack = prevGetCurrentStackImpl, prevDispatcher === Dispatcher && switchContext(prevContext);
          }
        }
      }
      function flushSubtree(request, destination, segment) {
        switch (segment.parentFlushed = !0, segment.status) {
          case PENDING: {
            var segmentID = segment.id = request.nextSegmentId++;
            return segment.lastPushedText = !1, segment.textEmbedded = !1, writePlaceholder(destination, request.responseState, segmentID);
          }
          case COMPLETED: {
            segment.status = FLUSHED;
            for (var r3 = !0, chunks = segment.chunks, chunkIdx = 0, children = segment.children, childIdx = 0; childIdx < children.length; childIdx++) {
              for (var nextChild = children[childIdx]; chunkIdx < nextChild.index; chunkIdx++)
                writeChunk(destination, chunks[chunkIdx]);
              r3 = flushSegment(request, destination, nextChild);
            }
            for (; chunkIdx < chunks.length - 1; chunkIdx++)
              writeChunk(destination, chunks[chunkIdx]);
            return chunkIdx < chunks.length && (r3 = writeChunkAndReturn(destination, chunks[chunkIdx])), r3;
          }
          default:
            throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
        }
      }
      function flushSegment(request, destination, segment) {
        var boundary = segment.boundary;
        if (boundary === null)
          return flushSubtree(request, destination, segment);
        if (boundary.parentFlushed = !0, boundary.forceClientRender)
          return writeStartClientRenderedSuspenseBoundary$1(destination, request.responseState, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack), flushSubtree(request, destination, segment), writeEndClientRenderedSuspenseBoundary$1(destination, request.responseState);
        if (boundary.pendingTasks > 0) {
          boundary.rootSegmentID = request.nextSegmentId++, boundary.completedSegments.length > 0 && request.partialBoundaries.push(boundary);
          var id4 = boundary.id = assignSuspenseBoundaryID(request.responseState);
          return writeStartPendingSuspenseBoundary(destination, request.responseState, id4), flushSubtree(request, destination, segment), writeEndPendingSuspenseBoundary(destination, request.responseState);
        } else {
          if (boundary.byteSize > request.progressiveChunkSize)
            return boundary.rootSegmentID = request.nextSegmentId++, request.completedBoundaries.push(boundary), writeStartPendingSuspenseBoundary(destination, request.responseState, boundary.id), flushSubtree(request, destination, segment), writeEndPendingSuspenseBoundary(destination, request.responseState);
          writeStartCompletedSuspenseBoundary$1(destination, request.responseState);
          var completedSegments = boundary.completedSegments;
          if (completedSegments.length !== 1)
            throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
          var contentSegment = completedSegments[0];
          return flushSegment(request, destination, contentSegment), writeEndCompletedSuspenseBoundary$1(destination, request.responseState);
        }
      }
      function flushClientRenderedBoundary(request, destination, boundary) {
        return writeClientRenderBoundaryInstruction(destination, request.responseState, boundary.id, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
      }
      function flushSegmentContainer(request, destination, segment) {
        return writeStartSegment(destination, request.responseState, segment.formatContext, segment.id), flushSegment(request, destination, segment), writeEndSegment(destination, segment.formatContext);
      }
      function flushCompletedBoundary(request, destination, boundary) {
        for (var completedSegments = boundary.completedSegments, i3 = 0; i3 < completedSegments.length; i3++) {
          var segment = completedSegments[i3];
          flushPartiallyCompletedSegment(request, destination, boundary, segment);
        }
        return completedSegments.length = 0, writeCompletedBoundaryInstruction(destination, request.responseState, boundary.id, boundary.rootSegmentID);
      }
      function flushPartialBoundary(request, destination, boundary) {
        for (var completedSegments = boundary.completedSegments, i3 = 0; i3 < completedSegments.length; i3++) {
          var segment = completedSegments[i3];
          if (!flushPartiallyCompletedSegment(request, destination, boundary, segment))
            return i3++, completedSegments.splice(0, i3), !1;
        }
        return completedSegments.splice(0, i3), !0;
      }
      function flushPartiallyCompletedSegment(request, destination, boundary, segment) {
        if (segment.status === FLUSHED)
          return !0;
        var segmentID = segment.id;
        if (segmentID === -1) {
          var rootSegmentID = segment.id = boundary.rootSegmentID;
          if (rootSegmentID === -1)
            throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
          return flushSegmentContainer(request, destination, segment);
        } else
          return flushSegmentContainer(request, destination, segment), writeCompletedSegmentInstruction(destination, request.responseState, segmentID);
      }
      function flushCompletedQueues(request, destination) {
        try {
          var completedRootSegment = request.completedRootSegment;
          completedRootSegment !== null && request.pendingRootTasks === 0 && (flushSegment(request, destination, completedRootSegment), request.completedRootSegment = null, writeCompletedRoot(destination, request.responseState));
          var clientRenderedBoundaries = request.clientRenderedBoundaries, i3;
          for (i3 = 0; i3 < clientRenderedBoundaries.length; i3++) {
            var boundary = clientRenderedBoundaries[i3];
            if (!flushClientRenderedBoundary(request, destination, boundary)) {
              request.destination = null, i3++, clientRenderedBoundaries.splice(0, i3);
              return;
            }
          }
          clientRenderedBoundaries.splice(0, i3);
          var completedBoundaries = request.completedBoundaries;
          for (i3 = 0; i3 < completedBoundaries.length; i3++) {
            var _boundary = completedBoundaries[i3];
            if (!flushCompletedBoundary(request, destination, _boundary)) {
              request.destination = null, i3++, completedBoundaries.splice(0, i3);
              return;
            }
          }
          completedBoundaries.splice(0, i3);
          var partialBoundaries = request.partialBoundaries;
          for (i3 = 0; i3 < partialBoundaries.length; i3++) {
            var _boundary2 = partialBoundaries[i3];
            if (!flushPartialBoundary(request, destination, _boundary2)) {
              request.destination = null, i3++, partialBoundaries.splice(0, i3);
              return;
            }
          }
          partialBoundaries.splice(0, i3);
          var largeBoundaries = request.completedBoundaries;
          for (i3 = 0; i3 < largeBoundaries.length; i3++) {
            var _boundary3 = largeBoundaries[i3];
            if (!flushCompletedBoundary(request, destination, _boundary3)) {
              request.destination = null, i3++, largeBoundaries.splice(0, i3);
              return;
            }
          }
          largeBoundaries.splice(0, i3);
        } finally {
          request.allPendingTasks === 0 && request.pingedTasks.length === 0 && request.clientRenderedBoundaries.length === 0 && request.completedBoundaries.length === 0 && (request.abortableTasks.size !== 0 && error2("There was still abortable task at the root when we closed. This is a bug in React."), close(destination));
        }
      }
      function startWork(request) {
        scheduleWork(function() {
          return performWork(request);
        });
      }
      function startFlowing(request, destination) {
        if (request.status === CLOSING) {
          request.status = CLOSED, closeWithError(destination, request.fatalError);
          return;
        }
        if (request.status !== CLOSED && request.destination === null) {
          request.destination = destination;
          try {
            flushCompletedQueues(request, destination);
          } catch (error3) {
            logRecoverableError(request, error3), fatalError(request, error3);
          }
        }
      }
      function abort(request, reason) {
        try {
          var abortableTasks = request.abortableTasks;
          abortableTasks.forEach(function(task) {
            return abortTask(task, request, reason);
          }), abortableTasks.clear(), request.destination !== null && flushCompletedQueues(request, request.destination);
        } catch (error3) {
          logRecoverableError(request, error3), fatalError(request, error3);
        }
      }
      function onError() {
      }
      function renderToStringImpl(children, options2, generateStaticMarkup, abortReason) {
        var didFatal = !1, fatalError2 = null, result2 = "", destination = {
          push: function(chunk) {
            return chunk !== null && (result2 += chunk), !0;
          },
          destroy: function(error3) {
            didFatal = !0, fatalError2 = error3;
          }
        }, readyToStream = !1;
        function onShellReady() {
          readyToStream = !0;
        }
        var request = createRequest(children, createResponseState$1(generateStaticMarkup, options2 ? options2.identifierPrefix : void 0), createRootFormatContext(), 1 / 0, onError, void 0, onShellReady, void 0, void 0);
        if (startWork(request), abort(request, abortReason), startFlowing(request, destination), didFatal)
          throw fatalError2;
        if (!readyToStream)
          throw new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
        return result2;
      }
      function renderToString2(children, options2) {
        return renderToStringImpl(children, options2, !1, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
      }
      function renderToStaticMarkup(children, options2) {
        return renderToStringImpl(children, options2, !0, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
      }
      function renderToNodeStream() {
        throw new Error("ReactDOMServer.renderToNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToString() instead.");
      }
      function renderToStaticNodeStream() {
        throw new Error("ReactDOMServer.renderToStaticNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToStaticMarkup() instead.");
      }
      exports.renderToNodeStream = renderToNodeStream, exports.renderToStaticMarkup = renderToStaticMarkup, exports.renderToStaticNodeStream = renderToStaticNodeStream, exports.renderToString = renderToString2, exports.version = ReactVersion;
    })();
  }
});

// node_modules/react-dom/cjs/react-dom-server.browser.development.js
var require_react_dom_server_browser_development = __commonJS({
  "node_modules/react-dom/cjs/react-dom-server.browser.development.js"(exports) {
    "use strict";
    (function() {
      "use strict";
      var React17 = require_react(), ReactVersion = "18.2.0", ReactSharedInternals = React17.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function warn3(format2) {
        {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
            args[_key - 1] = arguments[_key];
          printWarning("warn", format2, args);
        }
      }
      function error2(format2) {
        {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)
            args[_key2 - 1] = arguments[_key2];
          printWarning("error", format2, args);
        }
      }
      function printWarning(level, format2, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame, stack2 = ReactDebugCurrentFrame2.getStackAddendum();
          stack2 !== "" && (format2 += "%s", args = args.concat([stack2]));
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format2), Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      function scheduleWork(callback) {
        callback();
      }
      var VIEW_SIZE = 512, currentView = null, writtenBytes = 0;
      function beginWriting(destination) {
        currentView = new Uint8Array(VIEW_SIZE), writtenBytes = 0;
      }
      function writeChunk(destination, chunk) {
        if (chunk.length !== 0) {
          if (chunk.length > VIEW_SIZE) {
            writtenBytes > 0 && (destination.enqueue(new Uint8Array(currentView.buffer, 0, writtenBytes)), currentView = new Uint8Array(VIEW_SIZE), writtenBytes = 0), destination.enqueue(chunk);
            return;
          }
          var bytesToWrite = chunk, allowableBytes = currentView.length - writtenBytes;
          allowableBytes < bytesToWrite.length && (allowableBytes === 0 ? destination.enqueue(currentView) : (currentView.set(bytesToWrite.subarray(0, allowableBytes), writtenBytes), destination.enqueue(currentView), bytesToWrite = bytesToWrite.subarray(allowableBytes)), currentView = new Uint8Array(VIEW_SIZE), writtenBytes = 0), currentView.set(bytesToWrite, writtenBytes), writtenBytes += bytesToWrite.length;
        }
      }
      function writeChunkAndReturn(destination, chunk) {
        return writeChunk(destination, chunk), !0;
      }
      function completeWriting(destination) {
        currentView && writtenBytes > 0 && (destination.enqueue(new Uint8Array(currentView.buffer, 0, writtenBytes)), currentView = null, writtenBytes = 0);
      }
      function close(destination) {
        destination.close();
      }
      var textEncoder = new TextEncoder();
      function stringToChunk(content) {
        return textEncoder.encode(content);
      }
      function stringToPrecomputedChunk(content) {
        return textEncoder.encode(content);
      }
      function closeWithError(destination, error3) {
        typeof destination.error == "function" ? destination.error(error3) : destination.close();
      }
      function typeName(value2) {
        {
          var hasToStringTag = typeof Symbol == "function" && Symbol.toStringTag, type2 = hasToStringTag && value2[Symbol.toStringTag] || value2.constructor.name || "Object";
          return type2;
        }
      }
      function willCoercionThrow(value2) {
        try {
          return testStringCoercion(value2), !1;
        } catch {
          return !0;
        }
      }
      function testStringCoercion(value2) {
        return "" + value2;
      }
      function checkAttributeStringCoercion(value2, attributeName) {
        if (willCoercionThrow(value2))
          return error2("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", attributeName, typeName(value2)), testStringCoercion(value2);
      }
      function checkCSSPropertyStringCoercion(value2, propName) {
        if (willCoercionThrow(value2))
          return error2("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value2)), testStringCoercion(value2);
      }
      function checkHtmlStringCoercion(value2) {
        if (willCoercionThrow(value2))
          return error2("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value2)), testStringCoercion(value2);
      }
      var hasOwnProperty2 = Object.prototype.hasOwnProperty, RESERVED = 0, STRING = 1, BOOLEANISH_STRING = 2, BOOLEAN = 3, OVERLOADED_BOOLEAN = 4, NUMERIC = 5, POSITIVE_NUMERIC = 6, ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$"), illegalAttributeNameCache = {}, validatedAttributeNameCache = {};
      function isAttributeNameSafe(attributeName) {
        return hasOwnProperty2.call(validatedAttributeNameCache, attributeName) ? !0 : hasOwnProperty2.call(illegalAttributeNameCache, attributeName) ? !1 : VALID_ATTRIBUTE_NAME_REGEX.test(attributeName) ? (validatedAttributeNameCache[attributeName] = !0, !0) : (illegalAttributeNameCache[attributeName] = !0, error2("Invalid attribute name: `%s`", attributeName), !1);
      }
      function shouldRemoveAttributeWithWarning(name, value2, propertyInfo, isCustomComponentTag) {
        if (propertyInfo !== null && propertyInfo.type === RESERVED)
          return !1;
        switch (typeof value2) {
          case "function":
          case "symbol":
            return !0;
          case "boolean": {
            if (isCustomComponentTag)
              return !1;
            if (propertyInfo !== null)
              return !propertyInfo.acceptsBooleans;
            var prefix2 = name.toLowerCase().slice(0, 5);
            return prefix2 !== "data-" && prefix2 !== "aria-";
          }
          default:
            return !1;
        }
      }
      function getPropertyInfo(name) {
        return properties.hasOwnProperty(name) ? properties[name] : null;
      }
      function PropertyInfoRecord(name, type2, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
        this.acceptsBooleans = type2 === BOOLEANISH_STRING || type2 === BOOLEAN || type2 === OVERLOADED_BOOLEAN, this.attributeName = attributeName, this.attributeNamespace = attributeNamespace, this.mustUseProperty = mustUseProperty, this.propertyName = name, this.type = type2, this.sanitizeURL = sanitizeURL2, this.removeEmptyString = removeEmptyString;
      }
      var properties = {}, reservedProps = [
        "children",
        "dangerouslySetInnerHTML",
        "defaultValue",
        "defaultChecked",
        "innerHTML",
        "suppressContentEditableWarning",
        "suppressHydrationWarning",
        "style"
      ];
      reservedProps.forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          RESERVED,
          !1,
          name,
          null,
          !1,
          !1
        );
      }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
        var name = _ref[0], attributeName = _ref[1];
        properties[name] = new PropertyInfoRecord(
          name,
          STRING,
          !1,
          attributeName,
          null,
          !1,
          !1
        );
      }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          BOOLEANISH_STRING,
          !1,
          name.toLowerCase(),
          null,
          !1,
          !1
        );
      }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          BOOLEANISH_STRING,
          !1,
          name,
          null,
          !1,
          !1
        );
      }), [
        "allowFullScreen",
        "async",
        "autoFocus",
        "autoPlay",
        "controls",
        "default",
        "defer",
        "disabled",
        "disablePictureInPicture",
        "disableRemotePlayback",
        "formNoValidate",
        "hidden",
        "loop",
        "noModule",
        "noValidate",
        "open",
        "playsInline",
        "readOnly",
        "required",
        "reversed",
        "scoped",
        "seamless",
        "itemScope"
      ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          BOOLEAN,
          !1,
          name.toLowerCase(),
          null,
          !1,
          !1
        );
      }), [
        "checked",
        "multiple",
        "muted",
        "selected"
      ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          BOOLEAN,
          !0,
          name,
          null,
          !1,
          !1
        );
      }), [
        "capture",
        "download"
      ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          OVERLOADED_BOOLEAN,
          !1,
          name,
          null,
          !1,
          !1
        );
      }), [
        "cols",
        "rows",
        "size",
        "span"
      ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          POSITIVE_NUMERIC,
          !1,
          name,
          null,
          !1,
          !1
        );
      }), ["rowSpan", "start"].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(
          name,
          NUMERIC,
          !1,
          name.toLowerCase(),
          null,
          !1,
          !1
        );
      });
      var CAMELIZE = /[\-\:]([a-z])/g, capitalize2 = function(token2) {
        return token2[1].toUpperCase();
      };
      [
        "accent-height",
        "alignment-baseline",
        "arabic-form",
        "baseline-shift",
        "cap-height",
        "clip-path",
        "clip-rule",
        "color-interpolation",
        "color-interpolation-filters",
        "color-profile",
        "color-rendering",
        "dominant-baseline",
        "enable-background",
        "fill-opacity",
        "fill-rule",
        "flood-color",
        "flood-opacity",
        "font-family",
        "font-size",
        "font-size-adjust",
        "font-stretch",
        "font-style",
        "font-variant",
        "font-weight",
        "glyph-name",
        "glyph-orientation-horizontal",
        "glyph-orientation-vertical",
        "horiz-adv-x",
        "horiz-origin-x",
        "image-rendering",
        "letter-spacing",
        "lighting-color",
        "marker-end",
        "marker-mid",
        "marker-start",
        "overline-position",
        "overline-thickness",
        "paint-order",
        "panose-1",
        "pointer-events",
        "rendering-intent",
        "shape-rendering",
        "stop-color",
        "stop-opacity",
        "strikethrough-position",
        "strikethrough-thickness",
        "stroke-dasharray",
        "stroke-dashoffset",
        "stroke-linecap",
        "stroke-linejoin",
        "stroke-miterlimit",
        "stroke-opacity",
        "stroke-width",
        "text-anchor",
        "text-decoration",
        "text-rendering",
        "underline-position",
        "underline-thickness",
        "unicode-bidi",
        "unicode-range",
        "units-per-em",
        "v-alphabetic",
        "v-hanging",
        "v-ideographic",
        "v-mathematical",
        "vector-effect",
        "vert-adv-y",
        "vert-origin-x",
        "vert-origin-y",
        "word-spacing",
        "writing-mode",
        "xmlns:xlink",
        "x-height"
      ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize2);
        properties[name] = new PropertyInfoRecord(
          name,
          STRING,
          !1,
          attributeName,
          null,
          !1,
          !1
        );
      }), [
        "xlink:actuate",
        "xlink:arcrole",
        "xlink:role",
        "xlink:show",
        "xlink:title",
        "xlink:type"
      ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize2);
        properties[name] = new PropertyInfoRecord(
          name,
          STRING,
          !1,
          attributeName,
          "http://www.w3.org/1999/xlink",
          !1,
          !1
        );
      }), [
        "xml:base",
        "xml:lang",
        "xml:space"
      ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize2);
        properties[name] = new PropertyInfoRecord(
          name,
          STRING,
          !1,
          attributeName,
          "http://www.w3.org/XML/1998/namespace",
          !1,
          !1
        );
      }), ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
        properties[attributeName] = new PropertyInfoRecord(
          attributeName,
          STRING,
          !1,
          attributeName.toLowerCase(),
          null,
          !1,
          !1
        );
      });
      var xlinkHref = "xlinkHref";
      properties[xlinkHref] = new PropertyInfoRecord(
        "xlinkHref",
        STRING,
        !1,
        "xlink:href",
        "http://www.w3.org/1999/xlink",
        !0,
        !1
      ), ["src", "href", "action", "formAction"].forEach(function(attributeName) {
        properties[attributeName] = new PropertyInfoRecord(
          attributeName,
          STRING,
          !1,
          attributeName.toLowerCase(),
          null,
          !0,
          !0
        );
      });
      var isUnitlessNumber = {
        animationIterationCount: !0,
        aspectRatio: !0,
        borderImageOutset: !0,
        borderImageSlice: !0,
        borderImageWidth: !0,
        boxFlex: !0,
        boxFlexGroup: !0,
        boxOrdinalGroup: !0,
        columnCount: !0,
        columns: !0,
        flex: !0,
        flexGrow: !0,
        flexPositive: !0,
        flexShrink: !0,
        flexNegative: !0,
        flexOrder: !0,
        gridArea: !0,
        gridRow: !0,
        gridRowEnd: !0,
        gridRowSpan: !0,
        gridRowStart: !0,
        gridColumn: !0,
        gridColumnEnd: !0,
        gridColumnSpan: !0,
        gridColumnStart: !0,
        fontWeight: !0,
        lineClamp: !0,
        lineHeight: !0,
        opacity: !0,
        order: !0,
        orphans: !0,
        tabSize: !0,
        widows: !0,
        zIndex: !0,
        zoom: !0,
        fillOpacity: !0,
        floodOpacity: !0,
        stopOpacity: !0,
        strokeDasharray: !0,
        strokeDashoffset: !0,
        strokeMiterlimit: !0,
        strokeOpacity: !0,
        strokeWidth: !0
      };
      function prefixKey(prefix2, key2) {
        return prefix2 + key2.charAt(0).toUpperCase() + key2.substring(1);
      }
      var prefixes = ["Webkit", "ms", "Moz", "O"];
      Object.keys(isUnitlessNumber).forEach(function(prop) {
        prefixes.forEach(function(prefix2) {
          isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];
        });
      });
      var hasReadOnlyValue = {
        button: !0,
        checkbox: !0,
        image: !0,
        hidden: !0,
        radio: !0,
        reset: !0,
        submit: !0
      };
      function checkControlledValueProps(tagName, props) {
        hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null || error2("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), props.onChange || props.readOnly || props.disabled || props.checked == null || error2("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
      }
      function isCustomComponent(tagName, props) {
        if (tagName.indexOf("-") === -1)
          return typeof props.is == "string";
        switch (tagName) {
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return !1;
          default:
            return !0;
        }
      }
      var ariaProperties = {
        "aria-current": 0,
        "aria-description": 0,
        "aria-details": 0,
        "aria-disabled": 0,
        "aria-hidden": 0,
        "aria-invalid": 0,
        "aria-keyshortcuts": 0,
        "aria-label": 0,
        "aria-roledescription": 0,
        "aria-autocomplete": 0,
        "aria-checked": 0,
        "aria-expanded": 0,
        "aria-haspopup": 0,
        "aria-level": 0,
        "aria-modal": 0,
        "aria-multiline": 0,
        "aria-multiselectable": 0,
        "aria-orientation": 0,
        "aria-placeholder": 0,
        "aria-pressed": 0,
        "aria-readonly": 0,
        "aria-required": 0,
        "aria-selected": 0,
        "aria-sort": 0,
        "aria-valuemax": 0,
        "aria-valuemin": 0,
        "aria-valuenow": 0,
        "aria-valuetext": 0,
        "aria-atomic": 0,
        "aria-busy": 0,
        "aria-live": 0,
        "aria-relevant": 0,
        "aria-dropeffect": 0,
        "aria-grabbed": 0,
        "aria-activedescendant": 0,
        "aria-colcount": 0,
        "aria-colindex": 0,
        "aria-colspan": 0,
        "aria-controls": 0,
        "aria-describedby": 0,
        "aria-errormessage": 0,
        "aria-flowto": 0,
        "aria-labelledby": 0,
        "aria-owns": 0,
        "aria-posinset": 0,
        "aria-rowcount": 0,
        "aria-rowindex": 0,
        "aria-rowspan": 0,
        "aria-setsize": 0
      }, warnedProperties = {}, rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$"), rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
      function validateProperty(tagName, name) {
        {
          if (hasOwnProperty2.call(warnedProperties, name) && warnedProperties[name])
            return !0;
          if (rARIACamel.test(name)) {
            var ariaName = "aria-" + name.slice(4).toLowerCase(), correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
            if (correctName == null)
              return error2("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name), warnedProperties[name] = !0, !0;
            if (name !== correctName)
              return error2("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, correctName), warnedProperties[name] = !0, !0;
          }
          if (rARIA.test(name)) {
            var lowerCasedName = name.toLowerCase(), standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
            if (standardName == null)
              return warnedProperties[name] = !0, !1;
            if (name !== standardName)
              return error2("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, standardName), warnedProperties[name] = !0, !0;
          }
        }
        return !0;
      }
      function warnInvalidARIAProps(type2, props) {
        {
          var invalidProps = [];
          for (var key2 in props) {
            var isValid = validateProperty(type2, key2);
            isValid || invalidProps.push(key2);
          }
          var unknownPropString = invalidProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          invalidProps.length === 1 ? error2("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type2) : invalidProps.length > 1 && error2("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type2);
        }
      }
      function validateProperties(type2, props) {
        isCustomComponent(type2, props) || warnInvalidARIAProps(type2, props);
      }
      var didWarnValueNull = !1;
      function validateProperties$1(type2, props) {
        {
          if (type2 !== "input" && type2 !== "textarea" && type2 !== "select")
            return;
          props != null && props.value === null && !didWarnValueNull && (didWarnValueNull = !0, type2 === "select" && props.multiple ? error2("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type2) : error2("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type2));
        }
      }
      var possibleStandardNames = {
        accept: "accept",
        acceptcharset: "acceptCharset",
        "accept-charset": "acceptCharset",
        accesskey: "accessKey",
        action: "action",
        allowfullscreen: "allowFullScreen",
        alt: "alt",
        as: "as",
        async: "async",
        autocapitalize: "autoCapitalize",
        autocomplete: "autoComplete",
        autocorrect: "autoCorrect",
        autofocus: "autoFocus",
        autoplay: "autoPlay",
        autosave: "autoSave",
        capture: "capture",
        cellpadding: "cellPadding",
        cellspacing: "cellSpacing",
        challenge: "challenge",
        charset: "charSet",
        checked: "checked",
        children: "children",
        cite: "cite",
        class: "className",
        classid: "classID",
        classname: "className",
        cols: "cols",
        colspan: "colSpan",
        content: "content",
        contenteditable: "contentEditable",
        contextmenu: "contextMenu",
        controls: "controls",
        controlslist: "controlsList",
        coords: "coords",
        crossorigin: "crossOrigin",
        dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
        data: "data",
        datetime: "dateTime",
        default: "default",
        defaultchecked: "defaultChecked",
        defaultvalue: "defaultValue",
        defer: "defer",
        dir: "dir",
        disabled: "disabled",
        disablepictureinpicture: "disablePictureInPicture",
        disableremoteplayback: "disableRemotePlayback",
        download: "download",
        draggable: "draggable",
        enctype: "encType",
        enterkeyhint: "enterKeyHint",
        for: "htmlFor",
        form: "form",
        formmethod: "formMethod",
        formaction: "formAction",
        formenctype: "formEncType",
        formnovalidate: "formNoValidate",
        formtarget: "formTarget",
        frameborder: "frameBorder",
        headers: "headers",
        height: "height",
        hidden: "hidden",
        high: "high",
        href: "href",
        hreflang: "hrefLang",
        htmlfor: "htmlFor",
        httpequiv: "httpEquiv",
        "http-equiv": "httpEquiv",
        icon: "icon",
        id: "id",
        imagesizes: "imageSizes",
        imagesrcset: "imageSrcSet",
        innerhtml: "innerHTML",
        inputmode: "inputMode",
        integrity: "integrity",
        is: "is",
        itemid: "itemID",
        itemprop: "itemProp",
        itemref: "itemRef",
        itemscope: "itemScope",
        itemtype: "itemType",
        keyparams: "keyParams",
        keytype: "keyType",
        kind: "kind",
        label: "label",
        lang: "lang",
        list: "list",
        loop: "loop",
        low: "low",
        manifest: "manifest",
        marginwidth: "marginWidth",
        marginheight: "marginHeight",
        max: "max",
        maxlength: "maxLength",
        media: "media",
        mediagroup: "mediaGroup",
        method: "method",
        min: "min",
        minlength: "minLength",
        multiple: "multiple",
        muted: "muted",
        name: "name",
        nomodule: "noModule",
        nonce: "nonce",
        novalidate: "noValidate",
        open: "open",
        optimum: "optimum",
        pattern: "pattern",
        placeholder: "placeholder",
        playsinline: "playsInline",
        poster: "poster",
        preload: "preload",
        profile: "profile",
        radiogroup: "radioGroup",
        readonly: "readOnly",
        referrerpolicy: "referrerPolicy",
        rel: "rel",
        required: "required",
        reversed: "reversed",
        role: "role",
        rows: "rows",
        rowspan: "rowSpan",
        sandbox: "sandbox",
        scope: "scope",
        scoped: "scoped",
        scrolling: "scrolling",
        seamless: "seamless",
        selected: "selected",
        shape: "shape",
        size: "size",
        sizes: "sizes",
        span: "span",
        spellcheck: "spellCheck",
        src: "src",
        srcdoc: "srcDoc",
        srclang: "srcLang",
        srcset: "srcSet",
        start: "start",
        step: "step",
        style: "style",
        summary: "summary",
        tabindex: "tabIndex",
        target: "target",
        title: "title",
        type: "type",
        usemap: "useMap",
        value: "value",
        width: "width",
        wmode: "wmode",
        wrap: "wrap",
        about: "about",
        accentheight: "accentHeight",
        "accent-height": "accentHeight",
        accumulate: "accumulate",
        additive: "additive",
        alignmentbaseline: "alignmentBaseline",
        "alignment-baseline": "alignmentBaseline",
        allowreorder: "allowReorder",
        alphabetic: "alphabetic",
        amplitude: "amplitude",
        arabicform: "arabicForm",
        "arabic-form": "arabicForm",
        ascent: "ascent",
        attributename: "attributeName",
        attributetype: "attributeType",
        autoreverse: "autoReverse",
        azimuth: "azimuth",
        basefrequency: "baseFrequency",
        baselineshift: "baselineShift",
        "baseline-shift": "baselineShift",
        baseprofile: "baseProfile",
        bbox: "bbox",
        begin: "begin",
        bias: "bias",
        by: "by",
        calcmode: "calcMode",
        capheight: "capHeight",
        "cap-height": "capHeight",
        clip: "clip",
        clippath: "clipPath",
        "clip-path": "clipPath",
        clippathunits: "clipPathUnits",
        cliprule: "clipRule",
        "clip-rule": "clipRule",
        color: "color",
        colorinterpolation: "colorInterpolation",
        "color-interpolation": "colorInterpolation",
        colorinterpolationfilters: "colorInterpolationFilters",
        "color-interpolation-filters": "colorInterpolationFilters",
        colorprofile: "colorProfile",
        "color-profile": "colorProfile",
        colorrendering: "colorRendering",
        "color-rendering": "colorRendering",
        contentscripttype: "contentScriptType",
        contentstyletype: "contentStyleType",
        cursor: "cursor",
        cx: "cx",
        cy: "cy",
        d: "d",
        datatype: "datatype",
        decelerate: "decelerate",
        descent: "descent",
        diffuseconstant: "diffuseConstant",
        direction: "direction",
        display: "display",
        divisor: "divisor",
        dominantbaseline: "dominantBaseline",
        "dominant-baseline": "dominantBaseline",
        dur: "dur",
        dx: "dx",
        dy: "dy",
        edgemode: "edgeMode",
        elevation: "elevation",
        enablebackground: "enableBackground",
        "enable-background": "enableBackground",
        end: "end",
        exponent: "exponent",
        externalresourcesrequired: "externalResourcesRequired",
        fill: "fill",
        fillopacity: "fillOpacity",
        "fill-opacity": "fillOpacity",
        fillrule: "fillRule",
        "fill-rule": "fillRule",
        filter: "filter",
        filterres: "filterRes",
        filterunits: "filterUnits",
        floodopacity: "floodOpacity",
        "flood-opacity": "floodOpacity",
        floodcolor: "floodColor",
        "flood-color": "floodColor",
        focusable: "focusable",
        fontfamily: "fontFamily",
        "font-family": "fontFamily",
        fontsize: "fontSize",
        "font-size": "fontSize",
        fontsizeadjust: "fontSizeAdjust",
        "font-size-adjust": "fontSizeAdjust",
        fontstretch: "fontStretch",
        "font-stretch": "fontStretch",
        fontstyle: "fontStyle",
        "font-style": "fontStyle",
        fontvariant: "fontVariant",
        "font-variant": "fontVariant",
        fontweight: "fontWeight",
        "font-weight": "fontWeight",
        format: "format",
        from: "from",
        fx: "fx",
        fy: "fy",
        g1: "g1",
        g2: "g2",
        glyphname: "glyphName",
        "glyph-name": "glyphName",
        glyphorientationhorizontal: "glyphOrientationHorizontal",
        "glyph-orientation-horizontal": "glyphOrientationHorizontal",
        glyphorientationvertical: "glyphOrientationVertical",
        "glyph-orientation-vertical": "glyphOrientationVertical",
        glyphref: "glyphRef",
        gradienttransform: "gradientTransform",
        gradientunits: "gradientUnits",
        hanging: "hanging",
        horizadvx: "horizAdvX",
        "horiz-adv-x": "horizAdvX",
        horizoriginx: "horizOriginX",
        "horiz-origin-x": "horizOriginX",
        ideographic: "ideographic",
        imagerendering: "imageRendering",
        "image-rendering": "imageRendering",
        in2: "in2",
        in: "in",
        inlist: "inlist",
        intercept: "intercept",
        k1: "k1",
        k2: "k2",
        k3: "k3",
        k4: "k4",
        k: "k",
        kernelmatrix: "kernelMatrix",
        kernelunitlength: "kernelUnitLength",
        kerning: "kerning",
        keypoints: "keyPoints",
        keysplines: "keySplines",
        keytimes: "keyTimes",
        lengthadjust: "lengthAdjust",
        letterspacing: "letterSpacing",
        "letter-spacing": "letterSpacing",
        lightingcolor: "lightingColor",
        "lighting-color": "lightingColor",
        limitingconeangle: "limitingConeAngle",
        local: "local",
        markerend: "markerEnd",
        "marker-end": "markerEnd",
        markerheight: "markerHeight",
        markermid: "markerMid",
        "marker-mid": "markerMid",
        markerstart: "markerStart",
        "marker-start": "markerStart",
        markerunits: "markerUnits",
        markerwidth: "markerWidth",
        mask: "mask",
        maskcontentunits: "maskContentUnits",
        maskunits: "maskUnits",
        mathematical: "mathematical",
        mode: "mode",
        numoctaves: "numOctaves",
        offset: "offset",
        opacity: "opacity",
        operator: "operator",
        order: "order",
        orient: "orient",
        orientation: "orientation",
        origin: "origin",
        overflow: "overflow",
        overlineposition: "overlinePosition",
        "overline-position": "overlinePosition",
        overlinethickness: "overlineThickness",
        "overline-thickness": "overlineThickness",
        paintorder: "paintOrder",
        "paint-order": "paintOrder",
        panose1: "panose1",
        "panose-1": "panose1",
        pathlength: "pathLength",
        patterncontentunits: "patternContentUnits",
        patterntransform: "patternTransform",
        patternunits: "patternUnits",
        pointerevents: "pointerEvents",
        "pointer-events": "pointerEvents",
        points: "points",
        pointsatx: "pointsAtX",
        pointsaty: "pointsAtY",
        pointsatz: "pointsAtZ",
        prefix: "prefix",
        preservealpha: "preserveAlpha",
        preserveaspectratio: "preserveAspectRatio",
        primitiveunits: "primitiveUnits",
        property: "property",
        r: "r",
        radius: "radius",
        refx: "refX",
        refy: "refY",
        renderingintent: "renderingIntent",
        "rendering-intent": "renderingIntent",
        repeatcount: "repeatCount",
        repeatdur: "repeatDur",
        requiredextensions: "requiredExtensions",
        requiredfeatures: "requiredFeatures",
        resource: "resource",
        restart: "restart",
        result: "result",
        results: "results",
        rotate: "rotate",
        rx: "rx",
        ry: "ry",
        scale: "scale",
        security: "security",
        seed: "seed",
        shaperendering: "shapeRendering",
        "shape-rendering": "shapeRendering",
        slope: "slope",
        spacing: "spacing",
        specularconstant: "specularConstant",
        specularexponent: "specularExponent",
        speed: "speed",
        spreadmethod: "spreadMethod",
        startoffset: "startOffset",
        stddeviation: "stdDeviation",
        stemh: "stemh",
        stemv: "stemv",
        stitchtiles: "stitchTiles",
        stopcolor: "stopColor",
        "stop-color": "stopColor",
        stopopacity: "stopOpacity",
        "stop-opacity": "stopOpacity",
        strikethroughposition: "strikethroughPosition",
        "strikethrough-position": "strikethroughPosition",
        strikethroughthickness: "strikethroughThickness",
        "strikethrough-thickness": "strikethroughThickness",
        string: "string",
        stroke: "stroke",
        strokedasharray: "strokeDasharray",
        "stroke-dasharray": "strokeDasharray",
        strokedashoffset: "strokeDashoffset",
        "stroke-dashoffset": "strokeDashoffset",
        strokelinecap: "strokeLinecap",
        "stroke-linecap": "strokeLinecap",
        strokelinejoin: "strokeLinejoin",
        "stroke-linejoin": "strokeLinejoin",
        strokemiterlimit: "strokeMiterlimit",
        "stroke-miterlimit": "strokeMiterlimit",
        strokewidth: "strokeWidth",
        "stroke-width": "strokeWidth",
        strokeopacity: "strokeOpacity",
        "stroke-opacity": "strokeOpacity",
        suppresscontenteditablewarning: "suppressContentEditableWarning",
        suppresshydrationwarning: "suppressHydrationWarning",
        surfacescale: "surfaceScale",
        systemlanguage: "systemLanguage",
        tablevalues: "tableValues",
        targetx: "targetX",
        targety: "targetY",
        textanchor: "textAnchor",
        "text-anchor": "textAnchor",
        textdecoration: "textDecoration",
        "text-decoration": "textDecoration",
        textlength: "textLength",
        textrendering: "textRendering",
        "text-rendering": "textRendering",
        to: "to",
        transform: "transform",
        typeof: "typeof",
        u1: "u1",
        u2: "u2",
        underlineposition: "underlinePosition",
        "underline-position": "underlinePosition",
        underlinethickness: "underlineThickness",
        "underline-thickness": "underlineThickness",
        unicode: "unicode",
        unicodebidi: "unicodeBidi",
        "unicode-bidi": "unicodeBidi",
        unicoderange: "unicodeRange",
        "unicode-range": "unicodeRange",
        unitsperem: "unitsPerEm",
        "units-per-em": "unitsPerEm",
        unselectable: "unselectable",
        valphabetic: "vAlphabetic",
        "v-alphabetic": "vAlphabetic",
        values: "values",
        vectoreffect: "vectorEffect",
        "vector-effect": "vectorEffect",
        version: "version",
        vertadvy: "vertAdvY",
        "vert-adv-y": "vertAdvY",
        vertoriginx: "vertOriginX",
        "vert-origin-x": "vertOriginX",
        vertoriginy: "vertOriginY",
        "vert-origin-y": "vertOriginY",
        vhanging: "vHanging",
        "v-hanging": "vHanging",
        videographic: "vIdeographic",
        "v-ideographic": "vIdeographic",
        viewbox: "viewBox",
        viewtarget: "viewTarget",
        visibility: "visibility",
        vmathematical: "vMathematical",
        "v-mathematical": "vMathematical",
        vocab: "vocab",
        widths: "widths",
        wordspacing: "wordSpacing",
        "word-spacing": "wordSpacing",
        writingmode: "writingMode",
        "writing-mode": "writingMode",
        x1: "x1",
        x2: "x2",
        x: "x",
        xchannelselector: "xChannelSelector",
        xheight: "xHeight",
        "x-height": "xHeight",
        xlinkactuate: "xlinkActuate",
        "xlink:actuate": "xlinkActuate",
        xlinkarcrole: "xlinkArcrole",
        "xlink:arcrole": "xlinkArcrole",
        xlinkhref: "xlinkHref",
        "xlink:href": "xlinkHref",
        xlinkrole: "xlinkRole",
        "xlink:role": "xlinkRole",
        xlinkshow: "xlinkShow",
        "xlink:show": "xlinkShow",
        xlinktitle: "xlinkTitle",
        "xlink:title": "xlinkTitle",
        xlinktype: "xlinkType",
        "xlink:type": "xlinkType",
        xmlbase: "xmlBase",
        "xml:base": "xmlBase",
        xmllang: "xmlLang",
        "xml:lang": "xmlLang",
        xmlns: "xmlns",
        "xml:space": "xmlSpace",
        xmlnsxlink: "xmlnsXlink",
        "xmlns:xlink": "xmlnsXlink",
        xmlspace: "xmlSpace",
        y1: "y1",
        y2: "y2",
        y: "y",
        ychannelselector: "yChannelSelector",
        z: "z",
        zoomandpan: "zoomAndPan"
      }, validateProperty$1 = function() {
      };
      {
        var warnedProperties$1 = {}, EVENT_NAME_REGEX = /^on./, INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/, rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$"), rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
        validateProperty$1 = function(tagName, name, value2, eventRegistry) {
          if (hasOwnProperty2.call(warnedProperties$1, name) && warnedProperties$1[name])
            return !0;
          var lowerCasedName = name.toLowerCase();
          if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout")
            return error2("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), warnedProperties$1[name] = !0, !0;
          if (eventRegistry != null) {
            var registrationNameDependencies = eventRegistry.registrationNameDependencies, possibleRegistrationNames = eventRegistry.possibleRegistrationNames;
            if (registrationNameDependencies.hasOwnProperty(name))
              return !0;
            var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
            if (registrationName != null)
              return error2("Invalid event handler property `%s`. Did you mean `%s`?", name, registrationName), warnedProperties$1[name] = !0, !0;
            if (EVENT_NAME_REGEX.test(name))
              return error2("Unknown event handler property `%s`. It will be ignored.", name), warnedProperties$1[name] = !0, !0;
          } else if (EVENT_NAME_REGEX.test(name))
            return INVALID_EVENT_NAME_REGEX.test(name) && error2("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name), warnedProperties$1[name] = !0, !0;
          if (rARIA$1.test(name) || rARIACamel$1.test(name))
            return !0;
          if (lowerCasedName === "innerhtml")
            return error2("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), warnedProperties$1[name] = !0, !0;
          if (lowerCasedName === "aria")
            return error2("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), warnedProperties$1[name] = !0, !0;
          if (lowerCasedName === "is" && value2 !== null && value2 !== void 0 && typeof value2 != "string")
            return error2("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value2), warnedProperties$1[name] = !0, !0;
          if (typeof value2 == "number" && isNaN(value2))
            return error2("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name), warnedProperties$1[name] = !0, !0;
          var propertyInfo = getPropertyInfo(name), isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
          if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
            var standardName = possibleStandardNames[lowerCasedName];
            if (standardName !== name)
              return error2("Invalid DOM property `%s`. Did you mean `%s`?", name, standardName), warnedProperties$1[name] = !0, !0;
          } else if (!isReserved && name !== lowerCasedName)
            return error2("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName), warnedProperties$1[name] = !0, !0;
          return typeof value2 == "boolean" && shouldRemoveAttributeWithWarning(name, value2, propertyInfo, !1) ? (value2 ? error2('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value2, name, name, value2, name) : error2('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value2, name, name, value2, name, name, name), warnedProperties$1[name] = !0, !0) : isReserved ? !0 : shouldRemoveAttributeWithWarning(name, value2, propertyInfo, !1) ? (warnedProperties$1[name] = !0, !1) : ((value2 === "false" || value2 === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN && (error2("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value2, name, value2 === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value2), warnedProperties$1[name] = !0), !0);
        };
      }
      var warnUnknownProperties = function(type2, props, eventRegistry) {
        {
          var unknownProps = [];
          for (var key2 in props) {
            var isValid = validateProperty$1(type2, key2, props[key2], eventRegistry);
            isValid || unknownProps.push(key2);
          }
          var unknownPropString = unknownProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          unknownProps.length === 1 ? error2("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type2) : unknownProps.length > 1 && error2("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type2);
        }
      };
      function validateProperties$2(type2, props, eventRegistry) {
        isCustomComponent(type2, props) || warnUnknownProperties(type2, props, eventRegistry);
      }
      var warnValidStyle = function() {
      };
      {
        var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/, msPattern = /^-ms-/, hyphenPattern = /-(.)/g, badStyleValueWithSemicolonPattern = /;\s*$/, warnedStyleNames = {}, warnedStyleValues = {}, warnedForNaNValue = !1, warnedForInfinityValue = !1, camelize = function(string2) {
          return string2.replace(hyphenPattern, function(_24, character) {
            return character.toUpperCase();
          });
        }, warnHyphenatedStyleName = function(name) {
          warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name] || (warnedStyleNames[name] = !0, error2(
            "Unsupported style property %s. Did you mean %s?",
            name,
            camelize(name.replace(msPattern, "ms-"))
          ));
        }, warnBadVendoredStyleName = function(name) {
          warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name] || (warnedStyleNames[name] = !0, error2("Unsupported vendor-prefixed style property %s. Did you mean %s?", name, name.charAt(0).toUpperCase() + name.slice(1)));
        }, warnStyleValueWithSemicolon = function(name, value2) {
          warnedStyleValues.hasOwnProperty(value2) && warnedStyleValues[value2] || (warnedStyleValues[value2] = !0, error2(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name, value2.replace(badStyleValueWithSemicolonPattern, "")));
        }, warnStyleValueIsNaN = function(name, value2) {
          warnedForNaNValue || (warnedForNaNValue = !0, error2("`NaN` is an invalid value for the `%s` css style property.", name));
        }, warnStyleValueIsInfinity = function(name, value2) {
          warnedForInfinityValue || (warnedForInfinityValue = !0, error2("`Infinity` is an invalid value for the `%s` css style property.", name));
        };
        warnValidStyle = function(name, value2) {
          name.indexOf("-") > -1 ? warnHyphenatedStyleName(name) : badVendoredStyleNamePattern.test(name) ? warnBadVendoredStyleName(name) : badStyleValueWithSemicolonPattern.test(value2) && warnStyleValueWithSemicolon(name, value2), typeof value2 == "number" && (isNaN(value2) ? warnStyleValueIsNaN(name, value2) : isFinite(value2) || warnStyleValueIsInfinity(name, value2));
        };
      }
      var warnValidStyle$1 = warnValidStyle, matchHtmlRegExp = /["'&<>]/;
      function escapeHtml3(string2) {
        checkHtmlStringCoercion(string2);
        var str2 = "" + string2, match = matchHtmlRegExp.exec(str2);
        if (!match)
          return str2;
        var escape4, html = "", index2, lastIndex = 0;
        for (index2 = match.index; index2 < str2.length; index2++) {
          switch (str2.charCodeAt(index2)) {
            case 34:
              escape4 = "&quot;";
              break;
            case 38:
              escape4 = "&amp;";
              break;
            case 39:
              escape4 = "&#x27;";
              break;
            case 60:
              escape4 = "&lt;";
              break;
            case 62:
              escape4 = "&gt;";
              break;
            default:
              continue;
          }
          lastIndex !== index2 && (html += str2.substring(lastIndex, index2)), lastIndex = index2 + 1, html += escape4;
        }
        return lastIndex !== index2 ? html + str2.substring(lastIndex, index2) : html;
      }
      function escapeTextForBrowser(text) {
        return typeof text == "boolean" || typeof text == "number" ? "" + text : escapeHtml3(text);
      }
      var uppercasePattern = /([A-Z])/g, msPattern$1 = /^ms-/;
      function hyphenateStyleName(name) {
        return name.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-");
      }
      var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, didWarn = !1;
      function sanitizeURL(url) {
        !didWarn && isJavaScriptProtocol.test(url) && (didWarn = !0, error2("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url)));
      }
      var isArrayImpl = Array.isArray;
      function isArray3(a3) {
        return isArrayImpl(a3);
      }
      var startInlineScript = stringToPrecomputedChunk("<script>"), endInlineScript = stringToPrecomputedChunk("</script>"), startScriptSrc = stringToPrecomputedChunk('<script src="'), startModuleSrc = stringToPrecomputedChunk('<script type="module" src="'), endAsyncScript = stringToPrecomputedChunk('" async=""></script>');
      function escapeBootstrapScriptContent(scriptText) {
        return checkHtmlStringCoercion(scriptText), ("" + scriptText).replace(scriptRegex, scriptReplacer);
      }
      var scriptRegex = /(<\/|<)(s)(cript)/gi, scriptReplacer = function(match, prefix2, s3, suffix) {
        return "" + prefix2 + (s3 === "s" ? "\\u0073" : "\\u0053") + suffix;
      };
      function createResponseState(identifierPrefix, nonce, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {
        var idPrefix = identifierPrefix === void 0 ? "" : identifierPrefix, inlineScriptWithNonce = nonce === void 0 ? startInlineScript : stringToPrecomputedChunk('<script nonce="' + escapeTextForBrowser(nonce) + '">'), bootstrapChunks = [];
        if (bootstrapScriptContent !== void 0 && bootstrapChunks.push(inlineScriptWithNonce, stringToChunk(escapeBootstrapScriptContent(bootstrapScriptContent)), endInlineScript), bootstrapScripts !== void 0)
          for (var i3 = 0; i3 < bootstrapScripts.length; i3++)
            bootstrapChunks.push(startScriptSrc, stringToChunk(escapeTextForBrowser(bootstrapScripts[i3])), endAsyncScript);
        if (bootstrapModules !== void 0)
          for (var _i = 0; _i < bootstrapModules.length; _i++)
            bootstrapChunks.push(startModuleSrc, stringToChunk(escapeTextForBrowser(bootstrapModules[_i])), endAsyncScript);
        return {
          bootstrapChunks,
          startInlineScript: inlineScriptWithNonce,
          placeholderPrefix: stringToPrecomputedChunk(idPrefix + "P:"),
          segmentPrefix: stringToPrecomputedChunk(idPrefix + "S:"),
          boundaryPrefix: idPrefix + "B:",
          idPrefix,
          nextSuspenseID: 0,
          sentCompleteSegmentFunction: !1,
          sentCompleteBoundaryFunction: !1,
          sentClientRenderFunction: !1
        };
      }
      var ROOT_HTML_MODE = 0, HTML_MODE = 1, SVG_MODE = 2, MATHML_MODE = 3, HTML_TABLE_MODE = 4, HTML_TABLE_BODY_MODE = 5, HTML_TABLE_ROW_MODE = 6, HTML_COLGROUP_MODE = 7;
      function createFormatContext(insertionMode, selectedValue) {
        return {
          insertionMode,
          selectedValue
        };
      }
      function createRootFormatContext(namespaceURI) {
        var insertionMode = namespaceURI === "http://www.w3.org/2000/svg" ? SVG_MODE : namespaceURI === "http://www.w3.org/1998/Math/MathML" ? MATHML_MODE : ROOT_HTML_MODE;
        return createFormatContext(insertionMode, null);
      }
      function getChildFormatContext(parentContext, type2, props) {
        switch (type2) {
          case "select":
            return createFormatContext(HTML_MODE, props.value != null ? props.value : props.defaultValue);
          case "svg":
            return createFormatContext(SVG_MODE, null);
          case "math":
            return createFormatContext(MATHML_MODE, null);
          case "foreignObject":
            return createFormatContext(HTML_MODE, null);
          case "table":
            return createFormatContext(HTML_TABLE_MODE, null);
          case "thead":
          case "tbody":
          case "tfoot":
            return createFormatContext(HTML_TABLE_BODY_MODE, null);
          case "colgroup":
            return createFormatContext(HTML_COLGROUP_MODE, null);
          case "tr":
            return createFormatContext(HTML_TABLE_ROW_MODE, null);
        }
        return parentContext.insertionMode >= HTML_TABLE_MODE || parentContext.insertionMode === ROOT_HTML_MODE ? createFormatContext(HTML_MODE, null) : parentContext;
      }
      var UNINITIALIZED_SUSPENSE_BOUNDARY_ID = null;
      function assignSuspenseBoundaryID(responseState) {
        var generatedID = responseState.nextSuspenseID++;
        return stringToPrecomputedChunk(responseState.boundaryPrefix + generatedID.toString(16));
      }
      function makeId(responseState, treeId, localId) {
        var idPrefix = responseState.idPrefix, id4 = ":" + idPrefix + "R" + treeId;
        return localId > 0 && (id4 += "H" + localId.toString(32)), id4 + ":";
      }
      function encodeHTMLTextNode(text) {
        return escapeTextForBrowser(text);
      }
      var textSeparator = stringToPrecomputedChunk("<!-- -->");
      function pushTextInstance(target, text, responseState, textEmbedded) {
        return text === "" ? textEmbedded : (textEmbedded && target.push(textSeparator), target.push(stringToChunk(encodeHTMLTextNode(text))), !0);
      }
      function pushSegmentFinale(target, responseState, lastPushedText, textEmbedded) {
        lastPushedText && textEmbedded && target.push(textSeparator);
      }
      var styleNameCache = /* @__PURE__ */ new Map();
      function processStyleName(styleName) {
        var chunk = styleNameCache.get(styleName);
        if (chunk !== void 0)
          return chunk;
        var result2 = stringToPrecomputedChunk(escapeTextForBrowser(hyphenateStyleName(styleName)));
        return styleNameCache.set(styleName, result2), result2;
      }
      var styleAttributeStart = stringToPrecomputedChunk(' style="'), styleAssign = stringToPrecomputedChunk(":"), styleSeparator = stringToPrecomputedChunk(";");
      function pushStyle(target, responseState, style) {
        if (typeof style != "object")
          throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
        var isFirst = !0;
        for (var styleName in style)
          if (!!hasOwnProperty2.call(style, styleName)) {
            var styleValue = style[styleName];
            if (!(styleValue == null || typeof styleValue == "boolean" || styleValue === "")) {
              var nameChunk = void 0, valueChunk = void 0, isCustomProperty = styleName.indexOf("--") === 0;
              isCustomProperty ? (nameChunk = stringToChunk(escapeTextForBrowser(styleName)), checkCSSPropertyStringCoercion(styleValue, styleName), valueChunk = stringToChunk(escapeTextForBrowser(("" + styleValue).trim()))) : (warnValidStyle$1(styleName, styleValue), nameChunk = processStyleName(styleName), typeof styleValue == "number" ? styleValue !== 0 && !hasOwnProperty2.call(isUnitlessNumber, styleName) ? valueChunk = stringToChunk(styleValue + "px") : valueChunk = stringToChunk("" + styleValue) : (checkCSSPropertyStringCoercion(styleValue, styleName), valueChunk = stringToChunk(escapeTextForBrowser(("" + styleValue).trim())))), isFirst ? (isFirst = !1, target.push(styleAttributeStart, nameChunk, styleAssign, valueChunk)) : target.push(styleSeparator, nameChunk, styleAssign, valueChunk);
            }
          }
        isFirst || target.push(attributeEnd);
      }
      var attributeSeparator = stringToPrecomputedChunk(" "), attributeAssign = stringToPrecomputedChunk('="'), attributeEnd = stringToPrecomputedChunk('"'), attributeEmptyString = stringToPrecomputedChunk('=""');
      function pushAttribute(target, responseState, name, value2) {
        switch (name) {
          case "style": {
            pushStyle(target, responseState, value2);
            return;
          }
          case "defaultValue":
          case "defaultChecked":
          case "innerHTML":
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
            return;
        }
        if (!(name.length > 2 && (name[0] === "o" || name[0] === "O") && (name[1] === "n" || name[1] === "N"))) {
          var propertyInfo = getPropertyInfo(name);
          if (propertyInfo !== null) {
            switch (typeof value2) {
              case "function":
              case "symbol":
                return;
              case "boolean":
                if (!propertyInfo.acceptsBooleans)
                  return;
            }
            var attributeName = propertyInfo.attributeName, attributeNameChunk = stringToChunk(attributeName);
            switch (propertyInfo.type) {
              case BOOLEAN:
                value2 && target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
                return;
              case OVERLOADED_BOOLEAN:
                value2 === !0 ? target.push(attributeSeparator, attributeNameChunk, attributeEmptyString) : value2 === !1 || target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value2)), attributeEnd);
                return;
              case NUMERIC:
                isNaN(value2) || target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value2)), attributeEnd);
                break;
              case POSITIVE_NUMERIC:
                !isNaN(value2) && value2 >= 1 && target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value2)), attributeEnd);
                break;
              default:
                propertyInfo.sanitizeURL && (checkAttributeStringCoercion(value2, attributeName), value2 = "" + value2, sanitizeURL(value2)), target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value2)), attributeEnd);
            }
          } else if (isAttributeNameSafe(name)) {
            switch (typeof value2) {
              case "function":
              case "symbol":
                return;
              case "boolean": {
                var prefix2 = name.toLowerCase().slice(0, 5);
                if (prefix2 !== "data-" && prefix2 !== "aria-")
                  return;
              }
            }
            target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value2)), attributeEnd);
          }
        }
      }
      var endOfStartTag = stringToPrecomputedChunk(">"), endOfStartTagSelfClosing = stringToPrecomputedChunk("/>");
      function pushInnerHTML(target, innerHTML, children) {
        if (innerHTML != null) {
          if (children != null)
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          if (typeof innerHTML != "object" || !("__html" in innerHTML))
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
          var html = innerHTML.__html;
          html != null && (checkHtmlStringCoercion(html), target.push(stringToChunk("" + html)));
        }
      }
      var didWarnDefaultInputValue = !1, didWarnDefaultChecked = !1, didWarnDefaultSelectValue = !1, didWarnDefaultTextareaValue = !1, didWarnInvalidOptionChildren = !1, didWarnInvalidOptionInnerHTML = !1, didWarnSelectedSetOnOption = !1;
      function checkSelectProp(props, propName) {
        {
          var value2 = props[propName];
          if (value2 != null) {
            var array = isArray3(value2);
            props.multiple && !array ? error2("The `%s` prop supplied to <select> must be an array if `multiple` is true.", propName) : !props.multiple && array && error2("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", propName);
          }
        }
      }
      function pushStartSelect(target, props, responseState) {
        checkControlledValueProps("select", props), checkSelectProp(props, "value"), checkSelectProp(props, "defaultValue"), props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultSelectValue && (error2("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), didWarnDefaultSelectValue = !0), target.push(startChunkForTag("select"));
        var children = null, innerHTML = null;
        for (var propKey in props)
          if (hasOwnProperty2.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null)
              continue;
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              case "defaultValue":
              case "value":
                break;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        return target.push(endOfStartTag), pushInnerHTML(target, innerHTML, children), children;
      }
      function flattenOptionChildren(children) {
        var content = "";
        return React17.Children.forEach(children, function(child) {
          child != null && (content += child, !didWarnInvalidOptionChildren && typeof child != "string" && typeof child != "number" && (didWarnInvalidOptionChildren = !0, error2("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
        }), content;
      }
      var selectedMarkerAttribute = stringToPrecomputedChunk(' selected=""');
      function pushStartOption(target, props, responseState, formatContext) {
        var selectedValue = formatContext.selectedValue;
        target.push(startChunkForTag("option"));
        var children = null, value2 = null, selected = null, innerHTML = null;
        for (var propKey in props)
          if (hasOwnProperty2.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null)
              continue;
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "selected":
                selected = propValue, didWarnSelectedSetOnOption || (error2("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), didWarnSelectedSetOnOption = !0);
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              case "value":
                value2 = propValue;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        if (selectedValue != null) {
          var stringValue;
          if (value2 !== null ? (checkAttributeStringCoercion(value2, "value"), stringValue = "" + value2) : (innerHTML !== null && (didWarnInvalidOptionInnerHTML || (didWarnInvalidOptionInnerHTML = !0, error2("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."))), stringValue = flattenOptionChildren(children)), isArray3(selectedValue))
            for (var i3 = 0; i3 < selectedValue.length; i3++) {
              checkAttributeStringCoercion(selectedValue[i3], "value");
              var v2 = "" + selectedValue[i3];
              if (v2 === stringValue) {
                target.push(selectedMarkerAttribute);
                break;
              }
            }
          else
            checkAttributeStringCoercion(selectedValue, "select.value"), "" + selectedValue === stringValue && target.push(selectedMarkerAttribute);
        } else
          selected && target.push(selectedMarkerAttribute);
        return target.push(endOfStartTag), pushInnerHTML(target, innerHTML, children), children;
      }
      function pushInput(target, props, responseState) {
        checkControlledValueProps("input", props), props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnDefaultChecked && (error2("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type), didWarnDefaultChecked = !0), props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultInputValue && (error2("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type), didWarnDefaultInputValue = !0), target.push(startChunkForTag("input"));
        var value2 = null, defaultValue = null, checked2 = null, defaultChecked = null;
        for (var propKey in props)
          if (hasOwnProperty2.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null)
              continue;
            switch (propKey) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              case "defaultChecked":
                defaultChecked = propValue;
                break;
              case "defaultValue":
                defaultValue = propValue;
                break;
              case "checked":
                checked2 = propValue;
                break;
              case "value":
                value2 = propValue;
                break;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        return checked2 !== null ? pushAttribute(target, responseState, "checked", checked2) : defaultChecked !== null && pushAttribute(target, responseState, "checked", defaultChecked), value2 !== null ? pushAttribute(target, responseState, "value", value2) : defaultValue !== null && pushAttribute(target, responseState, "value", defaultValue), target.push(endOfStartTagSelfClosing), null;
      }
      function pushStartTextArea(target, props, responseState) {
        checkControlledValueProps("textarea", props), props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultTextareaValue && (error2("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components"), didWarnDefaultTextareaValue = !0), target.push(startChunkForTag("textarea"));
        var value2 = null, defaultValue = null, children = null;
        for (var propKey in props)
          if (hasOwnProperty2.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null)
              continue;
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "value":
                value2 = propValue;
                break;
              case "defaultValue":
                defaultValue = propValue;
                break;
              case "dangerouslySetInnerHTML":
                throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        if (value2 === null && defaultValue !== null && (value2 = defaultValue), target.push(endOfStartTag), children != null) {
          if (error2("Use the `defaultValue` or `value` props instead of setting children on <textarea>."), value2 != null)
            throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
          if (isArray3(children)) {
            if (children.length > 1)
              throw new Error("<textarea> can only have at most one child.");
            checkHtmlStringCoercion(children[0]), value2 = "" + children[0];
          }
          checkHtmlStringCoercion(children), value2 = "" + children;
        }
        return typeof value2 == "string" && value2[0] === `
` && target.push(leadingNewline), value2 !== null && (checkAttributeStringCoercion(value2, "value"), target.push(stringToChunk(encodeHTMLTextNode("" + value2)))), null;
      }
      function pushSelfClosing(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        for (var propKey in props)
          if (hasOwnProperty2.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null)
              continue;
            switch (propKey) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw new Error(tag + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        return target.push(endOfStartTagSelfClosing), null;
      }
      function pushStartMenuItem(target, props, responseState) {
        target.push(startChunkForTag("menuitem"));
        for (var propKey in props)
          if (hasOwnProperty2.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null)
              continue;
            switch (propKey) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        return target.push(endOfStartTag), null;
      }
      function pushStartTitle(target, props, responseState) {
        target.push(startChunkForTag("title"));
        var children = null;
        for (var propKey in props)
          if (hasOwnProperty2.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null)
              continue;
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        target.push(endOfStartTag);
        {
          var child = Array.isArray(children) && children.length < 2 ? children[0] || null : children;
          Array.isArray(children) && children.length > 1 ? error2("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : child != null && child.$$typeof != null ? error2("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : child != null && typeof child != "string" && typeof child != "number" && error2("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
        }
        return children;
      }
      function pushStartGenericElement(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        var children = null, innerHTML = null;
        for (var propKey in props)
          if (hasOwnProperty2.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null)
              continue;
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        return target.push(endOfStartTag), pushInnerHTML(target, innerHTML, children), typeof children == "string" ? (target.push(stringToChunk(encodeHTMLTextNode(children))), null) : children;
      }
      function pushStartCustomElement(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        var children = null, innerHTML = null;
        for (var propKey in props)
          if (hasOwnProperty2.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null)
              continue;
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              case "style":
                pushStyle(target, responseState, propValue);
                break;
              case "suppressContentEditableWarning":
              case "suppressHydrationWarning":
                break;
              default:
                isAttributeNameSafe(propKey) && typeof propValue != "function" && typeof propValue != "symbol" && target.push(attributeSeparator, stringToChunk(propKey), attributeAssign, stringToChunk(escapeTextForBrowser(propValue)), attributeEnd);
                break;
            }
          }
        return target.push(endOfStartTag), pushInnerHTML(target, innerHTML, children), children;
      }
      var leadingNewline = stringToPrecomputedChunk(`
`);
      function pushStartPreformattedElement(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        var children = null, innerHTML = null;
        for (var propKey in props)
          if (hasOwnProperty2.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null)
              continue;
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        if (target.push(endOfStartTag), innerHTML != null) {
          if (children != null)
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          if (typeof innerHTML != "object" || !("__html" in innerHTML))
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
          var html = innerHTML.__html;
          html != null && (typeof html == "string" && html.length > 0 && html[0] === `
` ? target.push(leadingNewline, stringToChunk(html)) : (checkHtmlStringCoercion(html), target.push(stringToChunk("" + html))));
        }
        return typeof children == "string" && children[0] === `
` && target.push(leadingNewline), children;
      }
      var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, validatedTagCache = /* @__PURE__ */ new Map();
      function startChunkForTag(tag) {
        var tagStartChunk = validatedTagCache.get(tag);
        if (tagStartChunk === void 0) {
          if (!VALID_TAG_REGEX.test(tag))
            throw new Error("Invalid tag: " + tag);
          tagStartChunk = stringToPrecomputedChunk("<" + tag), validatedTagCache.set(tag, tagStartChunk);
        }
        return tagStartChunk;
      }
      var DOCTYPE = stringToPrecomputedChunk("<!DOCTYPE html>");
      function pushStartInstance(target, type2, props, responseState, formatContext) {
        switch (validateProperties(type2, props), validateProperties$1(type2, props), validateProperties$2(type2, props, null), !props.suppressContentEditableWarning && props.contentEditable && props.children != null && error2("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), formatContext.insertionMode !== SVG_MODE && formatContext.insertionMode !== MATHML_MODE && type2.indexOf("-") === -1 && typeof props.is != "string" && type2.toLowerCase() !== type2 && error2("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type2), type2) {
          case "select":
            return pushStartSelect(target, props, responseState);
          case "option":
            return pushStartOption(target, props, responseState, formatContext);
          case "textarea":
            return pushStartTextArea(target, props, responseState);
          case "input":
            return pushInput(target, props, responseState);
          case "menuitem":
            return pushStartMenuItem(target, props, responseState);
          case "title":
            return pushStartTitle(target, props, responseState);
          case "listing":
          case "pre":
            return pushStartPreformattedElement(target, props, type2, responseState);
          case "area":
          case "base":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "img":
          case "keygen":
          case "link":
          case "meta":
          case "param":
          case "source":
          case "track":
          case "wbr":
            return pushSelfClosing(target, props, type2, responseState);
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return pushStartGenericElement(target, props, type2, responseState);
          case "html":
            return formatContext.insertionMode === ROOT_HTML_MODE && target.push(DOCTYPE), pushStartGenericElement(target, props, type2, responseState);
          default:
            return type2.indexOf("-") === -1 && typeof props.is != "string" ? pushStartGenericElement(target, props, type2, responseState) : pushStartCustomElement(target, props, type2, responseState);
        }
      }
      var endTag1 = stringToPrecomputedChunk("</"), endTag2 = stringToPrecomputedChunk(">");
      function pushEndInstance(target, type2, props) {
        switch (type2) {
          case "area":
          case "base":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "img":
          case "input":
          case "keygen":
          case "link":
          case "meta":
          case "param":
          case "source":
          case "track":
          case "wbr":
            break;
          default:
            target.push(endTag1, stringToChunk(type2), endTag2);
        }
      }
      function writeCompletedRoot(destination, responseState) {
        for (var bootstrapChunks = responseState.bootstrapChunks, i3 = 0; i3 < bootstrapChunks.length - 1; i3++)
          writeChunk(destination, bootstrapChunks[i3]);
        return i3 < bootstrapChunks.length ? writeChunkAndReturn(destination, bootstrapChunks[i3]) : !0;
      }
      var placeholder1 = stringToPrecomputedChunk('<template id="'), placeholder2 = stringToPrecomputedChunk('"></template>');
      function writePlaceholder(destination, responseState, id4) {
        writeChunk(destination, placeholder1), writeChunk(destination, responseState.placeholderPrefix);
        var formattedID = stringToChunk(id4.toString(16));
        return writeChunk(destination, formattedID), writeChunkAndReturn(destination, placeholder2);
      }
      var startCompletedSuspenseBoundary = stringToPrecomputedChunk("<!--$-->"), startPendingSuspenseBoundary1 = stringToPrecomputedChunk('<!--$?--><template id="'), startPendingSuspenseBoundary2 = stringToPrecomputedChunk('"></template>'), startClientRenderedSuspenseBoundary = stringToPrecomputedChunk("<!--$!-->"), endSuspenseBoundary = stringToPrecomputedChunk("<!--/$-->"), clientRenderedSuspenseBoundaryError1 = stringToPrecomputedChunk("<template"), clientRenderedSuspenseBoundaryErrorAttrInterstitial = stringToPrecomputedChunk('"'), clientRenderedSuspenseBoundaryError1A = stringToPrecomputedChunk(' data-dgst="'), clientRenderedSuspenseBoundaryError1B = stringToPrecomputedChunk(' data-msg="'), clientRenderedSuspenseBoundaryError1C = stringToPrecomputedChunk(' data-stck="'), clientRenderedSuspenseBoundaryError2 = stringToPrecomputedChunk("></template>");
      function writeStartCompletedSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, startCompletedSuspenseBoundary);
      }
      function writeStartPendingSuspenseBoundary(destination, responseState, id4) {
        if (writeChunk(destination, startPendingSuspenseBoundary1), id4 === null)
          throw new Error("An ID must have been assigned before we can complete the boundary.");
        return writeChunk(destination, id4), writeChunkAndReturn(destination, startPendingSuspenseBoundary2);
      }
      function writeStartClientRenderedSuspenseBoundary(destination, responseState, errorDigest, errorMesssage, errorComponentStack) {
        var result2;
        return result2 = writeChunkAndReturn(destination, startClientRenderedSuspenseBoundary), writeChunk(destination, clientRenderedSuspenseBoundaryError1), errorDigest && (writeChunk(destination, clientRenderedSuspenseBoundaryError1A), writeChunk(destination, stringToChunk(escapeTextForBrowser(errorDigest))), writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial)), errorMesssage && (writeChunk(destination, clientRenderedSuspenseBoundaryError1B), writeChunk(destination, stringToChunk(escapeTextForBrowser(errorMesssage))), writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial)), errorComponentStack && (writeChunk(destination, clientRenderedSuspenseBoundaryError1C), writeChunk(destination, stringToChunk(escapeTextForBrowser(errorComponentStack))), writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial)), result2 = writeChunkAndReturn(destination, clientRenderedSuspenseBoundaryError2), result2;
      }
      function writeEndCompletedSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, endSuspenseBoundary);
      }
      function writeEndPendingSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, endSuspenseBoundary);
      }
      function writeEndClientRenderedSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, endSuspenseBoundary);
      }
      var startSegmentHTML = stringToPrecomputedChunk('<div hidden id="'), startSegmentHTML2 = stringToPrecomputedChunk('">'), endSegmentHTML = stringToPrecomputedChunk("</div>"), startSegmentSVG = stringToPrecomputedChunk('<svg aria-hidden="true" style="display:none" id="'), startSegmentSVG2 = stringToPrecomputedChunk('">'), endSegmentSVG = stringToPrecomputedChunk("</svg>"), startSegmentMathML = stringToPrecomputedChunk('<math aria-hidden="true" style="display:none" id="'), startSegmentMathML2 = stringToPrecomputedChunk('">'), endSegmentMathML = stringToPrecomputedChunk("</math>"), startSegmentTable = stringToPrecomputedChunk('<table hidden id="'), startSegmentTable2 = stringToPrecomputedChunk('">'), endSegmentTable = stringToPrecomputedChunk("</table>"), startSegmentTableBody = stringToPrecomputedChunk('<table hidden><tbody id="'), startSegmentTableBody2 = stringToPrecomputedChunk('">'), endSegmentTableBody = stringToPrecomputedChunk("</tbody></table>"), startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id="'), startSegmentTableRow2 = stringToPrecomputedChunk('">'), endSegmentTableRow = stringToPrecomputedChunk("</tr></table>"), startSegmentColGroup = stringToPrecomputedChunk('<table hidden><colgroup id="'), startSegmentColGroup2 = stringToPrecomputedChunk('">'), endSegmentColGroup = stringToPrecomputedChunk("</colgroup></table>");
      function writeStartSegment(destination, responseState, formatContext, id4) {
        switch (formatContext.insertionMode) {
          case ROOT_HTML_MODE:
          case HTML_MODE:
            return writeChunk(destination, startSegmentHTML), writeChunk(destination, responseState.segmentPrefix), writeChunk(destination, stringToChunk(id4.toString(16))), writeChunkAndReturn(destination, startSegmentHTML2);
          case SVG_MODE:
            return writeChunk(destination, startSegmentSVG), writeChunk(destination, responseState.segmentPrefix), writeChunk(destination, stringToChunk(id4.toString(16))), writeChunkAndReturn(destination, startSegmentSVG2);
          case MATHML_MODE:
            return writeChunk(destination, startSegmentMathML), writeChunk(destination, responseState.segmentPrefix), writeChunk(destination, stringToChunk(id4.toString(16))), writeChunkAndReturn(destination, startSegmentMathML2);
          case HTML_TABLE_MODE:
            return writeChunk(destination, startSegmentTable), writeChunk(destination, responseState.segmentPrefix), writeChunk(destination, stringToChunk(id4.toString(16))), writeChunkAndReturn(destination, startSegmentTable2);
          case HTML_TABLE_BODY_MODE:
            return writeChunk(destination, startSegmentTableBody), writeChunk(destination, responseState.segmentPrefix), writeChunk(destination, stringToChunk(id4.toString(16))), writeChunkAndReturn(destination, startSegmentTableBody2);
          case HTML_TABLE_ROW_MODE:
            return writeChunk(destination, startSegmentTableRow), writeChunk(destination, responseState.segmentPrefix), writeChunk(destination, stringToChunk(id4.toString(16))), writeChunkAndReturn(destination, startSegmentTableRow2);
          case HTML_COLGROUP_MODE:
            return writeChunk(destination, startSegmentColGroup), writeChunk(destination, responseState.segmentPrefix), writeChunk(destination, stringToChunk(id4.toString(16))), writeChunkAndReturn(destination, startSegmentColGroup2);
          default:
            throw new Error("Unknown insertion mode. This is a bug in React.");
        }
      }
      function writeEndSegment(destination, formatContext) {
        switch (formatContext.insertionMode) {
          case ROOT_HTML_MODE:
          case HTML_MODE:
            return writeChunkAndReturn(destination, endSegmentHTML);
          case SVG_MODE:
            return writeChunkAndReturn(destination, endSegmentSVG);
          case MATHML_MODE:
            return writeChunkAndReturn(destination, endSegmentMathML);
          case HTML_TABLE_MODE:
            return writeChunkAndReturn(destination, endSegmentTable);
          case HTML_TABLE_BODY_MODE:
            return writeChunkAndReturn(destination, endSegmentTableBody);
          case HTML_TABLE_ROW_MODE:
            return writeChunkAndReturn(destination, endSegmentTableRow);
          case HTML_COLGROUP_MODE:
            return writeChunkAndReturn(destination, endSegmentColGroup);
          default:
            throw new Error("Unknown insertion mode. This is a bug in React.");
        }
      }
      var completeSegmentFunction = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}", completeBoundaryFunction = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}', clientRenderFunction = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}', completeSegmentScript1Full = stringToPrecomputedChunk(completeSegmentFunction + ';$RS("'), completeSegmentScript1Partial = stringToPrecomputedChunk('$RS("'), completeSegmentScript2 = stringToPrecomputedChunk('","'), completeSegmentScript3 = stringToPrecomputedChunk('")</script>');
      function writeCompletedSegmentInstruction(destination, responseState, contentSegmentID) {
        writeChunk(destination, responseState.startInlineScript), responseState.sentCompleteSegmentFunction ? writeChunk(destination, completeSegmentScript1Partial) : (responseState.sentCompleteSegmentFunction = !0, writeChunk(destination, completeSegmentScript1Full)), writeChunk(destination, responseState.segmentPrefix);
        var formattedID = stringToChunk(contentSegmentID.toString(16));
        return writeChunk(destination, formattedID), writeChunk(destination, completeSegmentScript2), writeChunk(destination, responseState.placeholderPrefix), writeChunk(destination, formattedID), writeChunkAndReturn(destination, completeSegmentScript3);
      }
      var completeBoundaryScript1Full = stringToPrecomputedChunk(completeBoundaryFunction + ';$RC("'), completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC("'), completeBoundaryScript2 = stringToPrecomputedChunk('","'), completeBoundaryScript3 = stringToPrecomputedChunk('")</script>');
      function writeCompletedBoundaryInstruction(destination, responseState, boundaryID, contentSegmentID) {
        if (writeChunk(destination, responseState.startInlineScript), responseState.sentCompleteBoundaryFunction ? writeChunk(destination, completeBoundaryScript1Partial) : (responseState.sentCompleteBoundaryFunction = !0, writeChunk(destination, completeBoundaryScript1Full)), boundaryID === null)
          throw new Error("An ID must have been assigned before we can complete the boundary.");
        var formattedContentID = stringToChunk(contentSegmentID.toString(16));
        return writeChunk(destination, boundaryID), writeChunk(destination, completeBoundaryScript2), writeChunk(destination, responseState.segmentPrefix), writeChunk(destination, formattedContentID), writeChunkAndReturn(destination, completeBoundaryScript3);
      }
      var clientRenderScript1Full = stringToPrecomputedChunk(clientRenderFunction + ';$RX("'), clientRenderScript1Partial = stringToPrecomputedChunk('$RX("'), clientRenderScript1A = stringToPrecomputedChunk('"'), clientRenderScript2 = stringToPrecomputedChunk(")</script>"), clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(",");
      function writeClientRenderBoundaryInstruction(destination, responseState, boundaryID, errorDigest, errorMessage, errorComponentStack) {
        if (writeChunk(destination, responseState.startInlineScript), responseState.sentClientRenderFunction ? writeChunk(destination, clientRenderScript1Partial) : (responseState.sentClientRenderFunction = !0, writeChunk(destination, clientRenderScript1Full)), boundaryID === null)
          throw new Error("An ID must have been assigned before we can complete the boundary.");
        return writeChunk(destination, boundaryID), writeChunk(destination, clientRenderScript1A), (errorDigest || errorMessage || errorComponentStack) && (writeChunk(destination, clientRenderErrorScriptArgInterstitial), writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorDigest || "")))), (errorMessage || errorComponentStack) && (writeChunk(destination, clientRenderErrorScriptArgInterstitial), writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorMessage || "")))), errorComponentStack && (writeChunk(destination, clientRenderErrorScriptArgInterstitial), writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorComponentStack)))), writeChunkAndReturn(destination, clientRenderScript2);
      }
      var regexForJSStringsInScripts = /[<\u2028\u2029]/g;
      function escapeJSStringsForInstructionScripts(input) {
        var escaped = JSON.stringify(input);
        return escaped.replace(regexForJSStringsInScripts, function(match) {
          switch (match) {
            case "<":
              return "\\u003c";
            case "\u2028":
              return "\\u2028";
            case "\u2029":
              return "\\u2029";
            default:
              throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
          }
        });
      }
      var assign = Object.assign, REACT_ELEMENT_TYPE = Symbol.for("react.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_PROVIDER_TYPE = Symbol.for("react.provider"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_SCOPE_TYPE = Symbol.for("react.scope"), REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for("react.debug_trace_mode"), REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden"), REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for("react.default_value"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable != "object")
          return null;
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        return typeof maybeIterator == "function" ? maybeIterator : null;
      }
      function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName;
        if (displayName)
          return displayName;
        var functionName = innerType.displayName || innerType.name || "";
        return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
      }
      function getContextName(type2) {
        return type2.displayName || "Context";
      }
      function getComponentNameFromType(type2) {
        if (type2 == null)
          return null;
        if (typeof type2.tag == "number" && error2("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof type2 == "function")
          return type2.displayName || type2.name || null;
        if (typeof type2 == "string")
          return type2;
        switch (type2) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type2 == "object")
          switch (type2.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type2;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type2;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type2, type2.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              var outerName = type2.displayName || null;
              return outerName !== null ? outerName : getComponentNameFromType(type2.type) || "Memo";
            case REACT_LAZY_TYPE: {
              var lazyComponent = type2, payload = lazyComponent._payload, init4 = lazyComponent._init;
              try {
                return getComponentNameFromType(init4(payload));
              } catch {
                return null;
              }
            }
          }
        return null;
      }
      var disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
      function disabledLog() {
      }
      disabledLog.__reactDisabledLog = !0;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log, prevInfo = console.info, prevWarn = console.warn, prevError = console.error, prevGroup = console.group, prevGroupCollapsed = console.groupCollapsed, prevGroupEnd = console.groupEnd;
            var props = {
              configurable: !0,
              enumerable: !0,
              value: disabledLog,
              writable: !0
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          if (disabledDepth--, disabledDepth === 0) {
            var props = {
              configurable: !0,
              enumerable: !0,
              writable: !0
            };
            Object.defineProperties(console, {
              log: assign({}, props, {
                value: prevLog
              }),
              info: assign({}, props, {
                value: prevInfo
              }),
              warn: assign({}, props, {
                value: prevWarn
              }),
              error: assign({}, props, {
                value: prevError
              }),
              group: assign({}, props, {
                value: prevGroup
              }),
              groupCollapsed: assign({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: assign({}, props, {
                value: prevGroupEnd
              })
            });
          }
          disabledDepth < 0 && error2("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
      }
      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher, prefix;
      function describeBuiltInComponentFrame(name, source2, ownerFn) {
        {
          if (prefix === void 0)
            try {
              throw Error();
            } catch (x2) {
              var match = x2.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
            }
          return `
` + prefix + name;
        }
      }
      var reentry = !1, componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap == "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap();
      }
      function describeNativeComponentFrame(fn, construct4) {
        if (!fn || reentry)
          return "";
        {
          var frame = componentFrameCache.get(fn);
          if (frame !== void 0)
            return frame;
        }
        var control;
        reentry = !0;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var previousDispatcher;
        previousDispatcher = ReactCurrentDispatcher.current, ReactCurrentDispatcher.current = null, disableLogs();
        try {
          if (construct4) {
            var Fake = function() {
              throw Error();
            };
            if (Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x2) {
                control = x2;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x2) {
                control = x2;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x2) {
              control = x2;
            }
            fn();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack == "string") {
            for (var sampleLines = sample.stack.split(`
`), controlLines = control.stack.split(`
`), s3 = sampleLines.length - 1, c4 = controlLines.length - 1; s3 >= 1 && c4 >= 0 && sampleLines[s3] !== controlLines[c4]; )
              c4--;
            for (; s3 >= 1 && c4 >= 0; s3--, c4--)
              if (sampleLines[s3] !== controlLines[c4]) {
                if (s3 !== 1 || c4 !== 1)
                  do
                    if (s3--, c4--, c4 < 0 || sampleLines[s3] !== controlLines[c4]) {
                      var _frame = `
` + sampleLines[s3].replace(" at new ", " at ");
                      return fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName)), typeof fn == "function" && componentFrameCache.set(fn, _frame), _frame;
                    }
                  while (s3 >= 1 && c4 >= 0);
                break;
              }
          }
        } finally {
          reentry = !1, ReactCurrentDispatcher.current = previousDispatcher, reenableLogs(), Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name = fn ? fn.displayName || fn.name : "", syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
        return typeof fn == "function" && componentFrameCache.set(fn, syntheticFrame), syntheticFrame;
      }
      function describeClassComponentFrame(ctor, source2, ownerFn) {
        return describeNativeComponentFrame(ctor, !0);
      }
      function describeFunctionComponentFrame(fn, source2, ownerFn) {
        return describeNativeComponentFrame(fn, !1);
      }
      function shouldConstruct(Component3) {
        var prototype = Component3.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type2, source2, ownerFn) {
        if (type2 == null)
          return "";
        if (typeof type2 == "function")
          return describeNativeComponentFrame(type2, shouldConstruct(type2));
        if (typeof type2 == "string")
          return describeBuiltInComponentFrame(type2);
        switch (type2) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type2 == "object")
          switch (type2.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type2.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type2.type, source2, ownerFn);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type2, payload = lazyComponent._payload, init4 = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init4(payload), source2, ownerFn);
              } catch {
              }
            }
          }
        return "";
      }
      var loggedTypeFailures = {}, ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        if (element) {
          var owner = element._owner, stack2 = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
          ReactDebugCurrentFrame.setExtraStackFrame(stack2);
        } else
          ReactDebugCurrentFrame.setExtraStackFrame(null);
      }
      function checkPropTypes(typeSpecs, values, location, componentName, element) {
        {
          var has = Function.call.bind(hasOwnProperty2);
          for (var typeSpecName in typeSpecs)
            if (has(typeSpecs, typeSpecName)) {
              var error$1 = void 0;
              try {
                if (typeof typeSpecs[typeSpecName] != "function") {
                  var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw err.name = "Invariant Violation", err;
                }
                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex) {
                error$1 = ex;
              }
              error$1 && !(error$1 instanceof Error) && (setCurrentlyValidatingElement(element), error2("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1), setCurrentlyValidatingElement(null)), error$1 instanceof Error && !(error$1.message in loggedTypeFailures) && (loggedTypeFailures[error$1.message] = !0, setCurrentlyValidatingElement(element), error2("Failed %s type: %s", location, error$1.message), setCurrentlyValidatingElement(null));
            }
        }
      }
      var warnedAboutMissingGetChildContext;
      warnedAboutMissingGetChildContext = {};
      var emptyContextObject = {};
      Object.freeze(emptyContextObject);
      function getMaskedContext(type2, unmaskedContext) {
        {
          var contextTypes = type2.contextTypes;
          if (!contextTypes)
            return emptyContextObject;
          var context = {};
          for (var key2 in contextTypes)
            context[key2] = unmaskedContext[key2];
          {
            var name = getComponentNameFromType(type2) || "Unknown";
            checkPropTypes(contextTypes, context, "context", name);
          }
          return context;
        }
      }
      function processChildContext(instance2, type2, parentContext, childContextTypes) {
        {
          if (typeof instance2.getChildContext != "function") {
            {
              var componentName = getComponentNameFromType(type2) || "Unknown";
              warnedAboutMissingGetChildContext[componentName] || (warnedAboutMissingGetChildContext[componentName] = !0, error2("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName));
            }
            return parentContext;
          }
          var childContext = instance2.getChildContext();
          for (var contextKey in childContext)
            if (!(contextKey in childContextTypes))
              throw new Error((getComponentNameFromType(type2) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
          {
            var name = getComponentNameFromType(type2) || "Unknown";
            checkPropTypes(childContextTypes, childContext, "child context", name);
          }
          return assign({}, parentContext, childContext);
        }
      }
      var rendererSigil;
      rendererSigil = {};
      var rootContextSnapshot = null, currentActiveSnapshot = null;
      function popNode(prev) {
        prev.context._currentValue = prev.parentValue;
      }
      function pushNode(next) {
        next.context._currentValue = next.value;
      }
      function popToNearestCommonAncestor(prev, next) {
        if (prev !== next) {
          popNode(prev);
          var parentPrev = prev.parent, parentNext = next.parent;
          if (parentPrev === null) {
            if (parentNext !== null)
              throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
          } else {
            if (parentNext === null)
              throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
            popToNearestCommonAncestor(parentPrev, parentNext);
          }
          pushNode(next);
        }
      }
      function popAllPrevious(prev) {
        popNode(prev);
        var parentPrev = prev.parent;
        parentPrev !== null && popAllPrevious(parentPrev);
      }
      function pushAllNext(next) {
        var parentNext = next.parent;
        parentNext !== null && pushAllNext(parentNext), pushNode(next);
      }
      function popPreviousToCommonLevel(prev, next) {
        popNode(prev);
        var parentPrev = prev.parent;
        if (parentPrev === null)
          throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
        parentPrev.depth === next.depth ? popToNearestCommonAncestor(parentPrev, next) : popPreviousToCommonLevel(parentPrev, next);
      }
      function popNextToCommonLevel(prev, next) {
        var parentNext = next.parent;
        if (parentNext === null)
          throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
        prev.depth === parentNext.depth ? popToNearestCommonAncestor(prev, parentNext) : popNextToCommonLevel(prev, parentNext), pushNode(next);
      }
      function switchContext(newSnapshot) {
        var prev = currentActiveSnapshot, next = newSnapshot;
        prev !== next && (prev === null ? pushAllNext(next) : next === null ? popAllPrevious(prev) : prev.depth === next.depth ? popToNearestCommonAncestor(prev, next) : prev.depth > next.depth ? popPreviousToCommonLevel(prev, next) : popNextToCommonLevel(prev, next), currentActiveSnapshot = next);
      }
      function pushProvider(context, nextValue) {
        var prevValue;
        prevValue = context._currentValue, context._currentValue = nextValue, context._currentRenderer !== void 0 && context._currentRenderer !== null && context._currentRenderer !== rendererSigil && error2("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), context._currentRenderer = rendererSigil;
        var prevNode = currentActiveSnapshot, newNode = {
          parent: prevNode,
          depth: prevNode === null ? 0 : prevNode.depth + 1,
          context,
          parentValue: prevValue,
          value: nextValue
        };
        return currentActiveSnapshot = newNode, newNode;
      }
      function popProvider(context) {
        var prevSnapshot = currentActiveSnapshot;
        if (prevSnapshot === null)
          throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
        prevSnapshot.context !== context && error2("The parent context is not the expected context. This is probably a bug in React.");
        {
          var value2 = prevSnapshot.parentValue;
          value2 === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED ? prevSnapshot.context._currentValue = prevSnapshot.context._defaultValue : prevSnapshot.context._currentValue = value2, context._currentRenderer !== void 0 && context._currentRenderer !== null && context._currentRenderer !== rendererSigil && error2("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), context._currentRenderer = rendererSigil;
        }
        return currentActiveSnapshot = prevSnapshot.parent;
      }
      function getActiveContext() {
        return currentActiveSnapshot;
      }
      function readContext(context) {
        var value2 = context._currentValue;
        return value2;
      }
      function get2(key2) {
        return key2._reactInternals;
      }
      function set2(key2, value2) {
        key2._reactInternals = value2;
      }
      var didWarnAboutNoopUpdateForComponent = {}, didWarnAboutDeprecatedWillMount = {}, didWarnAboutUninitializedState, didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate, didWarnAboutLegacyLifecyclesAndDerivedState, didWarnAboutUndefinedDerivedState, warnOnUndefinedDerivedState, warnOnInvalidCallback, didWarnAboutDirectlyAssigningPropsToState, didWarnAboutContextTypeAndContextTypes, didWarnAboutInvalidateContextType;
      {
        didWarnAboutUninitializedState = /* @__PURE__ */ new Set(), didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set(), didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set(), didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set(), didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set(), didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set(), didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
        var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
        warnOnInvalidCallback = function(callback, callerName) {
          if (!(callback === null || typeof callback == "function")) {
            var key2 = callerName + "_" + callback;
            didWarnOnInvalidCallback.has(key2) || (didWarnOnInvalidCallback.add(key2), error2("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback));
          }
        }, warnOnUndefinedDerivedState = function(type2, partialState) {
          if (partialState === void 0) {
            var componentName = getComponentNameFromType(type2) || "Component";
            didWarnAboutUndefinedDerivedState.has(componentName) || (didWarnAboutUndefinedDerivedState.add(componentName), error2("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName));
          }
        };
      }
      function warnNoop(publicInstance, callerName) {
        {
          var _constructor = publicInstance.constructor, componentName = _constructor && getComponentNameFromType(_constructor) || "ReactClass", warningKey = componentName + "." + callerName;
          if (didWarnAboutNoopUpdateForComponent[warningKey])
            return;
          error2(`%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.

Please check the code for the %s component.`, callerName, callerName, componentName), didWarnAboutNoopUpdateForComponent[warningKey] = !0;
        }
      }
      var classComponentUpdater = {
        isMounted: function(inst) {
          return !1;
        },
        enqueueSetState: function(inst, payload, callback) {
          var internals = get2(inst);
          internals.queue === null ? warnNoop(inst, "setState") : (internals.queue.push(payload), callback != null && warnOnInvalidCallback(callback, "setState"));
        },
        enqueueReplaceState: function(inst, payload, callback) {
          var internals = get2(inst);
          internals.replace = !0, internals.queue = [payload], callback != null && warnOnInvalidCallback(callback, "setState");
        },
        enqueueForceUpdate: function(inst, callback) {
          var internals = get2(inst);
          internals.queue === null ? warnNoop(inst, "forceUpdate") : callback != null && warnOnInvalidCallback(callback, "setState");
        }
      };
      function applyDerivedStateFromProps(instance2, ctor, getDerivedStateFromProps, prevState, nextProps) {
        var partialState = getDerivedStateFromProps(nextProps, prevState);
        warnOnUndefinedDerivedState(ctor, partialState);
        var newState = partialState == null ? prevState : assign({}, prevState, partialState);
        return newState;
      }
      function constructClassInstance(ctor, props, maskedLegacyContext) {
        var context = emptyContextObject, contextType = ctor.contextType;
        if ("contextType" in ctor) {
          var isValid = contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0;
          if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
            didWarnAboutInvalidateContextType.add(ctor);
            var addendum = "";
            contextType === void 0 ? addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof contextType != "object" ? addendum = " However, it is set to a " + typeof contextType + "." : contextType.$$typeof === REACT_PROVIDER_TYPE ? addendum = " Did you accidentally pass the Context.Provider instead?" : contextType._context !== void 0 ? addendum = " Did you accidentally pass the Context.Consumer instead?" : addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.", error2("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || "Component", addendum);
          }
        }
        typeof contextType == "object" && contextType !== null ? context = readContext(contextType) : context = maskedLegacyContext;
        var instance2 = new ctor(props, context);
        {
          if (typeof ctor.getDerivedStateFromProps == "function" && (instance2.state === null || instance2.state === void 0)) {
            var componentName = getComponentNameFromType(ctor) || "Component";
            didWarnAboutUninitializedState.has(componentName) || (didWarnAboutUninitializedState.add(componentName), error2("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance2.state === null ? "null" : "undefined", componentName));
          }
          if (typeof ctor.getDerivedStateFromProps == "function" || typeof instance2.getSnapshotBeforeUpdate == "function") {
            var foundWillMountName = null, foundWillReceivePropsName = null, foundWillUpdateName = null;
            if (typeof instance2.componentWillMount == "function" && instance2.componentWillMount.__suppressDeprecationWarning !== !0 ? foundWillMountName = "componentWillMount" : typeof instance2.UNSAFE_componentWillMount == "function" && (foundWillMountName = "UNSAFE_componentWillMount"), typeof instance2.componentWillReceiveProps == "function" && instance2.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? foundWillReceivePropsName = "componentWillReceiveProps" : typeof instance2.UNSAFE_componentWillReceiveProps == "function" && (foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps"), typeof instance2.componentWillUpdate == "function" && instance2.componentWillUpdate.__suppressDeprecationWarning !== !0 ? foundWillUpdateName = "componentWillUpdate" : typeof instance2.UNSAFE_componentWillUpdate == "function" && (foundWillUpdateName = "UNSAFE_componentWillUpdate"), foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
              var _componentName = getComponentNameFromType(ctor) || "Component", newApiName = typeof ctor.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
              didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName) || (didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName), error2(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, _componentName, newApiName, foundWillMountName !== null ? `
  ` + foundWillMountName : "", foundWillReceivePropsName !== null ? `
  ` + foundWillReceivePropsName : "", foundWillUpdateName !== null ? `
  ` + foundWillUpdateName : ""));
            }
          }
        }
        return instance2;
      }
      function checkClassInstance(instance2, ctor, newProps) {
        {
          var name = getComponentNameFromType(ctor) || "Component", renderPresent = instance2.render;
          renderPresent || (ctor.prototype && typeof ctor.prototype.render == "function" ? error2("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name) : error2("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name)), instance2.getInitialState && !instance2.getInitialState.isReactClassApproved && !instance2.state && error2("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name), instance2.getDefaultProps && !instance2.getDefaultProps.isReactClassApproved && error2("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name), instance2.propTypes && error2("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name), instance2.contextType && error2("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name), instance2.contextTypes && error2("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name), ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor) && (didWarnAboutContextTypeAndContextTypes.add(ctor), error2("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name)), typeof instance2.componentShouldUpdate == "function" && error2("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name), ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance2.shouldComponentUpdate < "u" && error2("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || "A pure component"), typeof instance2.componentDidUnmount == "function" && error2("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name), typeof instance2.componentDidReceiveProps == "function" && error2("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name), typeof instance2.componentWillRecieveProps == "function" && error2("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name), typeof instance2.UNSAFE_componentWillRecieveProps == "function" && error2("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name);
          var hasMutatedProps = instance2.props !== newProps;
          instance2.props !== void 0 && hasMutatedProps && error2("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name, name), instance2.defaultProps && error2("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name, name), typeof instance2.getSnapshotBeforeUpdate == "function" && typeof instance2.componentDidUpdate != "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor) && (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor), error2("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor))), typeof instance2.getDerivedStateFromProps == "function" && error2("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name), typeof instance2.getDerivedStateFromError == "function" && error2("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name), typeof ctor.getSnapshotBeforeUpdate == "function" && error2("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name);
          var _state = instance2.state;
          _state && (typeof _state != "object" || isArray3(_state)) && error2("%s.state: must be set to an object or null", name), typeof instance2.getChildContext == "function" && typeof ctor.childContextTypes != "object" && error2("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name);
        }
      }
      function callComponentWillMount(type2, instance2) {
        var oldState = instance2.state;
        if (typeof instance2.componentWillMount == "function") {
          if (instance2.componentWillMount.__suppressDeprecationWarning !== !0) {
            var componentName = getComponentNameFromType(type2) || "Unknown";
            didWarnAboutDeprecatedWillMount[componentName] || (warn3(
              `componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.

Please update the following components: %s`,
              componentName
            ), didWarnAboutDeprecatedWillMount[componentName] = !0);
          }
          instance2.componentWillMount();
        }
        typeof instance2.UNSAFE_componentWillMount == "function" && instance2.UNSAFE_componentWillMount(), oldState !== instance2.state && (error2("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromType(type2) || "Component"), classComponentUpdater.enqueueReplaceState(instance2, instance2.state, null));
      }
      function processUpdateQueue(internalInstance, inst, props, maskedLegacyContext) {
        if (internalInstance.queue !== null && internalInstance.queue.length > 0) {
          var oldQueue = internalInstance.queue, oldReplace = internalInstance.replace;
          if (internalInstance.queue = null, internalInstance.replace = !1, oldReplace && oldQueue.length === 1)
            inst.state = oldQueue[0];
          else {
            for (var nextState = oldReplace ? oldQueue[0] : inst.state, dontMutate = !0, i3 = oldReplace ? 1 : 0; i3 < oldQueue.length; i3++) {
              var partial = oldQueue[i3], partialState = typeof partial == "function" ? partial.call(inst, nextState, props, maskedLegacyContext) : partial;
              partialState != null && (dontMutate ? (dontMutate = !1, nextState = assign({}, nextState, partialState)) : assign(nextState, partialState));
            }
            inst.state = nextState;
          }
        } else
          internalInstance.queue = null;
      }
      function mountClassInstance(instance2, ctor, newProps, maskedLegacyContext) {
        checkClassInstance(instance2, ctor, newProps);
        var initialState = instance2.state !== void 0 ? instance2.state : null;
        instance2.updater = classComponentUpdater, instance2.props = newProps, instance2.state = initialState;
        var internalInstance = {
          queue: [],
          replace: !1
        };
        set2(instance2, internalInstance);
        var contextType = ctor.contextType;
        if (typeof contextType == "object" && contextType !== null ? instance2.context = readContext(contextType) : instance2.context = maskedLegacyContext, instance2.state === newProps) {
          var componentName = getComponentNameFromType(ctor) || "Component";
          didWarnAboutDirectlyAssigningPropsToState.has(componentName) || (didWarnAboutDirectlyAssigningPropsToState.add(componentName), error2("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName));
        }
        var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
        typeof getDerivedStateFromProps == "function" && (instance2.state = applyDerivedStateFromProps(instance2, ctor, getDerivedStateFromProps, initialState, newProps)), typeof ctor.getDerivedStateFromProps != "function" && typeof instance2.getSnapshotBeforeUpdate != "function" && (typeof instance2.UNSAFE_componentWillMount == "function" || typeof instance2.componentWillMount == "function") && (callComponentWillMount(ctor, instance2), processUpdateQueue(internalInstance, instance2, newProps, maskedLegacyContext));
      }
      var emptyTreeContext = {
        id: 1,
        overflow: ""
      };
      function getTreeId(context) {
        var overflow = context.overflow, idWithLeadingBit = context.id, id4 = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
        return id4.toString(32) + overflow;
      }
      function pushTreeContext(baseContext, totalChildren, index2) {
        var baseIdWithLeadingBit = baseContext.id, baseOverflow = baseContext.overflow, baseLength = getBitLength(baseIdWithLeadingBit) - 1, baseId = baseIdWithLeadingBit & ~(1 << baseLength), slot = index2 + 1, length = getBitLength(totalChildren) + baseLength;
        if (length > 30) {
          var numberOfOverflowBits = baseLength - baseLength % 5, newOverflowBits = (1 << numberOfOverflowBits) - 1, newOverflow = (baseId & newOverflowBits).toString(32), restOfBaseId = baseId >> numberOfOverflowBits, restOfBaseLength = baseLength - numberOfOverflowBits, restOfLength = getBitLength(totalChildren) + restOfBaseLength, restOfNewBits = slot << restOfBaseLength, id4 = restOfNewBits | restOfBaseId, overflow = newOverflow + baseOverflow;
          return {
            id: 1 << restOfLength | id4,
            overflow
          };
        } else {
          var newBits = slot << baseLength, _id = newBits | baseId, _overflow = baseOverflow;
          return {
            id: 1 << length | _id,
            overflow: _overflow
          };
        }
      }
      function getBitLength(number4) {
        return 32 - clz32(number4);
      }
      function getLeadingBit(id4) {
        return 1 << getBitLength(id4) - 1;
      }
      var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log2 = Math.log, LN2 = Math.LN2;
      function clz32Fallback(x2) {
        var asUint = x2 >>> 0;
        return asUint === 0 ? 32 : 31 - (log2(asUint) / LN2 | 0) | 0;
      }
      function is2(x2, y2) {
        return x2 === y2 && (x2 !== 0 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
      }
      var objectIs = typeof Object.is == "function" ? Object.is : is2, currentlyRenderingComponent = null, currentlyRenderingTask = null, firstWorkInProgressHook = null, workInProgressHook = null, isReRender = !1, didScheduleRenderPhaseUpdate = !1, localIdCounter = 0, renderPhaseUpdates = null, numberOfReRenders = 0, RE_RENDER_LIMIT = 25, isInHookUserCodeInDev = !1, currentHookNameInDev;
      function resolveCurrentlyRenderingComponent() {
        if (currentlyRenderingComponent === null)
          throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
        return isInHookUserCodeInDev && error2("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks"), currentlyRenderingComponent;
      }
      function areHookInputsEqual(nextDeps, prevDeps) {
        if (prevDeps === null)
          return error2("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev), !1;
        nextDeps.length !== prevDeps.length && error2(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, currentHookNameInDev, "[" + nextDeps.join(", ") + "]", "[" + prevDeps.join(", ") + "]");
        for (var i3 = 0; i3 < prevDeps.length && i3 < nextDeps.length; i3++)
          if (!objectIs(nextDeps[i3], prevDeps[i3]))
            return !1;
        return !0;
      }
      function createHook() {
        if (numberOfReRenders > 0)
          throw new Error("Rendered more hooks than during the previous render");
        return {
          memoizedState: null,
          queue: null,
          next: null
        };
      }
      function createWorkInProgressHook() {
        return workInProgressHook === null ? firstWorkInProgressHook === null ? (isReRender = !1, firstWorkInProgressHook = workInProgressHook = createHook()) : (isReRender = !0, workInProgressHook = firstWorkInProgressHook) : workInProgressHook.next === null ? (isReRender = !1, workInProgressHook = workInProgressHook.next = createHook()) : (isReRender = !0, workInProgressHook = workInProgressHook.next), workInProgressHook;
      }
      function prepareToUseHooks(task, componentIdentity) {
        currentlyRenderingComponent = componentIdentity, currentlyRenderingTask = task, isInHookUserCodeInDev = !1, localIdCounter = 0;
      }
      function finishHooks(Component3, props, children, refOrContext) {
        for (; didScheduleRenderPhaseUpdate; )
          didScheduleRenderPhaseUpdate = !1, localIdCounter = 0, numberOfReRenders += 1, workInProgressHook = null, children = Component3(props, refOrContext);
        return resetHooksState(), children;
      }
      function checkDidRenderIdHook() {
        var didRenderIdHook = localIdCounter !== 0;
        return didRenderIdHook;
      }
      function resetHooksState() {
        isInHookUserCodeInDev = !1, currentlyRenderingComponent = null, currentlyRenderingTask = null, didScheduleRenderPhaseUpdate = !1, firstWorkInProgressHook = null, numberOfReRenders = 0, renderPhaseUpdates = null, workInProgressHook = null;
      }
      function readContext$1(context) {
        return isInHookUserCodeInDev && error2("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."), readContext(context);
      }
      function useContext17(context) {
        return currentHookNameInDev = "useContext", resolveCurrentlyRenderingComponent(), readContext(context);
      }
      function basicStateReducer(state, action3) {
        return typeof action3 == "function" ? action3(state) : action3;
      }
      function useState14(initialState) {
        return currentHookNameInDev = "useState", useReducer(
          basicStateReducer,
          initialState
        );
      }
      function useReducer(reducer, initialArg, init4) {
        if (reducer !== basicStateReducer && (currentHookNameInDev = "useReducer"), currentlyRenderingComponent = resolveCurrentlyRenderingComponent(), workInProgressHook = createWorkInProgressHook(), isReRender) {
          var queue2 = workInProgressHook.queue, dispatch = queue2.dispatch;
          if (renderPhaseUpdates !== null) {
            var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue2);
            if (firstRenderPhaseUpdate !== void 0) {
              renderPhaseUpdates.delete(queue2);
              var newState = workInProgressHook.memoizedState, update = firstRenderPhaseUpdate;
              do {
                var action3 = update.action;
                isInHookUserCodeInDev = !0, newState = reducer(newState, action3), isInHookUserCodeInDev = !1, update = update.next;
              } while (update !== null);
              return workInProgressHook.memoizedState = newState, [newState, dispatch];
            }
          }
          return [workInProgressHook.memoizedState, dispatch];
        } else {
          isInHookUserCodeInDev = !0;
          var initialState;
          reducer === basicStateReducer ? initialState = typeof initialArg == "function" ? initialArg() : initialArg : initialState = init4 !== void 0 ? init4(initialArg) : initialArg, isInHookUserCodeInDev = !1, workInProgressHook.memoizedState = initialState;
          var _queue = workInProgressHook.queue = {
            last: null,
            dispatch: null
          }, _dispatch = _queue.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, _queue);
          return [workInProgressHook.memoizedState, _dispatch];
        }
      }
      function useMemo11(nextCreate, deps) {
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent(), workInProgressHook = createWorkInProgressHook();
        var nextDeps = deps === void 0 ? null : deps;
        if (workInProgressHook !== null) {
          var prevState = workInProgressHook.memoizedState;
          if (prevState !== null && nextDeps !== null) {
            var prevDeps = prevState[1];
            if (areHookInputsEqual(nextDeps, prevDeps))
              return prevState[0];
          }
        }
        isInHookUserCodeInDev = !0;
        var nextValue = nextCreate();
        return isInHookUserCodeInDev = !1, workInProgressHook.memoizedState = [nextValue, nextDeps], nextValue;
      }
      function useRef14(initialValue) {
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent(), workInProgressHook = createWorkInProgressHook();
        var previousRef = workInProgressHook.memoizedState;
        if (previousRef === null) {
          var ref = {
            current: initialValue
          };
          return Object.seal(ref), workInProgressHook.memoizedState = ref, ref;
        } else
          return previousRef;
      }
      function useLayoutEffect6(create, inputs) {
        currentHookNameInDev = "useLayoutEffect", error2("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
      }
      function dispatchAction(componentIdentity, queue2, action3) {
        if (numberOfReRenders >= RE_RENDER_LIMIT)
          throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
        if (componentIdentity === currentlyRenderingComponent) {
          didScheduleRenderPhaseUpdate = !0;
          var update = {
            action: action3,
            next: null
          };
          renderPhaseUpdates === null && (renderPhaseUpdates = /* @__PURE__ */ new Map());
          var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue2);
          if (firstRenderPhaseUpdate === void 0)
            renderPhaseUpdates.set(queue2, update);
          else {
            for (var lastRenderPhaseUpdate = firstRenderPhaseUpdate; lastRenderPhaseUpdate.next !== null; )
              lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
            lastRenderPhaseUpdate.next = update;
          }
        }
      }
      function useCallback5(callback, deps) {
        return useMemo11(function() {
          return callback;
        }, deps);
      }
      function useMutableSource(source2, getSnapshot, subscribe) {
        return resolveCurrentlyRenderingComponent(), getSnapshot(source2._source);
      }
      function useSyncExternalStore3(subscribe, getSnapshot, getServerSnapshot) {
        if (getServerSnapshot === void 0)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        return getServerSnapshot();
      }
      function useDeferredValue(value2) {
        return resolveCurrentlyRenderingComponent(), value2;
      }
      function unsupportedStartTransition() {
        throw new Error("startTransition cannot be called during server rendering.");
      }
      function useTransition2() {
        return resolveCurrentlyRenderingComponent(), [!1, unsupportedStartTransition];
      }
      function useId4() {
        var task = currentlyRenderingTask, treeId = getTreeId(task.treeContext), responseState = currentResponseState;
        if (responseState === null)
          throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
        var localId = localIdCounter++;
        return makeId(responseState, treeId, localId);
      }
      function noop4() {
      }
      var Dispatcher = {
        readContext: readContext$1,
        useContext: useContext17,
        useMemo: useMemo11,
        useReducer,
        useRef: useRef14,
        useState: useState14,
        useInsertionEffect: noop4,
        useLayoutEffect: useLayoutEffect6,
        useCallback: useCallback5,
        useImperativeHandle: noop4,
        useEffect: noop4,
        useDebugValue: noop4,
        useDeferredValue,
        useTransition: useTransition2,
        useId: useId4,
        useMutableSource,
        useSyncExternalStore: useSyncExternalStore3
      }, currentResponseState = null;
      function setCurrentResponseState(responseState) {
        currentResponseState = responseState;
      }
      function getStackByComponentStackNode(componentStack) {
        try {
          var info = "", node = componentStack;
          do {
            switch (node.tag) {
              case 0:
                info += describeBuiltInComponentFrame(node.type, null, null);
                break;
              case 1:
                info += describeFunctionComponentFrame(node.type, null, null);
                break;
              case 2:
                info += describeClassComponentFrame(node.type, null, null);
                break;
            }
            node = node.parent;
          } while (node);
          return info;
        } catch (x2) {
          return `
Error generating stack: ` + x2.message + `
` + x2.stack;
        }
      }
      var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher, ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame, PENDING = 0, COMPLETED = 1, FLUSHED = 2, ABORTED = 3, ERRORED = 4, OPEN = 0, CLOSING = 1, CLOSED = 2, DEFAULT_PROGRESSIVE_CHUNK_SIZE = 12800;
      function defaultErrorHandler(error3) {
        return console.error(error3), null;
      }
      function noop$1() {
      }
      function createRequest(children, responseState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError) {
        var pingedTasks = [], abortSet = /* @__PURE__ */ new Set(), request = {
          destination: null,
          responseState,
          progressiveChunkSize: progressiveChunkSize === void 0 ? DEFAULT_PROGRESSIVE_CHUNK_SIZE : progressiveChunkSize,
          status: OPEN,
          fatalError: null,
          nextSegmentId: 0,
          allPendingTasks: 0,
          pendingRootTasks: 0,
          completedRootSegment: null,
          abortableTasks: abortSet,
          pingedTasks,
          clientRenderedBoundaries: [],
          completedBoundaries: [],
          partialBoundaries: [],
          onError: onError === void 0 ? defaultErrorHandler : onError,
          onAllReady: onAllReady === void 0 ? noop$1 : onAllReady,
          onShellReady: onShellReady === void 0 ? noop$1 : onShellReady,
          onShellError: onShellError === void 0 ? noop$1 : onShellError,
          onFatalError: onFatalError === void 0 ? noop$1 : onFatalError
        }, rootSegment = createPendingSegment(
          request,
          0,
          null,
          rootFormatContext,
          !1,
          !1
        );
        rootSegment.parentFlushed = !0;
        var rootTask = createTask(request, children, null, rootSegment, abortSet, emptyContextObject, rootContextSnapshot, emptyTreeContext);
        return pingedTasks.push(rootTask), request;
      }
      function pingTask(request, task) {
        var pingedTasks = request.pingedTasks;
        pingedTasks.push(task), pingedTasks.length === 1 && scheduleWork(function() {
          return performWork(request);
        });
      }
      function createSuspenseBoundary(request, fallbackAbortableTasks) {
        return {
          id: UNINITIALIZED_SUSPENSE_BOUNDARY_ID,
          rootSegmentID: -1,
          parentFlushed: !1,
          pendingTasks: 0,
          forceClientRender: !1,
          completedSegments: [],
          byteSize: 0,
          fallbackAbortableTasks,
          errorDigest: null
        };
      }
      function createTask(request, node, blockedBoundary, blockedSegment, abortSet, legacyContext, context, treeContext) {
        request.allPendingTasks++, blockedBoundary === null ? request.pendingRootTasks++ : blockedBoundary.pendingTasks++;
        var task = {
          node,
          ping: function() {
            return pingTask(request, task);
          },
          blockedBoundary,
          blockedSegment,
          abortSet,
          legacyContext,
          context,
          treeContext
        };
        return task.componentStack = null, abortSet.add(task), task;
      }
      function createPendingSegment(request, index2, boundary, formatContext, lastPushedText, textEmbedded) {
        return {
          status: PENDING,
          id: -1,
          index: index2,
          parentFlushed: !1,
          chunks: [],
          children: [],
          formatContext,
          boundary,
          lastPushedText,
          textEmbedded
        };
      }
      var currentTaskInDEV = null;
      function getCurrentStackInDEV() {
        return currentTaskInDEV === null || currentTaskInDEV.componentStack === null ? "" : getStackByComponentStackNode(currentTaskInDEV.componentStack);
      }
      function pushBuiltInComponentStackInDEV(task, type2) {
        task.componentStack = {
          tag: 0,
          parent: task.componentStack,
          type: type2
        };
      }
      function pushFunctionComponentStackInDEV(task, type2) {
        task.componentStack = {
          tag: 1,
          parent: task.componentStack,
          type: type2
        };
      }
      function pushClassComponentStackInDEV(task, type2) {
        task.componentStack = {
          tag: 2,
          parent: task.componentStack,
          type: type2
        };
      }
      function popComponentStackInDEV(task) {
        task.componentStack === null ? error2("Unexpectedly popped too many stack frames. This is a bug in React.") : task.componentStack = task.componentStack.parent;
      }
      var lastBoundaryErrorComponentStackDev = null;
      function captureBoundaryErrorDetailsDev(boundary, error3) {
        {
          var errorMessage;
          typeof error3 == "string" ? errorMessage = error3 : error3 && typeof error3.message == "string" ? errorMessage = error3.message : errorMessage = String(error3);
          var errorComponentStack = lastBoundaryErrorComponentStackDev || getCurrentStackInDEV();
          lastBoundaryErrorComponentStackDev = null, boundary.errorMessage = errorMessage, boundary.errorComponentStack = errorComponentStack;
        }
      }
      function logRecoverableError(request, error3) {
        var errorDigest = request.onError(error3);
        if (errorDigest != null && typeof errorDigest != "string")
          throw new Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof errorDigest + '" instead');
        return errorDigest;
      }
      function fatalError(request, error3) {
        var onShellError = request.onShellError;
        onShellError(error3);
        var onFatalError = request.onFatalError;
        onFatalError(error3), request.destination !== null ? (request.status = CLOSED, closeWithError(request.destination, error3)) : (request.status = CLOSING, request.fatalError = error3);
      }
      function renderSuspenseBoundary(request, task, props) {
        pushBuiltInComponentStackInDEV(task, "Suspense");
        var parentBoundary = task.blockedBoundary, parentSegment = task.blockedSegment, fallback = props.fallback, content = props.children, fallbackAbortSet = /* @__PURE__ */ new Set(), newBoundary = createSuspenseBoundary(request, fallbackAbortSet), insertionIndex = parentSegment.chunks.length, boundarySegment = createPendingSegment(
          request,
          insertionIndex,
          newBoundary,
          parentSegment.formatContext,
          !1,
          !1
        );
        parentSegment.children.push(boundarySegment), parentSegment.lastPushedText = !1;
        var contentRootSegment = createPendingSegment(
          request,
          0,
          null,
          parentSegment.formatContext,
          !1,
          !1
        );
        contentRootSegment.parentFlushed = !0, task.blockedBoundary = newBoundary, task.blockedSegment = contentRootSegment;
        try {
          if (renderNode(request, task, content), pushSegmentFinale(contentRootSegment.chunks, request.responseState, contentRootSegment.lastPushedText, contentRootSegment.textEmbedded), contentRootSegment.status = COMPLETED, queueCompletedSegment(newBoundary, contentRootSegment), newBoundary.pendingTasks === 0) {
            popComponentStackInDEV(task);
            return;
          }
        } catch (error3) {
          contentRootSegment.status = ERRORED, newBoundary.forceClientRender = !0, newBoundary.errorDigest = logRecoverableError(request, error3), captureBoundaryErrorDetailsDev(newBoundary, error3);
        } finally {
          task.blockedBoundary = parentBoundary, task.blockedSegment = parentSegment;
        }
        var suspendedFallbackTask = createTask(request, fallback, parentBoundary, boundarySegment, fallbackAbortSet, task.legacyContext, task.context, task.treeContext);
        suspendedFallbackTask.componentStack = task.componentStack, request.pingedTasks.push(suspendedFallbackTask), popComponentStackInDEV(task);
      }
      function renderHostElement(request, task, type2, props) {
        pushBuiltInComponentStackInDEV(task, type2);
        var segment = task.blockedSegment, children = pushStartInstance(segment.chunks, type2, props, request.responseState, segment.formatContext);
        segment.lastPushedText = !1;
        var prevContext = segment.formatContext;
        segment.formatContext = getChildFormatContext(prevContext, type2, props), renderNode(request, task, children), segment.formatContext = prevContext, pushEndInstance(segment.chunks, type2), segment.lastPushedText = !1, popComponentStackInDEV(task);
      }
      function shouldConstruct$1(Component3) {
        return Component3.prototype && Component3.prototype.isReactComponent;
      }
      function renderWithHooks(request, task, Component3, props, secondArg) {
        var componentIdentity = {};
        prepareToUseHooks(task, componentIdentity);
        var result2 = Component3(props, secondArg);
        return finishHooks(Component3, props, result2, secondArg);
      }
      function finishClassComponent(request, task, instance2, Component3, props) {
        var nextChildren = instance2.render();
        instance2.props !== props && (didWarnAboutReassigningProps || error2("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromType(Component3) || "a component"), didWarnAboutReassigningProps = !0);
        {
          var childContextTypes = Component3.childContextTypes;
          if (childContextTypes != null) {
            var previousContext = task.legacyContext, mergedContext = processChildContext(instance2, Component3, previousContext, childContextTypes);
            task.legacyContext = mergedContext, renderNodeDestructive(request, task, nextChildren), task.legacyContext = previousContext;
            return;
          }
        }
        renderNodeDestructive(request, task, nextChildren);
      }
      function renderClassComponent(request, task, Component3, props) {
        pushClassComponentStackInDEV(task, Component3);
        var maskedContext = getMaskedContext(Component3, task.legacyContext), instance2 = constructClassInstance(Component3, props, maskedContext);
        mountClassInstance(instance2, Component3, props, maskedContext), finishClassComponent(request, task, instance2, Component3, props), popComponentStackInDEV(task);
      }
      var didWarnAboutBadClass = {}, didWarnAboutModulePatternComponent = {}, didWarnAboutContextTypeOnFunctionComponent = {}, didWarnAboutGetDerivedStateOnFunctionComponent = {}, didWarnAboutReassigningProps = !1, didWarnAboutGenerators = !1, didWarnAboutMaps = !1, hasWarnedAboutUsingContextAsConsumer = !1;
      function renderIndeterminateComponent(request, task, Component3, props) {
        var legacyContext;
        if (legacyContext = getMaskedContext(Component3, task.legacyContext), pushFunctionComponentStackInDEV(task, Component3), Component3.prototype && typeof Component3.prototype.render == "function") {
          var componentName = getComponentNameFromType(Component3) || "Unknown";
          didWarnAboutBadClass[componentName] || (error2("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName), didWarnAboutBadClass[componentName] = !0);
        }
        var value2 = renderWithHooks(request, task, Component3, props, legacyContext), hasId = checkDidRenderIdHook();
        if (typeof value2 == "object" && value2 !== null && typeof value2.render == "function" && value2.$$typeof === void 0) {
          var _componentName = getComponentNameFromType(Component3) || "Unknown";
          didWarnAboutModulePatternComponent[_componentName] || (error2("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName), didWarnAboutModulePatternComponent[_componentName] = !0);
        }
        if (typeof value2 == "object" && value2 !== null && typeof value2.render == "function" && value2.$$typeof === void 0) {
          {
            var _componentName2 = getComponentNameFromType(Component3) || "Unknown";
            didWarnAboutModulePatternComponent[_componentName2] || (error2("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2), didWarnAboutModulePatternComponent[_componentName2] = !0);
          }
          mountClassInstance(value2, Component3, props, legacyContext), finishClassComponent(request, task, value2, Component3, props);
        } else if (validateFunctionComponentInDev(Component3), hasId) {
          var prevTreeContext = task.treeContext, totalChildren = 1, index2 = 0;
          task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index2);
          try {
            renderNodeDestructive(request, task, value2);
          } finally {
            task.treeContext = prevTreeContext;
          }
        } else
          renderNodeDestructive(request, task, value2);
        popComponentStackInDEV(task);
      }
      function validateFunctionComponentInDev(Component3) {
        {
          if (Component3 && Component3.childContextTypes && error2("%s(...): childContextTypes cannot be defined on a function component.", Component3.displayName || Component3.name || "Component"), typeof Component3.getDerivedStateFromProps == "function") {
            var _componentName3 = getComponentNameFromType(Component3) || "Unknown";
            didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] || (error2("%s: Function components do not support getDerivedStateFromProps.", _componentName3), didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = !0);
          }
          if (typeof Component3.contextType == "object" && Component3.contextType !== null) {
            var _componentName4 = getComponentNameFromType(Component3) || "Unknown";
            didWarnAboutContextTypeOnFunctionComponent[_componentName4] || (error2("%s: Function components do not support contextType.", _componentName4), didWarnAboutContextTypeOnFunctionComponent[_componentName4] = !0);
          }
        }
      }
      function resolveDefaultProps(Component3, baseProps) {
        if (Component3 && Component3.defaultProps) {
          var props = assign({}, baseProps), defaultProps = Component3.defaultProps;
          for (var propName in defaultProps)
            props[propName] === void 0 && (props[propName] = defaultProps[propName]);
          return props;
        }
        return baseProps;
      }
      function renderForwardRef(request, task, type2, props, ref) {
        pushFunctionComponentStackInDEV(task, type2.render);
        var children = renderWithHooks(request, task, type2.render, props, ref), hasId = checkDidRenderIdHook();
        if (hasId) {
          var prevTreeContext = task.treeContext, totalChildren = 1, index2 = 0;
          task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index2);
          try {
            renderNodeDestructive(request, task, children);
          } finally {
            task.treeContext = prevTreeContext;
          }
        } else
          renderNodeDestructive(request, task, children);
        popComponentStackInDEV(task);
      }
      function renderMemo(request, task, type2, props, ref) {
        var innerType = type2.type, resolvedProps = resolveDefaultProps(innerType, props);
        renderElement(request, task, innerType, resolvedProps, ref);
      }
      function renderContextConsumer(request, task, context, props) {
        context._context === void 0 ? context !== context.Consumer && (hasWarnedAboutUsingContextAsConsumer || (hasWarnedAboutUsingContextAsConsumer = !0, error2("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : context = context._context;
        var render = props.children;
        typeof render != "function" && error2("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
        var newValue = readContext(context), newChildren = render(newValue);
        renderNodeDestructive(request, task, newChildren);
      }
      function renderContextProvider(request, task, type2, props) {
        var context = type2._context, value2 = props.value, children = props.children, prevSnapshot;
        prevSnapshot = task.context, task.context = pushProvider(context, value2), renderNodeDestructive(request, task, children), task.context = popProvider(context), prevSnapshot !== task.context && error2("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
      }
      function renderLazyComponent(request, task, lazyComponent, props, ref) {
        pushBuiltInComponentStackInDEV(task, "Lazy");
        var payload = lazyComponent._payload, init4 = lazyComponent._init, Component3 = init4(payload), resolvedProps = resolveDefaultProps(Component3, props);
        renderElement(request, task, Component3, resolvedProps, ref), popComponentStackInDEV(task);
      }
      function renderElement(request, task, type2, props, ref) {
        if (typeof type2 == "function")
          if (shouldConstruct$1(type2)) {
            renderClassComponent(request, task, type2, props);
            return;
          } else {
            renderIndeterminateComponent(request, task, type2, props);
            return;
          }
        if (typeof type2 == "string") {
          renderHostElement(request, task, type2, props);
          return;
        }
        switch (type2) {
          case REACT_LEGACY_HIDDEN_TYPE:
          case REACT_DEBUG_TRACING_MODE_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_FRAGMENT_TYPE: {
            renderNodeDestructive(request, task, props.children);
            return;
          }
          case REACT_SUSPENSE_LIST_TYPE: {
            pushBuiltInComponentStackInDEV(task, "SuspenseList"), renderNodeDestructive(request, task, props.children), popComponentStackInDEV(task);
            return;
          }
          case REACT_SCOPE_TYPE:
            throw new Error("ReactDOMServer does not yet support scope components.");
          case REACT_SUSPENSE_TYPE: {
            renderSuspenseBoundary(request, task, props);
            return;
          }
        }
        if (typeof type2 == "object" && type2 !== null)
          switch (type2.$$typeof) {
            case REACT_FORWARD_REF_TYPE: {
              renderForwardRef(request, task, type2, props, ref);
              return;
            }
            case REACT_MEMO_TYPE: {
              renderMemo(request, task, type2, props, ref);
              return;
            }
            case REACT_PROVIDER_TYPE: {
              renderContextProvider(request, task, type2, props);
              return;
            }
            case REACT_CONTEXT_TYPE: {
              renderContextConsumer(request, task, type2, props);
              return;
            }
            case REACT_LAZY_TYPE: {
              renderLazyComponent(request, task, type2, props);
              return;
            }
          }
        var info = "";
        throw (type2 === void 0 || typeof type2 == "object" && type2 !== null && Object.keys(type2).length === 0) && (info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."), new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (type2 == null ? type2 : typeof type2) + "." + info));
      }
      function validateIterable(iterable, iteratorFn) {
        typeof Symbol == "function" && iterable[Symbol.toStringTag] === "Generator" && (didWarnAboutGenerators || error2("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), didWarnAboutGenerators = !0), iterable.entries === iteratorFn && (didWarnAboutMaps || error2("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), didWarnAboutMaps = !0);
      }
      function renderNodeDestructive(request, task, node) {
        try {
          return renderNodeDestructiveImpl(request, task, node);
        } catch (x2) {
          throw typeof x2 == "object" && x2 !== null && typeof x2.then == "function" || (lastBoundaryErrorComponentStackDev = lastBoundaryErrorComponentStackDev !== null ? lastBoundaryErrorComponentStackDev : getCurrentStackInDEV()), x2;
        }
      }
      function renderNodeDestructiveImpl(request, task, node) {
        if (task.node = node, typeof node == "object" && node !== null) {
          switch (node.$$typeof) {
            case REACT_ELEMENT_TYPE: {
              var element = node, type2 = element.type, props = element.props, ref = element.ref;
              renderElement(request, task, type2, props, ref);
              return;
            }
            case REACT_PORTAL_TYPE:
              throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
            case REACT_LAZY_TYPE: {
              var lazyNode = node, payload = lazyNode._payload, init4 = lazyNode._init, resolvedNode;
              try {
                resolvedNode = init4(payload);
              } catch (x2) {
                throw typeof x2 == "object" && x2 !== null && typeof x2.then == "function" && pushBuiltInComponentStackInDEV(task, "Lazy"), x2;
              }
              renderNodeDestructive(request, task, resolvedNode);
              return;
            }
          }
          if (isArray3(node)) {
            renderChildrenArray(request, task, node);
            return;
          }
          var iteratorFn = getIteratorFn(node);
          if (iteratorFn) {
            validateIterable(node, iteratorFn);
            var iterator = iteratorFn.call(node);
            if (iterator) {
              var step = iterator.next();
              if (!step.done) {
                var children = [];
                do
                  children.push(step.value), step = iterator.next();
                while (!step.done);
                renderChildrenArray(request, task, children);
                return;
              }
              return;
            }
          }
          var childString = Object.prototype.toString.call(node);
          throw new Error("Objects are not valid as a React child (found: " + (childString === "[object Object]" ? "object with keys {" + Object.keys(node).join(", ") + "}" : childString) + "). If you meant to render a collection of children, use an array instead.");
        }
        if (typeof node == "string") {
          var segment = task.blockedSegment;
          segment.lastPushedText = pushTextInstance(task.blockedSegment.chunks, node, request.responseState, segment.lastPushedText);
          return;
        }
        if (typeof node == "number") {
          var _segment = task.blockedSegment;
          _segment.lastPushedText = pushTextInstance(task.blockedSegment.chunks, "" + node, request.responseState, _segment.lastPushedText);
          return;
        }
        typeof node == "function" && error2("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
      }
      function renderChildrenArray(request, task, children) {
        for (var totalChildren = children.length, i3 = 0; i3 < totalChildren; i3++) {
          var prevTreeContext = task.treeContext;
          task.treeContext = pushTreeContext(prevTreeContext, totalChildren, i3);
          try {
            renderNode(request, task, children[i3]);
          } finally {
            task.treeContext = prevTreeContext;
          }
        }
      }
      function spawnNewSuspendedTask(request, task, x2) {
        var segment = task.blockedSegment, insertionIndex = segment.chunks.length, newSegment = createPendingSegment(
          request,
          insertionIndex,
          null,
          segment.formatContext,
          segment.lastPushedText,
          !0
        );
        segment.children.push(newSegment), segment.lastPushedText = !1;
        var newTask = createTask(request, task.node, task.blockedBoundary, newSegment, task.abortSet, task.legacyContext, task.context, task.treeContext);
        task.componentStack !== null && (newTask.componentStack = task.componentStack.parent);
        var ping = newTask.ping;
        x2.then(ping, ping);
      }
      function renderNode(request, task, node) {
        var previousFormatContext = task.blockedSegment.formatContext, previousLegacyContext = task.legacyContext, previousContext = task.context, previousComponentStack = null;
        previousComponentStack = task.componentStack;
        try {
          return renderNodeDestructive(request, task, node);
        } catch (x2) {
          if (resetHooksState(), typeof x2 == "object" && x2 !== null && typeof x2.then == "function") {
            spawnNewSuspendedTask(request, task, x2), task.blockedSegment.formatContext = previousFormatContext, task.legacyContext = previousLegacyContext, task.context = previousContext, switchContext(previousContext), task.componentStack = previousComponentStack;
            return;
          } else
            throw task.blockedSegment.formatContext = previousFormatContext, task.legacyContext = previousLegacyContext, task.context = previousContext, switchContext(previousContext), task.componentStack = previousComponentStack, x2;
        }
      }
      function erroredTask(request, boundary, segment, error3) {
        var errorDigest = logRecoverableError(request, error3);
        if (boundary === null ? fatalError(request, error3) : (boundary.pendingTasks--, boundary.forceClientRender || (boundary.forceClientRender = !0, boundary.errorDigest = errorDigest, captureBoundaryErrorDetailsDev(boundary, error3), boundary.parentFlushed && request.clientRenderedBoundaries.push(boundary))), request.allPendingTasks--, request.allPendingTasks === 0) {
          var onAllReady = request.onAllReady;
          onAllReady();
        }
      }
      function abortTaskSoft(task) {
        var request = this, boundary = task.blockedBoundary, segment = task.blockedSegment;
        segment.status = ABORTED, finishedTask(request, boundary, segment);
      }
      function abortTask(task, request, reason) {
        var boundary = task.blockedBoundary, segment = task.blockedSegment;
        if (segment.status = ABORTED, boundary === null)
          request.allPendingTasks--, request.status !== CLOSED && (request.status = CLOSED, request.destination !== null && close(request.destination));
        else {
          if (boundary.pendingTasks--, !boundary.forceClientRender) {
            boundary.forceClientRender = !0;
            var _error = reason === void 0 ? new Error("The render was aborted by the server without a reason.") : reason;
            boundary.errorDigest = request.onError(_error);
            {
              var errorPrefix = "The server did not finish this Suspense boundary: ";
              _error && typeof _error.message == "string" ? _error = errorPrefix + _error.message : _error = errorPrefix + String(_error);
              var previousTaskInDev = currentTaskInDEV;
              currentTaskInDEV = task;
              try {
                captureBoundaryErrorDetailsDev(boundary, _error);
              } finally {
                currentTaskInDEV = previousTaskInDev;
              }
            }
            boundary.parentFlushed && request.clientRenderedBoundaries.push(boundary);
          }
          if (boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
            return abortTask(fallbackTask, request, reason);
          }), boundary.fallbackAbortableTasks.clear(), request.allPendingTasks--, request.allPendingTasks === 0) {
            var onAllReady = request.onAllReady;
            onAllReady();
          }
        }
      }
      function queueCompletedSegment(boundary, segment) {
        if (segment.chunks.length === 0 && segment.children.length === 1 && segment.children[0].boundary === null) {
          var childSegment = segment.children[0];
          childSegment.id = segment.id, childSegment.parentFlushed = !0, childSegment.status === COMPLETED && queueCompletedSegment(boundary, childSegment);
        } else {
          var completedSegments = boundary.completedSegments;
          completedSegments.push(segment);
        }
      }
      function finishedTask(request, boundary, segment) {
        if (boundary === null) {
          if (segment.parentFlushed) {
            if (request.completedRootSegment !== null)
              throw new Error("There can only be one root segment. This is a bug in React.");
            request.completedRootSegment = segment;
          }
          if (request.pendingRootTasks--, request.pendingRootTasks === 0) {
            request.onShellError = noop$1;
            var onShellReady = request.onShellReady;
            onShellReady();
          }
        } else if (boundary.pendingTasks--, !boundary.forceClientRender) {
          if (boundary.pendingTasks === 0)
            segment.parentFlushed && segment.status === COMPLETED && queueCompletedSegment(boundary, segment), boundary.parentFlushed && request.completedBoundaries.push(boundary), boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request), boundary.fallbackAbortableTasks.clear();
          else if (segment.parentFlushed && segment.status === COMPLETED) {
            queueCompletedSegment(boundary, segment);
            var completedSegments = boundary.completedSegments;
            completedSegments.length === 1 && boundary.parentFlushed && request.partialBoundaries.push(boundary);
          }
        }
        if (request.allPendingTasks--, request.allPendingTasks === 0) {
          var onAllReady = request.onAllReady;
          onAllReady();
        }
      }
      function retryTask(request, task) {
        var segment = task.blockedSegment;
        if (segment.status === PENDING) {
          switchContext(task.context);
          var prevTaskInDEV = null;
          prevTaskInDEV = currentTaskInDEV, currentTaskInDEV = task;
          try {
            renderNodeDestructive(request, task, task.node), pushSegmentFinale(segment.chunks, request.responseState, segment.lastPushedText, segment.textEmbedded), task.abortSet.delete(task), segment.status = COMPLETED, finishedTask(request, task.blockedBoundary, segment);
          } catch (x2) {
            if (resetHooksState(), typeof x2 == "object" && x2 !== null && typeof x2.then == "function") {
              var ping = task.ping;
              x2.then(ping, ping);
            } else
              task.abortSet.delete(task), segment.status = ERRORED, erroredTask(request, task.blockedBoundary, segment, x2);
          } finally {
            currentTaskInDEV = prevTaskInDEV;
          }
        }
      }
      function performWork(request) {
        if (request.status !== CLOSED) {
          var prevContext = getActiveContext(), prevDispatcher = ReactCurrentDispatcher$1.current;
          ReactCurrentDispatcher$1.current = Dispatcher;
          var prevGetCurrentStackImpl;
          prevGetCurrentStackImpl = ReactDebugCurrentFrame$1.getCurrentStack, ReactDebugCurrentFrame$1.getCurrentStack = getCurrentStackInDEV;
          var prevResponseState = currentResponseState;
          setCurrentResponseState(request.responseState);
          try {
            var pingedTasks = request.pingedTasks, i3;
            for (i3 = 0; i3 < pingedTasks.length; i3++) {
              var task = pingedTasks[i3];
              retryTask(request, task);
            }
            pingedTasks.splice(0, i3), request.destination !== null && flushCompletedQueues(request, request.destination);
          } catch (error3) {
            logRecoverableError(request, error3), fatalError(request, error3);
          } finally {
            setCurrentResponseState(prevResponseState), ReactCurrentDispatcher$1.current = prevDispatcher, ReactDebugCurrentFrame$1.getCurrentStack = prevGetCurrentStackImpl, prevDispatcher === Dispatcher && switchContext(prevContext);
          }
        }
      }
      function flushSubtree(request, destination, segment) {
        switch (segment.parentFlushed = !0, segment.status) {
          case PENDING: {
            var segmentID = segment.id = request.nextSegmentId++;
            return segment.lastPushedText = !1, segment.textEmbedded = !1, writePlaceholder(destination, request.responseState, segmentID);
          }
          case COMPLETED: {
            segment.status = FLUSHED;
            for (var r3 = !0, chunks = segment.chunks, chunkIdx = 0, children = segment.children, childIdx = 0; childIdx < children.length; childIdx++) {
              for (var nextChild = children[childIdx]; chunkIdx < nextChild.index; chunkIdx++)
                writeChunk(destination, chunks[chunkIdx]);
              r3 = flushSegment(request, destination, nextChild);
            }
            for (; chunkIdx < chunks.length - 1; chunkIdx++)
              writeChunk(destination, chunks[chunkIdx]);
            return chunkIdx < chunks.length && (r3 = writeChunkAndReturn(destination, chunks[chunkIdx])), r3;
          }
          default:
            throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
        }
      }
      function flushSegment(request, destination, segment) {
        var boundary = segment.boundary;
        if (boundary === null)
          return flushSubtree(request, destination, segment);
        if (boundary.parentFlushed = !0, boundary.forceClientRender)
          return writeStartClientRenderedSuspenseBoundary(destination, request.responseState, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack), flushSubtree(request, destination, segment), writeEndClientRenderedSuspenseBoundary(destination, request.responseState);
        if (boundary.pendingTasks > 0) {
          boundary.rootSegmentID = request.nextSegmentId++, boundary.completedSegments.length > 0 && request.partialBoundaries.push(boundary);
          var id4 = boundary.id = assignSuspenseBoundaryID(request.responseState);
          return writeStartPendingSuspenseBoundary(destination, request.responseState, id4), flushSubtree(request, destination, segment), writeEndPendingSuspenseBoundary(destination, request.responseState);
        } else {
          if (boundary.byteSize > request.progressiveChunkSize)
            return boundary.rootSegmentID = request.nextSegmentId++, request.completedBoundaries.push(boundary), writeStartPendingSuspenseBoundary(destination, request.responseState, boundary.id), flushSubtree(request, destination, segment), writeEndPendingSuspenseBoundary(destination, request.responseState);
          writeStartCompletedSuspenseBoundary(destination, request.responseState);
          var completedSegments = boundary.completedSegments;
          if (completedSegments.length !== 1)
            throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
          var contentSegment = completedSegments[0];
          return flushSegment(request, destination, contentSegment), writeEndCompletedSuspenseBoundary(destination, request.responseState);
        }
      }
      function flushClientRenderedBoundary(request, destination, boundary) {
        return writeClientRenderBoundaryInstruction(destination, request.responseState, boundary.id, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
      }
      function flushSegmentContainer(request, destination, segment) {
        return writeStartSegment(destination, request.responseState, segment.formatContext, segment.id), flushSegment(request, destination, segment), writeEndSegment(destination, segment.formatContext);
      }
      function flushCompletedBoundary(request, destination, boundary) {
        for (var completedSegments = boundary.completedSegments, i3 = 0; i3 < completedSegments.length; i3++) {
          var segment = completedSegments[i3];
          flushPartiallyCompletedSegment(request, destination, boundary, segment);
        }
        return completedSegments.length = 0, writeCompletedBoundaryInstruction(destination, request.responseState, boundary.id, boundary.rootSegmentID);
      }
      function flushPartialBoundary(request, destination, boundary) {
        for (var completedSegments = boundary.completedSegments, i3 = 0; i3 < completedSegments.length; i3++) {
          var segment = completedSegments[i3];
          if (!flushPartiallyCompletedSegment(request, destination, boundary, segment))
            return i3++, completedSegments.splice(0, i3), !1;
        }
        return completedSegments.splice(0, i3), !0;
      }
      function flushPartiallyCompletedSegment(request, destination, boundary, segment) {
        if (segment.status === FLUSHED)
          return !0;
        var segmentID = segment.id;
        if (segmentID === -1) {
          var rootSegmentID = segment.id = boundary.rootSegmentID;
          if (rootSegmentID === -1)
            throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
          return flushSegmentContainer(request, destination, segment);
        } else
          return flushSegmentContainer(request, destination, segment), writeCompletedSegmentInstruction(destination, request.responseState, segmentID);
      }
      function flushCompletedQueues(request, destination) {
        beginWriting();
        try {
          var completedRootSegment = request.completedRootSegment;
          completedRootSegment !== null && request.pendingRootTasks === 0 && (flushSegment(request, destination, completedRootSegment), request.completedRootSegment = null, writeCompletedRoot(destination, request.responseState));
          var clientRenderedBoundaries = request.clientRenderedBoundaries, i3;
          for (i3 = 0; i3 < clientRenderedBoundaries.length; i3++) {
            var boundary = clientRenderedBoundaries[i3];
            if (!flushClientRenderedBoundary(request, destination, boundary)) {
              request.destination = null, i3++, clientRenderedBoundaries.splice(0, i3);
              return;
            }
          }
          clientRenderedBoundaries.splice(0, i3);
          var completedBoundaries = request.completedBoundaries;
          for (i3 = 0; i3 < completedBoundaries.length; i3++) {
            var _boundary = completedBoundaries[i3];
            if (!flushCompletedBoundary(request, destination, _boundary)) {
              request.destination = null, i3++, completedBoundaries.splice(0, i3);
              return;
            }
          }
          completedBoundaries.splice(0, i3), completeWriting(destination), beginWriting(destination);
          var partialBoundaries = request.partialBoundaries;
          for (i3 = 0; i3 < partialBoundaries.length; i3++) {
            var _boundary2 = partialBoundaries[i3];
            if (!flushPartialBoundary(request, destination, _boundary2)) {
              request.destination = null, i3++, partialBoundaries.splice(0, i3);
              return;
            }
          }
          partialBoundaries.splice(0, i3);
          var largeBoundaries = request.completedBoundaries;
          for (i3 = 0; i3 < largeBoundaries.length; i3++) {
            var _boundary3 = largeBoundaries[i3];
            if (!flushCompletedBoundary(request, destination, _boundary3)) {
              request.destination = null, i3++, largeBoundaries.splice(0, i3);
              return;
            }
          }
          largeBoundaries.splice(0, i3);
        } finally {
          completeWriting(destination), request.allPendingTasks === 0 && request.pingedTasks.length === 0 && request.clientRenderedBoundaries.length === 0 && request.completedBoundaries.length === 0 && (request.abortableTasks.size !== 0 && error2("There was still abortable task at the root when we closed. This is a bug in React."), close(destination));
        }
      }
      function startWork(request) {
        scheduleWork(function() {
          return performWork(request);
        });
      }
      function startFlowing(request, destination) {
        if (request.status === CLOSING) {
          request.status = CLOSED, closeWithError(destination, request.fatalError);
          return;
        }
        if (request.status !== CLOSED && request.destination === null) {
          request.destination = destination;
          try {
            flushCompletedQueues(request, destination);
          } catch (error3) {
            logRecoverableError(request, error3), fatalError(request, error3);
          }
        }
      }
      function abort(request, reason) {
        try {
          var abortableTasks = request.abortableTasks;
          abortableTasks.forEach(function(task) {
            return abortTask(task, request, reason);
          }), abortableTasks.clear(), request.destination !== null && flushCompletedQueues(request, request.destination);
        } catch (error3) {
          logRecoverableError(request, error3), fatalError(request, error3);
        }
      }
      function renderToReadableStream(children, options2) {
        return new Promise(function(resolve2, reject) {
          var onFatalError, onAllReady, allReady = new Promise(function(res, rej) {
            onAllReady = res, onFatalError = rej;
          });
          function onShellReady() {
            var stream = new ReadableStream(
              {
                type: "bytes",
                pull: function(controller) {
                  startFlowing(request, controller);
                },
                cancel: function(reason) {
                  abort(request);
                }
              },
              {
                highWaterMark: 0
              }
            );
            stream.allReady = allReady, resolve2(stream);
          }
          function onShellError(error3) {
            allReady.catch(function() {
            }), reject(error3);
          }
          var request = createRequest(children, createResponseState(options2 ? options2.identifierPrefix : void 0, options2 ? options2.nonce : void 0, options2 ? options2.bootstrapScriptContent : void 0, options2 ? options2.bootstrapScripts : void 0, options2 ? options2.bootstrapModules : void 0), createRootFormatContext(options2 ? options2.namespaceURI : void 0), options2 ? options2.progressiveChunkSize : void 0, options2 ? options2.onError : void 0, onAllReady, onShellReady, onShellError, onFatalError);
          if (options2 && options2.signal) {
            var signal = options2.signal, listener = function() {
              abort(request, signal.reason), signal.removeEventListener("abort", listener);
            };
            signal.addEventListener("abort", listener);
          }
          startWork(request);
        });
      }
      exports.renderToReadableStream = renderToReadableStream, exports.version = ReactVersion;
    })();
  }
});

// node_modules/react-dom/server.browser.js
var require_server_browser = __commonJS({
  "node_modules/react-dom/server.browser.js"(exports) {
    "use strict";
    var l2, s3;
    l2 = require_react_dom_server_legacy_browser_development(), s3 = require_react_dom_server_browser_development();
    exports.version = l2.version;
    exports.renderToString = l2.renderToString;
    exports.renderToStaticMarkup = l2.renderToStaticMarkup;
    exports.renderToNodeStream = l2.renderToNodeStream;
    exports.renderToStaticNodeStream = l2.renderToStaticNodeStream;
    exports.renderToReadableStream = s3.renderToReadableStream;
  }
});

// node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose2(source2, excluded) {
  if (source2 == null)
    return {};
  var target = {}, sourceKeys = Object.keys(source2), key2, i3;
  for (i3 = 0; i3 < sourceKeys.length; i3++)
    key2 = sourceKeys[i3], !(excluded.indexOf(key2) >= 0) && (target[key2] = source2[key2]);
  return target;
}
var init_objectWithoutPropertiesLoose = __esm({
  "node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js
function _objectWithoutProperties(source2, excluded) {
  if (source2 == null)
    return {};
  var target = _objectWithoutPropertiesLoose2(source2, excluded), key2, i3;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source2);
    for (i3 = 0; i3 < sourceSymbolKeys.length; i3++)
      key2 = sourceSymbolKeys[i3], !(excluded.indexOf(key2) >= 0) && (!Object.prototype.propertyIsEnumerable.call(source2, key2) || (target[key2] = source2[key2]));
  }
  return target;
}
var init_objectWithoutProperties = __esm({
  "node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js"() {
    init_objectWithoutPropertiesLoose();
  }
});

// node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof3(obj) {
  return _typeof3 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof3(obj);
}
var init_typeof = __esm({
  "node_modules/@babel/runtime/helpers/esm/typeof.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function _toPrimitive(input, hint) {
  if (_typeof3(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof3(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var init_toPrimitive = __esm({
  "node_modules/@babel/runtime/helpers/esm/toPrimitive.js"() {
    init_typeof();
  }
});

// node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function _toPropertyKey(arg) {
  var key2 = _toPrimitive(arg, "string");
  return _typeof3(key2) === "symbol" ? key2 : String(key2);
}
var init_toPropertyKey = __esm({
  "node_modules/@babel/runtime/helpers/esm/toPropertyKey.js"() {
    init_typeof();
    init_toPrimitive();
  }
});

// node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(obj, key2, value2) {
  return key2 = _toPropertyKey(key2), key2 in obj ? Object.defineProperty(obj, key2, {
    value: value2,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key2] = value2, obj;
}
var init_defineProperty = __esm({
  "node_modules/@babel/runtime/helpers/esm/defineProperty.js"() {
    init_toPropertyKey();
  }
});

// node_modules/void-elements/index.js
var require_void_elements = __commonJS({
  "node_modules/void-elements/index.js"(exports, module2) {
    module2.exports = {
      area: !0,
      base: !0,
      br: !0,
      col: !0,
      embed: !0,
      hr: !0,
      img: !0,
      input: !0,
      link: !0,
      meta: !0,
      param: !0,
      source: !0,
      track: !0,
      wbr: !0
    };
  }
});

// node_modules/html-parse-stringify/dist/html-parse-stringify.module.js
function n(n3) {
  var r3 = { type: "tag", name: "", voidElement: !1, attrs: {}, children: [] }, i3 = n3.match(/<\/?([^\s]+?)[/\s>]/);
  if (i3 && (r3.name = i3[1], (import_void_elements.default[i3[1]] || n3.charAt(n3.length - 2) === "/") && (r3.voidElement = !0), r3.name.startsWith("!--"))) {
    var s3 = n3.indexOf("-->");
    return { type: "comment", comment: s3 !== -1 ? n3.slice(4, s3) : "" };
  }
  for (var a3 = new RegExp(t), c4 = null; (c4 = a3.exec(n3)) !== null; )
    if (c4[0].trim())
      if (c4[1]) {
        var o2 = c4[1].trim(), l2 = [o2, ""];
        o2.indexOf("=") > -1 && (l2 = o2.split("=")), r3.attrs[l2[0]] = l2[1], a3.lastIndex--;
      } else
        c4[2] && (r3.attrs[c4[2]] = c4[3].trim().substring(1, c4[3].length - 1));
  return r3;
}
function a(e3, t4) {
  switch (t4.type) {
    case "text":
      return e3 + t4.content;
    case "tag":
      return e3 += "<" + t4.name + (t4.attrs ? function(e4) {
        var t5 = [];
        for (var n3 in e4)
          t5.push(n3 + '="' + e4[n3] + '"');
        return t5.length ? " " + t5.join(" ") : "";
      }(t4.attrs) : "") + (t4.voidElement ? "/>" : ">"), t4.voidElement ? e3 : e3 + t4.children.reduce(a, "") + "</" + t4.name + ">";
    case "comment":
      return e3 + "<!--" + t4.comment + "-->";
  }
}
var import_void_elements, t, r, i, s, c2, html_parse_stringify_module_default, init_html_parse_stringify_module = __esm({
  "node_modules/html-parse-stringify/dist/html-parse-stringify.module.js"() {
    import_void_elements = __toESM(require_void_elements()), t = /\s([^'"/\s><]+?)[\s/>]|([^\s=]+)=\s?(".*?"|'.*?')/g;
    r = /<[a-zA-Z0-9\-\!\/](?:"[^"]*"|'[^']*'|[^'">])*>/g, i = /^\s*$/, s = /* @__PURE__ */ Object.create(null);
    c2 = { parse: function(e3, t4) {
      t4 || (t4 = {}), t4.components || (t4.components = s);
      var a3, c4 = [], o2 = [], l2 = -1, m2 = !1;
      if (e3.indexOf("<") !== 0) {
        var u2 = e3.indexOf("<");
        c4.push({ type: "text", content: u2 === -1 ? e3 : e3.substring(0, u2) });
      }
      return e3.replace(r, function(r3, s3) {
        if (m2) {
          if (r3 !== "</" + a3.name + ">")
            return;
          m2 = !1;
        }
        var u3, f2 = r3.charAt(1) !== "/", h = r3.startsWith("<!--"), p = s3 + r3.length, d2 = e3.charAt(p);
        if (h) {
          var v2 = n(r3);
          return l2 < 0 ? (c4.push(v2), c4) : ((u3 = o2[l2]).children.push(v2), c4);
        }
        if (f2 && (l2++, (a3 = n(r3)).type === "tag" && t4.components[a3.name] && (a3.type = "component", m2 = !0), a3.voidElement || m2 || !d2 || d2 === "<" || a3.children.push({ type: "text", content: e3.slice(p, e3.indexOf("<", p)) }), l2 === 0 && c4.push(a3), (u3 = o2[l2 - 1]) && u3.children.push(a3), o2[l2] = a3), (!f2 || a3.voidElement) && (l2 > -1 && (a3.voidElement || a3.name === r3.slice(2, -1)) && (l2--, a3 = l2 === -1 ? c4 : o2[l2]), !m2 && d2 !== "<" && d2)) {
          u3 = l2 === -1 ? c4 : o2[l2].children;
          var x2 = e3.indexOf("<", p), g2 = e3.slice(p, x2 === -1 ? void 0 : x2);
          i.test(g2) && (g2 = " "), (x2 > -1 && l2 + u3.length >= 0 || g2 !== " ") && u3.push({ type: "text", content: g2 });
        }
      }), c4;
    }, stringify: function(e3) {
      return e3.reduce(function(e4, t4) {
        return e4 + a("", t4);
      }, "");
    } }, html_parse_stringify_module_default = c2;
  }
});

// node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck2(instance2, Constructor) {
  if (!(instance2 instanceof Constructor))
    throw new TypeError("Cannot call a class as a function");
}
var init_classCallCheck = __esm({
  "node_modules/@babel/runtime/helpers/esm/classCallCheck.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties2(target, props) {
  for (var i3 = 0; i3 < props.length; i3++) {
    var descriptor = props[i3];
    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass2(Constructor, protoProps, staticProps) {
  return protoProps && _defineProperties2(Constructor.prototype, protoProps), staticProps && _defineProperties2(Constructor, staticProps), Object.defineProperty(Constructor, "prototype", {
    writable: !1
  }), Constructor;
}
var init_createClass = __esm({
  "node_modules/@babel/runtime/helpers/esm/createClass.js"() {
    init_toPropertyKey();
  }
});

// node_modules/react-i18next/dist/es/unescape.js
var matchHtmlEntity, htmlEntities, unescapeHtmlEntity, unescape2, init_unescape = __esm({
  "node_modules/react-i18next/dist/es/unescape.js"() {
    matchHtmlEntity = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g, htmlEntities = {
      "&amp;": "&",
      "&#38;": "&",
      "&lt;": "<",
      "&#60;": "<",
      "&gt;": ">",
      "&#62;": ">",
      "&apos;": "'",
      "&#39;": "'",
      "&quot;": '"',
      "&#34;": '"',
      "&nbsp;": " ",
      "&#160;": " ",
      "&copy;": "\xA9",
      "&#169;": "\xA9",
      "&reg;": "\xAE",
      "&#174;": "\xAE",
      "&hellip;": "\u2026",
      "&#8230;": "\u2026",
      "&#x2F;": "/",
      "&#47;": "/"
    }, unescapeHtmlEntity = function(m2) {
      return htmlEntities[m2];
    }, unescape2 = function(text) {
      return text.replace(matchHtmlEntity, unescapeHtmlEntity);
    };
  }
});

// node_modules/react-i18next/dist/es/context.js
function ownKeys(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source2 = arguments[i3] != null ? arguments[i3] : {};
    i3 % 2 ? ownKeys(Object(source2), !0).forEach(function(key2) {
      _defineProperty(target, key2, source2[key2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2)) : ownKeys(Object(source2)).forEach(function(key2) {
      Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source2, key2));
    });
  }
  return target;
}
function setDefaults() {
  var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  defaultOptions = _objectSpread(_objectSpread({}, defaultOptions), options2);
}
function getDefaults3() {
  return defaultOptions;
}
function setI18n(instance2) {
  i18nInstance = instance2;
}
function getI18n() {
  return i18nInstance;
}
function composeInitialProps(ForComponent) {
  return function(ctx) {
    return new Promise(function(resolve2) {
      var i18nInitialProps = getInitialProps();
      ForComponent.getInitialProps ? ForComponent.getInitialProps(ctx).then(function(componentsInitialProps) {
        resolve2(_objectSpread(_objectSpread({}, componentsInitialProps), i18nInitialProps));
      }) : resolve2(i18nInitialProps);
    });
  };
}
function getInitialProps() {
  var i18n = getI18n(), namespaces = i18n.reportNamespaces ? i18n.reportNamespaces.getUsedNamespaces() : [], ret = {}, initialI18nStore = {};
  return i18n.languages.forEach(function(l2) {
    initialI18nStore[l2] = {}, namespaces.forEach(function(ns) {
      initialI18nStore[l2][ns] = i18n.getResourceBundle(l2, ns) || {};
    });
  }), ret.initialI18nStore = initialI18nStore, ret.initialLanguage = i18n.language, ret;
}
var import_react2, defaultOptions, i18nInstance, I18nContext, ReportNamespaces, initReactI18next, init_context = __esm({
  "node_modules/react-i18next/dist/es/context.js"() {
    init_classCallCheck();
    init_createClass();
    init_defineProperty();
    import_react2 = __toESM(require_react());
    init_unescape();
    defaultOptions = {
      bindI18n: "languageChanged",
      bindI18nStore: "",
      transEmptyNodeValue: "",
      transSupportBasicHtmlNodes: !0,
      transWrapTextNodes: "",
      transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
      useSuspense: !0,
      unescape: unescape2
    }, I18nContext = (0, import_react2.createContext)();
    ReportNamespaces = function() {
      function ReportNamespaces2() {
        _classCallCheck2(this, ReportNamespaces2), this.usedNamespaces = {};
      }
      return _createClass2(ReportNamespaces2, [{
        key: "addUsedNamespaces",
        value: function(namespaces) {
          var _this = this;
          namespaces.forEach(function(ns) {
            _this.usedNamespaces[ns] || (_this.usedNamespaces[ns] = !0);
          });
        }
      }, {
        key: "getUsedNamespaces",
        value: function() {
          return Object.keys(this.usedNamespaces);
        }
      }]), ReportNamespaces2;
    }();
    initReactI18next = {
      type: "3rdParty",
      init: function(instance2) {
        setDefaults(instance2.options.react), setI18n(instance2);
      }
    };
  }
});

// node_modules/react-i18next/dist/es/utils.js
function warn() {
  if (console && console.warn) {
    for (var _console, _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    typeof args[0] == "string" && (args[0] = "react-i18next:: ".concat(args[0])), (_console = console).warn.apply(_console, args);
  }
}
function warnOnce2() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++)
    args[_key2] = arguments[_key2];
  typeof args[0] == "string" && alreadyWarned4[args[0]] || (typeof args[0] == "string" && (alreadyWarned4[args[0]] = new Date()), warn.apply(void 0, args));
}
function loadNamespaces(i18n, ns, cb) {
  i18n.loadNamespaces(ns, function() {
    if (i18n.isInitialized)
      cb();
    else {
      var initialized = function initialized2() {
        setTimeout(function() {
          i18n.off("initialized", initialized2);
        }, 0), cb();
      };
      i18n.on("initialized", initialized);
    }
  });
}
function oldI18nextHasLoadedNamespace(ns, i18n) {
  var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, lng2 = i18n.languages[0], fallbackLng = i18n.options ? i18n.options.fallbackLng : !1, lastLng = i18n.languages[i18n.languages.length - 1];
  if (lng2.toLowerCase() === "cimode")
    return !0;
  var loadNotPending = function(l2, n3) {
    var loadState = i18n.services.backendConnector.state["".concat(l2, "|").concat(n3)];
    return loadState === -1 || loadState === 2;
  };
  return options2.bindI18n && options2.bindI18n.indexOf("languageChanging") > -1 && i18n.services.backendConnector.backend && i18n.isLanguageChangingTo && !loadNotPending(i18n.isLanguageChangingTo, ns) ? !1 : !!(i18n.hasResourceBundle(lng2, ns) || !i18n.services.backendConnector.backend || i18n.options.resources && !i18n.options.partialBundledLanguages || loadNotPending(lng2, ns) && (!fallbackLng || loadNotPending(lastLng, ns)));
}
function hasLoadedNamespace(ns, i18n) {
  var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (!i18n.languages || !i18n.languages.length)
    return warnOnce2("i18n.languages were undefined or empty", i18n.languages), !0;
  var isNewerI18next = i18n.options.ignoreJSONStructure !== void 0;
  return isNewerI18next ? i18n.hasLoadedNamespace(ns, {
    precheck: function(i18nInstance2, loadNotPending) {
      if (options2.bindI18n && options2.bindI18n.indexOf("languageChanging") > -1 && i18nInstance2.services.backendConnector.backend && i18nInstance2.isLanguageChangingTo && !loadNotPending(i18nInstance2.isLanguageChangingTo, ns))
        return !1;
    }
  }) : oldI18nextHasLoadedNamespace(ns, i18n, options2);
}
function getDisplayName(Component3) {
  return Component3.displayName || Component3.name || (typeof Component3 == "string" && Component3.length > 0 ? Component3 : "Unknown");
}
var alreadyWarned4, init_utils2 = __esm({
  "node_modules/react-i18next/dist/es/utils.js"() {
    alreadyWarned4 = {};
  }
});

// node_modules/react-i18next/dist/es/Trans.js
function ownKeys2(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source2 = arguments[i3] != null ? arguments[i3] : {};
    i3 % 2 ? ownKeys2(Object(source2), !0).forEach(function(key2) {
      _defineProperty(target, key2, source2[key2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2)) : ownKeys2(Object(source2)).forEach(function(key2) {
      Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source2, key2));
    });
  }
  return target;
}
function hasChildren(node, checkLength) {
  if (!node)
    return !1;
  var base = node.props ? node.props.children : node.children;
  return checkLength ? base.length > 0 : !!base;
}
function getChildren(node) {
  return node ? node.props ? node.props.children : node.children : [];
}
function hasValidReactChildren(children) {
  return Object.prototype.toString.call(children) !== "[object Array]" ? !1 : children.every(function(child) {
    return (0, import_react3.isValidElement)(child);
  });
}
function getAsArray(data2) {
  return Array.isArray(data2) ? data2 : [data2];
}
function mergeProps(source2, target) {
  var newTarget = _objectSpread2({}, target);
  return newTarget.props = Object.assign(source2.props, target.props), newTarget;
}
function nodesToString(children, i18nOptions) {
  if (!children)
    return "";
  var stringNode = "", childrenArray = getAsArray(children), keepArray = i18nOptions.transSupportBasicHtmlNodes && i18nOptions.transKeepBasicHtmlNodesFor ? i18nOptions.transKeepBasicHtmlNodesFor : [];
  return childrenArray.forEach(function(child, childIndex) {
    if (typeof child == "string")
      stringNode += "".concat(child);
    else if ((0, import_react3.isValidElement)(child)) {
      var childPropsCount = Object.keys(child.props).length, shouldKeepChild = keepArray.indexOf(child.type) > -1, childChildren = child.props.children;
      if (!childChildren && shouldKeepChild && childPropsCount === 0)
        stringNode += "<".concat(child.type, "/>");
      else if (!childChildren && (!shouldKeepChild || childPropsCount !== 0))
        stringNode += "<".concat(childIndex, "></").concat(childIndex, ">");
      else if (child.props.i18nIsDynamicList)
        stringNode += "<".concat(childIndex, "></").concat(childIndex, ">");
      else if (shouldKeepChild && childPropsCount === 1 && typeof childChildren == "string")
        stringNode += "<".concat(child.type, ">").concat(childChildren, "</").concat(child.type, ">");
      else {
        var content = nodesToString(childChildren, i18nOptions);
        stringNode += "<".concat(childIndex, ">").concat(content, "</").concat(childIndex, ">");
      }
    } else if (child === null)
      warn("Trans: the passed in value is invalid - seems you passed in a null child.");
    else if (_typeof3(child) === "object") {
      var format2 = child.format, clone = _objectWithoutProperties(child, _excluded4), keys2 = Object.keys(clone);
      if (keys2.length === 1) {
        var value2 = format2 ? "".concat(keys2[0], ", ").concat(format2) : keys2[0];
        stringNode += "{{".concat(value2, "}}");
      } else
        warn("react-i18next: the passed in object contained more than one variable - the object should look like {{ value, format }} where format is optional.", child);
    } else
      warn("Trans: the passed in value is invalid - seems you passed in a variable like {number} - please pass in variables for interpolation as full objects like {{number}}.", child);
  }), stringNode;
}
function renderNodes(children, targetString, i18n, i18nOptions, combinedTOpts, shouldUnescape) {
  if (targetString === "")
    return [];
  var keepArray = i18nOptions.transKeepBasicHtmlNodesFor || [], emptyChildrenButNeedsHandling = targetString && new RegExp(keepArray.join("|")).test(targetString);
  if (!children && !emptyChildrenButNeedsHandling)
    return [targetString];
  var data2 = {};
  function getData(childs) {
    var childrenArray = getAsArray(childs);
    childrenArray.forEach(function(child) {
      typeof child != "string" && (hasChildren(child) ? getData(getChildren(child)) : _typeof3(child) === "object" && !(0, import_react3.isValidElement)(child) && Object.assign(data2, child));
    });
  }
  getData(children);
  var ast = html_parse_stringify_module_default.parse("<0>".concat(targetString, "</0>")), opts = _objectSpread2(_objectSpread2({}, data2), combinedTOpts);
  function renderInner(child, node, rootReactNode) {
    var childs = getChildren(child), mappedChildren = mapAST(childs, node.children, rootReactNode);
    return hasValidReactChildren(childs) && mappedChildren.length === 0 ? childs : mappedChildren;
  }
  function pushTranslatedJSX(child, inner, mem, i3, isVoid) {
    child.dummy && (child.children = inner), mem.push((0, import_react3.cloneElement)(child, _objectSpread2(_objectSpread2({}, child.props), {}, {
      key: i3
    }), isVoid ? void 0 : inner));
  }
  function mapAST(reactNode, astNode, rootReactNode) {
    var reactNodes = getAsArray(reactNode), astNodes = getAsArray(astNode);
    return astNodes.reduce(function(mem, node, i3) {
      var translationContent = node.children && node.children[0] && node.children[0].content && i18n.services.interpolator.interpolate(node.children[0].content, opts, i18n.language);
      if (node.type === "tag") {
        var tmp = reactNodes[parseInt(node.name, 10)];
        !tmp && rootReactNode.length === 1 && rootReactNode[0][node.name] && (tmp = rootReactNode[0][node.name]), tmp || (tmp = {});
        var child = Object.keys(node.attrs).length !== 0 ? mergeProps({
          props: node.attrs
        }, tmp) : tmp, isElement = (0, import_react3.isValidElement)(child), isValidTranslationWithChildren = isElement && hasChildren(node, !0) && !node.voidElement, isEmptyTransWithHTML = emptyChildrenButNeedsHandling && _typeof3(child) === "object" && child.dummy && !isElement, isKnownComponent = _typeof3(children) === "object" && children !== null && Object.hasOwnProperty.call(children, node.name);
        if (typeof child == "string") {
          var value2 = i18n.services.interpolator.interpolate(child, opts, i18n.language);
          mem.push(value2);
        } else if (hasChildren(child) || isValidTranslationWithChildren) {
          var inner = renderInner(child, node, rootReactNode);
          pushTranslatedJSX(child, inner, mem, i3);
        } else if (isEmptyTransWithHTML) {
          var _inner = mapAST(reactNodes, node.children, rootReactNode);
          mem.push((0, import_react3.cloneElement)(child, _objectSpread2(_objectSpread2({}, child.props), {}, {
            key: i3
          }), _inner));
        } else if (Number.isNaN(parseFloat(node.name)))
          if (isKnownComponent) {
            var _inner2 = renderInner(child, node, rootReactNode);
            pushTranslatedJSX(child, _inner2, mem, i3, node.voidElement);
          } else if (i18nOptions.transSupportBasicHtmlNodes && keepArray.indexOf(node.name) > -1)
            if (node.voidElement)
              mem.push((0, import_react3.createElement)(node.name, {
                key: "".concat(node.name, "-").concat(i3)
              }));
            else {
              var _inner3 = mapAST(reactNodes, node.children, rootReactNode);
              mem.push((0, import_react3.createElement)(node.name, {
                key: "".concat(node.name, "-").concat(i3)
              }, _inner3));
            }
          else if (node.voidElement)
            mem.push("<".concat(node.name, " />"));
          else {
            var _inner4 = mapAST(reactNodes, node.children, rootReactNode);
            mem.push("<".concat(node.name, ">").concat(_inner4, "</").concat(node.name, ">"));
          }
        else if (_typeof3(child) === "object" && !isElement) {
          var content = node.children[0] ? translationContent : null;
          content && mem.push(content);
        } else
          node.children.length === 1 && translationContent ? mem.push((0, import_react3.cloneElement)(child, _objectSpread2(_objectSpread2({}, child.props), {}, {
            key: i3
          }), translationContent)) : mem.push((0, import_react3.cloneElement)(child, _objectSpread2(_objectSpread2({}, child.props), {}, {
            key: i3
          })));
      } else if (node.type === "text") {
        var wrapTextNodes = i18nOptions.transWrapTextNodes, _content = shouldUnescape ? i18nOptions.unescape(i18n.services.interpolator.interpolate(node.content, opts, i18n.language)) : i18n.services.interpolator.interpolate(node.content, opts, i18n.language);
        wrapTextNodes ? mem.push((0, import_react3.createElement)(wrapTextNodes, {
          key: "".concat(node.name, "-").concat(i3)
        }, _content)) : mem.push(_content);
      }
      return mem;
    }, []);
  }
  var result2 = mapAST([{
    dummy: !0,
    children: children || []
  }], ast, getAsArray(children || []));
  return getChildren(result2[0]);
}
function Trans(_ref) {
  var children = _ref.children, count = _ref.count, parent = _ref.parent, i18nKey = _ref.i18nKey, context = _ref.context, _ref$tOptions = _ref.tOptions, tOptions = _ref$tOptions === void 0 ? {} : _ref$tOptions, values = _ref.values, defaults2 = _ref.defaults, components = _ref.components, ns = _ref.ns, i18nFromProps = _ref.i18n, tFromProps = _ref.t, shouldUnescape = _ref.shouldUnescape, additionalProps = _objectWithoutProperties(_ref, _excluded22), _ref2 = (0, import_react3.useContext)(I18nContext) || {}, i18nFromContext = _ref2.i18n, defaultNSFromContext = _ref2.defaultNS, i18n = i18nFromProps || i18nFromContext || getI18n();
  if (!i18n)
    return warnOnce2("You will need to pass in an i18next instance by using i18nextReactModule"), children;
  var t4 = tFromProps || i18n.t.bind(i18n) || function(k2) {
    return k2;
  };
  context && (tOptions.context = context);
  var reactI18nextOptions = _objectSpread2(_objectSpread2({}, getDefaults3()), i18n.options && i18n.options.react), namespaces = ns || t4.ns || defaultNSFromContext || i18n.options && i18n.options.defaultNS;
  namespaces = typeof namespaces == "string" ? [namespaces] : namespaces || ["translation"];
  var defaultValue = defaults2 || nodesToString(children, reactI18nextOptions) || reactI18nextOptions.transEmptyNodeValue || i18nKey, hashTransKey = reactI18nextOptions.hashTransKey, key2 = i18nKey || (hashTransKey ? hashTransKey(defaultValue) : defaultValue), interpolationOverride = values ? tOptions.interpolation : {
    interpolation: _objectSpread2(_objectSpread2({}, tOptions.interpolation), {}, {
      prefix: "#$?",
      suffix: "?$#"
    })
  }, combinedTOpts = _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, tOptions), {}, {
    count
  }, values), interpolationOverride), {}, {
    defaultValue,
    ns: namespaces
  }), translation = key2 ? t4(key2, combinedTOpts) : defaultValue, content = renderNodes(components || children, translation, i18n, reactI18nextOptions, combinedTOpts, shouldUnescape), useAsParent = parent !== void 0 ? parent : reactI18nextOptions.defaultTransParent;
  return useAsParent ? (0, import_react3.createElement)(useAsParent, additionalProps, content) : content;
}
var import_react3, _excluded4, _excluded22, init_Trans = __esm({
  "node_modules/react-i18next/dist/es/Trans.js"() {
    init_objectWithoutProperties();
    init_typeof();
    init_defineProperty();
    import_react3 = __toESM(require_react());
    init_html_parse_stringify_module();
    init_context();
    init_utils2();
    _excluded4 = ["format"], _excluded22 = ["children", "count", "parent", "i18nKey", "context", "tOptions", "values", "defaults", "components", "ns", "i18n", "t", "shouldUnescape"];
  }
});

// node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
function _arrayWithHoles(arr2) {
  if (Array.isArray(arr2))
    return arr2;
}
var init_arrayWithHoles = __esm({
  "node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js
function _iterableToArrayLimit(arr2, i3) {
  var _i = arr2 == null ? null : typeof Symbol < "u" && arr2[Symbol.iterator] || arr2["@@iterator"];
  if (_i != null) {
    var _s, _e2, _x, _r, _arr = [], _n = !0, _d = !1;
    try {
      if (_x = (_i = _i.call(arr2)).next, i3 === 0) {
        if (Object(_i) !== _i)
          return;
        _n = !1;
      } else
        for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i3); _n = !0)
          ;
    } catch (err) {
      _d = !0, _e2 = err;
    } finally {
      try {
        if (!_n && _i.return != null && (_r = _i.return(), Object(_r) !== _r))
          return;
      } finally {
        if (_d)
          throw _e2;
      }
    }
    return _arr;
  }
}
var init_iterableToArrayLimit = __esm({
  "node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray2(arr2, len) {
  (len == null || len > arr2.length) && (len = arr2.length);
  for (var i3 = 0, arr22 = new Array(len); i3 < len; i3++)
    arr22[i3] = arr2[i3];
  return arr22;
}
var init_arrayLikeToArray = __esm({
  "node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
function _unsupportedIterableToArray2(o2, minLen) {
  if (!!o2) {
    if (typeof o2 == "string")
      return _arrayLikeToArray2(o2, minLen);
    var n3 = Object.prototype.toString.call(o2).slice(8, -1);
    if (n3 === "Object" && o2.constructor && (n3 = o2.constructor.name), n3 === "Map" || n3 === "Set")
      return Array.from(o2);
    if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3))
      return _arrayLikeToArray2(o2, minLen);
  }
}
var init_unsupportedIterableToArray = __esm({
  "node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js"() {
    init_arrayLikeToArray();
  }
});

// node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
function _nonIterableRest() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
var init_nonIterableRest = __esm({
  "node_modules/@babel/runtime/helpers/esm/nonIterableRest.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/slicedToArray.js
function _slicedToArray(arr2, i3) {
  return _arrayWithHoles(arr2) || _iterableToArrayLimit(arr2, i3) || _unsupportedIterableToArray2(arr2, i3) || _nonIterableRest();
}
var init_slicedToArray = __esm({
  "node_modules/@babel/runtime/helpers/esm/slicedToArray.js"() {
    init_arrayWithHoles();
    init_iterableToArrayLimit();
    init_unsupportedIterableToArray();
    init_nonIterableRest();
  }
});

// node_modules/react-i18next/dist/es/useTranslation.js
function ownKeys3(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread3(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source2 = arguments[i3] != null ? arguments[i3] : {};
    i3 % 2 ? ownKeys3(Object(source2), !0).forEach(function(key2) {
      _defineProperty(target, key2, source2[key2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2)) : ownKeys3(Object(source2)).forEach(function(key2) {
      Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source2, key2));
    });
  }
  return target;
}
function useTranslation(ns) {
  var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i18nFromProps = props.i18n, _ref = (0, import_react4.useContext)(I18nContext) || {}, i18nFromContext = _ref.i18n, defaultNSFromContext = _ref.defaultNS, i18n = i18nFromProps || i18nFromContext || getI18n();
  if (i18n && !i18n.reportNamespaces && (i18n.reportNamespaces = new ReportNamespaces()), !i18n) {
    warnOnce2("You will need to pass in an i18next instance by using initReactI18next");
    var notReadyT = function(k2) {
      return Array.isArray(k2) ? k2[k2.length - 1] : k2;
    }, retNotReady = [notReadyT, {}, !1];
    return retNotReady.t = notReadyT, retNotReady.i18n = {}, retNotReady.ready = !1, retNotReady;
  }
  i18n.options.react && i18n.options.react.wait !== void 0 && warnOnce2("It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");
  var i18nOptions = _objectSpread3(_objectSpread3(_objectSpread3({}, getDefaults3()), i18n.options.react), props), useSuspense = i18nOptions.useSuspense, keyPrefix = i18nOptions.keyPrefix, namespaces = ns || defaultNSFromContext || i18n.options && i18n.options.defaultNS;
  namespaces = typeof namespaces == "string" ? [namespaces] : namespaces || ["translation"], i18n.reportNamespaces.addUsedNamespaces && i18n.reportNamespaces.addUsedNamespaces(namespaces);
  var ready = (i18n.isInitialized || i18n.initializedStoreOnce) && namespaces.every(function(n3) {
    return hasLoadedNamespace(n3, i18n, i18nOptions);
  });
  function getT() {
    return i18n.getFixedT(null, i18nOptions.nsMode === "fallback" ? namespaces : namespaces[0], keyPrefix);
  }
  var _useState = (0, import_react4.useState)(getT), _useState2 = _slicedToArray(_useState, 2), t4 = _useState2[0], setT = _useState2[1], joinedNS = namespaces.join(), previousJoinedNS = usePrevious(joinedNS), isMounted = (0, import_react4.useRef)(!0);
  (0, import_react4.useEffect)(function() {
    var bindI18n = i18nOptions.bindI18n, bindI18nStore = i18nOptions.bindI18nStore;
    isMounted.current = !0, !ready && !useSuspense && loadNamespaces(i18n, namespaces, function() {
      isMounted.current && setT(getT);
    }), ready && previousJoinedNS && previousJoinedNS !== joinedNS && isMounted.current && setT(getT);
    function boundReset() {
      isMounted.current && setT(getT);
    }
    return bindI18n && i18n && i18n.on(bindI18n, boundReset), bindI18nStore && i18n && i18n.store.on(bindI18nStore, boundReset), function() {
      isMounted.current = !1, bindI18n && i18n && bindI18n.split(" ").forEach(function(e3) {
        return i18n.off(e3, boundReset);
      }), bindI18nStore && i18n && bindI18nStore.split(" ").forEach(function(e3) {
        return i18n.store.off(e3, boundReset);
      });
    };
  }, [i18n, joinedNS]);
  var isInitial = (0, import_react4.useRef)(!0);
  (0, import_react4.useEffect)(function() {
    isMounted.current && !isInitial.current && setT(getT), isInitial.current = !1;
  }, [i18n, keyPrefix]);
  var ret = [t4, i18n, ready];
  if (ret.t = t4, ret.i18n = i18n, ret.ready = ready, ready || !ready && !useSuspense)
    return ret;
  throw new Promise(function(resolve2) {
    loadNamespaces(i18n, namespaces, function() {
      resolve2();
    });
  });
}
var import_react4, usePrevious, init_useTranslation = __esm({
  "node_modules/react-i18next/dist/es/useTranslation.js"() {
    init_slicedToArray();
    init_defineProperty();
    import_react4 = __toESM(require_react());
    init_context();
    init_utils2();
    usePrevious = function(value2, ignore) {
      var ref = (0, import_react4.useRef)();
      return (0, import_react4.useEffect)(function() {
        ref.current = ignore ? ref.current : value2;
      }, [value2, ignore]), ref.current;
    };
  }
});

// node_modules/react-i18next/dist/es/withTranslation.js
function ownKeys4(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread4(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source2 = arguments[i3] != null ? arguments[i3] : {};
    i3 % 2 ? ownKeys4(Object(source2), !0).forEach(function(key2) {
      _defineProperty(target, key2, source2[key2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2)) : ownKeys4(Object(source2)).forEach(function(key2) {
      Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source2, key2));
    });
  }
  return target;
}
function withTranslation(ns) {
  var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function(WrappedComponent) {
    function I18nextWithTranslation(_ref) {
      var forwardedRef = _ref.forwardedRef, rest = _objectWithoutProperties(_ref, _excluded5), _useTranslation = useTranslation(ns, _objectSpread4(_objectSpread4({}, rest), {}, {
        keyPrefix: options2.keyPrefix
      })), _useTranslation2 = _slicedToArray(_useTranslation, 3), t4 = _useTranslation2[0], i18n = _useTranslation2[1], ready = _useTranslation2[2], passDownProps = _objectSpread4(_objectSpread4({}, rest), {}, {
        t: t4,
        i18n,
        tReady: ready
      });
      return options2.withRef && forwardedRef ? passDownProps.ref = forwardedRef : !options2.withRef && forwardedRef && (passDownProps.forwardedRef = forwardedRef), (0, import_react5.createElement)(WrappedComponent, passDownProps);
    }
    I18nextWithTranslation.displayName = "withI18nextTranslation(".concat(getDisplayName(WrappedComponent), ")"), I18nextWithTranslation.WrappedComponent = WrappedComponent;
    var forwardRef6 = function(props, ref) {
      return (0, import_react5.createElement)(I18nextWithTranslation, Object.assign({}, props, {
        forwardedRef: ref
      }));
    };
    return options2.withRef ? (0, import_react5.forwardRef)(forwardRef6) : I18nextWithTranslation;
  };
}
var import_react5, _excluded5, init_withTranslation = __esm({
  "node_modules/react-i18next/dist/es/withTranslation.js"() {
    init_defineProperty();
    init_slicedToArray();
    init_objectWithoutProperties();
    import_react5 = __toESM(require_react());
    init_useTranslation();
    init_utils2();
    _excluded5 = ["forwardedRef"];
  }
});

// node_modules/react-i18next/dist/es/Translation.js
function Translation(props) {
  var ns = props.ns, children = props.children, options2 = _objectWithoutProperties(props, _excluded6), _useTranslation = useTranslation(ns, options2), _useTranslation2 = _slicedToArray(_useTranslation, 3), t4 = _useTranslation2[0], i18n = _useTranslation2[1], ready = _useTranslation2[2];
  return children(t4, {
    i18n,
    lng: i18n.language
  }, ready);
}
var _excluded6, init_Translation = __esm({
  "node_modules/react-i18next/dist/es/Translation.js"() {
    init_slicedToArray();
    init_objectWithoutProperties();
    init_useTranslation();
    _excluded6 = ["ns", "children"];
  }
});

// node_modules/react-i18next/dist/es/I18nextProvider.js
function I18nextProvider(_ref) {
  var i18n = _ref.i18n, defaultNS = _ref.defaultNS, children = _ref.children, value2 = (0, import_react6.useMemo)(function() {
    return {
      i18n,
      defaultNS
    };
  }, [i18n, defaultNS]);
  return (0, import_react6.createElement)(I18nContext.Provider, {
    value: value2
  }, children);
}
var import_react6, init_I18nextProvider = __esm({
  "node_modules/react-i18next/dist/es/I18nextProvider.js"() {
    import_react6 = __toESM(require_react());
    init_context();
  }
});

// node_modules/react-i18next/dist/es/useSSR.js
function useSSR(initialI18nStore, initialLanguage) {
  var props = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, i18nFromProps = props.i18n, _ref = (0, import_react7.useContext)(I18nContext) || {}, i18nFromContext = _ref.i18n, i18n = i18nFromProps || i18nFromContext || getI18n();
  i18n.options && i18n.options.isClone || (initialI18nStore && !i18n.initializedStoreOnce && (i18n.services.resourceStore.data = initialI18nStore, i18n.options.ns = Object.values(initialI18nStore).reduce(function(mem, lngResources) {
    return Object.keys(lngResources).forEach(function(ns) {
      mem.indexOf(ns) < 0 && mem.push(ns);
    }), mem;
  }, i18n.options.ns), i18n.initializedStoreOnce = !0, i18n.isInitialized = !0), initialLanguage && !i18n.initializedLanguageOnce && (i18n.changeLanguage(initialLanguage), i18n.initializedLanguageOnce = !0));
}
var import_react7, init_useSSR = __esm({
  "node_modules/react-i18next/dist/es/useSSR.js"() {
    import_react7 = __toESM(require_react());
    init_context();
  }
});

// node_modules/react-i18next/dist/es/withSSR.js
function ownKeys5(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread5(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source2 = arguments[i3] != null ? arguments[i3] : {};
    i3 % 2 ? ownKeys5(Object(source2), !0).forEach(function(key2) {
      _defineProperty(target, key2, source2[key2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2)) : ownKeys5(Object(source2)).forEach(function(key2) {
      Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source2, key2));
    });
  }
  return target;
}
function withSSR() {
  return function(WrappedComponent) {
    function I18nextWithSSR(_ref) {
      var initialI18nStore = _ref.initialI18nStore, initialLanguage = _ref.initialLanguage, rest = _objectWithoutProperties(_ref, _excluded7);
      return useSSR(initialI18nStore, initialLanguage), (0, import_react8.createElement)(WrappedComponent, _objectSpread5({}, rest));
    }
    return I18nextWithSSR.getInitialProps = composeInitialProps(WrappedComponent), I18nextWithSSR.displayName = "withI18nextSSR(".concat(getDisplayName(WrappedComponent), ")"), I18nextWithSSR.WrappedComponent = WrappedComponent, I18nextWithSSR;
  };
}
var import_react8, _excluded7, init_withSSR = __esm({
  "node_modules/react-i18next/dist/es/withSSR.js"() {
    init_defineProperty();
    init_objectWithoutProperties();
    import_react8 = __toESM(require_react());
    init_useSSR();
    init_context();
    init_utils2();
    _excluded7 = ["initialI18nStore", "initialLanguage"];
  }
});

// node_modules/react-i18next/dist/es/index.js
var es_exports = {};
__export(es_exports, {
  I18nContext: () => I18nContext,
  I18nextProvider: () => I18nextProvider,
  Trans: () => Trans,
  Translation: () => Translation,
  composeInitialProps: () => composeInitialProps,
  date: () => date,
  getDefaults: () => getDefaults3,
  getI18n: () => getI18n,
  getInitialProps: () => getInitialProps,
  initReactI18next: () => initReactI18next,
  number: () => number,
  plural: () => plural,
  select: () => select,
  selectOrdinal: () => selectOrdinal,
  setDefaults: () => setDefaults,
  setI18n: () => setI18n,
  time: () => time,
  useSSR: () => useSSR,
  useTranslation: () => useTranslation,
  withSSR: () => withSSR,
  withTranslation: () => withTranslation
});
var date, time, number, select, plural, selectOrdinal, init_es = __esm({
  "node_modules/react-i18next/dist/es/index.js"() {
    init_Trans();
    init_useTranslation();
    init_withTranslation();
    init_Translation();
    init_I18nextProvider();
    init_withSSR();
    init_useSSR();
    init_context();
    date = function() {
      return "";
    }, time = function() {
      return "";
    }, number = function() {
      return "";
    }, select = function() {
      return "";
    }, plural = function() {
      return "";
    }, selectOrdinal = function() {
      return "";
    };
  }
});

// node_modules/remix-i18next/build/client.js
var require_client = __commonJS({
  "node_modules/remix-i18next/build/client.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.getInitialNamespaces = void 0;
    function getInitialNamespaces() {
      return [...new Set(Object.values(window.__remixRouteModules).filter((route) => {
        var _a;
        return ((_a = route.handle) === null || _a === void 0 ? void 0 : _a.i18n) !== void 0;
      }).flatMap((route) => route.handle.i18n))];
    }
    exports.getInitialNamespaces = getInitialNamespaces;
  }
});

// node_modules/react/cjs/react-jsx-runtime.development.js
var require_react_jsx_runtime_development = __commonJS({
  "node_modules/react/cjs/react-jsx-runtime.development.js"(exports) {
    "use strict";
    (function() {
      "use strict";
      var React17 = require_react(), REACT_ELEMENT_TYPE = Symbol.for("react.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_PROVIDER_TYPE = Symbol.for("react.provider"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable != "object")
          return null;
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        return typeof maybeIterator == "function" ? maybeIterator : null;
      }
      var ReactSharedInternals = React17.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function error2(format2) {
        {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)
            args[_key2 - 1] = arguments[_key2];
          printWarning("error", format2, args);
        }
      }
      function printWarning(level, format2, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame, stack2 = ReactDebugCurrentFrame2.getStackAddendum();
          stack2 !== "" && (format2 += "%s", args = args.concat([stack2]));
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format2), Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      var enableScopeAPI = !1, enableCacheElement = !1, enableTransitionTracing = !1, enableLegacyHidden = !1, enableDebugTracing = !1, REACT_MODULE_REFERENCE;
      REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
      function isValidElementType(type2) {
        return !!(typeof type2 == "string" || typeof type2 == "function" || type2 === REACT_FRAGMENT_TYPE || type2 === REACT_PROFILER_TYPE || enableDebugTracing || type2 === REACT_STRICT_MODE_TYPE || type2 === REACT_SUSPENSE_TYPE || type2 === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type2 === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing || typeof type2 == "object" && type2 !== null && (type2.$$typeof === REACT_LAZY_TYPE || type2.$$typeof === REACT_MEMO_TYPE || type2.$$typeof === REACT_PROVIDER_TYPE || type2.$$typeof === REACT_CONTEXT_TYPE || type2.$$typeof === REACT_FORWARD_REF_TYPE || type2.$$typeof === REACT_MODULE_REFERENCE || type2.getModuleId !== void 0));
      }
      function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName;
        if (displayName)
          return displayName;
        var functionName = innerType.displayName || innerType.name || "";
        return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
      }
      function getContextName(type2) {
        return type2.displayName || "Context";
      }
      function getComponentNameFromType(type2) {
        if (type2 == null)
          return null;
        if (typeof type2.tag == "number" && error2("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof type2 == "function")
          return type2.displayName || type2.name || null;
        if (typeof type2 == "string")
          return type2;
        switch (type2) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type2 == "object")
          switch (type2.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type2;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type2;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type2, type2.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              var outerName = type2.displayName || null;
              return outerName !== null ? outerName : getComponentNameFromType(type2.type) || "Memo";
            case REACT_LAZY_TYPE: {
              var lazyComponent = type2, payload = lazyComponent._payload, init4 = lazyComponent._init;
              try {
                return getComponentNameFromType(init4(payload));
              } catch {
                return null;
              }
            }
          }
        return null;
      }
      var assign = Object.assign, disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
      function disabledLog() {
      }
      disabledLog.__reactDisabledLog = !0;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log, prevInfo = console.info, prevWarn = console.warn, prevError = console.error, prevGroup = console.group, prevGroupCollapsed = console.groupCollapsed, prevGroupEnd = console.groupEnd;
            var props = {
              configurable: !0,
              enumerable: !0,
              value: disabledLog,
              writable: !0
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          if (disabledDepth--, disabledDepth === 0) {
            var props = {
              configurable: !0,
              enumerable: !0,
              writable: !0
            };
            Object.defineProperties(console, {
              log: assign({}, props, {
                value: prevLog
              }),
              info: assign({}, props, {
                value: prevInfo
              }),
              warn: assign({}, props, {
                value: prevWarn
              }),
              error: assign({}, props, {
                value: prevError
              }),
              group: assign({}, props, {
                value: prevGroup
              }),
              groupCollapsed: assign({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: assign({}, props, {
                value: prevGroupEnd
              })
            });
          }
          disabledDepth < 0 && error2("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
      }
      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher, prefix;
      function describeBuiltInComponentFrame(name, source2, ownerFn) {
        {
          if (prefix === void 0)
            try {
              throw Error();
            } catch (x2) {
              var match = x2.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
            }
          return `
` + prefix + name;
        }
      }
      var reentry = !1, componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap == "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap();
      }
      function describeNativeComponentFrame(fn, construct4) {
        if (!fn || reentry)
          return "";
        {
          var frame = componentFrameCache.get(fn);
          if (frame !== void 0)
            return frame;
        }
        var control;
        reentry = !0;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var previousDispatcher;
        previousDispatcher = ReactCurrentDispatcher.current, ReactCurrentDispatcher.current = null, disableLogs();
        try {
          if (construct4) {
            var Fake = function() {
              throw Error();
            };
            if (Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x2) {
                control = x2;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x2) {
                control = x2;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x2) {
              control = x2;
            }
            fn();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack == "string") {
            for (var sampleLines = sample.stack.split(`
`), controlLines = control.stack.split(`
`), s3 = sampleLines.length - 1, c4 = controlLines.length - 1; s3 >= 1 && c4 >= 0 && sampleLines[s3] !== controlLines[c4]; )
              c4--;
            for (; s3 >= 1 && c4 >= 0; s3--, c4--)
              if (sampleLines[s3] !== controlLines[c4]) {
                if (s3 !== 1 || c4 !== 1)
                  do
                    if (s3--, c4--, c4 < 0 || sampleLines[s3] !== controlLines[c4]) {
                      var _frame = `
` + sampleLines[s3].replace(" at new ", " at ");
                      return fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName)), typeof fn == "function" && componentFrameCache.set(fn, _frame), _frame;
                    }
                  while (s3 >= 1 && c4 >= 0);
                break;
              }
          }
        } finally {
          reentry = !1, ReactCurrentDispatcher.current = previousDispatcher, reenableLogs(), Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name = fn ? fn.displayName || fn.name : "", syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
        return typeof fn == "function" && componentFrameCache.set(fn, syntheticFrame), syntheticFrame;
      }
      function describeFunctionComponentFrame(fn, source2, ownerFn) {
        return describeNativeComponentFrame(fn, !1);
      }
      function shouldConstruct(Component3) {
        var prototype = Component3.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type2, source2, ownerFn) {
        if (type2 == null)
          return "";
        if (typeof type2 == "function")
          return describeNativeComponentFrame(type2, shouldConstruct(type2));
        if (typeof type2 == "string")
          return describeBuiltInComponentFrame(type2);
        switch (type2) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type2 == "object")
          switch (type2.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type2.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type2.type, source2, ownerFn);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type2, payload = lazyComponent._payload, init4 = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init4(payload), source2, ownerFn);
              } catch {
              }
            }
          }
        return "";
      }
      var hasOwnProperty2 = Object.prototype.hasOwnProperty, loggedTypeFailures = {}, ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        if (element) {
          var owner = element._owner, stack2 = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
          ReactDebugCurrentFrame.setExtraStackFrame(stack2);
        } else
          ReactDebugCurrentFrame.setExtraStackFrame(null);
      }
      function checkPropTypes(typeSpecs, values, location, componentName, element) {
        {
          var has = Function.call.bind(hasOwnProperty2);
          for (var typeSpecName in typeSpecs)
            if (has(typeSpecs, typeSpecName)) {
              var error$1 = void 0;
              try {
                if (typeof typeSpecs[typeSpecName] != "function") {
                  var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw err.name = "Invariant Violation", err;
                }
                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex) {
                error$1 = ex;
              }
              error$1 && !(error$1 instanceof Error) && (setCurrentlyValidatingElement(element), error2("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1), setCurrentlyValidatingElement(null)), error$1 instanceof Error && !(error$1.message in loggedTypeFailures) && (loggedTypeFailures[error$1.message] = !0, setCurrentlyValidatingElement(element), error2("Failed %s type: %s", location, error$1.message), setCurrentlyValidatingElement(null));
            }
        }
      }
      var isArrayImpl = Array.isArray;
      function isArray3(a3) {
        return isArrayImpl(a3);
      }
      function typeName(value2) {
        {
          var hasToStringTag = typeof Symbol == "function" && Symbol.toStringTag, type2 = hasToStringTag && value2[Symbol.toStringTag] || value2.constructor.name || "Object";
          return type2;
        }
      }
      function willCoercionThrow(value2) {
        try {
          return testStringCoercion(value2), !1;
        } catch {
          return !0;
        }
      }
      function testStringCoercion(value2) {
        return "" + value2;
      }
      function checkKeyStringCoercion(value2) {
        if (willCoercionThrow(value2))
          return error2("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value2)), testStringCoercion(value2);
      }
      var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner, RESERVED_PROPS = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
      }, specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
      didWarnAboutStringRefs = {};
      function hasValidRef(config2) {
        if (hasOwnProperty2.call(config2, "ref")) {
          var getter = Object.getOwnPropertyDescriptor(config2, "ref").get;
          if (getter && getter.isReactWarning)
            return !1;
        }
        return config2.ref !== void 0;
      }
      function hasValidKey(config2) {
        if (hasOwnProperty2.call(config2, "key")) {
          var getter = Object.getOwnPropertyDescriptor(config2, "key").get;
          if (getter && getter.isReactWarning)
            return !1;
        }
        return config2.key !== void 0;
      }
      function warnIfStringRefCannotBeAutoConverted(config2, self) {
        if (typeof config2.ref == "string" && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {
          var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
          didWarnAboutStringRefs[componentName] || (error2('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config2.ref), didWarnAboutStringRefs[componentName] = !0);
        }
      }
      function defineKeyPropWarningGetter(props, displayName) {
        {
          var warnAboutAccessingKey = function() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = !0, error2("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName));
          };
          warnAboutAccessingKey.isReactWarning = !0, Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: !0
          });
        }
      }
      function defineRefPropWarningGetter(props, displayName) {
        {
          var warnAboutAccessingRef = function() {
            specialPropRefWarningShown || (specialPropRefWarningShown = !0, error2("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName));
          };
          warnAboutAccessingRef.isReactWarning = !0, Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: !0
          });
        }
      }
      var ReactElement = function(type2, key2, ref, self, source2, owner, props) {
        var element = {
          $$typeof: REACT_ELEMENT_TYPE,
          type: type2,
          key: key2,
          ref,
          props,
          _owner: owner
        };
        return element._store = {}, Object.defineProperty(element._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: !1
        }), Object.defineProperty(element, "_self", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: self
        }), Object.defineProperty(element, "_source", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: source2
        }), Object.freeze && (Object.freeze(element.props), Object.freeze(element)), element;
      };
      function jsxDEV46(type2, config2, maybeKey, source2, self) {
        {
          var propName, props = {}, key2 = null, ref = null;
          maybeKey !== void 0 && (checkKeyStringCoercion(maybeKey), key2 = "" + maybeKey), hasValidKey(config2) && (checkKeyStringCoercion(config2.key), key2 = "" + config2.key), hasValidRef(config2) && (ref = config2.ref, warnIfStringRefCannotBeAutoConverted(config2, self));
          for (propName in config2)
            hasOwnProperty2.call(config2, propName) && !RESERVED_PROPS.hasOwnProperty(propName) && (props[propName] = config2[propName]);
          if (type2 && type2.defaultProps) {
            var defaultProps = type2.defaultProps;
            for (propName in defaultProps)
              props[propName] === void 0 && (props[propName] = defaultProps[propName]);
          }
          if (key2 || ref) {
            var displayName = typeof type2 == "function" ? type2.displayName || type2.name || "Unknown" : type2;
            key2 && defineKeyPropWarningGetter(props, displayName), ref && defineRefPropWarningGetter(props, displayName);
          }
          return ReactElement(type2, key2, ref, self, source2, ReactCurrentOwner.current, props);
        }
      }
      var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner, ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement$1(element) {
        if (element) {
          var owner = element._owner, stack2 = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
          ReactDebugCurrentFrame$1.setExtraStackFrame(stack2);
        } else
          ReactDebugCurrentFrame$1.setExtraStackFrame(null);
      }
      var propTypesMisspellWarningShown;
      propTypesMisspellWarningShown = !1;
      function isValidElement4(object) {
        return typeof object == "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      function getDeclarationErrorAddendum() {
        {
          if (ReactCurrentOwner$1.current) {
            var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);
            if (name)
              return `

Check the render method of \`` + name + "`.";
          }
          return "";
        }
      }
      function getSourceInfoErrorAddendum(source2) {
        {
          if (source2 !== void 0) {
            var fileName = source2.fileName.replace(/^.*[\\\/]/, ""), lineNumber = source2.lineNumber;
            return `

Check your code at ` + fileName + ":" + lineNumber + ".";
          }
          return "";
        }
      }
      var ownerHasKeyUseWarning = {};
      function getCurrentComponentErrorInfo(parentType) {
        {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType == "string" ? parentType : parentType.displayName || parentType.name;
            parentName && (info = `

Check the top-level render call using <` + parentName + ">.");
          }
          return info;
        }
      }
      function validateExplicitKey(element, parentType) {
        {
          if (!element._store || element._store.validated || element.key != null)
            return;
          element._store.validated = !0;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo])
            return;
          ownerHasKeyUseWarning[currentComponentErrorInfo] = !0;
          var childOwner = "";
          element && element._owner && element._owner !== ReactCurrentOwner$1.current && (childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + "."), setCurrentlyValidatingElement$1(element), error2('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner), setCurrentlyValidatingElement$1(null);
        }
      }
      function validateChildKeys(node, parentType) {
        {
          if (typeof node != "object")
            return;
          if (isArray3(node))
            for (var i3 = 0; i3 < node.length; i3++) {
              var child = node[i3];
              isValidElement4(child) && validateExplicitKey(child, parentType);
            }
          else if (isValidElement4(node))
            node._store && (node._store.validated = !0);
          else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn == "function" && iteratorFn !== node.entries)
              for (var iterator = iteratorFn.call(node), step; !(step = iterator.next()).done; )
                isValidElement4(step.value) && validateExplicitKey(step.value, parentType);
          }
        }
      }
      function validatePropTypes(element) {
        {
          var type2 = element.type;
          if (type2 == null || typeof type2 == "string")
            return;
          var propTypes;
          if (typeof type2 == "function")
            propTypes = type2.propTypes;
          else if (typeof type2 == "object" && (type2.$$typeof === REACT_FORWARD_REF_TYPE || type2.$$typeof === REACT_MEMO_TYPE))
            propTypes = type2.propTypes;
          else
            return;
          if (propTypes) {
            var name = getComponentNameFromType(type2);
            checkPropTypes(propTypes, element.props, "prop", name, element);
          } else if (type2.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
            propTypesMisspellWarningShown = !0;
            var _name = getComponentNameFromType(type2);
            error2("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
          }
          typeof type2.getDefaultProps == "function" && !type2.getDefaultProps.isReactClassApproved && error2("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
        }
      }
      function validateFragmentProps(fragment) {
        {
          for (var keys2 = Object.keys(fragment.props), i3 = 0; i3 < keys2.length; i3++) {
            var key2 = keys2[i3];
            if (key2 !== "children" && key2 !== "key") {
              setCurrentlyValidatingElement$1(fragment), error2("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key2), setCurrentlyValidatingElement$1(null);
              break;
            }
          }
          fragment.ref !== null && (setCurrentlyValidatingElement$1(fragment), error2("Invalid attribute `ref` supplied to `React.Fragment`."), setCurrentlyValidatingElement$1(null));
        }
      }
      function jsxWithValidation(type2, props, key2, isStaticChildren, source2, self) {
        {
          var validType = isValidElementType(type2);
          if (!validType) {
            var info = "";
            (type2 === void 0 || typeof type2 == "object" && type2 !== null && Object.keys(type2).length === 0) && (info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
            var sourceInfo = getSourceInfoErrorAddendum(source2);
            sourceInfo ? info += sourceInfo : info += getDeclarationErrorAddendum();
            var typeString;
            type2 === null ? typeString = "null" : isArray3(type2) ? typeString = "array" : type2 !== void 0 && type2.$$typeof === REACT_ELEMENT_TYPE ? (typeString = "<" + (getComponentNameFromType(type2.type) || "Unknown") + " />", info = " Did you accidentally export a JSX literal instead of a component?") : typeString = typeof type2, error2("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
          }
          var element = jsxDEV46(type2, props, key2, source2, self);
          if (element == null)
            return element;
          if (validType) {
            var children = props.children;
            if (children !== void 0)
              if (isStaticChildren)
                if (isArray3(children)) {
                  for (var i3 = 0; i3 < children.length; i3++)
                    validateChildKeys(children[i3], type2);
                  Object.freeze && Object.freeze(children);
                } else
                  error2("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
              else
                validateChildKeys(children, type2);
          }
          return type2 === REACT_FRAGMENT_TYPE ? validateFragmentProps(element) : validatePropTypes(element), element;
        }
      }
      function jsxWithValidationStatic(type2, props, key2) {
        return jsxWithValidation(type2, props, key2, !0);
      }
      function jsxWithValidationDynamic(type2, props, key2) {
        return jsxWithValidation(type2, props, key2, !1);
      }
      var jsx = jsxWithValidationDynamic, jsxs = jsxWithValidationStatic;
      exports.Fragment = REACT_FRAGMENT_TYPE, exports.jsx = jsx, exports.jsxs = jsxs;
    })();
  }
});

// node_modules/react/jsx-runtime.js
var require_jsx_runtime = __commonJS({
  "node_modules/react/jsx-runtime.js"(exports, module2) {
    "use strict";
    module2.exports = require_react_jsx_runtime_development();
  }
});

// node_modules/remix-i18next/build/react.js
var require_react2 = __commonJS({
  "node_modules/remix-i18next/build/react.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.useChangeLanguage = exports.useLocale = exports.PreloadTranslations = void 0;
    var jsx_runtime_1 = require_jsx_runtime(), react_1 = (init_esm2(), __toCommonJS(esm_exports2)), react_2 = require_react(), react_i18next_1 = (init_es(), __toCommonJS(es_exports));
    function PreloadTranslations({ loadPath }) {
      let { i18n } = (0, react_i18next_1.useTranslation)(), namespaces = [
        ...new Set((0, react_1.useMatches)().filter((route) => {
          var _a;
          return ((_a = route.handle) === null || _a === void 0 ? void 0 : _a.i18n) !== void 0;
        }).flatMap((route) => {
          var _a;
          return (_a = route.handle) === null || _a === void 0 ? void 0 : _a.i18n;
        }))
      ], lang = i18n.language;
      return (0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children: namespaces.map((namespace) => (0, jsx_runtime_1.jsx)("link", { rel: "preload", as: "fetch", href: loadPath.replace("{{lng}}", lang).replace("{{ns}}", namespace) }, namespace)) });
    }
    exports.PreloadTranslations = PreloadTranslations;
    function useLocale(localeKey = "locale") {
      var _a;
      let [rootMatch] = (0, react_1.useMatches)(), { [localeKey]: locale } = (_a = rootMatch.data) !== null && _a !== void 0 ? _a : {};
      if (!locale)
        throw new Error("Missing locale returned by the root loader.");
      if (typeof locale == "string")
        return locale;
      throw new Error("Invalid locale returned by the root loader.");
    }
    exports.useLocale = useLocale;
    function useChangeLanguage2(locale) {
      let { i18n } = (0, react_i18next_1.useTranslation)();
      (0, react_2.useEffect)(() => {
        i18n.changeLanguage(locale);
      }, [locale, i18n]);
    }
    exports.useChangeLanguage = useChangeLanguage2;
  }
});

// node_modules/accept-language-parser/index.js
var require_accept_language_parser = __commonJS({
  "node_modules/accept-language-parser/index.js"(exports, module2) {
    var regex = /((([a-zA-Z]+(-[a-zA-Z0-9]+){0,2})|\*)(;q=[0-1](\.[0-9]+)?)?)*/g, isString3 = function(s3) {
      return typeof s3 == "string";
    };
    function parse5(al) {
      var strings = (al || "").match(regex);
      return strings.map(function(m2) {
        if (!!m2) {
          var bits = m2.split(";"), ietf = bits[0].split("-"), hasScript = ietf.length === 3;
          return {
            code: ietf[0],
            script: hasScript ? ietf[1] : null,
            region: hasScript ? ietf[2] : ietf[1],
            quality: bits[1] ? parseFloat(bits[1].split("=")[1]) : 1
          };
        }
      }).filter(function(r3) {
        return r3;
      }).sort(function(a3, b2) {
        return b2.quality - a3.quality;
      });
    }
    function pick(supportedLanguages, acceptLanguage, options2) {
      if (options2 = options2 || {}, !supportedLanguages || !supportedLanguages.length || !acceptLanguage)
        return null;
      isString3(acceptLanguage) && (acceptLanguage = parse5(acceptLanguage));
      for (var supported = supportedLanguages.map(function(support2) {
        var bits = support2.split("-"), hasScript = bits.length === 3;
        return {
          code: bits[0],
          script: hasScript ? bits[1] : null,
          region: hasScript ? bits[2] : bits[1]
        };
      }), i3 = 0; i3 < acceptLanguage.length; i3++)
        for (var lang = acceptLanguage[i3], langCode = lang.code.toLowerCase(), langRegion = lang.region ? lang.region.toLowerCase() : lang.region, langScript = lang.script ? lang.script.toLowerCase() : lang.script, j2 = 0; j2 < supported.length; j2++) {
          var supportedCode = supported[j2].code.toLowerCase(), supportedScript = supported[j2].script ? supported[j2].script.toLowerCase() : supported[j2].script, supportedRegion = supported[j2].region ? supported[j2].region.toLowerCase() : supported[j2].region;
          if (langCode === supportedCode && (options2.loose || !langScript || langScript === supportedScript) && (options2.loose || !langRegion || langRegion === supportedRegion))
            return supportedLanguages[j2];
        }
      return null;
    }
    module2.exports.parse = parse5;
    module2.exports.pick = pick;
  }
});

// node_modules/@babel/runtime/helpers/typeof.js
var require_typeof = __commonJS({
  "node_modules/@babel/runtime/helpers/typeof.js"(exports, module2) {
    function _typeof4(obj) {
      return module2.exports = _typeof4 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, module2.exports.__esModule = !0, module2.exports.default = module2.exports, _typeof4(obj);
    }
    module2.exports = _typeof4, module2.exports.__esModule = !0, module2.exports.default = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/classCallCheck.js
var require_classCallCheck = __commonJS({
  "node_modules/@babel/runtime/helpers/classCallCheck.js"(exports, module2) {
    function _classCallCheck3(instance2, Constructor) {
      if (!(instance2 instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    module2.exports = _classCallCheck3, module2.exports.__esModule = !0, module2.exports.default = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/toPrimitive.js
var require_toPrimitive = __commonJS({
  "node_modules/@babel/runtime/helpers/toPrimitive.js"(exports, module2) {
    var _typeof4 = require_typeof().default;
    function _toPrimitive2(input, hint) {
      if (_typeof4(input) !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (_typeof4(res) !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    module2.exports = _toPrimitive2, module2.exports.__esModule = !0, module2.exports.default = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/toPropertyKey.js
var require_toPropertyKey = __commonJS({
  "node_modules/@babel/runtime/helpers/toPropertyKey.js"(exports, module2) {
    var _typeof4 = require_typeof().default, toPrimitive = require_toPrimitive();
    function _toPropertyKey2(arg) {
      var key2 = toPrimitive(arg, "string");
      return _typeof4(key2) === "symbol" ? key2 : String(key2);
    }
    module2.exports = _toPropertyKey2, module2.exports.__esModule = !0, module2.exports.default = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/createClass.js
var require_createClass = __commonJS({
  "node_modules/@babel/runtime/helpers/createClass.js"(exports, module2) {
    var toPropertyKey = require_toPropertyKey();
    function _defineProperties3(target, props) {
      for (var i3 = 0; i3 < props.length; i3++) {
        var descriptor = props[i3];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass3(Constructor, protoProps, staticProps) {
      return protoProps && _defineProperties3(Constructor.prototype, protoProps), staticProps && _defineProperties3(Constructor, staticProps), Object.defineProperty(Constructor, "prototype", {
        writable: !1
      }), Constructor;
    }
    module2.exports = _createClass3, module2.exports.__esModule = !0, module2.exports.default = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/assertThisInitialized.js
var require_assertThisInitialized = __commonJS({
  "node_modules/@babel/runtime/helpers/assertThisInitialized.js"(exports, module2) {
    function _assertThisInitialized2(self) {
      if (self === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    module2.exports = _assertThisInitialized2, module2.exports.__esModule = !0, module2.exports.default = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/setPrototypeOf.js
var require_setPrototypeOf = __commonJS({
  "node_modules/@babel/runtime/helpers/setPrototypeOf.js"(exports, module2) {
    function _setPrototypeOf2(o2, p) {
      return module2.exports = _setPrototypeOf2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(o3, p2) {
        return o3.__proto__ = p2, o3;
      }, module2.exports.__esModule = !0, module2.exports.default = module2.exports, _setPrototypeOf2(o2, p);
    }
    module2.exports = _setPrototypeOf2, module2.exports.__esModule = !0, module2.exports.default = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/inherits.js
var require_inherits = __commonJS({
  "node_modules/@babel/runtime/helpers/inherits.js"(exports, module2) {
    var setPrototypeOf = require_setPrototypeOf();
    function _inherits2(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function");
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: !0,
          configurable: !0
        }
      }), Object.defineProperty(subClass, "prototype", {
        writable: !1
      }), superClass && setPrototypeOf(subClass, superClass);
    }
    module2.exports = _inherits2, module2.exports.__esModule = !0, module2.exports.default = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/possibleConstructorReturn.js
var require_possibleConstructorReturn = __commonJS({
  "node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"(exports, module2) {
    var _typeof4 = require_typeof().default, assertThisInitialized = require_assertThisInitialized();
    function _possibleConstructorReturn2(self, call) {
      if (call && (_typeof4(call) === "object" || typeof call == "function"))
        return call;
      if (call !== void 0)
        throw new TypeError("Derived constructors may only return object or undefined");
      return assertThisInitialized(self);
    }
    module2.exports = _possibleConstructorReturn2, module2.exports.__esModule = !0, module2.exports.default = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/getPrototypeOf.js
var require_getPrototypeOf = __commonJS({
  "node_modules/@babel/runtime/helpers/getPrototypeOf.js"(exports, module2) {
    function _getPrototypeOf2(o2) {
      return module2.exports = _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(o3) {
        return o3.__proto__ || Object.getPrototypeOf(o3);
      }, module2.exports.__esModule = !0, module2.exports.default = module2.exports, _getPrototypeOf2(o2);
    }
    module2.exports = _getPrototypeOf2, module2.exports.__esModule = !0, module2.exports.default = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/defineProperty.js
var require_defineProperty = __commonJS({
  "node_modules/@babel/runtime/helpers/defineProperty.js"(exports, module2) {
    var toPropertyKey = require_toPropertyKey();
    function _defineProperty2(obj, key2, value2) {
      return key2 = toPropertyKey(key2), key2 in obj ? Object.defineProperty(obj, key2, {
        value: value2,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : obj[key2] = value2, obj;
    }
    module2.exports = _defineProperty2, module2.exports.__esModule = !0, module2.exports.default = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/arrayWithHoles.js
var require_arrayWithHoles = __commonJS({
  "node_modules/@babel/runtime/helpers/arrayWithHoles.js"(exports, module2) {
    function _arrayWithHoles2(arr2) {
      if (Array.isArray(arr2))
        return arr2;
    }
    module2.exports = _arrayWithHoles2, module2.exports.__esModule = !0, module2.exports.default = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/iterableToArray.js
var require_iterableToArray = __commonJS({
  "node_modules/@babel/runtime/helpers/iterableToArray.js"(exports, module2) {
    function _iterableToArray2(iter) {
      if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    module2.exports = _iterableToArray2, module2.exports.__esModule = !0, module2.exports.default = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/arrayLikeToArray.js
var require_arrayLikeToArray = __commonJS({
  "node_modules/@babel/runtime/helpers/arrayLikeToArray.js"(exports, module2) {
    function _arrayLikeToArray3(arr2, len) {
      (len == null || len > arr2.length) && (len = arr2.length);
      for (var i3 = 0, arr22 = new Array(len); i3 < len; i3++)
        arr22[i3] = arr2[i3];
      return arr22;
    }
    module2.exports = _arrayLikeToArray3, module2.exports.__esModule = !0, module2.exports.default = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js
var require_unsupportedIterableToArray = __commonJS({
  "node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js"(exports, module2) {
    var arrayLikeToArray = require_arrayLikeToArray();
    function _unsupportedIterableToArray3(o2, minLen) {
      if (!!o2) {
        if (typeof o2 == "string")
          return arrayLikeToArray(o2, minLen);
        var n3 = Object.prototype.toString.call(o2).slice(8, -1);
        if (n3 === "Object" && o2.constructor && (n3 = o2.constructor.name), n3 === "Map" || n3 === "Set")
          return Array.from(o2);
        if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3))
          return arrayLikeToArray(o2, minLen);
      }
    }
    module2.exports = _unsupportedIterableToArray3, module2.exports.__esModule = !0, module2.exports.default = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/nonIterableRest.js
var require_nonIterableRest = __commonJS({
  "node_modules/@babel/runtime/helpers/nonIterableRest.js"(exports, module2) {
    function _nonIterableRest2() {
      throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    module2.exports = _nonIterableRest2, module2.exports.__esModule = !0, module2.exports.default = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/toArray.js
var require_toArray = __commonJS({
  "node_modules/@babel/runtime/helpers/toArray.js"(exports, module2) {
    var arrayWithHoles = require_arrayWithHoles(), iterableToArray = require_iterableToArray(), unsupportedIterableToArray = require_unsupportedIterableToArray(), nonIterableRest = require_nonIterableRest();
    function _toArray2(arr2) {
      return arrayWithHoles(arr2) || iterableToArray(arr2) || unsupportedIterableToArray(arr2) || nonIterableRest();
    }
    module2.exports = _toArray2, module2.exports.__esModule = !0, module2.exports.default = module2.exports;
  }
});

// node_modules/i18next/dist/cjs/i18next.js
var require_i18next = __commonJS({
  "node_modules/i18next/dist/cjs/i18next.js"(exports, module2) {
    "use strict";
    var _typeof4 = require_typeof(), _classCallCheck3 = require_classCallCheck(), _createClass3 = require_createClass(), _assertThisInitialized2 = require_assertThisInitialized(), _inherits2 = require_inherits(), _possibleConstructorReturn2 = require_possibleConstructorReturn(), _getPrototypeOf2 = require_getPrototypeOf(), _defineProperty2 = require_defineProperty(), _toArray2 = require_toArray();
    function _interopDefaultLegacy(e3) {
      return e3 && typeof e3 == "object" && "default" in e3 ? e3 : { default: e3 };
    }
    var _typeof__default = /* @__PURE__ */ _interopDefaultLegacy(_typeof4), _classCallCheck__default = /* @__PURE__ */ _interopDefaultLegacy(_classCallCheck3), _createClass__default = /* @__PURE__ */ _interopDefaultLegacy(_createClass3), _assertThisInitialized__default = /* @__PURE__ */ _interopDefaultLegacy(_assertThisInitialized2), _inherits__default = /* @__PURE__ */ _interopDefaultLegacy(_inherits2), _possibleConstructorReturn__default = /* @__PURE__ */ _interopDefaultLegacy(_possibleConstructorReturn2), _getPrototypeOf__default = /* @__PURE__ */ _interopDefaultLegacy(_getPrototypeOf2), _defineProperty__default = /* @__PURE__ */ _interopDefaultLegacy(_defineProperty2), _toArray__default = /* @__PURE__ */ _interopDefaultLegacy(_toArray2);
    function ownKeys7(object, enumerableOnly) {
      var keys2 = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    function _objectSpread7(target) {
      for (var i3 = 1; i3 < arguments.length; i3++) {
        var source2 = arguments[i3] != null ? arguments[i3] : {};
        i3 % 2 ? ownKeys7(Object(source2), !0).forEach(function(key2) {
          _defineProperty__default.default(target, key2, source2[key2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2)) : ownKeys7(Object(source2)).forEach(function(key2) {
          Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source2, key2));
        });
      }
      return target;
    }
    var consoleLogger2 = {
      type: "logger",
      log: function(args) {
        this.output("log", args);
      },
      warn: function(args) {
        this.output("warn", args);
      },
      error: function(args) {
        this.output("error", args);
      },
      output: function(type2, args) {
        console && console[type2] && console[type2].apply(console, args);
      }
    }, Logger2 = function() {
      function Logger3(concreteLogger) {
        var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        _classCallCheck__default.default(this, Logger3), this.init(concreteLogger, options2);
      }
      return _createClass__default.default(Logger3, [{
        key: "init",
        value: function(concreteLogger) {
          var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          this.prefix = options2.prefix || "i18next:", this.logger = concreteLogger || consoleLogger2, this.options = options2, this.debug = options2.debug;
        }
      }, {
        key: "setDebug",
        value: function(bool2) {
          this.debug = bool2;
        }
      }, {
        key: "log",
        value: function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
            args[_key] = arguments[_key];
          return this.forward(args, "log", "", !0);
        }
      }, {
        key: "warn",
        value: function() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++)
            args[_key2] = arguments[_key2];
          return this.forward(args, "warn", "", !0);
        }
      }, {
        key: "error",
        value: function() {
          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++)
            args[_key3] = arguments[_key3];
          return this.forward(args, "error", "");
        }
      }, {
        key: "deprecate",
        value: function() {
          for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++)
            args[_key4] = arguments[_key4];
          return this.forward(args, "warn", "WARNING DEPRECATED: ", !0);
        }
      }, {
        key: "forward",
        value: function(args, lvl, prefix, debugOnly) {
          return debugOnly && !this.debug ? null : (typeof args[0] == "string" && (args[0] = "".concat(prefix).concat(this.prefix, " ").concat(args[0])), this.logger[lvl](args));
        }
      }, {
        key: "create",
        value: function(moduleName) {
          return new Logger3(this.logger, _objectSpread7(_objectSpread7({}, {
            prefix: "".concat(this.prefix, ":").concat(moduleName, ":")
          }), this.options));
        }
      }, {
        key: "clone",
        value: function(options2) {
          return options2 = options2 || this.options, options2.prefix = options2.prefix || this.prefix, new Logger3(this.logger, options2);
        }
      }]), Logger3;
    }(), baseLogger2 = new Logger2(), EventEmitter3 = function() {
      function EventEmitter4() {
        _classCallCheck__default.default(this, EventEmitter4), this.observers = {};
      }
      return _createClass__default.default(EventEmitter4, [{
        key: "on",
        value: function(events2, listener) {
          var _this = this;
          return events2.split(" ").forEach(function(event2) {
            _this.observers[event2] = _this.observers[event2] || [], _this.observers[event2].push(listener);
          }), this;
        }
      }, {
        key: "off",
        value: function(event2, listener) {
          if (!!this.observers[event2]) {
            if (!listener) {
              delete this.observers[event2];
              return;
            }
            this.observers[event2] = this.observers[event2].filter(function(l2) {
              return l2 !== listener;
            });
          }
        }
      }, {
        key: "emit",
        value: function(event2) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
            args[_key - 1] = arguments[_key];
          if (this.observers[event2]) {
            var cloned = [].concat(this.observers[event2]);
            cloned.forEach(function(observer) {
              observer.apply(void 0, args);
            });
          }
          if (this.observers["*"]) {
            var _cloned = [].concat(this.observers["*"]);
            _cloned.forEach(function(observer) {
              observer.apply(observer, [event2].concat(args));
            });
          }
        }
      }]), EventEmitter4;
    }();
    function defer5() {
      var res, rej, promise = new Promise(function(resolve2, reject) {
        res = resolve2, rej = reject;
      });
      return promise.resolve = res, promise.reject = rej, promise;
    }
    function makeString2(object) {
      return object == null ? "" : "" + object;
    }
    function copy3(a3, s3, t4) {
      a3.forEach(function(m2) {
        s3[m2] && (t4[m2] = s3[m2]);
      });
    }
    function getLastOfPath3(object, path2, Empty) {
      function cleanKey(key3) {
        return key3 && key3.indexOf("###") > -1 ? key3.replace(/###/g, ".") : key3;
      }
      function canNotTraverseDeeper() {
        return !object || typeof object == "string";
      }
      for (var stack2 = typeof path2 != "string" ? [].concat(path2) : path2.split("."); stack2.length > 1; ) {
        if (canNotTraverseDeeper())
          return {};
        var key2 = cleanKey(stack2.shift());
        !object[key2] && Empty && (object[key2] = new Empty()), Object.prototype.hasOwnProperty.call(object, key2) ? object = object[key2] : object = {};
      }
      return canNotTraverseDeeper() ? {} : {
        obj: object,
        k: cleanKey(stack2.shift())
      };
    }
    function setPath3(object, path2, newValue) {
      var _getLastOfPath = getLastOfPath3(object, path2, Object), obj = _getLastOfPath.obj, k2 = _getLastOfPath.k;
      obj[k2] = newValue;
    }
    function pushPath3(object, path2, newValue, concat2) {
      var _getLastOfPath2 = getLastOfPath3(object, path2, Object), obj = _getLastOfPath2.obj, k2 = _getLastOfPath2.k;
      obj[k2] = obj[k2] || [], concat2 && (obj[k2] = obj[k2].concat(newValue)), concat2 || obj[k2].push(newValue);
    }
    function getPath3(object, path2) {
      var _getLastOfPath3 = getLastOfPath3(object, path2), obj = _getLastOfPath3.obj, k2 = _getLastOfPath3.k;
      if (!!obj)
        return obj[k2];
    }
    function getPathWithDefaults2(data2, defaultData, key2) {
      var value2 = getPath3(data2, key2);
      return value2 !== void 0 ? value2 : getPath3(defaultData, key2);
    }
    function deepExtend2(target, source2, overwrite) {
      for (var prop in source2)
        prop !== "__proto__" && prop !== "constructor" && (prop in target ? typeof target[prop] == "string" || target[prop] instanceof String || typeof source2[prop] == "string" || source2[prop] instanceof String ? overwrite && (target[prop] = source2[prop]) : deepExtend2(target[prop], source2[prop], overwrite) : target[prop] = source2[prop]);
      return target;
    }
    function regexEscape2(str2) {
      return str2.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
    }
    var _entityMap2 = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;",
      "/": "&#x2F;"
    };
    function escape4(data2) {
      return typeof data2 == "string" ? data2.replace(/[&<>"'\/]/g, function(s3) {
        return _entityMap2[s3];
      }) : data2;
    }
    var isIE102 = typeof window < "u" && window.navigator && typeof window.navigator.userAgentData > "u" && window.navigator.userAgent && window.navigator.userAgent.indexOf("MSIE") > -1, chars2 = [" ", ",", "?", "!", ";"];
    function looksLikeObjectPath2(key2, nsSeparator, keySeparator) {
      nsSeparator = nsSeparator || "", keySeparator = keySeparator || "";
      var possibleChars = chars2.filter(function(c4) {
        return nsSeparator.indexOf(c4) < 0 && keySeparator.indexOf(c4) < 0;
      });
      if (possibleChars.length === 0)
        return !0;
      var r3 = new RegExp("(".concat(possibleChars.map(function(c4) {
        return c4 === "?" ? "\\?" : c4;
      }).join("|"), ")")), matched = !r3.test(key2);
      if (!matched) {
        var ki = key2.indexOf(keySeparator);
        ki > 0 && !r3.test(key2.substring(0, ki)) && (matched = !0);
      }
      return matched;
    }
    function ownKeys$12(object, enumerableOnly) {
      var keys2 = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    function _objectSpread$12(target) {
      for (var i3 = 1; i3 < arguments.length; i3++) {
        var source2 = arguments[i3] != null ? arguments[i3] : {};
        i3 % 2 ? ownKeys$12(Object(source2), !0).forEach(function(key2) {
          _defineProperty__default.default(target, key2, source2[key2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2)) : ownKeys$12(Object(source2)).forEach(function(key2) {
          Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source2, key2));
        });
      }
      return target;
    }
    function _createSuper2(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct2();
      return function() {
        var Super = _getPrototypeOf__default.default(Derived), result2;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default.default(this).constructor;
          result2 = Reflect.construct(Super, arguments, NewTarget);
        } else
          result2 = Super.apply(this, arguments);
        return _possibleConstructorReturn__default.default(this, result2);
      };
    }
    function _isNativeReflectConstruct2() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function deepFind2(obj, path2) {
      var keySeparator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
      if (!!obj) {
        if (obj[path2])
          return obj[path2];
        for (var paths = path2.split(keySeparator), current = obj, i3 = 0; i3 < paths.length; ++i3) {
          if (!current || typeof current[paths[i3]] == "string" && i3 + 1 < paths.length)
            return;
          if (current[paths[i3]] === void 0) {
            for (var j2 = 2, p = paths.slice(i3, i3 + j2).join(keySeparator), mix2 = current[p]; mix2 === void 0 && paths.length > i3 + j2; )
              j2++, p = paths.slice(i3, i3 + j2).join(keySeparator), mix2 = current[p];
            if (mix2 === void 0)
              return;
            if (mix2 === null)
              return null;
            if (path2.endsWith(p)) {
              if (typeof mix2 == "string")
                return mix2;
              if (p && typeof mix2[p] == "string")
                return mix2[p];
            }
            var joinedPath = paths.slice(i3 + j2).join(keySeparator);
            return joinedPath ? deepFind2(mix2, joinedPath, keySeparator) : void 0;
          }
          current = current[paths[i3]];
        }
        return current;
      }
    }
    var ResourceStore2 = function(_EventEmitter) {
      _inherits__default.default(ResourceStore3, _EventEmitter);
      var _super = _createSuper2(ResourceStore3);
      function ResourceStore3(data2) {
        var _this, options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
          ns: ["translation"],
          defaultNS: "translation"
        };
        return _classCallCheck__default.default(this, ResourceStore3), _this = _super.call(this), isIE102 && EventEmitter3.call(_assertThisInitialized__default.default(_this)), _this.data = data2 || {}, _this.options = options2, _this.options.keySeparator === void 0 && (_this.options.keySeparator = "."), _this.options.ignoreJSONStructure === void 0 && (_this.options.ignoreJSONStructure = !0), _this;
      }
      return _createClass__default.default(ResourceStore3, [{
        key: "addNamespaces",
        value: function(ns) {
          this.options.ns.indexOf(ns) < 0 && this.options.ns.push(ns);
        }
      }, {
        key: "removeNamespaces",
        value: function(ns) {
          var index2 = this.options.ns.indexOf(ns);
          index2 > -1 && this.options.ns.splice(index2, 1);
        }
      }, {
        key: "getResource",
        value: function(lng2, ns, key2) {
          var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, keySeparator = options2.keySeparator !== void 0 ? options2.keySeparator : this.options.keySeparator, ignoreJSONStructure = options2.ignoreJSONStructure !== void 0 ? options2.ignoreJSONStructure : this.options.ignoreJSONStructure, path2 = [lng2, ns];
          key2 && typeof key2 != "string" && (path2 = path2.concat(key2)), key2 && typeof key2 == "string" && (path2 = path2.concat(keySeparator ? key2.split(keySeparator) : key2)), lng2.indexOf(".") > -1 && (path2 = lng2.split("."));
          var result2 = getPath3(this.data, path2);
          return result2 || !ignoreJSONStructure || typeof key2 != "string" ? result2 : deepFind2(this.data && this.data[lng2] && this.data[lng2][ns], key2, keySeparator);
        }
      }, {
        key: "addResource",
        value: function(lng2, ns, key2, value2) {
          var options2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
            silent: !1
          }, keySeparator = this.options.keySeparator;
          keySeparator === void 0 && (keySeparator = ".");
          var path2 = [lng2, ns];
          key2 && (path2 = path2.concat(keySeparator ? key2.split(keySeparator) : key2)), lng2.indexOf(".") > -1 && (path2 = lng2.split("."), value2 = ns, ns = path2[1]), this.addNamespaces(ns), setPath3(this.data, path2, value2), options2.silent || this.emit("added", lng2, ns, key2, value2);
        }
      }, {
        key: "addResources",
        value: function(lng2, ns, resources) {
          var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
            silent: !1
          };
          for (var m2 in resources)
            (typeof resources[m2] == "string" || Object.prototype.toString.apply(resources[m2]) === "[object Array]") && this.addResource(lng2, ns, m2, resources[m2], {
              silent: !0
            });
          options2.silent || this.emit("added", lng2, ns, resources);
        }
      }, {
        key: "addResourceBundle",
        value: function(lng2, ns, resources, deep, overwrite) {
          var options2 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
            silent: !1
          }, path2 = [lng2, ns];
          lng2.indexOf(".") > -1 && (path2 = lng2.split("."), deep = resources, resources = ns, ns = path2[1]), this.addNamespaces(ns);
          var pack = getPath3(this.data, path2) || {};
          deep ? deepExtend2(pack, resources, overwrite) : pack = _objectSpread$12(_objectSpread$12({}, pack), resources), setPath3(this.data, path2, pack), options2.silent || this.emit("added", lng2, ns, resources);
        }
      }, {
        key: "removeResourceBundle",
        value: function(lng2, ns) {
          this.hasResourceBundle(lng2, ns) && delete this.data[lng2][ns], this.removeNamespaces(ns), this.emit("removed", lng2, ns);
        }
      }, {
        key: "hasResourceBundle",
        value: function(lng2, ns) {
          return this.getResource(lng2, ns) !== void 0;
        }
      }, {
        key: "getResourceBundle",
        value: function(lng2, ns) {
          return ns || (ns = this.options.defaultNS), this.options.compatibilityAPI === "v1" ? _objectSpread$12(_objectSpread$12({}, {}), this.getResource(lng2, ns)) : this.getResource(lng2, ns);
        }
      }, {
        key: "getDataByLanguage",
        value: function(lng2) {
          return this.data[lng2];
        }
      }, {
        key: "hasLanguageSomeTranslations",
        value: function(lng2) {
          var data2 = this.getDataByLanguage(lng2), n3 = data2 && Object.keys(data2) || [];
          return !!n3.find(function(v2) {
            return data2[v2] && Object.keys(data2[v2]).length > 0;
          });
        }
      }, {
        key: "toJSON",
        value: function() {
          return this.data;
        }
      }]), ResourceStore3;
    }(EventEmitter3), postProcessor2 = {
      processors: {},
      addPostProcessor: function(module3) {
        this.processors[module3.name] = module3;
      },
      handle: function(processors, value2, key2, options2, translator) {
        var _this = this;
        return processors.forEach(function(processor) {
          _this.processors[processor] && (value2 = _this.processors[processor].process(value2, key2, options2, translator));
        }), value2;
      }
    };
    function ownKeys$22(object, enumerableOnly) {
      var keys2 = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    function _objectSpread$22(target) {
      for (var i3 = 1; i3 < arguments.length; i3++) {
        var source2 = arguments[i3] != null ? arguments[i3] : {};
        i3 % 2 ? ownKeys$22(Object(source2), !0).forEach(function(key2) {
          _defineProperty__default.default(target, key2, source2[key2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2)) : ownKeys$22(Object(source2)).forEach(function(key2) {
          Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source2, key2));
        });
      }
      return target;
    }
    function _createSuper$12(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$12();
      return function() {
        var Super = _getPrototypeOf__default.default(Derived), result2;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default.default(this).constructor;
          result2 = Reflect.construct(Super, arguments, NewTarget);
        } else
          result2 = Super.apply(this, arguments);
        return _possibleConstructorReturn__default.default(this, result2);
      };
    }
    function _isNativeReflectConstruct$12() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    var checkedLoadedFor2 = {}, Translator2 = function(_EventEmitter) {
      _inherits__default.default(Translator3, _EventEmitter);
      var _super = _createSuper$12(Translator3);
      function Translator3(services) {
        var _this, options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        return _classCallCheck__default.default(this, Translator3), _this = _super.call(this), isIE102 && EventEmitter3.call(_assertThisInitialized__default.default(_this)), copy3(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, _assertThisInitialized__default.default(_this)), _this.options = options2, _this.options.keySeparator === void 0 && (_this.options.keySeparator = "."), _this.logger = baseLogger2.create("translator"), _this;
      }
      return _createClass__default.default(Translator3, [{
        key: "changeLanguage",
        value: function(lng2) {
          lng2 && (this.language = lng2);
        }
      }, {
        key: "exists",
        value: function(key2) {
          var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
            interpolation: {}
          };
          if (key2 == null)
            return !1;
          var resolved = this.resolve(key2, options2);
          return resolved && resolved.res !== void 0;
        }
      }, {
        key: "extractFromKey",
        value: function(key2, options2) {
          var nsSeparator = options2.nsSeparator !== void 0 ? options2.nsSeparator : this.options.nsSeparator;
          nsSeparator === void 0 && (nsSeparator = ":");
          var keySeparator = options2.keySeparator !== void 0 ? options2.keySeparator : this.options.keySeparator, namespaces = options2.ns || this.options.defaultNS || [], wouldCheckForNsInKey = nsSeparator && key2.indexOf(nsSeparator) > -1, seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options2.keySeparator && !this.options.userDefinedNsSeparator && !options2.nsSeparator && !looksLikeObjectPath2(key2, nsSeparator, keySeparator);
          if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
            var m2 = key2.match(this.interpolator.nestingRegexp);
            if (m2 && m2.length > 0)
              return {
                key: key2,
                namespaces
              };
            var parts = key2.split(nsSeparator);
            (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) && (namespaces = parts.shift()), key2 = parts.join(keySeparator);
          }
          return typeof namespaces == "string" && (namespaces = [namespaces]), {
            key: key2,
            namespaces
          };
        }
      }, {
        key: "translate",
        value: function(keys2, options2, lastKey) {
          var _this2 = this;
          if (_typeof__default.default(options2) !== "object" && this.options.overloadTranslationOptionHandler && (options2 = this.options.overloadTranslationOptionHandler(arguments)), options2 || (options2 = {}), keys2 == null)
            return "";
          Array.isArray(keys2) || (keys2 = [String(keys2)]);
          var returnDetails = options2.returnDetails !== void 0 ? options2.returnDetails : this.options.returnDetails, keySeparator = options2.keySeparator !== void 0 ? options2.keySeparator : this.options.keySeparator, _this$extractFromKey = this.extractFromKey(keys2[keys2.length - 1], options2), key2 = _this$extractFromKey.key, namespaces = _this$extractFromKey.namespaces, namespace = namespaces[namespaces.length - 1], lng2 = options2.lng || this.language, appendNamespaceToCIMode = options2.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
          if (lng2 && lng2.toLowerCase() === "cimode") {
            if (appendNamespaceToCIMode) {
              var nsSeparator = options2.nsSeparator || this.options.nsSeparator;
              return returnDetails ? (resolved.res = "".concat(namespace).concat(nsSeparator).concat(key2), resolved) : "".concat(namespace).concat(nsSeparator).concat(key2);
            }
            return returnDetails ? (resolved.res = key2, resolved) : key2;
          }
          var resolved = this.resolve(keys2, options2), res = resolved && resolved.res, resUsedKey = resolved && resolved.usedKey || key2, resExactUsedKey = resolved && resolved.exactUsedKey || key2, resType = Object.prototype.toString.apply(res), noObject = ["[object Number]", "[object Function]", "[object RegExp]"], joinArrays = options2.joinArrays !== void 0 ? options2.joinArrays : this.options.joinArrays, handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject, handleAsObject = typeof res != "string" && typeof res != "boolean" && typeof res != "number";
          if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays == "string" && resType === "[object Array]")) {
            if (!options2.returnObjects && !this.options.returnObjects) {
              this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!");
              var r3 = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, _objectSpread$22(_objectSpread$22({}, options2), {}, {
                ns: namespaces
              })) : "key '".concat(key2, " (").concat(this.language, ")' returned an object instead of string.");
              return returnDetails ? (resolved.res = r3, resolved) : r3;
            }
            if (keySeparator) {
              var resTypeIsArray = resType === "[object Array]", copy4 = resTypeIsArray ? [] : {}, newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
              for (var m2 in res)
                if (Object.prototype.hasOwnProperty.call(res, m2)) {
                  var deepKey = "".concat(newKeyToUse).concat(keySeparator).concat(m2);
                  copy4[m2] = this.translate(deepKey, _objectSpread$22(_objectSpread$22({}, options2), {
                    joinArrays: !1,
                    ns: namespaces
                  })), copy4[m2] === deepKey && (copy4[m2] = res[m2]);
                }
              res = copy4;
            }
          } else if (handleAsObjectInI18nFormat && typeof joinArrays == "string" && resType === "[object Array]")
            res = res.join(joinArrays), res && (res = this.extendTranslation(res, keys2, options2, lastKey));
          else {
            var usedDefault = !1, usedKey = !1, needsPluralHandling = options2.count !== void 0 && typeof options2.count != "string", hasDefaultValue = Translator3.hasDefaultValue(options2), defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng2, options2.count, options2) : "", defaultValue = options2["defaultValue".concat(defaultValueSuffix)] || options2.defaultValue;
            !this.isValidLookup(res) && hasDefaultValue && (usedDefault = !0, res = defaultValue), this.isValidLookup(res) || (usedKey = !0, res = key2);
            var missingKeyNoValueFallbackToKey = options2.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey, resForMissing = missingKeyNoValueFallbackToKey && usedKey ? void 0 : res, updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
            if (usedKey || usedDefault || updateMissing) {
              if (this.logger.log(updateMissing ? "updateKey" : "missingKey", lng2, namespace, key2, updateMissing ? defaultValue : res), keySeparator) {
                var fk = this.resolve(key2, _objectSpread$22(_objectSpread$22({}, options2), {}, {
                  keySeparator: !1
                }));
                fk && fk.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
              }
              var lngs = [], fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options2.lng || this.language);
              if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0])
                for (var i3 = 0; i3 < fallbackLngs.length; i3++)
                  lngs.push(fallbackLngs[i3]);
              else
                this.options.saveMissingTo === "all" ? lngs = this.languageUtils.toResolveHierarchy(options2.lng || this.language) : lngs.push(options2.lng || this.language);
              var send = function(l2, k2, specificDefaultValue) {
                var defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
                _this2.options.missingKeyHandler ? _this2.options.missingKeyHandler(l2, namespace, k2, defaultForMissing, updateMissing, options2) : _this2.backendConnector && _this2.backendConnector.saveMissing && _this2.backendConnector.saveMissing(l2, namespace, k2, defaultForMissing, updateMissing, options2), _this2.emit("missingKey", l2, namespace, k2, res);
              };
              this.options.saveMissing && (this.options.saveMissingPlurals && needsPluralHandling ? lngs.forEach(function(language) {
                _this2.pluralResolver.getSuffixes(language, options2).forEach(function(suffix) {
                  send([language], key2 + suffix, options2["defaultValue".concat(suffix)] || defaultValue);
                });
              }) : send(lngs, key2, defaultValue));
            }
            res = this.extendTranslation(res, keys2, options2, resolved, lastKey), usedKey && res === key2 && this.options.appendNamespaceToMissingKey && (res = "".concat(namespace, ":").concat(key2)), (usedKey || usedDefault) && this.options.parseMissingKeyHandler && (this.options.compatibilityAPI !== "v1" ? res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? "".concat(namespace, ":").concat(key2) : key2, usedDefault ? res : void 0) : res = this.options.parseMissingKeyHandler(res));
          }
          return returnDetails ? (resolved.res = res, resolved) : res;
        }
      }, {
        key: "extendTranslation",
        value: function(res, key2, options2, resolved, lastKey) {
          var _this3 = this;
          if (this.i18nFormat && this.i18nFormat.parse)
            res = this.i18nFormat.parse(res, _objectSpread$22(_objectSpread$22({}, this.options.interpolation.defaultVariables), options2), resolved.usedLng, resolved.usedNS, resolved.usedKey, {
              resolved
            });
          else if (!options2.skipInterpolation) {
            options2.interpolation && this.interpolator.init(_objectSpread$22(_objectSpread$22({}, options2), {
              interpolation: _objectSpread$22(_objectSpread$22({}, this.options.interpolation), options2.interpolation)
            }));
            var skipOnVariables = typeof res == "string" && (options2 && options2.interpolation && options2.interpolation.skipOnVariables !== void 0 ? options2.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables), nestBef;
            if (skipOnVariables) {
              var nb = res.match(this.interpolator.nestingRegexp);
              nestBef = nb && nb.length;
            }
            var data2 = options2.replace && typeof options2.replace != "string" ? options2.replace : options2;
            if (this.options.interpolation.defaultVariables && (data2 = _objectSpread$22(_objectSpread$22({}, this.options.interpolation.defaultVariables), data2)), res = this.interpolator.interpolate(res, data2, options2.lng || this.language, options2), skipOnVariables) {
              var na = res.match(this.interpolator.nestingRegexp), nestAft = na && na.length;
              nestBef < nestAft && (options2.nest = !1);
            }
            options2.nest !== !1 && (res = this.interpolator.nest(res, function() {
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
                args[_key] = arguments[_key];
              return lastKey && lastKey[0] === args[0] && !options2.context ? (_this3.logger.warn("It seems you are nesting recursively key: ".concat(args[0], " in key: ").concat(key2[0])), null) : _this3.translate.apply(_this3, args.concat([key2]));
            }, options2)), options2.interpolation && this.interpolator.reset();
          }
          var postProcess = options2.postProcess || this.options.postProcess, postProcessorNames = typeof postProcess == "string" ? [postProcess] : postProcess;
          return res != null && postProcessorNames && postProcessorNames.length && options2.applyPostProcessor !== !1 && (res = postProcessor2.handle(postProcessorNames, res, key2, this.options && this.options.postProcessPassResolved ? _objectSpread$22({
            i18nResolved: resolved
          }, options2) : options2, this)), res;
        }
      }, {
        key: "resolve",
        value: function(keys2) {
          var _this4 = this, options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, found, usedKey, exactUsedKey, usedLng, usedNS;
          return typeof keys2 == "string" && (keys2 = [keys2]), keys2.forEach(function(k2) {
            if (!_this4.isValidLookup(found)) {
              var extracted = _this4.extractFromKey(k2, options2), key2 = extracted.key;
              usedKey = key2;
              var namespaces = extracted.namespaces;
              _this4.options.fallbackNS && (namespaces = namespaces.concat(_this4.options.fallbackNS));
              var needsPluralHandling = options2.count !== void 0 && typeof options2.count != "string", needsZeroSuffixLookup = needsPluralHandling && !options2.ordinal && options2.count === 0 && _this4.pluralResolver.shouldUseIntlApi(), needsContextHandling = options2.context !== void 0 && (typeof options2.context == "string" || typeof options2.context == "number") && options2.context !== "", codes = options2.lngs ? options2.lngs : _this4.languageUtils.toResolveHierarchy(options2.lng || _this4.language, options2.fallbackLng);
              namespaces.forEach(function(ns) {
                _this4.isValidLookup(found) || (usedNS = ns, !checkedLoadedFor2["".concat(codes[0], "-").concat(ns)] && _this4.utils && _this4.utils.hasLoadedNamespace && !_this4.utils.hasLoadedNamespace(usedNS) && (checkedLoadedFor2["".concat(codes[0], "-").concat(ns)] = !0, _this4.logger.warn('key "'.concat(usedKey, '" for languages "').concat(codes.join(", "), `" won't get resolved as namespace "`).concat(usedNS, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")), codes.forEach(function(code) {
                  if (!_this4.isValidLookup(found)) {
                    usedLng = code;
                    var finalKeys = [key2];
                    if (_this4.i18nFormat && _this4.i18nFormat.addLookupKeys)
                      _this4.i18nFormat.addLookupKeys(finalKeys, key2, code, ns, options2);
                    else {
                      var pluralSuffix;
                      needsPluralHandling && (pluralSuffix = _this4.pluralResolver.getSuffix(code, options2.count, options2));
                      var zeroSuffix = "".concat(_this4.options.pluralSeparator, "zero");
                      if (needsPluralHandling && (finalKeys.push(key2 + pluralSuffix), needsZeroSuffixLookup && finalKeys.push(key2 + zeroSuffix)), needsContextHandling) {
                        var contextKey = "".concat(key2).concat(_this4.options.contextSeparator).concat(options2.context);
                        finalKeys.push(contextKey), needsPluralHandling && (finalKeys.push(contextKey + pluralSuffix), needsZeroSuffixLookup && finalKeys.push(contextKey + zeroSuffix));
                      }
                    }
                    for (var possibleKey; possibleKey = finalKeys.pop(); )
                      _this4.isValidLookup(found) || (exactUsedKey = possibleKey, found = _this4.getResource(code, ns, possibleKey, options2));
                  }
                }));
              });
            }
          }), {
            res: found,
            usedKey,
            exactUsedKey,
            usedLng,
            usedNS
          };
        }
      }, {
        key: "isValidLookup",
        value: function(res) {
          return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
        }
      }, {
        key: "getResource",
        value: function(code, ns, key2) {
          var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
          return this.i18nFormat && this.i18nFormat.getResource ? this.i18nFormat.getResource(code, ns, key2, options2) : this.resourceStore.getResource(code, ns, key2, options2);
        }
      }], [{
        key: "hasDefaultValue",
        value: function(options2) {
          var prefix = "defaultValue";
          for (var option in options2)
            if (Object.prototype.hasOwnProperty.call(options2, option) && prefix === option.substring(0, prefix.length) && options2[option] !== void 0)
              return !0;
          return !1;
        }
      }]), Translator3;
    }(EventEmitter3);
    function capitalize2(string2) {
      return string2.charAt(0).toUpperCase() + string2.slice(1);
    }
    var LanguageUtil2 = function() {
      function LanguageUtil3(options2) {
        _classCallCheck__default.default(this, LanguageUtil3), this.options = options2, this.supportedLngs = this.options.supportedLngs || !1, this.logger = baseLogger2.create("languageUtils");
      }
      return _createClass__default.default(LanguageUtil3, [{
        key: "getScriptPartFromCode",
        value: function(code) {
          if (!code || code.indexOf("-") < 0)
            return null;
          var p = code.split("-");
          return p.length === 2 || (p.pop(), p[p.length - 1].toLowerCase() === "x") ? null : this.formatLanguageCode(p.join("-"));
        }
      }, {
        key: "getLanguagePartFromCode",
        value: function(code) {
          if (!code || code.indexOf("-") < 0)
            return code;
          var p = code.split("-");
          return this.formatLanguageCode(p[0]);
        }
      }, {
        key: "formatLanguageCode",
        value: function(code) {
          if (typeof code == "string" && code.indexOf("-") > -1) {
            var specialCases = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"], p = code.split("-");
            return this.options.lowerCaseLng ? p = p.map(function(part) {
              return part.toLowerCase();
            }) : p.length === 2 ? (p[0] = p[0].toLowerCase(), p[1] = p[1].toUpperCase(), specialCases.indexOf(p[1].toLowerCase()) > -1 && (p[1] = capitalize2(p[1].toLowerCase()))) : p.length === 3 && (p[0] = p[0].toLowerCase(), p[1].length === 2 && (p[1] = p[1].toUpperCase()), p[0] !== "sgn" && p[2].length === 2 && (p[2] = p[2].toUpperCase()), specialCases.indexOf(p[1].toLowerCase()) > -1 && (p[1] = capitalize2(p[1].toLowerCase())), specialCases.indexOf(p[2].toLowerCase()) > -1 && (p[2] = capitalize2(p[2].toLowerCase()))), p.join("-");
          }
          return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
        }
      }, {
        key: "isSupportedCode",
        value: function(code) {
          return (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) && (code = this.getLanguagePartFromCode(code)), !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
        }
      }, {
        key: "getBestMatchFromCodes",
        value: function(codes) {
          var _this = this;
          if (!codes)
            return null;
          var found;
          return codes.forEach(function(code) {
            if (!found) {
              var cleanedLng = _this.formatLanguageCode(code);
              (!_this.options.supportedLngs || _this.isSupportedCode(cleanedLng)) && (found = cleanedLng);
            }
          }), !found && this.options.supportedLngs && codes.forEach(function(code) {
            if (!found) {
              var lngOnly = _this.getLanguagePartFromCode(code);
              if (_this.isSupportedCode(lngOnly))
                return found = lngOnly;
              found = _this.options.supportedLngs.find(function(supportedLng) {
                if (supportedLng.indexOf(lngOnly) === 0)
                  return supportedLng;
              });
            }
          }), found || (found = this.getFallbackCodes(this.options.fallbackLng)[0]), found;
        }
      }, {
        key: "getFallbackCodes",
        value: function(fallbacks, code) {
          if (!fallbacks)
            return [];
          if (typeof fallbacks == "function" && (fallbacks = fallbacks(code)), typeof fallbacks == "string" && (fallbacks = [fallbacks]), Object.prototype.toString.apply(fallbacks) === "[object Array]")
            return fallbacks;
          if (!code)
            return fallbacks.default || [];
          var found = fallbacks[code];
          return found || (found = fallbacks[this.getScriptPartFromCode(code)]), found || (found = fallbacks[this.formatLanguageCode(code)]), found || (found = fallbacks[this.getLanguagePartFromCode(code)]), found || (found = fallbacks.default), found || [];
        }
      }, {
        key: "toResolveHierarchy",
        value: function(code, fallbackCode) {
          var _this2 = this, fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code), codes = [], addCode = function(c4) {
            !c4 || (_this2.isSupportedCode(c4) ? codes.push(c4) : _this2.logger.warn("rejecting language code not found in supportedLngs: ".concat(c4)));
          };
          return typeof code == "string" && code.indexOf("-") > -1 ? (this.options.load !== "languageOnly" && addCode(this.formatLanguageCode(code)), this.options.load !== "languageOnly" && this.options.load !== "currentOnly" && addCode(this.getScriptPartFromCode(code)), this.options.load !== "currentOnly" && addCode(this.getLanguagePartFromCode(code))) : typeof code == "string" && addCode(this.formatLanguageCode(code)), fallbackCodes.forEach(function(fc) {
            codes.indexOf(fc) < 0 && addCode(_this2.formatLanguageCode(fc));
          }), codes;
        }
      }]), LanguageUtil3;
    }(), sets2 = [{
      lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
      nr: [1, 2],
      fc: 1
    }, {
      lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
      nr: [1, 2],
      fc: 2
    }, {
      lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
      nr: [1],
      fc: 3
    }, {
      lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
      nr: [1, 2, 5],
      fc: 4
    }, {
      lngs: ["ar"],
      nr: [0, 1, 2, 3, 11, 100],
      fc: 5
    }, {
      lngs: ["cs", "sk"],
      nr: [1, 2, 5],
      fc: 6
    }, {
      lngs: ["csb", "pl"],
      nr: [1, 2, 5],
      fc: 7
    }, {
      lngs: ["cy"],
      nr: [1, 2, 3, 8],
      fc: 8
    }, {
      lngs: ["fr"],
      nr: [1, 2],
      fc: 9
    }, {
      lngs: ["ga"],
      nr: [1, 2, 3, 7, 11],
      fc: 10
    }, {
      lngs: ["gd"],
      nr: [1, 2, 3, 20],
      fc: 11
    }, {
      lngs: ["is"],
      nr: [1, 2],
      fc: 12
    }, {
      lngs: ["jv"],
      nr: [0, 1],
      fc: 13
    }, {
      lngs: ["kw"],
      nr: [1, 2, 3, 4],
      fc: 14
    }, {
      lngs: ["lt"],
      nr: [1, 2, 10],
      fc: 15
    }, {
      lngs: ["lv"],
      nr: [1, 2, 0],
      fc: 16
    }, {
      lngs: ["mk"],
      nr: [1, 2],
      fc: 17
    }, {
      lngs: ["mnk"],
      nr: [0, 1, 2],
      fc: 18
    }, {
      lngs: ["mt"],
      nr: [1, 2, 11, 20],
      fc: 19
    }, {
      lngs: ["or"],
      nr: [2, 1],
      fc: 2
    }, {
      lngs: ["ro"],
      nr: [1, 2, 20],
      fc: 20
    }, {
      lngs: ["sl"],
      nr: [5, 1, 2, 3],
      fc: 21
    }, {
      lngs: ["he", "iw"],
      nr: [1, 2, 20, 21],
      fc: 22
    }], _rulesPluralsTypes2 = {
      1: function(n3) {
        return Number(n3 > 1);
      },
      2: function(n3) {
        return Number(n3 != 1);
      },
      3: function(n3) {
        return 0;
      },
      4: function(n3) {
        return Number(n3 % 10 == 1 && n3 % 100 != 11 ? 0 : n3 % 10 >= 2 && n3 % 10 <= 4 && (n3 % 100 < 10 || n3 % 100 >= 20) ? 1 : 2);
      },
      5: function(n3) {
        return Number(n3 == 0 ? 0 : n3 == 1 ? 1 : n3 == 2 ? 2 : n3 % 100 >= 3 && n3 % 100 <= 10 ? 3 : n3 % 100 >= 11 ? 4 : 5);
      },
      6: function(n3) {
        return Number(n3 == 1 ? 0 : n3 >= 2 && n3 <= 4 ? 1 : 2);
      },
      7: function(n3) {
        return Number(n3 == 1 ? 0 : n3 % 10 >= 2 && n3 % 10 <= 4 && (n3 % 100 < 10 || n3 % 100 >= 20) ? 1 : 2);
      },
      8: function(n3) {
        return Number(n3 == 1 ? 0 : n3 == 2 ? 1 : n3 != 8 && n3 != 11 ? 2 : 3);
      },
      9: function(n3) {
        return Number(n3 >= 2);
      },
      10: function(n3) {
        return Number(n3 == 1 ? 0 : n3 == 2 ? 1 : n3 < 7 ? 2 : n3 < 11 ? 3 : 4);
      },
      11: function(n3) {
        return Number(n3 == 1 || n3 == 11 ? 0 : n3 == 2 || n3 == 12 ? 1 : n3 > 2 && n3 < 20 ? 2 : 3);
      },
      12: function(n3) {
        return Number(n3 % 10 != 1 || n3 % 100 == 11);
      },
      13: function(n3) {
        return Number(n3 !== 0);
      },
      14: function(n3) {
        return Number(n3 == 1 ? 0 : n3 == 2 ? 1 : n3 == 3 ? 2 : 3);
      },
      15: function(n3) {
        return Number(n3 % 10 == 1 && n3 % 100 != 11 ? 0 : n3 % 10 >= 2 && (n3 % 100 < 10 || n3 % 100 >= 20) ? 1 : 2);
      },
      16: function(n3) {
        return Number(n3 % 10 == 1 && n3 % 100 != 11 ? 0 : n3 !== 0 ? 1 : 2);
      },
      17: function(n3) {
        return Number(n3 == 1 || n3 % 10 == 1 && n3 % 100 != 11 ? 0 : 1);
      },
      18: function(n3) {
        return Number(n3 == 0 ? 0 : n3 == 1 ? 1 : 2);
      },
      19: function(n3) {
        return Number(n3 == 1 ? 0 : n3 == 0 || n3 % 100 > 1 && n3 % 100 < 11 ? 1 : n3 % 100 > 10 && n3 % 100 < 20 ? 2 : 3);
      },
      20: function(n3) {
        return Number(n3 == 1 ? 0 : n3 == 0 || n3 % 100 > 0 && n3 % 100 < 20 ? 1 : 2);
      },
      21: function(n3) {
        return Number(n3 % 100 == 1 ? 1 : n3 % 100 == 2 ? 2 : n3 % 100 == 3 || n3 % 100 == 4 ? 3 : 0);
      },
      22: function(n3) {
        return Number(n3 == 1 ? 0 : n3 == 2 ? 1 : (n3 < 0 || n3 > 10) && n3 % 10 == 0 ? 2 : 3);
      }
    }, deprecatedJsonVersions2 = ["v1", "v2", "v3"], suffixesOrder2 = {
      zero: 0,
      one: 1,
      two: 2,
      few: 3,
      many: 4,
      other: 5
    };
    function createRules2() {
      var rules = {};
      return sets2.forEach(function(set2) {
        set2.lngs.forEach(function(l2) {
          rules[l2] = {
            numbers: set2.nr,
            plurals: _rulesPluralsTypes2[set2.fc]
          };
        });
      }), rules;
    }
    var PluralResolver2 = function() {
      function PluralResolver3(languageUtils) {
        var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        _classCallCheck__default.default(this, PluralResolver3), this.languageUtils = languageUtils, this.options = options2, this.logger = baseLogger2.create("pluralResolver"), (!this.options.compatibilityJSON || this.options.compatibilityJSON === "v4") && (typeof Intl > "u" || !Intl.PluralRules) && (this.options.compatibilityJSON = "v3", this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.")), this.rules = createRules2();
      }
      return _createClass__default.default(PluralResolver3, [{
        key: "addRule",
        value: function(lng2, obj) {
          this.rules[lng2] = obj;
        }
      }, {
        key: "getRule",
        value: function(code) {
          var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          if (this.shouldUseIntlApi())
            try {
              return new Intl.PluralRules(code, {
                type: options2.ordinal ? "ordinal" : "cardinal"
              });
            } catch {
              return;
            }
          return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
        }
      }, {
        key: "needsPlural",
        value: function(code) {
          var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, rule = this.getRule(code, options2);
          return this.shouldUseIntlApi() ? rule && rule.resolvedOptions().pluralCategories.length > 1 : rule && rule.numbers.length > 1;
        }
      }, {
        key: "getPluralFormsOfKey",
        value: function(code, key2) {
          var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          return this.getSuffixes(code, options2).map(function(suffix) {
            return "".concat(key2).concat(suffix);
          });
        }
      }, {
        key: "getSuffixes",
        value: function(code) {
          var _this = this, options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, rule = this.getRule(code, options2);
          return rule ? this.shouldUseIntlApi() ? rule.resolvedOptions().pluralCategories.sort(function(pluralCategory1, pluralCategory2) {
            return suffixesOrder2[pluralCategory1] - suffixesOrder2[pluralCategory2];
          }).map(function(pluralCategory) {
            return "".concat(_this.options.prepend).concat(pluralCategory);
          }) : rule.numbers.map(function(number4) {
            return _this.getSuffix(code, number4, options2);
          }) : [];
        }
      }, {
        key: "getSuffix",
        value: function(code, count) {
          var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, rule = this.getRule(code, options2);
          return rule ? this.shouldUseIntlApi() ? "".concat(this.options.prepend).concat(rule.select(count)) : this.getSuffixRetroCompatible(rule, count) : (this.logger.warn("no plural rule found for: ".concat(code)), "");
        }
      }, {
        key: "getSuffixRetroCompatible",
        value: function(rule, count) {
          var _this2 = this, idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count)), suffix = rule.numbers[idx];
          this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1 && (suffix === 2 ? suffix = "plural" : suffix === 1 && (suffix = ""));
          var returnSuffix = function() {
            return _this2.options.prepend && suffix.toString() ? _this2.options.prepend + suffix.toString() : suffix.toString();
          };
          return this.options.compatibilityJSON === "v1" ? suffix === 1 ? "" : typeof suffix == "number" ? "_plural_".concat(suffix.toString()) : returnSuffix() : this.options.compatibilityJSON === "v2" || this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1 ? returnSuffix() : this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
        }
      }, {
        key: "shouldUseIntlApi",
        value: function() {
          return !deprecatedJsonVersions2.includes(this.options.compatibilityJSON);
        }
      }]), PluralResolver3;
    }();
    function ownKeys$32(object, enumerableOnly) {
      var keys2 = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    function _objectSpread$32(target) {
      for (var i3 = 1; i3 < arguments.length; i3++) {
        var source2 = arguments[i3] != null ? arguments[i3] : {};
        i3 % 2 ? ownKeys$32(Object(source2), !0).forEach(function(key2) {
          _defineProperty__default.default(target, key2, source2[key2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2)) : ownKeys$32(Object(source2)).forEach(function(key2) {
          Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source2, key2));
        });
      }
      return target;
    }
    var Interpolator2 = function() {
      function Interpolator3() {
        var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _classCallCheck__default.default(this, Interpolator3), this.logger = baseLogger2.create("interpolator"), this.options = options2, this.format = options2.interpolation && options2.interpolation.format || function(value2) {
          return value2;
        }, this.init(options2);
      }
      return _createClass__default.default(Interpolator3, [{
        key: "init",
        value: function() {
          var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          options2.interpolation || (options2.interpolation = {
            escapeValue: !0
          });
          var iOpts = options2.interpolation;
          this.escape = iOpts.escape !== void 0 ? iOpts.escape : escape4, this.escapeValue = iOpts.escapeValue !== void 0 ? iOpts.escapeValue : !0, this.useRawValueToEscape = iOpts.useRawValueToEscape !== void 0 ? iOpts.useRawValueToEscape : !1, this.prefix = iOpts.prefix ? regexEscape2(iOpts.prefix) : iOpts.prefixEscaped || "{{", this.suffix = iOpts.suffix ? regexEscape2(iOpts.suffix) : iOpts.suffixEscaped || "}}", this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",", this.unescapePrefix = iOpts.unescapeSuffix ? "" : iOpts.unescapePrefix || "-", this.unescapeSuffix = this.unescapePrefix ? "" : iOpts.unescapeSuffix || "", this.nestingPrefix = iOpts.nestingPrefix ? regexEscape2(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape2("$t("), this.nestingSuffix = iOpts.nestingSuffix ? regexEscape2(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape2(")"), this.nestingOptionsSeparator = iOpts.nestingOptionsSeparator ? iOpts.nestingOptionsSeparator : iOpts.nestingOptionsSeparator || ",", this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1e3, this.alwaysFormat = iOpts.alwaysFormat !== void 0 ? iOpts.alwaysFormat : !1, this.resetRegExp();
        }
      }, {
        key: "reset",
        value: function() {
          this.options && this.init(this.options);
        }
      }, {
        key: "resetRegExp",
        value: function() {
          var regexpStr = "".concat(this.prefix, "(.+?)").concat(this.suffix);
          this.regexp = new RegExp(regexpStr, "g");
          var regexpUnescapeStr = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
          this.regexpUnescape = new RegExp(regexpUnescapeStr, "g");
          var nestingRegexpStr = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
          this.nestingRegexp = new RegExp(nestingRegexpStr, "g");
        }
      }, {
        key: "interpolate",
        value: function(str2, data2, lng2, options2) {
          var _this = this, match, value2, replaces, defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
          function regexSafe(val) {
            return val.replace(/\$/g, "$$$$");
          }
          var handleFormat = function(key2) {
            if (key2.indexOf(_this.formatSeparator) < 0) {
              var path2 = getPathWithDefaults2(data2, defaultData, key2);
              return _this.alwaysFormat ? _this.format(path2, void 0, lng2, _objectSpread$32(_objectSpread$32(_objectSpread$32({}, options2), data2), {}, {
                interpolationkey: key2
              })) : path2;
            }
            var p = key2.split(_this.formatSeparator), k2 = p.shift().trim(), f2 = p.join(_this.formatSeparator).trim();
            return _this.format(getPathWithDefaults2(data2, defaultData, k2), f2, lng2, _objectSpread$32(_objectSpread$32(_objectSpread$32({}, options2), data2), {}, {
              interpolationkey: k2
            }));
          };
          this.resetRegExp();
          var missingInterpolationHandler = options2 && options2.missingInterpolationHandler || this.options.missingInterpolationHandler, skipOnVariables = options2 && options2.interpolation && options2.interpolation.skipOnVariables !== void 0 ? options2.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables, todos = [{
            regex: this.regexpUnescape,
            safeValue: function(val) {
              return regexSafe(val);
            }
          }, {
            regex: this.regexp,
            safeValue: function(val) {
              return _this.escapeValue ? regexSafe(_this.escape(val)) : regexSafe(val);
            }
          }];
          return todos.forEach(function(todo) {
            for (replaces = 0; match = todo.regex.exec(str2); ) {
              var matchedVar = match[1].trim();
              if (value2 = handleFormat(matchedVar), value2 === void 0)
                if (typeof missingInterpolationHandler == "function") {
                  var temp = missingInterpolationHandler(str2, match, options2);
                  value2 = typeof temp == "string" ? temp : "";
                } else if (options2 && options2.hasOwnProperty(matchedVar))
                  value2 = "";
                else if (skipOnVariables) {
                  value2 = match[0];
                  continue;
                } else
                  _this.logger.warn("missed to pass in variable ".concat(matchedVar, " for interpolating ").concat(str2)), value2 = "";
              else
                typeof value2 != "string" && !_this.useRawValueToEscape && (value2 = makeString2(value2));
              var safeValue = todo.safeValue(value2);
              if (str2 = str2.replace(match[0], safeValue), skipOnVariables ? (todo.regex.lastIndex += value2.length, todo.regex.lastIndex -= match[0].length) : todo.regex.lastIndex = 0, replaces++, replaces >= _this.maxReplaces)
                break;
            }
          }), str2;
        }
      }, {
        key: "nest",
        value: function(str2, fc) {
          var _this2 = this, options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, match, value2, clonedOptions = _objectSpread$32({}, options2);
          clonedOptions.applyPostProcessor = !1, delete clonedOptions.defaultValue;
          function handleHasOptions(key2, inheritedOptions) {
            var sep2 = this.nestingOptionsSeparator;
            if (key2.indexOf(sep2) < 0)
              return key2;
            var c4 = key2.split(new RegExp("".concat(sep2, "[ ]*{"))), optionsString = "{".concat(c4[1]);
            key2 = c4[0], optionsString = this.interpolate(optionsString, clonedOptions);
            var matchedSingleQuotes = optionsString.match(/'/g), matchedDoubleQuotes = optionsString.match(/"/g);
            (matchedSingleQuotes && matchedSingleQuotes.length % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) && (optionsString = optionsString.replace(/'/g, '"'));
            try {
              clonedOptions = JSON.parse(optionsString), inheritedOptions && (clonedOptions = _objectSpread$32(_objectSpread$32({}, inheritedOptions), clonedOptions));
            } catch (e3) {
              return this.logger.warn("failed parsing options string in nesting for key ".concat(key2), e3), "".concat(key2).concat(sep2).concat(optionsString);
            }
            return delete clonedOptions.defaultValue, key2;
          }
          for (; match = this.nestingRegexp.exec(str2); ) {
            var formatters = [], doReduce = !1;
            if (match[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match[1])) {
              var r3 = match[1].split(this.formatSeparator).map(function(elem) {
                return elem.trim();
              });
              match[1] = r3.shift(), formatters = r3, doReduce = !0;
            }
            if (value2 = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions), value2 && match[0] === str2 && typeof value2 != "string")
              return value2;
            typeof value2 != "string" && (value2 = makeString2(value2)), value2 || (this.logger.warn("missed to resolve ".concat(match[1], " for nesting ").concat(str2)), value2 = ""), doReduce && (value2 = formatters.reduce(function(v2, f2) {
              return _this2.format(v2, f2, options2.lng, _objectSpread$32(_objectSpread$32({}, options2), {}, {
                interpolationkey: match[1].trim()
              }));
            }, value2.trim())), str2 = str2.replace(match[0], value2), this.regexp.lastIndex = 0;
          }
          return str2;
        }
      }]), Interpolator3;
    }();
    function ownKeys$42(object, enumerableOnly) {
      var keys2 = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    function _objectSpread$42(target) {
      for (var i3 = 1; i3 < arguments.length; i3++) {
        var source2 = arguments[i3] != null ? arguments[i3] : {};
        i3 % 2 ? ownKeys$42(Object(source2), !0).forEach(function(key2) {
          _defineProperty__default.default(target, key2, source2[key2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2)) : ownKeys$42(Object(source2)).forEach(function(key2) {
          Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source2, key2));
        });
      }
      return target;
    }
    function parseFormatStr2(formatStr) {
      var formatName = formatStr.toLowerCase().trim(), formatOptions = {};
      if (formatStr.indexOf("(") > -1) {
        var p = formatStr.split("(");
        formatName = p[0].toLowerCase().trim();
        var optStr = p[1].substring(0, p[1].length - 1);
        if (formatName === "currency" && optStr.indexOf(":") < 0)
          formatOptions.currency || (formatOptions.currency = optStr.trim());
        else if (formatName === "relativetime" && optStr.indexOf(":") < 0)
          formatOptions.range || (formatOptions.range = optStr.trim());
        else {
          var opts = optStr.split(";");
          opts.forEach(function(opt) {
            if (!!opt) {
              var _opt$split = opt.split(":"), _opt$split2 = _toArray__default.default(_opt$split), key2 = _opt$split2[0], rest = _opt$split2.slice(1), val = rest.join(":").trim().replace(/^'+|'+$/g, "");
              formatOptions[key2.trim()] || (formatOptions[key2.trim()] = val), val === "false" && (formatOptions[key2.trim()] = !1), val === "true" && (formatOptions[key2.trim()] = !0), isNaN(val) || (formatOptions[key2.trim()] = parseInt(val, 10));
            }
          });
        }
      }
      return {
        formatName,
        formatOptions
      };
    }
    function createCachedFormatter2(fn) {
      var cache = {};
      return function(val, lng2, options2) {
        var key2 = lng2 + JSON.stringify(options2), formatter = cache[key2];
        return formatter || (formatter = fn(lng2, options2), cache[key2] = formatter), formatter(val);
      };
    }
    var Formatter2 = function() {
      function Formatter3() {
        var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _classCallCheck__default.default(this, Formatter3), this.logger = baseLogger2.create("formatter"), this.options = options2, this.formats = {
          number: createCachedFormatter2(function(lng2, options3) {
            var formatter = new Intl.NumberFormat(lng2, options3);
            return function(val) {
              return formatter.format(val);
            };
          }),
          currency: createCachedFormatter2(function(lng2, options3) {
            var formatter = new Intl.NumberFormat(lng2, _objectSpread$42(_objectSpread$42({}, options3), {}, {
              style: "currency"
            }));
            return function(val) {
              return formatter.format(val);
            };
          }),
          datetime: createCachedFormatter2(function(lng2, options3) {
            var formatter = new Intl.DateTimeFormat(lng2, _objectSpread$42({}, options3));
            return function(val) {
              return formatter.format(val);
            };
          }),
          relativetime: createCachedFormatter2(function(lng2, options3) {
            var formatter = new Intl.RelativeTimeFormat(lng2, _objectSpread$42({}, options3));
            return function(val) {
              return formatter.format(val, options3.range || "day");
            };
          }),
          list: createCachedFormatter2(function(lng2, options3) {
            var formatter = new Intl.ListFormat(lng2, _objectSpread$42({}, options3));
            return function(val) {
              return formatter.format(val);
            };
          })
        }, this.init(options2);
      }
      return _createClass__default.default(Formatter3, [{
        key: "init",
        value: function(services) {
          var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
            interpolation: {}
          }, iOpts = options2.interpolation;
          this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
        }
      }, {
        key: "add",
        value: function(name, fc) {
          this.formats[name.toLowerCase().trim()] = fc;
        }
      }, {
        key: "addCached",
        value: function(name, fc) {
          this.formats[name.toLowerCase().trim()] = createCachedFormatter2(fc);
        }
      }, {
        key: "format",
        value: function(value2, _format, lng2, options2) {
          var _this = this, formats = _format.split(this.formatSeparator), result2 = formats.reduce(function(mem, f2) {
            var _parseFormatStr = parseFormatStr2(f2), formatName = _parseFormatStr.formatName, formatOptions = _parseFormatStr.formatOptions;
            if (_this.formats[formatName]) {
              var formatted = mem;
              try {
                var valOptions = options2 && options2.formatParams && options2.formatParams[options2.interpolationkey] || {}, l2 = valOptions.locale || valOptions.lng || options2.locale || options2.lng || lng2;
                formatted = _this.formats[formatName](mem, l2, _objectSpread$42(_objectSpread$42(_objectSpread$42({}, formatOptions), options2), valOptions));
              } catch (error2) {
                _this.logger.warn(error2);
              }
              return formatted;
            } else
              _this.logger.warn("there was no format function for ".concat(formatName));
            return mem;
          }, value2);
          return result2;
        }
      }]), Formatter3;
    }();
    function ownKeys$52(object, enumerableOnly) {
      var keys2 = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    function _objectSpread$52(target) {
      for (var i3 = 1; i3 < arguments.length; i3++) {
        var source2 = arguments[i3] != null ? arguments[i3] : {};
        i3 % 2 ? ownKeys$52(Object(source2), !0).forEach(function(key2) {
          _defineProperty__default.default(target, key2, source2[key2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2)) : ownKeys$52(Object(source2)).forEach(function(key2) {
          Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source2, key2));
        });
      }
      return target;
    }
    function _createSuper$22(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$22();
      return function() {
        var Super = _getPrototypeOf__default.default(Derived), result2;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default.default(this).constructor;
          result2 = Reflect.construct(Super, arguments, NewTarget);
        } else
          result2 = Super.apply(this, arguments);
        return _possibleConstructorReturn__default.default(this, result2);
      };
    }
    function _isNativeReflectConstruct$22() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function removePending2(q2, name) {
      q2.pending[name] !== void 0 && (delete q2.pending[name], q2.pendingCount--);
    }
    var Connector2 = function(_EventEmitter) {
      _inherits__default.default(Connector3, _EventEmitter);
      var _super = _createSuper$22(Connector3);
      function Connector3(backend, store, services) {
        var _this, options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
        return _classCallCheck__default.default(this, Connector3), _this = _super.call(this), isIE102 && EventEmitter3.call(_assertThisInitialized__default.default(_this)), _this.backend = backend, _this.store = store, _this.services = services, _this.languageUtils = services.languageUtils, _this.options = options2, _this.logger = baseLogger2.create("backendConnector"), _this.waitingReads = [], _this.maxParallelReads = options2.maxParallelReads || 10, _this.readingCalls = 0, _this.maxRetries = options2.maxRetries >= 0 ? options2.maxRetries : 5, _this.retryTimeout = options2.retryTimeout >= 1 ? options2.retryTimeout : 350, _this.state = {}, _this.queue = [], _this.backend && _this.backend.init && _this.backend.init(services, options2.backend, options2), _this;
      }
      return _createClass__default.default(Connector3, [{
        key: "queueLoad",
        value: function(languages, namespaces, options2, callback) {
          var _this2 = this, toLoad = {}, pending = {}, toLoadLanguages = {}, toLoadNamespaces = {};
          return languages.forEach(function(lng2) {
            var hasAllNamespaces = !0;
            namespaces.forEach(function(ns) {
              var name = "".concat(lng2, "|").concat(ns);
              !options2.reload && _this2.store.hasResourceBundle(lng2, ns) ? _this2.state[name] = 2 : _this2.state[name] < 0 || (_this2.state[name] === 1 ? pending[name] === void 0 && (pending[name] = !0) : (_this2.state[name] = 1, hasAllNamespaces = !1, pending[name] === void 0 && (pending[name] = !0), toLoad[name] === void 0 && (toLoad[name] = !0), toLoadNamespaces[ns] === void 0 && (toLoadNamespaces[ns] = !0)));
            }), hasAllNamespaces || (toLoadLanguages[lng2] = !0);
          }), (Object.keys(toLoad).length || Object.keys(pending).length) && this.queue.push({
            pending,
            pendingCount: Object.keys(pending).length,
            loaded: {},
            errors: [],
            callback
          }), {
            toLoad: Object.keys(toLoad),
            pending: Object.keys(pending),
            toLoadLanguages: Object.keys(toLoadLanguages),
            toLoadNamespaces: Object.keys(toLoadNamespaces)
          };
        }
      }, {
        key: "loaded",
        value: function(name, err, data2) {
          var s3 = name.split("|"), lng2 = s3[0], ns = s3[1];
          err && this.emit("failedLoading", lng2, ns, err), data2 && this.store.addResourceBundle(lng2, ns, data2), this.state[name] = err ? -1 : 2;
          var loaded2 = {};
          this.queue.forEach(function(q2) {
            pushPath3(q2.loaded, [lng2], ns), removePending2(q2, name), err && q2.errors.push(err), q2.pendingCount === 0 && !q2.done && (Object.keys(q2.loaded).forEach(function(l2) {
              loaded2[l2] || (loaded2[l2] = {});
              var loadedKeys = q2.loaded[l2];
              loadedKeys.length && loadedKeys.forEach(function(ns2) {
                loaded2[l2][ns2] === void 0 && (loaded2[l2][ns2] = !0);
              });
            }), q2.done = !0, q2.errors.length ? q2.callback(q2.errors) : q2.callback());
          }), this.emit("loaded", loaded2), this.queue = this.queue.filter(function(q2) {
            return !q2.done;
          });
        }
      }, {
        key: "read",
        value: function(lng2, ns, fcName) {
          var _this3 = this, tried = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, wait = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout, callback = arguments.length > 5 ? arguments[5] : void 0;
          if (!lng2.length)
            return callback(null, {});
          if (this.readingCalls >= this.maxParallelReads) {
            this.waitingReads.push({
              lng: lng2,
              ns,
              fcName,
              tried,
              wait,
              callback
            });
            return;
          }
          return this.readingCalls++, this.backend[fcName](lng2, ns, function(err, data2) {
            if (_this3.readingCalls--, _this3.waitingReads.length > 0) {
              var next = _this3.waitingReads.shift();
              _this3.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);
            }
            if (err && data2 && tried < _this3.maxRetries) {
              setTimeout(function() {
                _this3.read.call(_this3, lng2, ns, fcName, tried + 1, wait * 2, callback);
              }, wait);
              return;
            }
            callback(err, data2);
          });
        }
      }, {
        key: "prepareLoading",
        value: function(languages, namespaces) {
          var _this4 = this, options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, callback = arguments.length > 3 ? arguments[3] : void 0;
          if (!this.backend)
            return this.logger.warn("No backend was added via i18next.use. Will not load resources."), callback && callback();
          typeof languages == "string" && (languages = this.languageUtils.toResolveHierarchy(languages)), typeof namespaces == "string" && (namespaces = [namespaces]);
          var toLoad = this.queueLoad(languages, namespaces, options2, callback);
          if (!toLoad.toLoad.length)
            return toLoad.pending.length || callback(), null;
          toLoad.toLoad.forEach(function(name) {
            _this4.loadOne(name);
          });
        }
      }, {
        key: "load",
        value: function(languages, namespaces, callback) {
          this.prepareLoading(languages, namespaces, {}, callback);
        }
      }, {
        key: "reload",
        value: function(languages, namespaces, callback) {
          this.prepareLoading(languages, namespaces, {
            reload: !0
          }, callback);
        }
      }, {
        key: "loadOne",
        value: function(name) {
          var _this5 = this, prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", s3 = name.split("|"), lng2 = s3[0], ns = s3[1];
          this.read(lng2, ns, "read", void 0, void 0, function(err, data2) {
            err && _this5.logger.warn("".concat(prefix, "loading namespace ").concat(ns, " for language ").concat(lng2, " failed"), err), !err && data2 && _this5.logger.log("".concat(prefix, "loaded namespace ").concat(ns, " for language ").concat(lng2), data2), _this5.loaded(name, err, data2);
          });
        }
      }, {
        key: "saveMissing",
        value: function(languages, namespace, key2, fallbackValue, isUpdate) {
          var options2 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
          if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
            this.logger.warn('did not save key "'.concat(key2, '" as the namespace "').concat(namespace, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
            return;
          }
          key2 == null || key2 === "" || (this.backend && this.backend.create && this.backend.create(languages, namespace, key2, fallbackValue, null, _objectSpread$52(_objectSpread$52({}, options2), {}, {
            isUpdate
          })), !(!languages || !languages[0]) && this.store.addResource(languages[0], namespace, key2, fallbackValue));
        }
      }]), Connector3;
    }(EventEmitter3);
    function get2() {
      return {
        debug: !1,
        initImmediate: !0,
        ns: ["translation"],
        defaultNS: ["translation"],
        fallbackLng: ["dev"],
        fallbackNS: !1,
        supportedLngs: !1,
        nonExplicitSupportedLngs: !1,
        load: "all",
        preload: !1,
        simplifyPluralSuffix: !0,
        keySeparator: ".",
        nsSeparator: ":",
        pluralSeparator: "_",
        contextSeparator: "_",
        partialBundledLanguages: !1,
        saveMissing: !1,
        updateMissing: !1,
        saveMissingTo: "fallback",
        saveMissingPlurals: !0,
        missingKeyHandler: !1,
        missingInterpolationHandler: !1,
        postProcess: !1,
        postProcessPassResolved: !1,
        returnNull: !0,
        returnEmptyString: !0,
        returnObjects: !1,
        joinArrays: !1,
        returnedObjectHandler: !1,
        parseMissingKeyHandler: !1,
        appendNamespaceToMissingKey: !1,
        appendNamespaceToCIMode: !1,
        overloadTranslationOptionHandler: function(args) {
          var ret = {};
          if (_typeof__default.default(args[1]) === "object" && (ret = args[1]), typeof args[1] == "string" && (ret.defaultValue = args[1]), typeof args[2] == "string" && (ret.tDescription = args[2]), _typeof__default.default(args[2]) === "object" || _typeof__default.default(args[3]) === "object") {
            var options2 = args[3] || args[2];
            Object.keys(options2).forEach(function(key2) {
              ret[key2] = options2[key2];
            });
          }
          return ret;
        },
        interpolation: {
          escapeValue: !0,
          format: function(value2, _format, lng2, options2) {
            return value2;
          },
          prefix: "{{",
          suffix: "}}",
          formatSeparator: ",",
          unescapePrefix: "-",
          nestingPrefix: "$t(",
          nestingSuffix: ")",
          nestingOptionsSeparator: ",",
          maxReplaces: 1e3,
          skipOnVariables: !0
        }
      };
    }
    function transformOptions2(options2) {
      return typeof options2.ns == "string" && (options2.ns = [options2.ns]), typeof options2.fallbackLng == "string" && (options2.fallbackLng = [options2.fallbackLng]), typeof options2.fallbackNS == "string" && (options2.fallbackNS = [options2.fallbackNS]), options2.supportedLngs && options2.supportedLngs.indexOf("cimode") < 0 && (options2.supportedLngs = options2.supportedLngs.concat(["cimode"])), options2;
    }
    function ownKeys$62(object, enumerableOnly) {
      var keys2 = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    function _objectSpread$62(target) {
      for (var i3 = 1; i3 < arguments.length; i3++) {
        var source2 = arguments[i3] != null ? arguments[i3] : {};
        i3 % 2 ? ownKeys$62(Object(source2), !0).forEach(function(key2) {
          _defineProperty__default.default(target, key2, source2[key2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2)) : ownKeys$62(Object(source2)).forEach(function(key2) {
          Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source2, key2));
        });
      }
      return target;
    }
    function _createSuper$32(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$32();
      return function() {
        var Super = _getPrototypeOf__default.default(Derived), result2;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf__default.default(this).constructor;
          result2 = Reflect.construct(Super, arguments, NewTarget);
        } else
          result2 = Super.apply(this, arguments);
        return _possibleConstructorReturn__default.default(this, result2);
      };
    }
    function _isNativeReflectConstruct$32() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function noop4() {
    }
    function bindMemberFunctions2(inst) {
      var mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
      mems.forEach(function(mem) {
        typeof inst[mem] == "function" && (inst[mem] = inst[mem].bind(inst));
      });
    }
    var I18n2 = function(_EventEmitter) {
      _inherits__default.default(I18n3, _EventEmitter);
      var _super = _createSuper$32(I18n3);
      function I18n3() {
        var _this, options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, callback = arguments.length > 1 ? arguments[1] : void 0;
        if (_classCallCheck__default.default(this, I18n3), _this = _super.call(this), isIE102 && EventEmitter3.call(_assertThisInitialized__default.default(_this)), _this.options = transformOptions2(options2), _this.services = {}, _this.logger = baseLogger2, _this.modules = {
          external: []
        }, bindMemberFunctions2(_assertThisInitialized__default.default(_this)), callback && !_this.isInitialized && !options2.isClone) {
          if (!_this.options.initImmediate)
            return _this.init(options2, callback), _possibleConstructorReturn__default.default(_this, _assertThisInitialized__default.default(_this));
          setTimeout(function() {
            _this.init(options2, callback);
          }, 0);
        }
        return _this;
      }
      return _createClass__default.default(I18n3, [{
        key: "init",
        value: function() {
          var _this2 = this, options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, callback = arguments.length > 1 ? arguments[1] : void 0;
          typeof options2 == "function" && (callback = options2, options2 = {}), !options2.defaultNS && options2.defaultNS !== !1 && options2.ns && (typeof options2.ns == "string" ? options2.defaultNS = options2.ns : options2.ns.indexOf("translation") < 0 && (options2.defaultNS = options2.ns[0]));
          var defOpts = get2();
          this.options = _objectSpread$62(_objectSpread$62(_objectSpread$62({}, defOpts), this.options), transformOptions2(options2)), this.options.compatibilityAPI !== "v1" && (this.options.interpolation = _objectSpread$62(_objectSpread$62({}, defOpts.interpolation), this.options.interpolation)), options2.keySeparator !== void 0 && (this.options.userDefinedKeySeparator = options2.keySeparator), options2.nsSeparator !== void 0 && (this.options.userDefinedNsSeparator = options2.nsSeparator);
          function createClassOnDemand(ClassOrObject) {
            return ClassOrObject ? typeof ClassOrObject == "function" ? new ClassOrObject() : ClassOrObject : null;
          }
          if (!this.options.isClone) {
            this.modules.logger ? baseLogger2.init(createClassOnDemand(this.modules.logger), this.options) : baseLogger2.init(null, this.options);
            var formatter;
            this.modules.formatter ? formatter = this.modules.formatter : typeof Intl < "u" && (formatter = Formatter2);
            var lu = new LanguageUtil2(this.options);
            this.store = new ResourceStore2(this.options.resources, this.options);
            var s3 = this.services;
            s3.logger = baseLogger2, s3.resourceStore = this.store, s3.languageUtils = lu, s3.pluralResolver = new PluralResolver2(lu, {
              prepend: this.options.pluralSeparator,
              compatibilityJSON: this.options.compatibilityJSON,
              simplifyPluralSuffix: this.options.simplifyPluralSuffix
            }), formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format) && (s3.formatter = createClassOnDemand(formatter), s3.formatter.init(s3, this.options), this.options.interpolation.format = s3.formatter.format.bind(s3.formatter)), s3.interpolator = new Interpolator2(this.options), s3.utils = {
              hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
            }, s3.backendConnector = new Connector2(createClassOnDemand(this.modules.backend), s3.resourceStore, s3, this.options), s3.backendConnector.on("*", function(event2) {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
                args[_key - 1] = arguments[_key];
              _this2.emit.apply(_this2, [event2].concat(args));
            }), this.modules.languageDetector && (s3.languageDetector = createClassOnDemand(this.modules.languageDetector), s3.languageDetector.init(s3, this.options.detection, this.options)), this.modules.i18nFormat && (s3.i18nFormat = createClassOnDemand(this.modules.i18nFormat), s3.i18nFormat.init && s3.i18nFormat.init(this)), this.translator = new Translator2(this.services, this.options), this.translator.on("*", function(event2) {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)
                args[_key2 - 1] = arguments[_key2];
              _this2.emit.apply(_this2, [event2].concat(args));
            }), this.modules.external.forEach(function(m2) {
              m2.init && m2.init(_this2);
            });
          }
          if (this.format = this.options.interpolation.format, callback || (callback = noop4), this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
            var codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
            codes.length > 0 && codes[0] !== "dev" && (this.options.lng = codes[0]);
          }
          !this.services.languageDetector && !this.options.lng && this.logger.warn("init: no languageDetector is used and no lng is defined");
          var storeApi = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
          storeApi.forEach(function(fcName) {
            _this2[fcName] = function() {
              var _this2$store;
              return (_this2$store = _this2.store)[fcName].apply(_this2$store, arguments);
            };
          });
          var storeApiChained = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
          storeApiChained.forEach(function(fcName) {
            _this2[fcName] = function() {
              var _this2$store2;
              return (_this2$store2 = _this2.store)[fcName].apply(_this2$store2, arguments), _this2;
            };
          });
          var deferred = defer5(), load2 = function() {
            var finish = function(err, t4) {
              _this2.isInitialized && !_this2.initializedStoreOnce && _this2.logger.warn("init: i18next is already initialized. You should call init just once!"), _this2.isInitialized = !0, _this2.options.isClone || _this2.logger.log("initialized", _this2.options), _this2.emit("initialized", _this2.options), deferred.resolve(t4), callback(err, t4);
            };
            if (_this2.languages && _this2.options.compatibilityAPI !== "v1" && !_this2.isInitialized)
              return finish(null, _this2.t.bind(_this2));
            _this2.changeLanguage(_this2.options.lng, finish);
          };
          return this.options.resources || !this.options.initImmediate ? load2() : setTimeout(load2, 0), deferred;
        }
      }, {
        key: "loadResources",
        value: function(language) {
          var _this3 = this, callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop4, usedCallback = callback, usedLng = typeof language == "string" ? language : this.language;
          if (typeof language == "function" && (usedCallback = language), !this.options.resources || this.options.partialBundledLanguages) {
            if (usedLng && usedLng.toLowerCase() === "cimode")
              return usedCallback();
            var toLoad = [], append = function(lng2) {
              if (!!lng2) {
                var lngs = _this3.services.languageUtils.toResolveHierarchy(lng2);
                lngs.forEach(function(l2) {
                  toLoad.indexOf(l2) < 0 && toLoad.push(l2);
                });
              }
            };
            if (usedLng)
              append(usedLng);
            else {
              var fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
              fallbacks.forEach(function(l2) {
                return append(l2);
              });
            }
            this.options.preload && this.options.preload.forEach(function(l2) {
              return append(l2);
            }), this.services.backendConnector.load(toLoad, this.options.ns, function(e3) {
              !e3 && !_this3.resolvedLanguage && _this3.language && _this3.setResolvedLanguage(_this3.language), usedCallback(e3);
            });
          } else
            usedCallback(null);
        }
      }, {
        key: "reloadResources",
        value: function(lngs, ns, callback) {
          var deferred = defer5();
          return lngs || (lngs = this.languages), ns || (ns = this.options.ns), callback || (callback = noop4), this.services.backendConnector.reload(lngs, ns, function(err) {
            deferred.resolve(), callback(err);
          }), deferred;
        }
      }, {
        key: "use",
        value: function(module3) {
          if (!module3)
            throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
          if (!module3.type)
            throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
          return module3.type === "backend" && (this.modules.backend = module3), (module3.type === "logger" || module3.log && module3.warn && module3.error) && (this.modules.logger = module3), module3.type === "languageDetector" && (this.modules.languageDetector = module3), module3.type === "i18nFormat" && (this.modules.i18nFormat = module3), module3.type === "postProcessor" && postProcessor2.addPostProcessor(module3), module3.type === "formatter" && (this.modules.formatter = module3), module3.type === "3rdParty" && this.modules.external.push(module3), this;
        }
      }, {
        key: "setResolvedLanguage",
        value: function(l2) {
          if (!(!l2 || !this.languages) && !(["cimode", "dev"].indexOf(l2) > -1))
            for (var li = 0; li < this.languages.length; li++) {
              var lngInLngs = this.languages[li];
              if (!(["cimode", "dev"].indexOf(lngInLngs) > -1) && this.store.hasLanguageSomeTranslations(lngInLngs)) {
                this.resolvedLanguage = lngInLngs;
                break;
              }
            }
        }
      }, {
        key: "changeLanguage",
        value: function(lng2, callback) {
          var _this4 = this;
          this.isLanguageChangingTo = lng2;
          var deferred = defer5();
          this.emit("languageChanging", lng2);
          var setLngProps = function(l2) {
            _this4.language = l2, _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l2), _this4.resolvedLanguage = void 0, _this4.setResolvedLanguage(l2);
          }, done2 = function(err, l2) {
            l2 ? (setLngProps(l2), _this4.translator.changeLanguage(l2), _this4.isLanguageChangingTo = void 0, _this4.emit("languageChanged", l2), _this4.logger.log("languageChanged", l2)) : _this4.isLanguageChangingTo = void 0, deferred.resolve(function() {
              return _this4.t.apply(_this4, arguments);
            }), callback && callback(err, function() {
              return _this4.t.apply(_this4, arguments);
            });
          }, setLng = function(lngs) {
            !lng2 && !lngs && _this4.services.languageDetector && (lngs = []);
            var l2 = typeof lngs == "string" ? lngs : _this4.services.languageUtils.getBestMatchFromCodes(lngs);
            l2 && (_this4.language || setLngProps(l2), _this4.translator.language || _this4.translator.changeLanguage(l2), _this4.services.languageDetector && _this4.services.languageDetector.cacheUserLanguage(l2)), _this4.loadResources(l2, function(err) {
              done2(err, l2);
            });
          };
          return !lng2 && this.services.languageDetector && !this.services.languageDetector.async ? setLng(this.services.languageDetector.detect()) : !lng2 && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect(setLng) : setLng(lng2), deferred;
        }
      }, {
        key: "getFixedT",
        value: function(lng2, ns, keyPrefix) {
          var _this5 = this, fixedT = function fixedT2(key2, opts) {
            var options2;
            if (_typeof__default.default(opts) !== "object") {
              for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++)
                rest[_key3 - 2] = arguments[_key3];
              options2 = _this5.options.overloadTranslationOptionHandler([key2, opts].concat(rest));
            } else
              options2 = _objectSpread$62({}, opts);
            options2.lng = options2.lng || fixedT2.lng, options2.lngs = options2.lngs || fixedT2.lngs, options2.ns = options2.ns || fixedT2.ns, options2.keyPrefix = options2.keyPrefix || keyPrefix || fixedT2.keyPrefix;
            var keySeparator = _this5.options.keySeparator || ".", resultKey = options2.keyPrefix ? "".concat(options2.keyPrefix).concat(keySeparator).concat(key2) : key2;
            return _this5.t(resultKey, options2);
          };
          return typeof lng2 == "string" ? fixedT.lng = lng2 : fixedT.lngs = lng2, fixedT.ns = ns, fixedT.keyPrefix = keyPrefix, fixedT;
        }
      }, {
        key: "t",
        value: function() {
          var _this$translator;
          return this.translator && (_this$translator = this.translator).translate.apply(_this$translator, arguments);
        }
      }, {
        key: "exists",
        value: function() {
          var _this$translator2;
          return this.translator && (_this$translator2 = this.translator).exists.apply(_this$translator2, arguments);
        }
      }, {
        key: "setDefaultNamespace",
        value: function(ns) {
          this.options.defaultNS = ns;
        }
      }, {
        key: "hasLoadedNamespace",
        value: function(ns) {
          var _this6 = this, options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          if (!this.isInitialized)
            return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages), !1;
          if (!this.languages || !this.languages.length)
            return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages), !1;
          var lng2 = this.resolvedLanguage || this.languages[0], fallbackLng = this.options ? this.options.fallbackLng : !1, lastLng = this.languages[this.languages.length - 1];
          if (lng2.toLowerCase() === "cimode")
            return !0;
          var loadNotPending = function(l2, n3) {
            var loadState = _this6.services.backendConnector.state["".concat(l2, "|").concat(n3)];
            return loadState === -1 || loadState === 2;
          };
          if (options2.precheck) {
            var preResult = options2.precheck(this, loadNotPending);
            if (preResult !== void 0)
              return preResult;
          }
          return !!(this.hasResourceBundle(lng2, ns) || !this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages || loadNotPending(lng2, ns) && (!fallbackLng || loadNotPending(lastLng, ns)));
        }
      }, {
        key: "loadNamespaces",
        value: function(ns, callback) {
          var _this7 = this, deferred = defer5();
          return this.options.ns ? (typeof ns == "string" && (ns = [ns]), ns.forEach(function(n3) {
            _this7.options.ns.indexOf(n3) < 0 && _this7.options.ns.push(n3);
          }), this.loadResources(function(err) {
            deferred.resolve(), callback && callback(err);
          }), deferred) : (callback && callback(), Promise.resolve());
        }
      }, {
        key: "loadLanguages",
        value: function(lngs, callback) {
          var deferred = defer5();
          typeof lngs == "string" && (lngs = [lngs]);
          var preloaded = this.options.preload || [], newLngs = lngs.filter(function(lng2) {
            return preloaded.indexOf(lng2) < 0;
          });
          return newLngs.length ? (this.options.preload = preloaded.concat(newLngs), this.loadResources(function(err) {
            deferred.resolve(), callback && callback(err);
          }), deferred) : (callback && callback(), Promise.resolve());
        }
      }, {
        key: "dir",
        value: function(lng2) {
          if (lng2 || (lng2 = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language)), !lng2)
            return "rtl";
          var rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"];
          return rtlLngs.indexOf(this.services.languageUtils.getLanguagePartFromCode(lng2)) > -1 || lng2.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
        }
      }, {
        key: "cloneInstance",
        value: function() {
          var _this8 = this, options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop4, mergedOptions = _objectSpread$62(_objectSpread$62(_objectSpread$62({}, this.options), options2), {
            isClone: !0
          }), clone = new I18n3(mergedOptions);
          (options2.debug !== void 0 || options2.prefix !== void 0) && (clone.logger = clone.logger.clone(options2));
          var membersToCopy = ["store", "services", "language"];
          return membersToCopy.forEach(function(m2) {
            clone[m2] = _this8[m2];
          }), clone.services = _objectSpread$62({}, this.services), clone.services.utils = {
            hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
          }, clone.translator = new Translator2(clone.services, clone.options), clone.translator.on("*", function(event2) {
            for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++)
              args[_key4 - 1] = arguments[_key4];
            clone.emit.apply(clone, [event2].concat(args));
          }), clone.init(mergedOptions, callback), clone.translator.options = clone.options, clone.translator.backendConnector.services.utils = {
            hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
          }, clone;
        }
      }, {
        key: "toJSON",
        value: function() {
          return {
            options: this.options,
            store: this.store,
            language: this.language,
            languages: this.languages,
            resolvedLanguage: this.resolvedLanguage
          };
        }
      }]), I18n3;
    }(EventEmitter3);
    _defineProperty__default.default(I18n2, "createInstance", function() {
      var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, callback = arguments.length > 1 ? arguments[1] : void 0;
      return new I18n2(options2, callback);
    });
    var instance2 = I18n2.createInstance();
    instance2.createInstance = I18n2.createInstance;
    module2.exports = instance2;
  }
});

// node_modules/intl-parse-accept-language/dist/intl-parse-accept-language.esm.js
var intl_parse_accept_language_esm_exports = {};
__export(intl_parse_accept_language_esm_exports, {
  parseAcceptLanguage: () => parseAcceptLanguage
});
var defaultValidate, parseAcceptLanguage, init_intl_parse_accept_language_esm = __esm({
  "node_modules/intl-parse-accept-language/dist/intl-parse-accept-language.esm.js"() {
    defaultValidate = function(locale) {
      return locale;
    }, parseAcceptLanguage = function(languageHeaderValue, options2) {
      if (options2 === void 0 && (options2 = {}), !languageHeaderValue)
        return [];
      var _options = options2, _options$ignoreWildca = _options.ignoreWildcard, ignoreWildcard = _options$ignoreWildca === void 0 ? !0 : _options$ignoreWildca, _options$validate = _options.validate, validate = _options$validate === void 0 ? defaultValidate : _options$validate;
      return languageHeaderValue.split(",").map(function(lang) {
        var _lang$split = lang.split(";"), locale = _lang$split[0], _lang$split$ = _lang$split[1], q2 = _lang$split$ === void 0 ? "q=1" : _lang$split$, trimmedLocale = locale.trim(), numQ = Number(q2.replace(/q ?=/, ""));
        return isNaN(numQ) ? [0, trimmedLocale] : [numQ, trimmedLocale];
      }).sort(function(_ref, _ref2) {
        var q1 = _ref[0], q2 = _ref2[0];
        return q2 - q1;
      }).flatMap(function(_ref3) {
        var locale = _ref3[1];
        if (locale === "*" && ignoreWildcard)
          return [];
        try {
          return validate(locale) || [];
        } catch {
          return [];
        }
      });
    };
  }
});

// node_modules/remix-i18next/build/lib/get-client-locales.js
var require_get_client_locales = __commonJS({
  "node_modules/remix-i18next/build/lib/get-client-locales.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.getClientLocales = void 0;
    var intl_parse_accept_language_1 = (init_intl_parse_accept_language_esm(), __toCommonJS(intl_parse_accept_language_esm_exports));
    function getClientLocales(requestOrHeaders) {
      let acceptLanguage = getHeaders(requestOrHeaders).get("Accept-Language");
      if (!acceptLanguage)
        return;
      let locales = (0, intl_parse_accept_language_1.parseAcceptLanguage)(acceptLanguage, {
        validate: Intl.DateTimeFormat.supportedLocalesOf,
        ignoreWildcard: !0
      });
      if (locales.length !== 0)
        return locales.length === 1 ? locales[0] : locales;
    }
    exports.getClientLocales = getClientLocales;
    function getHeaders(requestOrHeaders) {
      return requestOrHeaders instanceof Request ? requestOrHeaders.headers : requestOrHeaders;
    }
  }
});

// node_modules/remix-i18next/build/server.js
var require_server2 = __commonJS({
  "node_modules/remix-i18next/build/server.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.RemixI18Next = void 0;
    var accept_language_parser_1 = require_accept_language_parser(), i18next_1 = require_i18next(), get_client_locales_1 = require_get_client_locales(), RemixI18Next2 = class {
      constructor(options2) {
        this.options = options2, this.detector = new LanguageDetector(this.options.detection);
      }
      async getLocale(request) {
        return this.detector.detect(request);
      }
      getRouteNamespaces(context) {
        let namespaces = Object.values(context.routeModules).filter((route) => {
          var _a;
          return ((_a = route.handle) === null || _a === void 0 ? void 0 : _a.i18n) !== void 0;
        }).flatMap((route) => {
          let i18n = route.handle.i18n;
          return typeof i18n == "string" ? i18n : Array.isArray(i18n) ? i18n.every((ns) => typeof ns == "string") ? i18n : [] : [];
        });
        return [...new Set(namespaces)];
      }
      async getFixedT(requestOrLocale, namespaces, options2 = {}) {
        var _a;
        (!namespaces || namespaces.length === 0) && (namespaces = ((_a = this.options.i18next) === null || _a === void 0 ? void 0 : _a.defaultNS) || "translation");
        let [instance2, locale] = await Promise.all([
          this.createInstance({
            ...this.options.i18next,
            ...options2,
            fallbackNS: namespaces,
            defaultNS: typeof namespaces == "string" ? namespaces : namespaces[0]
          }),
          typeof requestOrLocale == "string" ? requestOrLocale : this.getLocale(requestOrLocale)
        ]);
        return await instance2.changeLanguage(locale), await instance2.loadNamespaces(namespaces), instance2.getFixedT(locale, namespaces);
      }
      async createInstance(options2 = {}) {
        let instance2 = (0, i18next_1.createInstance)();
        return this.options.backend && (instance2 = instance2.use(this.options.backend)), await instance2.init(options2), instance2;
      }
    };
    exports.RemixI18Next = RemixI18Next2;
    var LanguageDetector = class {
      constructor(options2) {
        this.options = options2, this.isSessionOnly(options2), this.isCookieOnly(options2);
      }
      isSessionOnly(options2) {
        var _a;
        if (((_a = options2.order) === null || _a === void 0 ? void 0 : _a.length) === 1 && options2.order[0] === "session" && !options2.sessionStorage)
          throw new Error("You need a sessionStorage if you want to only get the locale from the session");
      }
      isCookieOnly(options2) {
        var _a;
        if (((_a = options2.order) === null || _a === void 0 ? void 0 : _a.length) === 1 && options2.order[0] === "cookie" && !options2.cookie)
          throw new Error("You need a cookie if you want to only get the locale from the cookie");
      }
      async detect(request) {
        var _a;
        let order = (_a = this.options.order) !== null && _a !== void 0 ? _a : [
          "searchParams",
          "cookie",
          "session",
          "header"
        ];
        for (let method of order) {
          let locale = null;
          if (method === "searchParams" && (locale = await this.fromSearchParams(request)), method === "cookie" && (locale = await this.fromCookie(request)), method === "session" && (locale = await this.fromSessionStorage(request)), method === "header" && (locale = await this.fromHeader(request)), locale)
            return locale;
        }
        return this.options.fallbackLanguage;
      }
      async fromSearchParams(request) {
        let url = new URL(request.url);
        return url.searchParams.has("lng") ? this.fromSupported(url.searchParams.get("lng")) : null;
      }
      async fromCookie(request) {
        var _a;
        if (!this.options.cookie)
          return null;
        let lng2 = (_a = await this.options.cookie.parse(request.headers.get("Cookie"))) !== null && _a !== void 0 ? _a : "";
        return lng2 ? this.fromSupported(lng2) : null;
      }
      async fromSessionStorage(request) {
        var _a;
        if (!this.options.sessionStorage)
          return null;
        let lng2 = (await this.options.sessionStorage.getSession(request.headers.get("Cookie"))).get((_a = this.options.sessionKey) !== null && _a !== void 0 ? _a : "lng");
        return lng2 ? this.fromSupported(lng2) : null;
      }
      async fromHeader(request) {
        let locales = (0, get_client_locales_1.getClientLocales)(request);
        return locales ? Array.isArray(locales) ? this.fromSupported(locales.join(",")) : this.fromSupported(locales) : null;
      }
      fromSupported(language) {
        return (0, accept_language_parser_1.pick)(this.options.supportedLanguages, language ?? this.options.fallbackLanguage, { loose: !1 }) || (0, accept_language_parser_1.pick)(this.options.supportedLanguages, language ?? this.options.fallbackLanguage, { loose: !0 });
      }
    };
  }
});

// node_modules/remix-i18next/build/index.js
var require_build = __commonJS({
  "node_modules/remix-i18next/build/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      k22 === void 0 && (k22 = k2);
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) && (desc = { enumerable: !0, get: function() {
        return m2[k2];
      } }), Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      k22 === void 0 && (k22 = k2), o2[k22] = m2[k2];
    }), __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p in m2)
        p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p) && __createBinding(exports2, m2, p);
    };
    Object.defineProperty(exports, "__esModule", { value: !0 });
    __exportStar(require_client(), exports);
    __exportStar(require_react2(), exports);
    __exportStar(require_server2(), exports);
  }
});

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    (function() {
      "use strict";
      var REACT_ELEMENT_TYPE = Symbol.for("react.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_PROVIDER_TYPE = Symbol.for("react.provider"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_SERVER_CONTEXT_TYPE = Symbol.for("react.server_context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"), enableScopeAPI = !1, enableCacheElement = !1, enableTransitionTracing = !1, enableLegacyHidden = !1, enableDebugTracing = !1, REACT_MODULE_REFERENCE;
      REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
      function isValidElementType(type2) {
        return !!(typeof type2 == "string" || typeof type2 == "function" || type2 === REACT_FRAGMENT_TYPE || type2 === REACT_PROFILER_TYPE || enableDebugTracing || type2 === REACT_STRICT_MODE_TYPE || type2 === REACT_SUSPENSE_TYPE || type2 === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type2 === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing || typeof type2 == "object" && type2 !== null && (type2.$$typeof === REACT_LAZY_TYPE || type2.$$typeof === REACT_MEMO_TYPE || type2.$$typeof === REACT_PROVIDER_TYPE || type2.$$typeof === REACT_CONTEXT_TYPE || type2.$$typeof === REACT_FORWARD_REF_TYPE || type2.$$typeof === REACT_MODULE_REFERENCE || type2.getModuleId !== void 0));
      }
      function typeOf(object) {
        if (typeof object == "object" && object !== null) {
          var $$typeof = object.$$typeof;
          switch ($$typeof) {
            case REACT_ELEMENT_TYPE:
              var type2 = object.type;
              switch (type2) {
                case REACT_FRAGMENT_TYPE:
                case REACT_PROFILER_TYPE:
                case REACT_STRICT_MODE_TYPE:
                case REACT_SUSPENSE_TYPE:
                case REACT_SUSPENSE_LIST_TYPE:
                  return type2;
                default:
                  var $$typeofType = type2 && type2.$$typeof;
                  switch ($$typeofType) {
                    case REACT_SERVER_CONTEXT_TYPE:
                    case REACT_CONTEXT_TYPE:
                    case REACT_FORWARD_REF_TYPE:
                    case REACT_LAZY_TYPE:
                    case REACT_MEMO_TYPE:
                    case REACT_PROVIDER_TYPE:
                      return $$typeofType;
                    default:
                      return $$typeof;
                  }
              }
            case REACT_PORTAL_TYPE:
              return $$typeof;
          }
        }
      }
      var ContextConsumer = REACT_CONTEXT_TYPE, ContextProvider = REACT_PROVIDER_TYPE, Element2 = REACT_ELEMENT_TYPE, ForwardRef = REACT_FORWARD_REF_TYPE, Fragment8 = REACT_FRAGMENT_TYPE, Lazy = REACT_LAZY_TYPE, Memo = REACT_MEMO_TYPE, Portal = REACT_PORTAL_TYPE, Profiler = REACT_PROFILER_TYPE, StrictMode = REACT_STRICT_MODE_TYPE, Suspense2 = REACT_SUSPENSE_TYPE, SuspenseList = REACT_SUSPENSE_LIST_TYPE, hasWarnedAboutDeprecatedIsAsyncMode = !1, hasWarnedAboutDeprecatedIsConcurrentMode = !1;
      function isAsyncMode(object) {
        return hasWarnedAboutDeprecatedIsAsyncMode || (hasWarnedAboutDeprecatedIsAsyncMode = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.")), !1;
      }
      function isConcurrentMode(object) {
        return hasWarnedAboutDeprecatedIsConcurrentMode || (hasWarnedAboutDeprecatedIsConcurrentMode = !0, console.warn("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.")), !1;
      }
      function isContextConsumer(object) {
        return typeOf(object) === REACT_CONTEXT_TYPE;
      }
      function isContextProvider(object) {
        return typeOf(object) === REACT_PROVIDER_TYPE;
      }
      function isElement(object) {
        return typeof object == "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      function isForwardRef(object) {
        return typeOf(object) === REACT_FORWARD_REF_TYPE;
      }
      function isFragment(object) {
        return typeOf(object) === REACT_FRAGMENT_TYPE;
      }
      function isLazy(object) {
        return typeOf(object) === REACT_LAZY_TYPE;
      }
      function isMemo(object) {
        return typeOf(object) === REACT_MEMO_TYPE;
      }
      function isPortal(object) {
        return typeOf(object) === REACT_PORTAL_TYPE;
      }
      function isProfiler(object) {
        return typeOf(object) === REACT_PROFILER_TYPE;
      }
      function isStrictMode(object) {
        return typeOf(object) === REACT_STRICT_MODE_TYPE;
      }
      function isSuspense(object) {
        return typeOf(object) === REACT_SUSPENSE_TYPE;
      }
      function isSuspenseList(object) {
        return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
      }
      exports.ContextConsumer = ContextConsumer, exports.ContextProvider = ContextProvider, exports.Element = Element2, exports.ForwardRef = ForwardRef, exports.Fragment = Fragment8, exports.Lazy = Lazy, exports.Memo = Memo, exports.Portal = Portal, exports.Profiler = Profiler, exports.StrictMode = StrictMode, exports.Suspense = Suspense2, exports.SuspenseList = SuspenseList, exports.isAsyncMode = isAsyncMode, exports.isConcurrentMode = isConcurrentMode, exports.isContextConsumer = isContextConsumer, exports.isContextProvider = isContextProvider, exports.isElement = isElement, exports.isForwardRef = isForwardRef, exports.isFragment = isFragment, exports.isLazy = isLazy, exports.isMemo = isMemo, exports.isPortal = isPortal, exports.isProfiler = isProfiler, exports.isStrictMode = isStrictMode, exports.isSuspense = isSuspense, exports.isSuspenseList = isSuspenseList, exports.isValidElementType = isValidElementType, exports.typeOf = typeOf;
    })();
  }
});

// node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/react-is/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_react_is_development();
  }
});

// node_modules/shallowequal/index.js
var require_shallowequal = __commonJS({
  "node_modules/shallowequal/index.js"(exports, module2) {
    module2.exports = function(objA, objB, compare3, compareContext) {
      var ret = compare3 ? compare3.call(compareContext, objA, objB) : void 0;
      if (ret !== void 0)
        return !!ret;
      if (objA === objB)
        return !0;
      if (typeof objA != "object" || !objA || typeof objB != "object" || !objB)
        return !1;
      var keysA = Object.keys(objA), keysB = Object.keys(objB);
      if (keysA.length !== keysB.length)
        return !1;
      for (var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB), idx = 0; idx < keysA.length; idx++) {
        var key2 = keysA[idx];
        if (!bHasOwnProperty(key2))
          return !1;
        var valueA = objA[key2], valueB = objB[key2];
        if (ret = compare3 ? compare3.call(compareContext, valueA, valueB, key2) : void 0, ret === !1 || ret === void 0 && valueA !== valueB)
          return !1;
      }
      return !0;
    };
  }
});

// node_modules/@emotion/memoize/dist/emotion-memoize.cjs.dev.js
var require_emotion_memoize_cjs_dev = __commonJS({
  "node_modules/@emotion/memoize/dist/emotion-memoize.cjs.dev.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    function memoize2(fn) {
      var cache = /* @__PURE__ */ Object.create(null);
      return function(arg) {
        return cache[arg] === void 0 && (cache[arg] = fn(arg)), cache[arg];
      };
    }
    exports.default = memoize2;
  }
});

// node_modules/@emotion/memoize/dist/emotion-memoize.cjs.js
var require_emotion_memoize_cjs = __commonJS({
  "node_modules/@emotion/memoize/dist/emotion-memoize.cjs.js"(exports, module2) {
    "use strict";
    module2.exports = require_emotion_memoize_cjs_dev();
  }
});

// node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.cjs.dev.js
var require_emotion_is_prop_valid_cjs_dev = __commonJS({
  "node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.cjs.dev.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var memoize2 = require_emotion_memoize_cjs();
    function _interopDefault(e3) {
      return e3 && e3.__esModule ? e3 : { default: e3 };
    }
    var memoize__default = /* @__PURE__ */ _interopDefault(memoize2), reactPropsRegex2 = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, isPropValid = /* @__PURE__ */ memoize__default.default(
      function(prop) {
        return reactPropsRegex2.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
      }
    );
    exports.default = isPropValid;
  }
});

// node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.cjs.js
var require_emotion_is_prop_valid_cjs = __commonJS({
  "node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.cjs.js"(exports, module2) {
    "use strict";
    module2.exports = require_emotion_is_prop_valid_cjs_dev();
  }
});

// node_modules/hoist-non-react-statics/node_modules/react-is/cjs/react-is.development.js
var require_react_is_development2 = __commonJS({
  "node_modules/hoist-non-react-statics/node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    (function() {
      "use strict";
      var hasSymbol = typeof Symbol == "function" && Symbol.for, REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103, REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106, REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107, REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108, REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114, REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109, REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110, REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111, REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111, REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112, REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113, REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120, REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115, REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116, REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121, REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117, REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118, REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
      function isValidElementType(type2) {
        return typeof type2 == "string" || typeof type2 == "function" || type2 === REACT_FRAGMENT_TYPE || type2 === REACT_CONCURRENT_MODE_TYPE || type2 === REACT_PROFILER_TYPE || type2 === REACT_STRICT_MODE_TYPE || type2 === REACT_SUSPENSE_TYPE || type2 === REACT_SUSPENSE_LIST_TYPE || typeof type2 == "object" && type2 !== null && (type2.$$typeof === REACT_LAZY_TYPE || type2.$$typeof === REACT_MEMO_TYPE || type2.$$typeof === REACT_PROVIDER_TYPE || type2.$$typeof === REACT_CONTEXT_TYPE || type2.$$typeof === REACT_FORWARD_REF_TYPE || type2.$$typeof === REACT_FUNDAMENTAL_TYPE || type2.$$typeof === REACT_RESPONDER_TYPE || type2.$$typeof === REACT_SCOPE_TYPE || type2.$$typeof === REACT_BLOCK_TYPE);
      }
      function typeOf(object) {
        if (typeof object == "object" && object !== null) {
          var $$typeof = object.$$typeof;
          switch ($$typeof) {
            case REACT_ELEMENT_TYPE:
              var type2 = object.type;
              switch (type2) {
                case REACT_ASYNC_MODE_TYPE:
                case REACT_CONCURRENT_MODE_TYPE:
                case REACT_FRAGMENT_TYPE:
                case REACT_PROFILER_TYPE:
                case REACT_STRICT_MODE_TYPE:
                case REACT_SUSPENSE_TYPE:
                  return type2;
                default:
                  var $$typeofType = type2 && type2.$$typeof;
                  switch ($$typeofType) {
                    case REACT_CONTEXT_TYPE:
                    case REACT_FORWARD_REF_TYPE:
                    case REACT_LAZY_TYPE:
                    case REACT_MEMO_TYPE:
                    case REACT_PROVIDER_TYPE:
                      return $$typeofType;
                    default:
                      return $$typeof;
                  }
              }
            case REACT_PORTAL_TYPE:
              return $$typeof;
          }
        }
      }
      var AsyncMode = REACT_ASYNC_MODE_TYPE, ConcurrentMode = REACT_CONCURRENT_MODE_TYPE, ContextConsumer = REACT_CONTEXT_TYPE, ContextProvider = REACT_PROVIDER_TYPE, Element2 = REACT_ELEMENT_TYPE, ForwardRef = REACT_FORWARD_REF_TYPE, Fragment8 = REACT_FRAGMENT_TYPE, Lazy = REACT_LAZY_TYPE, Memo = REACT_MEMO_TYPE, Portal = REACT_PORTAL_TYPE, Profiler = REACT_PROFILER_TYPE, StrictMode = REACT_STRICT_MODE_TYPE, Suspense2 = REACT_SUSPENSE_TYPE, hasWarnedAboutDeprecatedIsAsyncMode = !1;
      function isAsyncMode(object) {
        return hasWarnedAboutDeprecatedIsAsyncMode || (hasWarnedAboutDeprecatedIsAsyncMode = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
      }
      function isConcurrentMode(object) {
        return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
      }
      function isContextConsumer(object) {
        return typeOf(object) === REACT_CONTEXT_TYPE;
      }
      function isContextProvider(object) {
        return typeOf(object) === REACT_PROVIDER_TYPE;
      }
      function isElement(object) {
        return typeof object == "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      function isForwardRef(object) {
        return typeOf(object) === REACT_FORWARD_REF_TYPE;
      }
      function isFragment(object) {
        return typeOf(object) === REACT_FRAGMENT_TYPE;
      }
      function isLazy(object) {
        return typeOf(object) === REACT_LAZY_TYPE;
      }
      function isMemo(object) {
        return typeOf(object) === REACT_MEMO_TYPE;
      }
      function isPortal(object) {
        return typeOf(object) === REACT_PORTAL_TYPE;
      }
      function isProfiler(object) {
        return typeOf(object) === REACT_PROFILER_TYPE;
      }
      function isStrictMode(object) {
        return typeOf(object) === REACT_STRICT_MODE_TYPE;
      }
      function isSuspense(object) {
        return typeOf(object) === REACT_SUSPENSE_TYPE;
      }
      exports.AsyncMode = AsyncMode, exports.ConcurrentMode = ConcurrentMode, exports.ContextConsumer = ContextConsumer, exports.ContextProvider = ContextProvider, exports.Element = Element2, exports.ForwardRef = ForwardRef, exports.Fragment = Fragment8, exports.Lazy = Lazy, exports.Memo = Memo, exports.Portal = Portal, exports.Profiler = Profiler, exports.StrictMode = StrictMode, exports.Suspense = Suspense2, exports.isAsyncMode = isAsyncMode, exports.isConcurrentMode = isConcurrentMode, exports.isContextConsumer = isContextConsumer, exports.isContextProvider = isContextProvider, exports.isElement = isElement, exports.isForwardRef = isForwardRef, exports.isFragment = isFragment, exports.isLazy = isLazy, exports.isMemo = isMemo, exports.isPortal = isPortal, exports.isProfiler = isProfiler, exports.isStrictMode = isStrictMode, exports.isSuspense = isSuspense, exports.isValidElementType = isValidElementType, exports.typeOf = typeOf;
    })();
  }
});

// node_modules/hoist-non-react-statics/node_modules/react-is/index.js
var require_react_is2 = __commonJS({
  "node_modules/hoist-non-react-statics/node_modules/react-is/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_react_is_development2();
  }
});

// node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js
var require_hoist_non_react_statics_cjs = __commonJS({
  "node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js"(exports, module2) {
    "use strict";
    var reactIs = require_react_is2(), REACT_STATICS = {
      childContextTypes: !0,
      contextType: !0,
      contextTypes: !0,
      defaultProps: !0,
      displayName: !0,
      getDefaultProps: !0,
      getDerivedStateFromError: !0,
      getDerivedStateFromProps: !0,
      mixins: !0,
      propTypes: !0,
      type: !0
    }, KNOWN_STATICS = {
      name: !0,
      length: !0,
      prototype: !0,
      caller: !0,
      callee: !0,
      arguments: !0,
      arity: !0
    }, FORWARD_REF_STATICS = {
      $$typeof: !0,
      render: !0,
      defaultProps: !0,
      displayName: !0,
      propTypes: !0
    }, MEMO_STATICS = {
      $$typeof: !0,
      compare: !0,
      defaultProps: !0,
      displayName: !0,
      propTypes: !0,
      type: !0
    }, TYPE_STATICS = {};
    TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
    TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
    function getStatics(component) {
      return reactIs.isMemo(component) ? MEMO_STATICS : TYPE_STATICS[component.$$typeof] || REACT_STATICS;
    }
    var defineProperty = Object.defineProperty, getOwnPropertyNames = Object.getOwnPropertyNames, getOwnPropertySymbols = Object.getOwnPropertySymbols, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor, getPrototypeOf = Object.getPrototypeOf, objectPrototype = Object.prototype;
    function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
      if (typeof sourceComponent != "string") {
        if (objectPrototype) {
          var inheritedComponent = getPrototypeOf(sourceComponent);
          inheritedComponent && inheritedComponent !== objectPrototype && hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
        }
        var keys2 = getOwnPropertyNames(sourceComponent);
        getOwnPropertySymbols && (keys2 = keys2.concat(getOwnPropertySymbols(sourceComponent)));
        for (var targetStatics = getStatics(targetComponent), sourceStatics = getStatics(sourceComponent), i3 = 0; i3 < keys2.length; ++i3) {
          var key2 = keys2[i3];
          if (!KNOWN_STATICS[key2] && !(blacklist && blacklist[key2]) && !(sourceStatics && sourceStatics[key2]) && !(targetStatics && targetStatics[key2])) {
            var descriptor = getOwnPropertyDescriptor(sourceComponent, key2);
            try {
              defineProperty(targetComponent, key2, descriptor);
            } catch {
            }
          }
        }
      }
      return targetComponent;
    }
    module2.exports = hoistNonReactStatics;
  }
});

// node-modules-polyfills:events
function EventHandlers() {
}
function EventEmitter() {
  EventEmitter.init.call(this);
}
function $getMaxListeners(that) {
  return that._maxListeners === void 0 ? EventEmitter.defaultMaxListeners : that._maxListeners;
}
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else
    for (var len = handler.length, listeners2 = arrayClone(handler, len), i3 = 0; i3 < len; ++i3)
      listeners2[i3].call(self);
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else
    for (var len = handler.length, listeners2 = arrayClone(handler, len), i3 = 0; i3 < len; ++i3)
      listeners2[i3].call(self, arg1);
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else
    for (var len = handler.length, listeners2 = arrayClone(handler, len), i3 = 0; i3 < len; ++i3)
      listeners2[i3].call(self, arg1, arg2);
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else
    for (var len = handler.length, listeners2 = arrayClone(handler, len), i3 = 0; i3 < len; ++i3)
      listeners2[i3].call(self, arg1, arg2, arg3);
}
function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else
    for (var len = handler.length, listeners2 = arrayClone(handler, len), i3 = 0; i3 < len; ++i3)
      listeners2[i3].apply(self, args);
}
function _addListener(target, type2, listener, prepend) {
  var m2, events2, existing;
  if (typeof listener != "function")
    throw new TypeError('"listener" argument must be a function');
  if (events2 = target._events, events2 ? (events2.newListener && (target.emit(
    "newListener",
    type2,
    listener.listener ? listener.listener : listener
  ), events2 = target._events), existing = events2[type2]) : (events2 = target._events = new EventHandlers(), target._eventsCount = 0), !existing)
    existing = events2[type2] = listener, ++target._eventsCount;
  else if (typeof existing == "function" ? existing = events2[type2] = prepend ? [listener, existing] : [existing, listener] : prepend ? existing.unshift(listener) : existing.push(listener), !existing.warned && (m2 = $getMaxListeners(target), m2 && m2 > 0 && existing.length > m2)) {
    existing.warned = !0;
    var w2 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type2 + " listeners added. Use emitter.setMaxListeners() to increase limit");
    w2.name = "MaxListenersExceededWarning", w2.emitter = target, w2.type = type2, w2.count = existing.length, emitWarning(w2);
  }
  return target;
}
function emitWarning(e3) {
  typeof console.warn == "function" ? console.warn(e3) : console.log(e3);
}
function _onceWrap(target, type2, listener) {
  var fired = !1;
  function g2() {
    target.removeListener(type2, g2), fired || (fired = !0, listener.apply(target, arguments));
  }
  return g2.listener = listener, g2;
}
function listenerCount(type2) {
  var events2 = this._events;
  if (events2) {
    var evlistener = events2[type2];
    if (typeof evlistener == "function")
      return 1;
    if (evlistener)
      return evlistener.length;
  }
  return 0;
}
function spliceOne(list, index2) {
  for (var i3 = index2, k2 = i3 + 1, n3 = list.length; k2 < n3; i3 += 1, k2 += 1)
    list[i3] = list[k2];
  list.pop();
}
function arrayClone(arr2, i3) {
  for (var copy3 = new Array(i3); i3--; )
    copy3[i3] = arr2[i3];
  return copy3;
}
function unwrapListeners(arr2) {
  for (var ret = new Array(arr2.length), i3 = 0; i3 < ret.length; ++i3)
    ret[i3] = arr2[i3].listener || arr2[i3];
  return ret;
}
var domain, events_default, init_events = __esm({
  "node-modules-polyfills:events"() {
    "use strict";
    EventHandlers.prototype = /* @__PURE__ */ Object.create(null);
    events_default = EventEmitter;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.usingDomains = !1;
    EventEmitter.prototype.domain = void 0;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._maxListeners = void 0;
    EventEmitter.defaultMaxListeners = 10;
    EventEmitter.init = function() {
      this.domain = null, EventEmitter.usingDomains && domain.active && !(this instanceof domain.Domain) && (this.domain = domain.active), (!this._events || this._events === Object.getPrototypeOf(this)._events) && (this._events = new EventHandlers(), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function(n3) {
      if (typeof n3 != "number" || n3 < 0 || isNaN(n3))
        throw new TypeError('"n" argument must be a positive number');
      return this._maxListeners = n3, this;
    };
    EventEmitter.prototype.getMaxListeners = function() {
      return $getMaxListeners(this);
    };
    EventEmitter.prototype.emit = function(type2) {
      var er, handler, len, args, i3, events2, domain2, needDomainExit = !1, doError = type2 === "error";
      if (events2 = this._events, events2)
        doError = doError && events2.error == null;
      else if (!doError)
        return !1;
      if (domain2 = this.domain, doError) {
        if (er = arguments[1], domain2)
          er || (er = new Error('Uncaught, unspecified "error" event')), er.domainEmitter = this, er.domain = domain2, er.domainThrown = !1, domain2.emit("error", er);
        else {
          if (er instanceof Error)
            throw er;
          var err = new Error('Uncaught, unspecified "error" event. (' + er + ")");
          throw err.context = er, err;
        }
        return !1;
      }
      if (handler = events2[type2], !handler)
        return !1;
      var isFn = typeof handler == "function";
      switch (len = arguments.length, len) {
        case 1:
          emitNone(handler, isFn, this);
          break;
        case 2:
          emitOne(handler, isFn, this, arguments[1]);
          break;
        case 3:
          emitTwo(handler, isFn, this, arguments[1], arguments[2]);
          break;
        case 4:
          emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
          break;
        default:
          for (args = new Array(len - 1), i3 = 1; i3 < len; i3++)
            args[i3 - 1] = arguments[i3];
          emitMany(handler, isFn, this, args);
      }
      return needDomainExit && domain2.exit(), !0;
    };
    EventEmitter.prototype.addListener = function(type2, listener) {
      return _addListener(this, type2, listener, !1);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function(type2, listener) {
      return _addListener(this, type2, listener, !0);
    };
    EventEmitter.prototype.once = function(type2, listener) {
      if (typeof listener != "function")
        throw new TypeError('"listener" argument must be a function');
      return this.on(type2, _onceWrap(this, type2, listener)), this;
    };
    EventEmitter.prototype.prependOnceListener = function(type2, listener) {
      if (typeof listener != "function")
        throw new TypeError('"listener" argument must be a function');
      return this.prependListener(type2, _onceWrap(this, type2, listener)), this;
    };
    EventEmitter.prototype.removeListener = function(type2, listener) {
      var list, events2, position, i3, originalListener;
      if (typeof listener != "function")
        throw new TypeError('"listener" argument must be a function');
      if (events2 = this._events, !events2)
        return this;
      if (list = events2[type2], !list)
        return this;
      if (list === listener || list.listener && list.listener === listener)
        --this._eventsCount === 0 ? this._events = new EventHandlers() : (delete events2[type2], events2.removeListener && this.emit("removeListener", type2, list.listener || listener));
      else if (typeof list != "function") {
        for (position = -1, i3 = list.length; i3-- > 0; )
          if (list[i3] === listener || list[i3].listener && list[i3].listener === listener) {
            originalListener = list[i3].listener, position = i3;
            break;
          }
        if (position < 0)
          return this;
        if (list.length === 1) {
          if (list[0] = void 0, --this._eventsCount === 0)
            return this._events = new EventHandlers(), this;
          delete events2[type2];
        } else
          spliceOne(list, position);
        events2.removeListener && this.emit("removeListener", type2, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function(type2) {
      var listeners2, events2;
      if (events2 = this._events, !events2)
        return this;
      if (!events2.removeListener)
        return arguments.length === 0 ? (this._events = new EventHandlers(), this._eventsCount = 0) : events2[type2] && (--this._eventsCount === 0 ? this._events = new EventHandlers() : delete events2[type2]), this;
      if (arguments.length === 0) {
        for (var keys2 = Object.keys(events2), i3 = 0, key2; i3 < keys2.length; ++i3)
          key2 = keys2[i3], key2 !== "removeListener" && this.removeAllListeners(key2);
        return this.removeAllListeners("removeListener"), this._events = new EventHandlers(), this._eventsCount = 0, this;
      }
      if (listeners2 = events2[type2], typeof listeners2 == "function")
        this.removeListener(type2, listeners2);
      else if (listeners2)
        do
          this.removeListener(type2, listeners2[listeners2.length - 1]);
        while (listeners2[0]);
      return this;
    };
    EventEmitter.prototype.listeners = function(type2) {
      var evlistener, ret, events2 = this._events;
      return events2 ? (evlistener = events2[type2], evlistener ? typeof evlistener == "function" ? ret = [evlistener.listener || evlistener] : ret = unwrapListeners(evlistener) : ret = []) : ret = [], ret;
    };
    EventEmitter.listenerCount = function(emitter, type2) {
      return typeof emitter.listenerCount == "function" ? emitter.listenerCount(type2) : listenerCount.call(emitter, type2);
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    EventEmitter.prototype.eventNames = function() {
      return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
    };
  }
});

// node-modules-polyfills:process
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout)
    return setTimeout(fun, 0);
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout)
    return cachedSetTimeout = setTimeout, setTimeout(fun, 0);
  try {
    return cachedSetTimeout(fun, 0);
  } catch {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout)
    return clearTimeout(marker);
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout)
    return cachedClearTimeout = clearTimeout, clearTimeout(marker);
  try {
    return cachedClearTimeout(marker);
  } catch {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
function cleanUpNextTick() {
  !draining || !currentQueue || (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue());
}
function drainQueue() {
  if (!draining) {
    var timeout2 = runTimeout(cleanUpNextTick);
    draining = !0;
    for (var len = queue.length; len; ) {
      for (currentQueue = queue, queue = []; ++queueIndex < len; )
        currentQueue && currentQueue[queueIndex].run();
      queueIndex = -1, len = queue.length;
    }
    currentQueue = null, draining = !1, runClearTimeout(timeout2);
  }
}
function nextTick(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var i3 = 1; i3 < arguments.length; i3++)
      args[i3 - 1] = arguments[i3];
  queue.push(new Item(fun, args)), queue.length === 1 && !draining && runTimeout(drainQueue);
}
function Item(fun, array) {
  this.fun = fun, this.array = array;
}
function noop() {
}
function binding(name) {
  throw new Error("process.binding is not supported");
}
function cwd() {
  return "/";
}
function chdir(dir) {
  throw new Error("process.chdir is not supported");
}
function umask() {
  return 0;
}
function hrtime(previousTimestamp) {
  var clocktime = performanceNow.call(performance2) * 1e-3, seconds = Math.floor(clocktime), nanoseconds = Math.floor(clocktime % 1 * 1e9);
  return previousTimestamp && (seconds = seconds - previousTimestamp[0], nanoseconds = nanoseconds - previousTimestamp[1], nanoseconds < 0 && (seconds--, nanoseconds += 1e9)), [seconds, nanoseconds];
}
function uptime() {
  var currentTime = new Date(), dif = currentTime - startTime;
  return dif / 1e3;
}
var cachedSetTimeout, cachedClearTimeout, queue, draining, currentQueue, queueIndex, title, platform, browser, env, argv, version, versions, release, config, on, addListener2, once2, off, removeListener2, removeAllListeners2, emit2, performance2, performanceNow, startTime, browser$1, process_default, init_process = __esm({
  "node-modules-polyfills:process"() {
    cachedSetTimeout = defaultSetTimout, cachedClearTimeout = defaultClearTimeout;
    typeof globalThis.setTimeout == "function" && (cachedSetTimeout = setTimeout);
    typeof globalThis.clearTimeout == "function" && (cachedClearTimeout = clearTimeout);
    queue = [], draining = !1, queueIndex = -1;
    Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    title = "browser", platform = "browser", browser = !0, env = {}, argv = [], version = "", versions = {}, release = {}, config = {};
    on = noop, addListener2 = noop, once2 = noop, off = noop, removeListener2 = noop, removeAllListeners2 = noop, emit2 = noop;
    performance2 = globalThis.performance || {}, performanceNow = performance2.now || performance2.mozNow || performance2.msNow || performance2.oNow || performance2.webkitNow || function() {
      return new Date().getTime();
    };
    startTime = new Date();
    browser$1 = {
      nextTick,
      title,
      browser,
      env,
      argv,
      version,
      versions,
      on,
      addListener: addListener2,
      once: once2,
      off,
      removeListener: removeListener2,
      removeAllListeners: removeAllListeners2,
      emit: emit2,
      binding,
      cwd,
      chdir,
      umask,
      hrtime,
      platform,
      release,
      config,
      uptime
    }, process_default = browser$1;
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/inherits.js
var inherits, inherits_default, init_inherits = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/inherits.js"() {
    typeof Object.create == "function" ? inherits = function(ctor, superCtor) {
      ctor.super_ = superCtor, ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: !1,
          writable: !0,
          configurable: !0
        }
      });
    } : inherits = function(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype, ctor.prototype = new TempCtor(), ctor.prototype.constructor = ctor;
    };
    inherits_default = inherits;
  }
});

// node-modules-polyfills:util
function format(f2) {
  if (!isString(f2)) {
    for (var objects = [], i3 = 0; i3 < arguments.length; i3++)
      objects.push(inspect(arguments[i3]));
    return objects.join(" ");
  }
  for (var i3 = 1, args = arguments, len = args.length, str2 = String(f2).replace(formatRegExp, function(x3) {
    if (x3 === "%%")
      return "%";
    if (i3 >= len)
      return x3;
    switch (x3) {
      case "%s":
        return String(args[i3++]);
      case "%d":
        return Number(args[i3++]);
      case "%j":
        try {
          return JSON.stringify(args[i3++]);
        } catch {
          return "[Circular]";
        }
      default:
        return x3;
    }
  }), x2 = args[i3]; i3 < len; x2 = args[++i3])
    isNull2(x2) || !isObject2(x2) ? str2 += " " + x2 : str2 += " " + inspect(x2);
  return str2;
}
function deprecate(fn, msg) {
  if (isUndefined(globalThis.process))
    return function() {
      return deprecate(fn, msg).apply(this, arguments);
    };
  if (process_default.noDeprecation === !0)
    return fn;
  var warned2 = !1;
  function deprecated() {
    if (!warned2) {
      if (process_default.throwDeprecation)
        throw new Error(msg);
      process_default.traceDeprecation ? console.trace(msg) : console.error(msg), warned2 = !0;
    }
    return fn.apply(this, arguments);
  }
  return deprecated;
}
function debuglog(set2) {
  if (isUndefined(debugEnviron) && (debugEnviron = process_default.env.NODE_DEBUG || ""), set2 = set2.toUpperCase(), !debugs[set2])
    if (new RegExp("\\b" + set2 + "\\b", "i").test(debugEnviron)) {
      var pid = 0;
      debugs[set2] = function() {
        var msg = format.apply(null, arguments);
        console.error("%s %d: %s", set2, pid, msg);
      };
    } else
      debugs[set2] = function() {
      };
  return debugs[set2];
}
function inspect(obj, opts) {
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  return arguments.length >= 3 && (ctx.depth = arguments[2]), arguments.length >= 4 && (ctx.colors = arguments[3]), isBoolean2(opts) ? ctx.showHidden = opts : opts && _extend(ctx, opts), isUndefined(ctx.showHidden) && (ctx.showHidden = !1), isUndefined(ctx.depth) && (ctx.depth = 2), isUndefined(ctx.colors) && (ctx.colors = !1), isUndefined(ctx.customInspect) && (ctx.customInspect = !0), ctx.colors && (ctx.stylize = stylizeWithColor), formatValue(ctx, obj, ctx.depth);
}
function stylizeWithColor(str2, styleType) {
  var style = inspect.styles[styleType];
  return style ? "\x1B[" + inspect.colors[style][0] + "m" + str2 + "\x1B[" + inspect.colors[style][1] + "m" : str2;
}
function stylizeNoColor(str2, styleType) {
  return str2;
}
function arrayToHash(array) {
  var hash = {};
  return array.forEach(function(val, idx) {
    hash[val] = !0;
  }), hash;
}
function formatValue(ctx, value2, recurseTimes) {
  if (ctx.customInspect && value2 && isFunction(value2.inspect) && value2.inspect !== inspect && !(value2.constructor && value2.constructor.prototype === value2)) {
    var ret = value2.inspect(recurseTimes, ctx);
    return isString(ret) || (ret = formatValue(ctx, ret, recurseTimes)), ret;
  }
  var primitive = formatPrimitive(ctx, value2);
  if (primitive)
    return primitive;
  var keys2 = Object.keys(value2), visibleKeys = arrayToHash(keys2);
  if (ctx.showHidden && (keys2 = Object.getOwnPropertyNames(value2)), isError(value2) && (keys2.indexOf("message") >= 0 || keys2.indexOf("description") >= 0))
    return formatError2(value2);
  if (keys2.length === 0) {
    if (isFunction(value2)) {
      var name = value2.name ? ": " + value2.name : "";
      return ctx.stylize("[Function" + name + "]", "special");
    }
    if (isRegExp(value2))
      return ctx.stylize(RegExp.prototype.toString.call(value2), "regexp");
    if (isDate(value2))
      return ctx.stylize(Date.prototype.toString.call(value2), "date");
    if (isError(value2))
      return formatError2(value2);
  }
  var base = "", array = !1, braces = ["{", "}"];
  if (isArray(value2) && (array = !0, braces = ["[", "]"]), isFunction(value2)) {
    var n3 = value2.name ? ": " + value2.name : "";
    base = " [Function" + n3 + "]";
  }
  if (isRegExp(value2) && (base = " " + RegExp.prototype.toString.call(value2)), isDate(value2) && (base = " " + Date.prototype.toUTCString.call(value2)), isError(value2) && (base = " " + formatError2(value2)), keys2.length === 0 && (!array || value2.length == 0))
    return braces[0] + base + braces[1];
  if (recurseTimes < 0)
    return isRegExp(value2) ? ctx.stylize(RegExp.prototype.toString.call(value2), "regexp") : ctx.stylize("[Object]", "special");
  ctx.seen.push(value2);
  var output2;
  return array ? output2 = formatArray(ctx, value2, recurseTimes, visibleKeys, keys2) : output2 = keys2.map(function(key2) {
    return formatProperty(ctx, value2, recurseTimes, visibleKeys, key2, array);
  }), ctx.seen.pop(), reduceToSingleString(output2, base, braces);
}
function formatPrimitive(ctx, value2) {
  if (isUndefined(value2))
    return ctx.stylize("undefined", "undefined");
  if (isString(value2)) {
    var simple = "'" + JSON.stringify(value2).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    return ctx.stylize(simple, "string");
  }
  if (isNumber(value2))
    return ctx.stylize("" + value2, "number");
  if (isBoolean2(value2))
    return ctx.stylize("" + value2, "boolean");
  if (isNull2(value2))
    return ctx.stylize("null", "null");
}
function formatError2(value2) {
  return "[" + Error.prototype.toString.call(value2) + "]";
}
function formatArray(ctx, value2, recurseTimes, visibleKeys, keys2) {
  for (var output2 = [], i3 = 0, l2 = value2.length; i3 < l2; ++i3)
    hasOwnProperty(value2, String(i3)) ? output2.push(formatProperty(
      ctx,
      value2,
      recurseTimes,
      visibleKeys,
      String(i3),
      !0
    )) : output2.push("");
  return keys2.forEach(function(key2) {
    key2.match(/^\d+$/) || output2.push(formatProperty(
      ctx,
      value2,
      recurseTimes,
      visibleKeys,
      key2,
      !0
    ));
  }), output2;
}
function formatProperty(ctx, value2, recurseTimes, visibleKeys, key2, array) {
  var name, str2, desc;
  if (desc = Object.getOwnPropertyDescriptor(value2, key2) || { value: value2[key2] }, desc.get ? desc.set ? str2 = ctx.stylize("[Getter/Setter]", "special") : str2 = ctx.stylize("[Getter]", "special") : desc.set && (str2 = ctx.stylize("[Setter]", "special")), hasOwnProperty(visibleKeys, key2) || (name = "[" + key2 + "]"), str2 || (ctx.seen.indexOf(desc.value) < 0 ? (isNull2(recurseTimes) ? str2 = formatValue(ctx, desc.value, null) : str2 = formatValue(ctx, desc.value, recurseTimes - 1), str2.indexOf(`
`) > -1 && (array ? str2 = str2.split(`
`).map(function(line2) {
    return "  " + line2;
  }).join(`
`).substr(2) : str2 = `
` + str2.split(`
`).map(function(line2) {
    return "   " + line2;
  }).join(`
`))) : str2 = ctx.stylize("[Circular]", "special")), isUndefined(name)) {
    if (array && key2.match(/^\d+$/))
      return str2;
    name = JSON.stringify("" + key2), name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (name = name.substr(1, name.length - 2), name = ctx.stylize(name, "name")) : (name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), name = ctx.stylize(name, "string"));
  }
  return name + ": " + str2;
}
function reduceToSingleString(output2, base, braces) {
  var numLinesEst = 0, length = output2.reduce(function(prev, cur) {
    return numLinesEst++, cur.indexOf(`
`) >= 0 && numLinesEst++, prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
  }, 0);
  return length > 60 ? braces[0] + (base === "" ? "" : base + `
 `) + " " + output2.join(`,
  `) + " " + braces[1] : braces[0] + base + " " + output2.join(", ") + " " + braces[1];
}
function isArray(ar) {
  return Array.isArray(ar);
}
function isBoolean2(arg) {
  return typeof arg == "boolean";
}
function isNull2(arg) {
  return arg === null;
}
function isNumber(arg) {
  return typeof arg == "number";
}
function isString(arg) {
  return typeof arg == "string";
}
function isUndefined(arg) {
  return arg === void 0;
}
function isRegExp(re2) {
  return isObject2(re2) && objectToString(re2) === "[object RegExp]";
}
function isObject2(arg) {
  return typeof arg == "object" && arg !== null;
}
function isDate(d2) {
  return isObject2(d2) && objectToString(d2) === "[object Date]";
}
function isError(e3) {
  return isObject2(e3) && (objectToString(e3) === "[object Error]" || e3 instanceof Error);
}
function isFunction(arg) {
  return typeof arg == "function";
}
function objectToString(o2) {
  return Object.prototype.toString.call(o2);
}
function _extend(origin, add) {
  if (!add || !isObject2(add))
    return origin;
  for (var keys2 = Object.keys(add), i3 = keys2.length; i3--; )
    origin[keys2[i3]] = add[keys2[i3]];
  return origin;
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var formatRegExp, debugs, debugEnviron, init_util = __esm({
  "node-modules-polyfills:util"() {
    init_process();
    init_inherits();
    formatRegExp = /%[sdj%]/g;
    debugs = {};
    inspect.colors = {
      bold: [1, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      white: [37, 39],
      grey: [90, 39],
      black: [30, 39],
      blue: [34, 39],
      cyan: [36, 39],
      green: [32, 39],
      magenta: [35, 39],
      red: [31, 39],
      yellow: [33, 39]
    };
    inspect.styles = {
      special: "cyan",
      number: "yellow",
      boolean: "yellow",
      undefined: "grey",
      null: "bold",
      string: "green",
      date: "magenta",
      regexp: "red"
    };
  }
});

// node-modules-polyfills:buffer
function init2() {
  inited = !0;
  for (var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", i3 = 0, len = code.length; i3 < len; ++i3)
    lookup[i3] = code[i3], revLookup[code.charCodeAt(i3)] = i3;
  revLookup["-".charCodeAt(0)] = 62, revLookup["_".charCodeAt(0)] = 63;
}
function toByteArray(b64) {
  inited || init2();
  var i3, j2, l2, tmp, placeHolders, arr2, len = b64.length;
  if (len % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0, arr2 = new Arr(len * 3 / 4 - placeHolders), l2 = placeHolders > 0 ? len - 4 : len;
  var L2 = 0;
  for (i3 = 0, j2 = 0; i3 < l2; i3 += 4, j2 += 3)
    tmp = revLookup[b64.charCodeAt(i3)] << 18 | revLookup[b64.charCodeAt(i3 + 1)] << 12 | revLookup[b64.charCodeAt(i3 + 2)] << 6 | revLookup[b64.charCodeAt(i3 + 3)], arr2[L2++] = tmp >> 16 & 255, arr2[L2++] = tmp >> 8 & 255, arr2[L2++] = tmp & 255;
  return placeHolders === 2 ? (tmp = revLookup[b64.charCodeAt(i3)] << 2 | revLookup[b64.charCodeAt(i3 + 1)] >> 4, arr2[L2++] = tmp & 255) : placeHolders === 1 && (tmp = revLookup[b64.charCodeAt(i3)] << 10 | revLookup[b64.charCodeAt(i3 + 1)] << 4 | revLookup[b64.charCodeAt(i3 + 2)] >> 2, arr2[L2++] = tmp >> 8 & 255, arr2[L2++] = tmp & 255), arr2;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start3, end3) {
  for (var tmp, output2 = [], i3 = start3; i3 < end3; i3 += 3)
    tmp = (uint8[i3] << 16) + (uint8[i3 + 1] << 8) + uint8[i3 + 2], output2.push(tripletToBase64(tmp));
  return output2.join("");
}
function fromByteArray(uint8) {
  inited || init2();
  for (var tmp, len = uint8.length, extraBytes = len % 3, output2 = "", parts = [], maxChunkLength = 16383, i3 = 0, len2 = len - extraBytes; i3 < len2; i3 += maxChunkLength)
    parts.push(encodeChunk(uint8, i3, i3 + maxChunkLength > len2 ? len2 : i3 + maxChunkLength));
  return extraBytes === 1 ? (tmp = uint8[len - 1], output2 += lookup[tmp >> 2], output2 += lookup[tmp << 4 & 63], output2 += "==") : extraBytes === 2 && (tmp = (uint8[len - 2] << 8) + uint8[len - 1], output2 += lookup[tmp >> 10], output2 += lookup[tmp >> 4 & 63], output2 += lookup[tmp << 2 & 63], output2 += "="), parts.push(output2), parts.join("");
}
function read2(buffer2, offset, isLE, mLen, nBytes) {
  var e3, m2, eLen = nBytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, nBits = -7, i3 = isLE ? nBytes - 1 : 0, d2 = isLE ? -1 : 1, s3 = buffer2[offset + i3];
  for (i3 += d2, e3 = s3 & (1 << -nBits) - 1, s3 >>= -nBits, nBits += eLen; nBits > 0; e3 = e3 * 256 + buffer2[offset + i3], i3 += d2, nBits -= 8)
    ;
  for (m2 = e3 & (1 << -nBits) - 1, e3 >>= -nBits, nBits += mLen; nBits > 0; m2 = m2 * 256 + buffer2[offset + i3], i3 += d2, nBits -= 8)
    ;
  if (e3 === 0)
    e3 = 1 - eBias;
  else {
    if (e3 === eMax)
      return m2 ? NaN : (s3 ? -1 : 1) * (1 / 0);
    m2 = m2 + Math.pow(2, mLen), e3 = e3 - eBias;
  }
  return (s3 ? -1 : 1) * m2 * Math.pow(2, e3 - mLen);
}
function write(buffer2, value2, offset, isLE, mLen, nBytes) {
  var e3, m2, c4, eLen = nBytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, i3 = isLE ? 0 : nBytes - 1, d2 = isLE ? 1 : -1, s3 = value2 < 0 || value2 === 0 && 1 / value2 < 0 ? 1 : 0;
  for (value2 = Math.abs(value2), isNaN(value2) || value2 === 1 / 0 ? (m2 = isNaN(value2) ? 1 : 0, e3 = eMax) : (e3 = Math.floor(Math.log(value2) / Math.LN2), value2 * (c4 = Math.pow(2, -e3)) < 1 && (e3--, c4 *= 2), e3 + eBias >= 1 ? value2 += rt / c4 : value2 += rt * Math.pow(2, 1 - eBias), value2 * c4 >= 2 && (e3++, c4 /= 2), e3 + eBias >= eMax ? (m2 = 0, e3 = eMax) : e3 + eBias >= 1 ? (m2 = (value2 * c4 - 1) * Math.pow(2, mLen), e3 = e3 + eBias) : (m2 = value2 * Math.pow(2, eBias - 1) * Math.pow(2, mLen), e3 = 0)); mLen >= 8; buffer2[offset + i3] = m2 & 255, i3 += d2, m2 /= 256, mLen -= 8)
    ;
  for (e3 = e3 << mLen | m2, eLen += mLen; eLen > 0; buffer2[offset + i3] = e3 & 255, i3 += d2, e3 /= 256, eLen -= 8)
    ;
  buffer2[offset + i3 - d2] |= s3 * 128;
}
function kMaxLength() {
  return Buffer2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer(that, length) {
  if (kMaxLength() < length)
    throw new RangeError("Invalid typed array length");
  return Buffer2.TYPED_ARRAY_SUPPORT ? (that = new Uint8Array(length), that.__proto__ = Buffer2.prototype) : (that === null && (that = new Buffer2(length)), that.length = length), that;
}
function Buffer2(arg, encodingOrOffset, length) {
  if (!Buffer2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer2))
    return new Buffer2(arg, encodingOrOffset, length);
  if (typeof arg == "number") {
    if (typeof encodingOrOffset == "string")
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      );
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length);
}
function from(that, value2, encodingOrOffset, length) {
  if (typeof value2 == "number")
    throw new TypeError('"value" argument must not be a number');
  return typeof ArrayBuffer < "u" && value2 instanceof ArrayBuffer ? fromArrayBuffer(that, value2, encodingOrOffset, length) : typeof value2 == "string" ? fromString(that, value2, encodingOrOffset) : fromObject(that, value2);
}
function assertSize(size) {
  if (typeof size != "number")
    throw new TypeError('"size" argument must be a number');
  if (size < 0)
    throw new RangeError('"size" argument must not be negative');
}
function alloc(that, size, fill2, encoding) {
  return assertSize(size), size <= 0 ? createBuffer(that, size) : fill2 !== void 0 ? typeof encoding == "string" ? createBuffer(that, size).fill(fill2, encoding) : createBuffer(that, size).fill(fill2) : createBuffer(that, size);
}
function allocUnsafe(that, size) {
  if (assertSize(size), that = createBuffer(that, size < 0 ? 0 : checked(size) | 0), !Buffer2.TYPED_ARRAY_SUPPORT)
    for (var i3 = 0; i3 < size; ++i3)
      that[i3] = 0;
  return that;
}
function fromString(that, string2, encoding) {
  if ((typeof encoding != "string" || encoding === "") && (encoding = "utf8"), !Buffer2.isEncoding(encoding))
    throw new TypeError('"encoding" must be a valid string encoding');
  var length = byteLength(string2, encoding) | 0;
  that = createBuffer(that, length);
  var actual = that.write(string2, encoding);
  return actual !== length && (that = that.slice(0, actual)), that;
}
function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i3 = 0; i3 < length; i3 += 1)
    that[i3] = array[i3] & 255;
  return that;
}
function fromArrayBuffer(that, array, byteOffset, length) {
  if (array.byteLength, byteOffset < 0 || array.byteLength < byteOffset)
    throw new RangeError("'offset' is out of bounds");
  if (array.byteLength < byteOffset + (length || 0))
    throw new RangeError("'length' is out of bounds");
  return byteOffset === void 0 && length === void 0 ? array = new Uint8Array(array) : length === void 0 ? array = new Uint8Array(array, byteOffset) : array = new Uint8Array(array, byteOffset, length), Buffer2.TYPED_ARRAY_SUPPORT ? (that = array, that.__proto__ = Buffer2.prototype) : that = fromArrayLike(that, array), that;
}
function fromObject(that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    return that = createBuffer(that, len), that.length === 0 || obj.copy(that, 0, 0, len), that;
  }
  if (obj) {
    if (typeof ArrayBuffer < "u" && obj.buffer instanceof ArrayBuffer || "length" in obj)
      return typeof obj.length != "number" || isnan(obj.length) ? createBuffer(that, 0) : fromArrayLike(that, obj);
    if (obj.type === "Buffer" && isArray2(obj.data))
      return fromArrayLike(that, obj.data);
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function checked(length) {
  if (length >= kMaxLength())
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
  return length | 0;
}
function internalIsBuffer(b2) {
  return !!(b2 != null && b2._isBuffer);
}
function byteLength(string2, encoding) {
  if (internalIsBuffer(string2))
    return string2.length;
  if (typeof ArrayBuffer < "u" && typeof ArrayBuffer.isView == "function" && (ArrayBuffer.isView(string2) || string2 instanceof ArrayBuffer))
    return string2.byteLength;
  typeof string2 != "string" && (string2 = "" + string2);
  var len = string2.length;
  if (len === 0)
    return 0;
  for (var loweredCase = !1; ; )
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes(string2).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes(string2).length;
      default:
        if (loweredCase)
          return utf8ToBytes(string2).length;
        encoding = ("" + encoding).toLowerCase(), loweredCase = !0;
    }
}
function slowToString(encoding, start3, end3) {
  var loweredCase = !1;
  if ((start3 === void 0 || start3 < 0) && (start3 = 0), start3 > this.length || ((end3 === void 0 || end3 > this.length) && (end3 = this.length), end3 <= 0) || (end3 >>>= 0, start3 >>>= 0, end3 <= start3))
    return "";
  for (encoding || (encoding = "utf8"); ; )
    switch (encoding) {
      case "hex":
        return hexSlice(this, start3, end3);
      case "utf8":
      case "utf-8":
        return utf8Slice(this, start3, end3);
      case "ascii":
        return asciiSlice(this, start3, end3);
      case "latin1":
      case "binary":
        return latin1Slice(this, start3, end3);
      case "base64":
        return base64Slice(this, start3, end3);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice(this, start3, end3);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase(), loweredCase = !0;
    }
}
function swap(b2, n3, m2) {
  var i3 = b2[n3];
  b2[n3] = b2[m2], b2[m2] = i3;
}
function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
  if (buffer2.length === 0)
    return -1;
  if (typeof byteOffset == "string" ? (encoding = byteOffset, byteOffset = 0) : byteOffset > 2147483647 ? byteOffset = 2147483647 : byteOffset < -2147483648 && (byteOffset = -2147483648), byteOffset = +byteOffset, isNaN(byteOffset) && (byteOffset = dir ? 0 : buffer2.length - 1), byteOffset < 0 && (byteOffset = buffer2.length + byteOffset), byteOffset >= buffer2.length) {
    if (dir)
      return -1;
    byteOffset = buffer2.length - 1;
  } else if (byteOffset < 0)
    if (dir)
      byteOffset = 0;
    else
      return -1;
  if (typeof val == "string" && (val = Buffer2.from(val, encoding)), internalIsBuffer(val))
    return val.length === 0 ? -1 : arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
  if (typeof val == "number")
    return val = val & 255, Buffer2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf == "function" ? dir ? Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset) : Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset) : arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr2, val, byteOffset, encoding, dir) {
  var indexSize = 1, arrLength = arr2.length, valLength = val.length;
  if (encoding !== void 0 && (encoding = String(encoding).toLowerCase(), encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le")) {
    if (arr2.length < 2 || val.length < 2)
      return -1;
    indexSize = 2, arrLength /= 2, valLength /= 2, byteOffset /= 2;
  }
  function read3(buf, i4) {
    return indexSize === 1 ? buf[i4] : buf.readUInt16BE(i4 * indexSize);
  }
  var i3;
  if (dir) {
    var foundIndex = -1;
    for (i3 = byteOffset; i3 < arrLength; i3++)
      if (read3(arr2, i3) === read3(val, foundIndex === -1 ? 0 : i3 - foundIndex)) {
        if (foundIndex === -1 && (foundIndex = i3), i3 - foundIndex + 1 === valLength)
          return foundIndex * indexSize;
      } else
        foundIndex !== -1 && (i3 -= i3 - foundIndex), foundIndex = -1;
  } else
    for (byteOffset + valLength > arrLength && (byteOffset = arrLength - valLength), i3 = byteOffset; i3 >= 0; i3--) {
      for (var found = !0, j2 = 0; j2 < valLength; j2++)
        if (read3(arr2, i3 + j2) !== read3(val, j2)) {
          found = !1;
          break;
        }
      if (found)
        return i3;
    }
  return -1;
}
function hexWrite(buf, string2, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  length ? (length = Number(length), length > remaining && (length = remaining)) : length = remaining;
  var strLen = string2.length;
  if (strLen % 2 !== 0)
    throw new TypeError("Invalid hex string");
  length > strLen / 2 && (length = strLen / 2);
  for (var i3 = 0; i3 < length; ++i3) {
    var parsed = parseInt(string2.substr(i3 * 2, 2), 16);
    if (isNaN(parsed))
      return i3;
    buf[offset + i3] = parsed;
  }
  return i3;
}
function utf8Write(buf, string2, offset, length) {
  return blitBuffer(utf8ToBytes(string2, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string2, offset, length) {
  return blitBuffer(asciiToBytes(string2), buf, offset, length);
}
function latin1Write(buf, string2, offset, length) {
  return asciiWrite(buf, string2, offset, length);
}
function base64Write(buf, string2, offset, length) {
  return blitBuffer(base64ToBytes(string2), buf, offset, length);
}
function ucs2Write(buf, string2, offset, length) {
  return blitBuffer(utf16leToBytes(string2, buf.length - offset), buf, offset, length);
}
function base64Slice(buf, start3, end3) {
  return start3 === 0 && end3 === buf.length ? fromByteArray(buf) : fromByteArray(buf.slice(start3, end3));
}
function utf8Slice(buf, start3, end3) {
  end3 = Math.min(buf.length, end3);
  for (var res = [], i3 = start3; i3 < end3; ) {
    var firstByte = buf[i3], codePoint = null, bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i3 + bytesPerSequence <= end3) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          firstByte < 128 && (codePoint = firstByte);
          break;
        case 2:
          secondByte = buf[i3 + 1], (secondByte & 192) === 128 && (tempCodePoint = (firstByte & 31) << 6 | secondByte & 63, tempCodePoint > 127 && (codePoint = tempCodePoint));
          break;
        case 3:
          secondByte = buf[i3 + 1], thirdByte = buf[i3 + 2], (secondByte & 192) === 128 && (thirdByte & 192) === 128 && (tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63, tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343) && (codePoint = tempCodePoint));
          break;
        case 4:
          secondByte = buf[i3 + 1], thirdByte = buf[i3 + 2], fourthByte = buf[i3 + 3], (secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128 && (tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63, tempCodePoint > 65535 && tempCodePoint < 1114112 && (codePoint = tempCodePoint));
      }
    }
    codePoint === null ? (codePoint = 65533, bytesPerSequence = 1) : codePoint > 65535 && (codePoint -= 65536, res.push(codePoint >>> 10 & 1023 | 55296), codePoint = 56320 | codePoint & 1023), res.push(codePoint), i3 += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH)
    return String.fromCharCode.apply(String, codePoints);
  for (var res = "", i3 = 0; i3 < len; )
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i3, i3 += MAX_ARGUMENTS_LENGTH)
    );
  return res;
}
function asciiSlice(buf, start3, end3) {
  var ret = "";
  end3 = Math.min(buf.length, end3);
  for (var i3 = start3; i3 < end3; ++i3)
    ret += String.fromCharCode(buf[i3] & 127);
  return ret;
}
function latin1Slice(buf, start3, end3) {
  var ret = "";
  end3 = Math.min(buf.length, end3);
  for (var i3 = start3; i3 < end3; ++i3)
    ret += String.fromCharCode(buf[i3]);
  return ret;
}
function hexSlice(buf, start3, end3) {
  var len = buf.length;
  (!start3 || start3 < 0) && (start3 = 0), (!end3 || end3 < 0 || end3 > len) && (end3 = len);
  for (var out = "", i3 = start3; i3 < end3; ++i3)
    out += toHex(buf[i3]);
  return out;
}
function utf16leSlice(buf, start3, end3) {
  for (var bytes = buf.slice(start3, end3), res = "", i3 = 0; i3 < bytes.length; i3 += 2)
    res += String.fromCharCode(bytes[i3] + bytes[i3 + 1] * 256);
  return res;
}
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0)
    throw new RangeError("offset is not uint");
  if (offset + ext > length)
    throw new RangeError("Trying to access beyond buffer length");
}
function checkInt(buf, value2, offset, ext, max, min) {
  if (!internalIsBuffer(buf))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value2 > max || value2 < min)
    throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
}
function objectWriteUInt16(buf, value2, offset, littleEndian) {
  value2 < 0 && (value2 = 65535 + value2 + 1);
  for (var i3 = 0, j2 = Math.min(buf.length - offset, 2); i3 < j2; ++i3)
    buf[offset + i3] = (value2 & 255 << 8 * (littleEndian ? i3 : 1 - i3)) >>> (littleEndian ? i3 : 1 - i3) * 8;
}
function objectWriteUInt32(buf, value2, offset, littleEndian) {
  value2 < 0 && (value2 = 4294967295 + value2 + 1);
  for (var i3 = 0, j2 = Math.min(buf.length - offset, 4); i3 < j2; ++i3)
    buf[offset + i3] = value2 >>> (littleEndian ? i3 : 3 - i3) * 8 & 255;
}
function checkIEEE754(buf, value2, offset, ext, max, min) {
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
  if (offset < 0)
    throw new RangeError("Index out of range");
}
function writeFloat(buf, value2, offset, littleEndian, noAssert) {
  return noAssert || checkIEEE754(buf, value2, offset, 4), write(buf, value2, offset, littleEndian, 23, 4), offset + 4;
}
function writeDouble(buf, value2, offset, littleEndian, noAssert) {
  return noAssert || checkIEEE754(buf, value2, offset, 8), write(buf, value2, offset, littleEndian, 52, 8), offset + 8;
}
function base64clean(str2) {
  if (str2 = stringtrim(str2).replace(INVALID_BASE64_RE, ""), str2.length < 2)
    return "";
  for (; str2.length % 4 !== 0; )
    str2 = str2 + "=";
  return str2;
}
function stringtrim(str2) {
  return str2.trim ? str2.trim() : str2.replace(/^\s+|\s+$/g, "");
}
function toHex(n3) {
  return n3 < 16 ? "0" + n3.toString(16) : n3.toString(16);
}
function utf8ToBytes(string2, units) {
  units = units || 1 / 0;
  for (var codePoint, length = string2.length, leadSurrogate = null, bytes = [], i3 = 0; i3 < length; ++i3) {
    if (codePoint = string2.charCodeAt(i3), codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          (units -= 3) > -1 && bytes.push(239, 191, 189);
          continue;
        } else if (i3 + 1 === length) {
          (units -= 3) > -1 && bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        (units -= 3) > -1 && bytes.push(239, 191, 189), leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else
      leadSurrogate && (units -= 3) > -1 && bytes.push(239, 191, 189);
    if (leadSurrogate = null, codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes.push(
        codePoint >> 6 | 192,
        codePoint & 63 | 128
      );
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes.push(
        codePoint >> 12 | 224,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes.push(
        codePoint >> 18 | 240,
        codePoint >> 12 & 63 | 128,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else
      throw new Error("Invalid code point");
  }
  return bytes;
}
function asciiToBytes(str2) {
  for (var byteArray = [], i3 = 0; i3 < str2.length; ++i3)
    byteArray.push(str2.charCodeAt(i3) & 255);
  return byteArray;
}
function utf16leToBytes(str2, units) {
  for (var c4, hi, lo, byteArray = [], i3 = 0; i3 < str2.length && !((units -= 2) < 0); ++i3)
    c4 = str2.charCodeAt(i3), hi = c4 >> 8, lo = c4 % 256, byteArray.push(lo), byteArray.push(hi);
  return byteArray;
}
function base64ToBytes(str2) {
  return toByteArray(base64clean(str2));
}
function blitBuffer(src, dst, offset, length) {
  for (var i3 = 0; i3 < length && !(i3 + offset >= dst.length || i3 >= src.length); ++i3)
    dst[i3 + offset] = src[i3];
  return i3;
}
function isnan(val) {
  return val !== val;
}
function isBuffer(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
}
function isFastBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer == "function" && obj.constructor.isBuffer(obj);
}
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE == "function" && typeof obj.slice == "function" && isFastBuffer(obj.slice(0, 0));
}
var lookup, revLookup, Arr, inited, toString2, isArray2, INSPECT_MAX_BYTES, _kMaxLength, MAX_ARGUMENTS_LENGTH, INVALID_BASE64_RE, init_buffer = __esm({
  "node-modules-polyfills:buffer"() {
    lookup = [], revLookup = [], Arr = typeof Uint8Array < "u" ? Uint8Array : Array, inited = !1;
    toString2 = {}.toString, isArray2 = Array.isArray || function(arr2) {
      return toString2.call(arr2) == "[object Array]";
    };
    INSPECT_MAX_BYTES = 50;
    Buffer2.TYPED_ARRAY_SUPPORT = globalThis.TYPED_ARRAY_SUPPORT !== void 0 ? globalThis.TYPED_ARRAY_SUPPORT : !0;
    _kMaxLength = kMaxLength();
    Buffer2.poolSize = 8192;
    Buffer2._augment = function(arr2) {
      return arr2.__proto__ = Buffer2.prototype, arr2;
    };
    Buffer2.from = function(value2, encodingOrOffset, length) {
      return from(null, value2, encodingOrOffset, length);
    };
    Buffer2.TYPED_ARRAY_SUPPORT && (Buffer2.prototype.__proto__ = Uint8Array.prototype, Buffer2.__proto__ = Uint8Array);
    Buffer2.alloc = function(size, fill2, encoding) {
      return alloc(null, size, fill2, encoding);
    };
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(null, size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(null, size);
    };
    Buffer2.isBuffer = isBuffer;
    Buffer2.compare = function(a3, b2) {
      if (!internalIsBuffer(a3) || !internalIsBuffer(b2))
        throw new TypeError("Arguments must be Buffers");
      if (a3 === b2)
        return 0;
      for (var x2 = a3.length, y2 = b2.length, i3 = 0, len = Math.min(x2, y2); i3 < len; ++i3)
        if (a3[i3] !== b2[i3]) {
          x2 = a3[i3], y2 = b2[i3];
          break;
        }
      return x2 < y2 ? -1 : y2 < x2 ? 1 : 0;
    };
    Buffer2.isEncoding = function(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return !0;
        default:
          return !1;
      }
    };
    Buffer2.concat = function(list, length) {
      if (!isArray2(list))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (list.length === 0)
        return Buffer2.alloc(0);
      var i3;
      if (length === void 0)
        for (length = 0, i3 = 0; i3 < list.length; ++i3)
          length += list[i3].length;
      var buffer2 = Buffer2.allocUnsafe(length), pos2 = 0;
      for (i3 = 0; i3 < list.length; ++i3) {
        var buf = list[i3];
        if (!internalIsBuffer(buf))
          throw new TypeError('"list" argument must be an Array of Buffers');
        buf.copy(buffer2, pos2), pos2 += buf.length;
      }
      return buffer2;
    };
    Buffer2.byteLength = byteLength;
    Buffer2.prototype._isBuffer = !0;
    Buffer2.prototype.swap16 = function() {
      var len = this.length;
      if (len % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (var i3 = 0; i3 < len; i3 += 2)
        swap(this, i3, i3 + 1);
      return this;
    };
    Buffer2.prototype.swap32 = function() {
      var len = this.length;
      if (len % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (var i3 = 0; i3 < len; i3 += 4)
        swap(this, i3, i3 + 3), swap(this, i3 + 1, i3 + 2);
      return this;
    };
    Buffer2.prototype.swap64 = function() {
      var len = this.length;
      if (len % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (var i3 = 0; i3 < len; i3 += 8)
        swap(this, i3, i3 + 7), swap(this, i3 + 1, i3 + 6), swap(this, i3 + 2, i3 + 5), swap(this, i3 + 3, i3 + 4);
      return this;
    };
    Buffer2.prototype.toString = function() {
      var length = this.length | 0;
      return length === 0 ? "" : arguments.length === 0 ? utf8Slice(this, 0, length) : slowToString.apply(this, arguments);
    };
    Buffer2.prototype.equals = function(b2) {
      if (!internalIsBuffer(b2))
        throw new TypeError("Argument must be a Buffer");
      return this === b2 ? !0 : Buffer2.compare(this, b2) === 0;
    };
    Buffer2.prototype.inspect = function() {
      var str2 = "", max = INSPECT_MAX_BYTES;
      return this.length > 0 && (str2 = this.toString("hex", 0, max).match(/.{2}/g).join(" "), this.length > max && (str2 += " ... ")), "<Buffer " + str2 + ">";
    };
    Buffer2.prototype.compare = function(target, start3, end3, thisStart, thisEnd) {
      if (!internalIsBuffer(target))
        throw new TypeError("Argument must be a Buffer");
      if (start3 === void 0 && (start3 = 0), end3 === void 0 && (end3 = target ? target.length : 0), thisStart === void 0 && (thisStart = 0), thisEnd === void 0 && (thisEnd = this.length), start3 < 0 || end3 > target.length || thisStart < 0 || thisEnd > this.length)
        throw new RangeError("out of range index");
      if (thisStart >= thisEnd && start3 >= end3)
        return 0;
      if (thisStart >= thisEnd)
        return -1;
      if (start3 >= end3)
        return 1;
      if (start3 >>>= 0, end3 >>>= 0, thisStart >>>= 0, thisEnd >>>= 0, this === target)
        return 0;
      for (var x2 = thisEnd - thisStart, y2 = end3 - start3, len = Math.min(x2, y2), thisCopy = this.slice(thisStart, thisEnd), targetCopy = target.slice(start3, end3), i3 = 0; i3 < len; ++i3)
        if (thisCopy[i3] !== targetCopy[i3]) {
          x2 = thisCopy[i3], y2 = targetCopy[i3];
          break;
        }
      return x2 < y2 ? -1 : y2 < x2 ? 1 : 0;
    };
    Buffer2.prototype.includes = function(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, !0);
    };
    Buffer2.prototype.lastIndexOf = function(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, !1);
    };
    Buffer2.prototype.write = function(string2, offset, length, encoding) {
      if (offset === void 0)
        encoding = "utf8", length = this.length, offset = 0;
      else if (length === void 0 && typeof offset == "string")
        encoding = offset, length = this.length, offset = 0;
      else if (isFinite(offset))
        offset = offset | 0, isFinite(length) ? (length = length | 0, encoding === void 0 && (encoding = "utf8")) : (encoding = length, length = void 0);
      else
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      var remaining = this.length - offset;
      if ((length === void 0 || length > remaining) && (length = remaining), string2.length > 0 && (length < 0 || offset < 0) || offset > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      encoding || (encoding = "utf8");
      for (var loweredCase = !1; ; )
        switch (encoding) {
          case "hex":
            return hexWrite(this, string2, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string2, offset, length);
          case "ascii":
            return asciiWrite(this, string2, offset, length);
          case "latin1":
          case "binary":
            return latin1Write(this, string2, offset, length);
          case "base64":
            return base64Write(this, string2, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string2, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase(), loweredCase = !0;
        }
    };
    Buffer2.prototype.toJSON = function() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    MAX_ARGUMENTS_LENGTH = 4096;
    Buffer2.prototype.slice = function(start3, end3) {
      var len = this.length;
      start3 = ~~start3, end3 = end3 === void 0 ? len : ~~end3, start3 < 0 ? (start3 += len, start3 < 0 && (start3 = 0)) : start3 > len && (start3 = len), end3 < 0 ? (end3 += len, end3 < 0 && (end3 = 0)) : end3 > len && (end3 = len), end3 < start3 && (end3 = start3);
      var newBuf;
      if (Buffer2.TYPED_ARRAY_SUPPORT)
        newBuf = this.subarray(start3, end3), newBuf.__proto__ = Buffer2.prototype;
      else {
        var sliceLen = end3 - start3;
        newBuf = new Buffer2(sliceLen, void 0);
        for (var i3 = 0; i3 < sliceLen; ++i3)
          newBuf[i3] = this[i3 + start3];
      }
      return newBuf;
    };
    Buffer2.prototype.readUIntLE = function(offset, byteLength2, noAssert) {
      offset = offset | 0, byteLength2 = byteLength2 | 0, noAssert || checkOffset(offset, byteLength2, this.length);
      for (var val = this[offset], mul = 1, i3 = 0; ++i3 < byteLength2 && (mul *= 256); )
        val += this[offset + i3] * mul;
      return val;
    };
    Buffer2.prototype.readUIntBE = function(offset, byteLength2, noAssert) {
      offset = offset | 0, byteLength2 = byteLength2 | 0, noAssert || checkOffset(offset, byteLength2, this.length);
      for (var val = this[offset + --byteLength2], mul = 1; byteLength2 > 0 && (mul *= 256); )
        val += this[offset + --byteLength2] * mul;
      return val;
    };
    Buffer2.prototype.readUInt8 = function(offset, noAssert) {
      return noAssert || checkOffset(offset, 1, this.length), this[offset];
    };
    Buffer2.prototype.readUInt16LE = function(offset, noAssert) {
      return noAssert || checkOffset(offset, 2, this.length), this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUInt16BE = function(offset, noAssert) {
      return noAssert || checkOffset(offset, 2, this.length), this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUInt32LE = function(offset, noAssert) {
      return noAssert || checkOffset(offset, 4, this.length), (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUInt32BE = function(offset, noAssert) {
      return noAssert || checkOffset(offset, 4, this.length), this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readIntLE = function(offset, byteLength2, noAssert) {
      offset = offset | 0, byteLength2 = byteLength2 | 0, noAssert || checkOffset(offset, byteLength2, this.length);
      for (var val = this[offset], mul = 1, i3 = 0; ++i3 < byteLength2 && (mul *= 256); )
        val += this[offset + i3] * mul;
      return mul *= 128, val >= mul && (val -= Math.pow(2, 8 * byteLength2)), val;
    };
    Buffer2.prototype.readIntBE = function(offset, byteLength2, noAssert) {
      offset = offset | 0, byteLength2 = byteLength2 | 0, noAssert || checkOffset(offset, byteLength2, this.length);
      for (var i3 = byteLength2, mul = 1, val = this[offset + --i3]; i3 > 0 && (mul *= 256); )
        val += this[offset + --i3] * mul;
      return mul *= 128, val >= mul && (val -= Math.pow(2, 8 * byteLength2)), val;
    };
    Buffer2.prototype.readInt8 = function(offset, noAssert) {
      return noAssert || checkOffset(offset, 1, this.length), this[offset] & 128 ? (255 - this[offset] + 1) * -1 : this[offset];
    };
    Buffer2.prototype.readInt16LE = function(offset, noAssert) {
      noAssert || checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function(offset, noAssert) {
      noAssert || checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function(offset, noAssert) {
      return noAssert || checkOffset(offset, 4, this.length), this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function(offset, noAssert) {
      return noAssert || checkOffset(offset, 4, this.length), this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readFloatLE = function(offset, noAssert) {
      return noAssert || checkOffset(offset, 4, this.length), read2(this, offset, !0, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function(offset, noAssert) {
      return noAssert || checkOffset(offset, 4, this.length), read2(this, offset, !1, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function(offset, noAssert) {
      return noAssert || checkOffset(offset, 8, this.length), read2(this, offset, !0, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function(offset, noAssert) {
      return noAssert || checkOffset(offset, 8, this.length), read2(this, offset, !1, 52, 8);
    };
    Buffer2.prototype.writeUIntLE = function(value2, offset, byteLength2, noAssert) {
      if (value2 = +value2, offset = offset | 0, byteLength2 = byteLength2 | 0, !noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value2, offset, byteLength2, maxBytes, 0);
      }
      var mul = 1, i3 = 0;
      for (this[offset] = value2 & 255; ++i3 < byteLength2 && (mul *= 256); )
        this[offset + i3] = value2 / mul & 255;
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUIntBE = function(value2, offset, byteLength2, noAssert) {
      if (value2 = +value2, offset = offset | 0, byteLength2 = byteLength2 | 0, !noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value2, offset, byteLength2, maxBytes, 0);
      }
      var i3 = byteLength2 - 1, mul = 1;
      for (this[offset + i3] = value2 & 255; --i3 >= 0 && (mul *= 256); )
        this[offset + i3] = value2 / mul & 255;
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUInt8 = function(value2, offset, noAssert) {
      return value2 = +value2, offset = offset | 0, noAssert || checkInt(this, value2, offset, 1, 255, 0), Buffer2.TYPED_ARRAY_SUPPORT || (value2 = Math.floor(value2)), this[offset] = value2 & 255, offset + 1;
    };
    Buffer2.prototype.writeUInt16LE = function(value2, offset, noAssert) {
      return value2 = +value2, offset = offset | 0, noAssert || checkInt(this, value2, offset, 2, 65535, 0), Buffer2.TYPED_ARRAY_SUPPORT ? (this[offset] = value2 & 255, this[offset + 1] = value2 >>> 8) : objectWriteUInt16(this, value2, offset, !0), offset + 2;
    };
    Buffer2.prototype.writeUInt16BE = function(value2, offset, noAssert) {
      return value2 = +value2, offset = offset | 0, noAssert || checkInt(this, value2, offset, 2, 65535, 0), Buffer2.TYPED_ARRAY_SUPPORT ? (this[offset] = value2 >>> 8, this[offset + 1] = value2 & 255) : objectWriteUInt16(this, value2, offset, !1), offset + 2;
    };
    Buffer2.prototype.writeUInt32LE = function(value2, offset, noAssert) {
      return value2 = +value2, offset = offset | 0, noAssert || checkInt(this, value2, offset, 4, 4294967295, 0), Buffer2.TYPED_ARRAY_SUPPORT ? (this[offset + 3] = value2 >>> 24, this[offset + 2] = value2 >>> 16, this[offset + 1] = value2 >>> 8, this[offset] = value2 & 255) : objectWriteUInt32(this, value2, offset, !0), offset + 4;
    };
    Buffer2.prototype.writeUInt32BE = function(value2, offset, noAssert) {
      return value2 = +value2, offset = offset | 0, noAssert || checkInt(this, value2, offset, 4, 4294967295, 0), Buffer2.TYPED_ARRAY_SUPPORT ? (this[offset] = value2 >>> 24, this[offset + 1] = value2 >>> 16, this[offset + 2] = value2 >>> 8, this[offset + 3] = value2 & 255) : objectWriteUInt32(this, value2, offset, !1), offset + 4;
    };
    Buffer2.prototype.writeIntLE = function(value2, offset, byteLength2, noAssert) {
      if (value2 = +value2, offset = offset | 0, !noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value2, offset, byteLength2, limit - 1, -limit);
      }
      var i3 = 0, mul = 1, sub = 0;
      for (this[offset] = value2 & 255; ++i3 < byteLength2 && (mul *= 256); )
        value2 < 0 && sub === 0 && this[offset + i3 - 1] !== 0 && (sub = 1), this[offset + i3] = (value2 / mul >> 0) - sub & 255;
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function(value2, offset, byteLength2, noAssert) {
      if (value2 = +value2, offset = offset | 0, !noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value2, offset, byteLength2, limit - 1, -limit);
      }
      var i3 = byteLength2 - 1, mul = 1, sub = 0;
      for (this[offset + i3] = value2 & 255; --i3 >= 0 && (mul *= 256); )
        value2 < 0 && sub === 0 && this[offset + i3 + 1] !== 0 && (sub = 1), this[offset + i3] = (value2 / mul >> 0) - sub & 255;
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function(value2, offset, noAssert) {
      return value2 = +value2, offset = offset | 0, noAssert || checkInt(this, value2, offset, 1, 127, -128), Buffer2.TYPED_ARRAY_SUPPORT || (value2 = Math.floor(value2)), value2 < 0 && (value2 = 255 + value2 + 1), this[offset] = value2 & 255, offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function(value2, offset, noAssert) {
      return value2 = +value2, offset = offset | 0, noAssert || checkInt(this, value2, offset, 2, 32767, -32768), Buffer2.TYPED_ARRAY_SUPPORT ? (this[offset] = value2 & 255, this[offset + 1] = value2 >>> 8) : objectWriteUInt16(this, value2, offset, !0), offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function(value2, offset, noAssert) {
      return value2 = +value2, offset = offset | 0, noAssert || checkInt(this, value2, offset, 2, 32767, -32768), Buffer2.TYPED_ARRAY_SUPPORT ? (this[offset] = value2 >>> 8, this[offset + 1] = value2 & 255) : objectWriteUInt16(this, value2, offset, !1), offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function(value2, offset, noAssert) {
      return value2 = +value2, offset = offset | 0, noAssert || checkInt(this, value2, offset, 4, 2147483647, -2147483648), Buffer2.TYPED_ARRAY_SUPPORT ? (this[offset] = value2 & 255, this[offset + 1] = value2 >>> 8, this[offset + 2] = value2 >>> 16, this[offset + 3] = value2 >>> 24) : objectWriteUInt32(this, value2, offset, !0), offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function(value2, offset, noAssert) {
      return value2 = +value2, offset = offset | 0, noAssert || checkInt(this, value2, offset, 4, 2147483647, -2147483648), value2 < 0 && (value2 = 4294967295 + value2 + 1), Buffer2.TYPED_ARRAY_SUPPORT ? (this[offset] = value2 >>> 24, this[offset + 1] = value2 >>> 16, this[offset + 2] = value2 >>> 8, this[offset + 3] = value2 & 255) : objectWriteUInt32(this, value2, offset, !1), offset + 4;
    };
    Buffer2.prototype.writeFloatLE = function(value2, offset, noAssert) {
      return writeFloat(this, value2, offset, !0, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function(value2, offset, noAssert) {
      return writeFloat(this, value2, offset, !1, noAssert);
    };
    Buffer2.prototype.writeDoubleLE = function(value2, offset, noAssert) {
      return writeDouble(this, value2, offset, !0, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function(value2, offset, noAssert) {
      return writeDouble(this, value2, offset, !1, noAssert);
    };
    Buffer2.prototype.copy = function(target, targetStart, start3, end3) {
      if (start3 || (start3 = 0), !end3 && end3 !== 0 && (end3 = this.length), targetStart >= target.length && (targetStart = target.length), targetStart || (targetStart = 0), end3 > 0 && end3 < start3 && (end3 = start3), end3 === start3 || target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0)
        throw new RangeError("targetStart out of bounds");
      if (start3 < 0 || start3 >= this.length)
        throw new RangeError("sourceStart out of bounds");
      if (end3 < 0)
        throw new RangeError("sourceEnd out of bounds");
      end3 > this.length && (end3 = this.length), target.length - targetStart < end3 - start3 && (end3 = target.length - targetStart + start3);
      var len = end3 - start3, i3;
      if (this === target && start3 < targetStart && targetStart < end3)
        for (i3 = len - 1; i3 >= 0; --i3)
          target[i3 + targetStart] = this[i3 + start3];
      else if (len < 1e3 || !Buffer2.TYPED_ARRAY_SUPPORT)
        for (i3 = 0; i3 < len; ++i3)
          target[i3 + targetStart] = this[i3 + start3];
      else
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start3, start3 + len),
          targetStart
        );
      return len;
    };
    Buffer2.prototype.fill = function(val, start3, end3, encoding) {
      if (typeof val == "string") {
        if (typeof start3 == "string" ? (encoding = start3, start3 = 0, end3 = this.length) : typeof end3 == "string" && (encoding = end3, end3 = this.length), val.length === 1) {
          var code = val.charCodeAt(0);
          code < 256 && (val = code);
        }
        if (encoding !== void 0 && typeof encoding != "string")
          throw new TypeError("encoding must be a string");
        if (typeof encoding == "string" && !Buffer2.isEncoding(encoding))
          throw new TypeError("Unknown encoding: " + encoding);
      } else
        typeof val == "number" && (val = val & 255);
      if (start3 < 0 || this.length < start3 || this.length < end3)
        throw new RangeError("Out of range index");
      if (end3 <= start3)
        return this;
      start3 = start3 >>> 0, end3 = end3 === void 0 ? this.length : end3 >>> 0, val || (val = 0);
      var i3;
      if (typeof val == "number")
        for (i3 = start3; i3 < end3; ++i3)
          this[i3] = val;
      else {
        var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer2(val, encoding).toString()), len = bytes.length;
        for (i3 = 0; i3 < end3 - start3; ++i3)
          this[i3 + start3] = bytes[i3 % len];
      }
      return this;
    };
    INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/buffer-list.js
function BufferList() {
  this.head = null, this.tail = null, this.length = 0;
}
var buffer_list_default, init_buffer_list = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/buffer-list.js"() {
    init_buffer();
    buffer_list_default = BufferList;
    BufferList.prototype.push = function(v2) {
      var entry2 = { data: v2, next: null };
      this.length > 0 ? this.tail.next = entry2 : this.head = entry2, this.tail = entry2, ++this.length;
    };
    BufferList.prototype.unshift = function(v2) {
      var entry2 = { data: v2, next: this.head };
      this.length === 0 && (this.tail = entry2), this.head = entry2, ++this.length;
    };
    BufferList.prototype.shift = function() {
      if (this.length !== 0) {
        var ret = this.head.data;
        return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, ret;
      }
    };
    BufferList.prototype.clear = function() {
      this.head = this.tail = null, this.length = 0;
    };
    BufferList.prototype.join = function(s3) {
      if (this.length === 0)
        return "";
      for (var p = this.head, ret = "" + p.data; p = p.next; )
        ret += s3 + p.data;
      return ret;
    };
    BufferList.prototype.concat = function(n3) {
      if (this.length === 0)
        return Buffer2.alloc(0);
      if (this.length === 1)
        return this.head.data;
      for (var ret = Buffer2.allocUnsafe(n3 >>> 0), p = this.head, i3 = 0; p; )
        p.data.copy(ret, i3), i3 += p.data.length, p = p.next;
      return ret;
    };
  }
});

// node-modules-polyfills:string_decoder
function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding))
    throw new Error("Unknown encoding: " + encoding);
}
function StringDecoder(encoding) {
  switch (this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, ""), assertEncoding(encoding), this.encoding) {
    case "utf8":
      this.surrogateSize = 3;
      break;
    case "ucs2":
    case "utf16le":
      this.surrogateSize = 2, this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case "base64":
      this.surrogateSize = 3, this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }
  this.charBuffer = new Buffer2(6), this.charReceived = 0, this.charLength = 0;
}
function passThroughWrite(buffer2) {
  return buffer2.toString(this.encoding);
}
function utf16DetectIncompleteChar(buffer2) {
  this.charReceived = buffer2.length % 2, this.charLength = this.charReceived ? 2 : 0;
}
function base64DetectIncompleteChar(buffer2) {
  this.charReceived = buffer2.length % 3, this.charLength = this.charReceived ? 3 : 0;
}
var isBufferEncoding, init_string_decoder = __esm({
  "node-modules-polyfills:string_decoder"() {
    init_buffer();
    isBufferEncoding = Buffer2.isEncoding || function(encoding) {
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return !0;
        default:
          return !1;
      }
    };
    StringDecoder.prototype.write = function(buffer2) {
      for (var charStr = ""; this.charLength; ) {
        var available = buffer2.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer2.length;
        if (buffer2.copy(this.charBuffer, this.charReceived, 0, available), this.charReceived += available, this.charReceived < this.charLength)
          return "";
        buffer2 = buffer2.slice(available, buffer2.length), charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
        var charCode = charStr.charCodeAt(charStr.length - 1);
        if (charCode >= 55296 && charCode <= 56319) {
          this.charLength += this.surrogateSize, charStr = "";
          continue;
        }
        if (this.charReceived = this.charLength = 0, buffer2.length === 0)
          return charStr;
        break;
      }
      this.detectIncompleteChar(buffer2);
      var end3 = buffer2.length;
      this.charLength && (buffer2.copy(this.charBuffer, 0, buffer2.length - this.charReceived, end3), end3 -= this.charReceived), charStr += buffer2.toString(this.encoding, 0, end3);
      var end3 = charStr.length - 1, charCode = charStr.charCodeAt(end3);
      if (charCode >= 55296 && charCode <= 56319) {
        var size = this.surrogateSize;
        return this.charLength += size, this.charReceived += size, this.charBuffer.copy(this.charBuffer, size, 0, size), buffer2.copy(this.charBuffer, 0, 0, size), charStr.substring(0, end3);
      }
      return charStr;
    };
    StringDecoder.prototype.detectIncompleteChar = function(buffer2) {
      for (var i3 = buffer2.length >= 3 ? 3 : buffer2.length; i3 > 0; i3--) {
        var c4 = buffer2[buffer2.length - i3];
        if (i3 == 1 && c4 >> 5 == 6) {
          this.charLength = 2;
          break;
        }
        if (i3 <= 2 && c4 >> 4 == 14) {
          this.charLength = 3;
          break;
        }
        if (i3 <= 3 && c4 >> 3 == 30) {
          this.charLength = 4;
          break;
        }
      }
      this.charReceived = i3;
    };
    StringDecoder.prototype.end = function(buffer2) {
      var res = "";
      if (buffer2 && buffer2.length && (res = this.write(buffer2)), this.charReceived) {
        var cr = this.charReceived, buf = this.charBuffer, enc = this.encoding;
        res += buf.slice(0, cr).toString(enc);
      }
      return res;
    };
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/readable.js
function prependListener2(emitter, event2, fn) {
  if (typeof emitter.prependListener == "function")
    return emitter.prependListener(event2, fn);
  !emitter._events || !emitter._events[event2] ? emitter.on(event2, fn) : Array.isArray(emitter._events[event2]) ? emitter._events[event2].unshift(fn) : emitter._events[event2] = [fn, emitter._events[event2]];
}
function listenerCount2(emitter, type2) {
  return emitter.listeners(type2).length;
}
function ReadableState(options2, stream) {
  options2 = options2 || {}, this.objectMode = !!options2.objectMode, stream instanceof Duplex && (this.objectMode = this.objectMode || !!options2.readableObjectMode);
  var hwm = options2.highWaterMark, defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm, this.highWaterMark = ~~this.highWaterMark, this.buffer = new buffer_list_default(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.defaultEncoding = options2.defaultEncoding || "utf8", this.ranOut = !1, this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, options2.encoding && (this.decoder = new StringDecoder(options2.encoding), this.encoding = options2.encoding);
}
function Readable(options2) {
  if (!(this instanceof Readable))
    return new Readable(options2);
  this._readableState = new ReadableState(options2, this), this.readable = !0, options2 && typeof options2.read == "function" && (this._read = options2.read), events_default.call(this);
}
function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er)
    stream.emit("error", er);
  else if (chunk === null)
    state.reading = !1, onEofChunk(stream, state);
  else if (state.objectMode || chunk && chunk.length > 0)
    if (state.ended && !addToFront) {
      var e3 = new Error("stream.push() after EOF");
      stream.emit("error", e3);
    } else if (state.endEmitted && addToFront) {
      var _e2 = new Error("stream.unshift() after end event");
      stream.emit("error", _e2);
    } else {
      var skipAdd;
      state.decoder && !addToFront && !encoding && (chunk = state.decoder.write(chunk), skipAdd = !state.objectMode && chunk.length === 0), addToFront || (state.reading = !1), skipAdd || (state.flowing && state.length === 0 && !state.sync ? (stream.emit("data", chunk), stream.read(0)) : (state.length += state.objectMode ? 1 : chunk.length, addToFront ? state.buffer.unshift(chunk) : state.buffer.push(chunk), state.needReadable && emitReadable(stream))), maybeReadMore(stream, state);
    }
  else
    addToFront || (state.reading = !1);
  return needMoreData(state);
}
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}
function computeNewHighWaterMark(n3) {
  return n3 >= MAX_HWM ? n3 = MAX_HWM : (n3--, n3 |= n3 >>> 1, n3 |= n3 >>> 2, n3 |= n3 >>> 4, n3 |= n3 >>> 8, n3 |= n3 >>> 16, n3++), n3;
}
function howMuchToRead(n3, state) {
  return n3 <= 0 || state.length === 0 && state.ended ? 0 : state.objectMode ? 1 : n3 !== n3 ? state.flowing && state.length ? state.buffer.head.data.length : state.length : (n3 > state.highWaterMark && (state.highWaterMark = computeNewHighWaterMark(n3)), n3 <= state.length ? n3 : state.ended ? state.length : (state.needReadable = !0, 0));
}
function chunkInvalid(state, chunk) {
  var er = null;
  return !Buffer.isBuffer(chunk) && typeof chunk != "string" && chunk !== null && chunk !== void 0 && !state.objectMode && (er = new TypeError("Invalid non-string/buffer chunk")), er;
}
function onEofChunk(stream, state) {
  if (!state.ended) {
    if (state.decoder) {
      var chunk = state.decoder.end();
      chunk && chunk.length && (state.buffer.push(chunk), state.length += state.objectMode ? 1 : chunk.length);
    }
    state.ended = !0, emitReadable(stream);
  }
}
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = !1, state.emittedReadable || (debug("emitReadable", state.flowing), state.emittedReadable = !0, state.sync ? nextTick(emitReadable_, stream) : emitReadable_(stream));
}
function emitReadable_(stream) {
  debug("emit readable"), stream.emit("readable"), flow(stream);
}
function maybeReadMore(stream, state) {
  state.readingMore || (state.readingMore = !0, nextTick(maybeReadMore_, stream, state));
}
function maybeReadMore_(stream, state) {
  for (var len = state.length; !state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark && (debug("maybeReadMore read 0"), stream.read(0), len !== state.length); )
    len = state.length;
  state.readingMore = !1;
}
function pipeOnDrain(src) {
  return function() {
    var state = src._readableState;
    debug("pipeOnDrain", state.awaitDrain), state.awaitDrain && state.awaitDrain--, state.awaitDrain === 0 && src.listeners("data").length && (state.flowing = !0, flow(src));
  };
}
function nReadingNextTick(self) {
  debug("readable nexttick read 0"), self.read(0);
}
function resume(stream, state) {
  state.resumeScheduled || (state.resumeScheduled = !0, nextTick(resume_, stream, state));
}
function resume_(stream, state) {
  state.reading || (debug("resume read 0"), stream.read(0)), state.resumeScheduled = !1, state.awaitDrain = 0, stream.emit("resume"), flow(stream), state.flowing && !state.reading && stream.read(0);
}
function flow(stream) {
  var state = stream._readableState;
  for (debug("flow", state.flowing); state.flowing && stream.read() !== null; )
    ;
}
function fromList(n3, state) {
  if (state.length === 0)
    return null;
  var ret;
  return state.objectMode ? ret = state.buffer.shift() : !n3 || n3 >= state.length ? (state.decoder ? ret = state.buffer.join("") : state.buffer.length === 1 ? ret = state.buffer.head.data : ret = state.buffer.concat(state.length), state.buffer.clear()) : ret = fromListPartial(n3, state.buffer, state.decoder), ret;
}
function fromListPartial(n3, list, hasStrings) {
  var ret;
  return n3 < list.head.data.length ? (ret = list.head.data.slice(0, n3), list.head.data = list.head.data.slice(n3)) : n3 === list.head.data.length ? ret = list.shift() : ret = hasStrings ? copyFromBufferString(n3, list) : copyFromBuffer(n3, list), ret;
}
function copyFromBufferString(n3, list) {
  var p = list.head, c4 = 1, ret = p.data;
  for (n3 -= ret.length; p = p.next; ) {
    var str2 = p.data, nb = n3 > str2.length ? str2.length : n3;
    if (nb === str2.length ? ret += str2 : ret += str2.slice(0, n3), n3 -= nb, n3 === 0) {
      nb === str2.length ? (++c4, p.next ? list.head = p.next : list.head = list.tail = null) : (list.head = p, p.data = str2.slice(nb));
      break;
    }
    ++c4;
  }
  return list.length -= c4, ret;
}
function copyFromBuffer(n3, list) {
  var ret = Buffer.allocUnsafe(n3), p = list.head, c4 = 1;
  for (p.data.copy(ret), n3 -= p.data.length; p = p.next; ) {
    var buf = p.data, nb = n3 > buf.length ? buf.length : n3;
    if (buf.copy(ret, ret.length - n3, 0, nb), n3 -= nb, n3 === 0) {
      nb === buf.length ? (++c4, p.next ? list.head = p.next : list.head = list.tail = null) : (list.head = p, p.data = buf.slice(nb));
      break;
    }
    ++c4;
  }
  return list.length -= c4, ret;
}
function endReadable(stream) {
  var state = stream._readableState;
  if (state.length > 0)
    throw new Error('"endReadable()" called on non-empty stream');
  state.endEmitted || (state.ended = !0, nextTick(endReadableNT, state, stream));
}
function endReadableNT(state, stream) {
  !state.endEmitted && state.length === 0 && (state.endEmitted = !0, stream.readable = !1, stream.emit("end"));
}
function forEach(xs, f2) {
  for (var i3 = 0, l2 = xs.length; i3 < l2; i3++)
    f2(xs[i3], i3);
}
function indexOf2(xs, x2) {
  for (var i3 = 0, l2 = xs.length; i3 < l2; i3++)
    if (xs[i3] === x2)
      return i3;
  return -1;
}
var debug, MAX_HWM, init_readable = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/readable.js"() {
    "use strict";
    init_events();
    init_util();
    init_buffer_list();
    init_string_decoder();
    init_duplex();
    init_process();
    Readable.ReadableState = ReadableState;
    debug = debuglog("stream");
    inherits_default(Readable, events_default);
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      return !state.objectMode && typeof chunk == "string" && (encoding = encoding || state.defaultEncoding, encoding !== state.encoding && (chunk = Buffer.from(chunk, encoding), encoding = "")), readableAddChunk(this, state, chunk, encoding, !1);
    };
    Readable.prototype.unshift = function(chunk) {
      var state = this._readableState;
      return readableAddChunk(this, state, chunk, "", !0);
    };
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === !1;
    };
    Readable.prototype.setEncoding = function(enc) {
      return this._readableState.decoder = new StringDecoder(enc), this._readableState.encoding = enc, this;
    };
    MAX_HWM = 8388608;
    Readable.prototype.read = function(n3) {
      debug("read", n3), n3 = parseInt(n3, 10);
      var state = this._readableState, nOrig = n3;
      if (n3 !== 0 && (state.emittedReadable = !1), n3 === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended))
        return debug("read: emitReadable", state.length, state.ended), state.length === 0 && state.ended ? endReadable(this) : emitReadable(this), null;
      if (n3 = howMuchToRead(n3, state), n3 === 0 && state.ended)
        return state.length === 0 && endReadable(this), null;
      var doRead = state.needReadable;
      debug("need readable", doRead), (state.length === 0 || state.length - n3 < state.highWaterMark) && (doRead = !0, debug("length less than watermark", doRead)), state.ended || state.reading ? (doRead = !1, debug("reading or ended", doRead)) : doRead && (debug("do read"), state.reading = !0, state.sync = !0, state.length === 0 && (state.needReadable = !0), this._read(state.highWaterMark), state.sync = !1, state.reading || (n3 = howMuchToRead(nOrig, state)));
      var ret;
      return n3 > 0 ? ret = fromList(n3, state) : ret = null, ret === null ? (state.needReadable = !0, n3 = 0) : state.length -= n3, state.length === 0 && (state.ended || (state.needReadable = !0), nOrig !== n3 && state.ended && endReadable(this)), ret !== null && this.emit("data", ret), ret;
    };
    Readable.prototype._read = function(n3) {
      this.emit("error", new Error("not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this, state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1, debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = !pipeOpts || pipeOpts.end !== !1, endFn = doEnd ? onend2 : cleanup;
      state.endEmitted ? nextTick(endFn) : src.once("end", endFn), dest.on("unpipe", onunpipe);
      function onunpipe(readable) {
        debug("onunpipe"), readable === src && cleanup();
      }
      function onend2() {
        debug("onend"), dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = !1;
      function cleanup() {
        debug("cleanup"), dest.removeListener("close", onclose), dest.removeListener("finish", onfinish), dest.removeListener("drain", ondrain), dest.removeListener("error", onerror), dest.removeListener("unpipe", onunpipe), src.removeListener("end", onend2), src.removeListener("end", cleanup), src.removeListener("data", ondata), cleanedUp = !0, state.awaitDrain && (!dest._writableState || dest._writableState.needDrain) && ondrain();
      }
      var increasedAwaitDrain = !1;
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata"), increasedAwaitDrain = !1;
        var ret = dest.write(chunk);
        ret === !1 && !increasedAwaitDrain && ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf2(state.pipes, dest) !== -1) && !cleanedUp && (debug("false write response, pause", src._readableState.awaitDrain), src._readableState.awaitDrain++, increasedAwaitDrain = !0), src.pause());
      }
      function onerror(er) {
        debug("onerror", er), unpipe(), dest.removeListener("error", onerror), listenerCount2(dest, "error") === 0 && dest.emit("error", er);
      }
      prependListener2(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish), unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish"), dest.removeListener("close", onclose), unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe"), src.unpipe(dest);
      }
      return dest.emit("pipe", src), state.flowing || (debug("pipe resume"), src.resume()), dest;
    };
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1)
        return dest && dest !== state.pipes ? this : (dest || (dest = state.pipes), state.pipes = null, state.pipesCount = 0, state.flowing = !1, dest && dest.emit("unpipe", this), this);
      if (!dest) {
        var dests = state.pipes, len = state.pipesCount;
        state.pipes = null, state.pipesCount = 0, state.flowing = !1;
        for (var _i = 0; _i < len; _i++)
          dests[_i].emit("unpipe", this);
        return this;
      }
      var i3 = indexOf2(state.pipes, dest);
      return i3 === -1 ? this : (state.pipes.splice(i3, 1), state.pipesCount -= 1, state.pipesCount === 1 && (state.pipes = state.pipes[0]), dest.emit("unpipe", this), this);
    };
    Readable.prototype.on = function(ev, fn) {
      var res = events_default.prototype.on.call(this, ev, fn);
      if (ev === "data")
        this._readableState.flowing !== !1 && this.resume();
      else if (ev === "readable") {
        var state = this._readableState;
        !state.endEmitted && !state.readableListening && (state.readableListening = state.needReadable = !0, state.emittedReadable = !1, state.reading ? state.length && emitReadable(this, state) : nextTick(nReadingNextTick, this));
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.resume = function() {
      var state = this._readableState;
      return state.flowing || (debug("resume"), state.flowing = !0, resume(this, state)), this;
    };
    Readable.prototype.pause = function() {
      return debug("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (debug("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
    };
    Readable.prototype.wrap = function(stream) {
      var state = this._readableState, paused = !1, self = this;
      stream.on("end", function() {
        if (debug("wrapped end"), state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          chunk && chunk.length && self.push(chunk);
        }
        self.push(null);
      }), stream.on("data", function(chunk) {
        if (debug("wrapped data"), state.decoder && (chunk = state.decoder.write(chunk)), !(state.objectMode && chunk == null) && !(!state.objectMode && (!chunk || !chunk.length))) {
          var ret = self.push(chunk);
          ret || (paused = !0, stream.pause());
        }
      });
      for (var i3 in stream)
        this[i3] === void 0 && typeof stream[i3] == "function" && (this[i3] = function(method) {
          return function() {
            return stream[method].apply(stream, arguments);
          };
        }(i3));
      var events2 = ["error", "close", "destroy", "pause", "resume"];
      return forEach(events2, function(ev) {
        stream.on(ev, self.emit.bind(self, ev));
      }), self._read = function(n3) {
        debug("wrapped _read", n3), paused && (paused = !1, stream.resume());
      }, self;
    };
    Readable._fromList = fromList;
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/writable.js
function nop() {
}
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk, this.encoding = encoding, this.callback = cb, this.next = null;
}
function WritableState(options2, stream) {
  Object.defineProperty(this, "buffer", {
    get: deprecate(function() {
      return this.getBuffer();
    }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.")
  }), options2 = options2 || {}, this.objectMode = !!options2.objectMode, stream instanceof Duplex && (this.objectMode = this.objectMode || !!options2.writableObjectMode);
  var hwm = options2.highWaterMark, defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm, this.highWaterMark = ~~this.highWaterMark, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1;
  var noDecode = options2.decodeStrings === !1;
  this.decodeStrings = !noDecode, this.defaultEncoding = options2.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(er) {
    onwrite(stream, er);
  }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new CorkedRequest(this);
}
function Writable(options2) {
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options2);
  this._writableState = new WritableState(options2, this), this.writable = !0, options2 && (typeof options2.write == "function" && (this._write = options2.write), typeof options2.writev == "function" && (this._writev = options2.writev)), EventEmitter.call(this);
}
function writeAfterEnd(stream, cb) {
  var er = new Error("write after end");
  stream.emit("error", er), nextTick(cb, er);
}
function validChunk(stream, state, chunk, cb) {
  var valid = !0, er = !1;
  return chunk === null ? er = new TypeError("May not write null values to stream") : !Buffer2.isBuffer(chunk) && typeof chunk != "string" && chunk !== void 0 && !state.objectMode && (er = new TypeError("Invalid non-string/buffer chunk")), er && (stream.emit("error", er), nextTick(cb, er), valid = !1), valid;
}
function decodeChunk(state, chunk, encoding) {
  return !state.objectMode && state.decodeStrings !== !1 && typeof chunk == "string" && (chunk = Buffer2.from(chunk, encoding)), chunk;
}
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding), Buffer2.isBuffer(chunk) && (encoding = "buffer");
  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark;
  if (ret || (state.needDrain = !0), state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb), last ? last.next = state.lastBufferedRequest : state.bufferedRequest = state.lastBufferedRequest, state.bufferedRequestCount += 1;
  } else
    doWrite(stream, state, !1, len, chunk, encoding, cb);
  return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len, state.writecb = cb, state.writing = !0, state.sync = !0, writev ? stream._writev(chunk, state.onwrite) : stream._write(chunk, encoding, state.onwrite), state.sync = !1;
}
function onwriteError(stream, state, sync2, er, cb) {
  --state.pendingcb, sync2 ? nextTick(cb, er) : cb(er), stream._writableState.errorEmitted = !0, stream.emit("error", er);
}
function onwriteStateUpdate(state) {
  state.writing = !1, state.writecb = null, state.length -= state.writelen, state.writelen = 0;
}
function onwrite(stream, er) {
  var state = stream._writableState, sync2 = state.sync, cb = state.writecb;
  if (onwriteStateUpdate(state), er)
    onwriteError(stream, state, sync2, er, cb);
  else {
    var finished = needFinish(state);
    !finished && !state.corked && !state.bufferProcessing && state.bufferedRequest && clearBuffer(stream, state), sync2 ? nextTick(afterWrite, stream, state, finished, cb) : afterWrite(stream, state, finished, cb);
  }
}
function afterWrite(stream, state, finished, cb) {
  finished || onwriteDrain(stream, state), state.pendingcb--, cb(), finishMaybe(stream, state);
}
function onwriteDrain(stream, state) {
  state.length === 0 && state.needDrain && (state.needDrain = !1, stream.emit("drain"));
}
function clearBuffer(stream, state) {
  state.bufferProcessing = !0;
  var entry2 = state.bufferedRequest;
  if (stream._writev && entry2 && entry2.next) {
    var l2 = state.bufferedRequestCount, buffer2 = new Array(l2), holder = state.corkedRequestsFree;
    holder.entry = entry2;
    for (var count = 0; entry2; )
      buffer2[count] = entry2, entry2 = entry2.next, count += 1;
    doWrite(stream, state, !0, state.length, buffer2, "", holder.finish), state.pendingcb++, state.lastBufferedRequest = null, holder.next ? (state.corkedRequestsFree = holder.next, holder.next = null) : state.corkedRequestsFree = new CorkedRequest(state);
  } else {
    for (; entry2; ) {
      var chunk = entry2.chunk, encoding = entry2.encoding, cb = entry2.callback, len = state.objectMode ? 1 : chunk.length;
      if (doWrite(stream, state, !1, len, chunk, encoding, cb), entry2 = entry2.next, state.writing)
        break;
    }
    entry2 === null && (state.lastBufferedRequest = null);
  }
  state.bufferedRequestCount = 0, state.bufferedRequest = entry2, state.bufferProcessing = !1;
}
function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function prefinish(stream, state) {
  state.prefinished || (state.prefinished = !0, stream.emit("prefinish"));
}
function finishMaybe(stream, state) {
  var need = needFinish(state);
  return need && (state.pendingcb === 0 ? (prefinish(stream, state), state.finished = !0, stream.emit("finish")) : prefinish(stream, state)), need;
}
function endWritable(stream, state, cb) {
  state.ending = !0, finishMaybe(stream, state), cb && (state.finished ? nextTick(cb) : stream.once("finish", cb)), state.ended = !0, stream.writable = !1;
}
function CorkedRequest(state) {
  var _this = this;
  this.next = null, this.entry = null, this.finish = function(err) {
    var entry2 = _this.entry;
    for (_this.entry = null; entry2; ) {
      var cb = entry2.callback;
      state.pendingcb--, cb(err), entry2 = entry2.next;
    }
    state.corkedRequestsFree ? state.corkedRequestsFree.next = _this : state.corkedRequestsFree = _this;
  };
}
var init_writable = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/writable.js"() {
    init_util();
    init_buffer();
    init_events();
    init_duplex();
    init_process();
    Writable.WritableState = WritableState;
    inherits_default(Writable, EventEmitter);
    WritableState.prototype.getBuffer = function() {
      for (var current = this.bufferedRequest, out = []; current; )
        out.push(current), current = current.next;
      return out;
    };
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState, ret = !1;
      return typeof encoding == "function" && (cb = encoding, encoding = null), Buffer2.isBuffer(chunk) ? encoding = "buffer" : encoding || (encoding = state.defaultEncoding), typeof cb != "function" && (cb = nop), state.ended ? writeAfterEnd(this, cb) : validChunk(this, state, chunk, cb) && (state.pendingcb++, ret = writeOrBuffer(this, state, chunk, encoding, cb)), ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      state.corked && (state.corked--, !state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest && clearBuffer(this, state));
    };
    Writable.prototype.setDefaultEncoding = function(encoding) {
      if (typeof encoding == "string" && (encoding = encoding.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new TypeError("Unknown encoding: " + encoding);
      return this._writableState.defaultEncoding = encoding, this;
    };
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      typeof chunk == "function" ? (cb = chunk, chunk = null, encoding = null) : typeof encoding == "function" && (cb = encoding, encoding = null), chunk != null && this.write(chunk, encoding), state.corked && (state.corked = 1, this.uncork()), !state.ending && !state.finished && endWritable(this, state, cb);
    };
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/duplex.js
function Duplex(options2) {
  if (!(this instanceof Duplex))
    return new Duplex(options2);
  Readable.call(this, options2), Writable.call(this, options2), options2 && options2.readable === !1 && (this.readable = !1), options2 && options2.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, options2 && options2.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", onend);
}
function onend() {
  this.allowHalfOpen || this._writableState.ended || nextTick(onEndNT, this);
}
function onEndNT(self) {
  self.end();
}
var keys, method, v2, init_duplex = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/duplex.js"() {
    init_util();
    init_process();
    init_readable();
    init_writable();
    inherits_default(Duplex, Readable);
    keys = Object.keys(Writable.prototype);
    for (v2 = 0; v2 < keys.length; v2++)
      method = keys[v2], Duplex.prototype[method] || (Duplex.prototype[method] = Writable.prototype[method]);
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/transform.js
function TransformState(stream) {
  this.afterTransform = function(er, data2) {
    return afterTransform(stream, er, data2);
  }, this.needTransform = !1, this.transforming = !1, this.writecb = null, this.writechunk = null, this.writeencoding = null;
}
function afterTransform(stream, er, data2) {
  var ts = stream._transformState;
  ts.transforming = !1;
  var cb = ts.writecb;
  if (!cb)
    return stream.emit("error", new Error("no writecb in Transform class"));
  ts.writechunk = null, ts.writecb = null, data2 != null && stream.push(data2), cb(er);
  var rs = stream._readableState;
  rs.reading = !1, (rs.needReadable || rs.length < rs.highWaterMark) && stream._read(rs.highWaterMark);
}
function Transform(options2) {
  if (!(this instanceof Transform))
    return new Transform(options2);
  Duplex.call(this, options2), this._transformState = new TransformState(this);
  var stream = this;
  this._readableState.needReadable = !0, this._readableState.sync = !1, options2 && (typeof options2.transform == "function" && (this._transform = options2.transform), typeof options2.flush == "function" && (this._flush = options2.flush)), this.once("prefinish", function() {
    typeof this._flush == "function" ? this._flush(function(er) {
      done(stream, er);
    }) : done(stream);
  });
}
function done(stream, er) {
  if (er)
    return stream.emit("error", er);
  var ws = stream._writableState, ts = stream._transformState;
  if (ws.length)
    throw new Error("Calling transform done when ws.length != 0");
  if (ts.transforming)
    throw new Error("Calling transform done when still transforming");
  return stream.push(null);
}
var init_transform = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/transform.js"() {
    init_duplex();
    init_util();
    inherits_default(Transform, Duplex);
    Transform.prototype.push = function(chunk, encoding) {
      return this._transformState.needTransform = !1, Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("Not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      if (ts.writecb = cb, ts.writechunk = chunk, ts.writeencoding = encoding, !ts.transforming) {
        var rs = this._readableState;
        (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) && this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n3) {
      var ts = this._transformState;
      ts.writechunk !== null && ts.writecb && !ts.transforming ? (ts.transforming = !0, this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform)) : ts.needTransform = !0;
    };
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/passthrough.js
function PassThrough(options2) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options2);
  Transform.call(this, options2);
}
var init_passthrough = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/passthrough.js"() {
    init_transform();
    init_util();
    inherits_default(PassThrough, Transform);
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node-modules-polyfills:stream
var stream_exports = {};
__export(stream_exports, {
  Duplex: () => Duplex,
  PassThrough: () => PassThrough,
  Readable: () => Readable,
  Stream: () => Stream,
  Transform: () => Transform,
  Writable: () => Writable,
  default: () => stream_default
});
function Stream() {
  events_default.call(this);
}
var stream_default, init_stream = __esm({
  "node-modules-polyfills:stream"() {
    init_events();
    init_util();
    init_duplex();
    init_readable();
    init_writable();
    init_transform();
    init_passthrough();
    inherits_default(Stream, events_default);
    Stream.Readable = Readable;
    Stream.Writable = Writable;
    Stream.Duplex = Duplex;
    Stream.Transform = Transform;
    Stream.PassThrough = PassThrough;
    Stream.Stream = Stream;
    stream_default = Stream;
    Stream.prototype.pipe = function(dest, options2) {
      var source2 = this;
      function ondata(chunk) {
        dest.writable && dest.write(chunk) === !1 && source2.pause && source2.pause();
      }
      source2.on("data", ondata);
      function ondrain() {
        source2.readable && source2.resume && source2.resume();
      }
      dest.on("drain", ondrain), !dest._isStdio && (!options2 || options2.end !== !1) && (source2.on("end", onend2), source2.on("close", onclose));
      var didOnEnd = !1;
      function onend2() {
        didOnEnd || (didOnEnd = !0, dest.end());
      }
      function onclose() {
        didOnEnd || (didOnEnd = !0, typeof dest.destroy == "function" && dest.destroy());
      }
      function onerror(er) {
        if (cleanup(), events_default.listenerCount(this, "error") === 0)
          throw er;
      }
      source2.on("error", onerror), dest.on("error", onerror);
      function cleanup() {
        source2.removeListener("data", ondata), dest.removeListener("drain", ondrain), source2.removeListener("end", onend2), source2.removeListener("close", onclose), source2.removeListener("error", onerror), dest.removeListener("error", onerror), source2.removeListener("end", cleanup), source2.removeListener("close", cleanup), dest.removeListener("close", cleanup);
      }
      return source2.on("end", cleanup), source2.on("close", cleanup), dest.on("close", cleanup), dest.emit("pipe", source2), dest;
    };
  }
});

// node-modules-polyfills-commonjs:stream
var require_stream = __commonJS({
  "node-modules-polyfills-commonjs:stream"(exports, module2) {
    var polyfill = (init_stream(), __toCommonJS(stream_exports));
    if (polyfill && polyfill.default) {
      module2.exports = polyfill.default;
      for (let k2 in polyfill)
        module2.exports[k2] = polyfill[k2];
    } else
      polyfill && (module2.exports = polyfill);
  }
});

// node_modules/react/cjs/react-jsx-dev-runtime.development.js
var require_react_jsx_dev_runtime_development = __commonJS({
  "node_modules/react/cjs/react-jsx-dev-runtime.development.js"(exports) {
    "use strict";
    (function() {
      "use strict";
      var React17 = require_react(), REACT_ELEMENT_TYPE = Symbol.for("react.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_PROVIDER_TYPE = Symbol.for("react.provider"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable != "object")
          return null;
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        return typeof maybeIterator == "function" ? maybeIterator : null;
      }
      var ReactSharedInternals = React17.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function error2(format2) {
        {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)
            args[_key2 - 1] = arguments[_key2];
          printWarning("error", format2, args);
        }
      }
      function printWarning(level, format2, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame, stack2 = ReactDebugCurrentFrame2.getStackAddendum();
          stack2 !== "" && (format2 += "%s", args = args.concat([stack2]));
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format2), Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      var enableScopeAPI = !1, enableCacheElement = !1, enableTransitionTracing = !1, enableLegacyHidden = !1, enableDebugTracing = !1, REACT_MODULE_REFERENCE;
      REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
      function isValidElementType(type2) {
        return !!(typeof type2 == "string" || typeof type2 == "function" || type2 === REACT_FRAGMENT_TYPE || type2 === REACT_PROFILER_TYPE || enableDebugTracing || type2 === REACT_STRICT_MODE_TYPE || type2 === REACT_SUSPENSE_TYPE || type2 === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type2 === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing || typeof type2 == "object" && type2 !== null && (type2.$$typeof === REACT_LAZY_TYPE || type2.$$typeof === REACT_MEMO_TYPE || type2.$$typeof === REACT_PROVIDER_TYPE || type2.$$typeof === REACT_CONTEXT_TYPE || type2.$$typeof === REACT_FORWARD_REF_TYPE || type2.$$typeof === REACT_MODULE_REFERENCE || type2.getModuleId !== void 0));
      }
      function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName;
        if (displayName)
          return displayName;
        var functionName = innerType.displayName || innerType.name || "";
        return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
      }
      function getContextName(type2) {
        return type2.displayName || "Context";
      }
      function getComponentNameFromType(type2) {
        if (type2 == null)
          return null;
        if (typeof type2.tag == "number" && error2("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof type2 == "function")
          return type2.displayName || type2.name || null;
        if (typeof type2 == "string")
          return type2;
        switch (type2) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type2 == "object")
          switch (type2.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type2;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type2;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type2, type2.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              var outerName = type2.displayName || null;
              return outerName !== null ? outerName : getComponentNameFromType(type2.type) || "Memo";
            case REACT_LAZY_TYPE: {
              var lazyComponent = type2, payload = lazyComponent._payload, init4 = lazyComponent._init;
              try {
                return getComponentNameFromType(init4(payload));
              } catch {
                return null;
              }
            }
          }
        return null;
      }
      var assign = Object.assign, disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
      function disabledLog() {
      }
      disabledLog.__reactDisabledLog = !0;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log, prevInfo = console.info, prevWarn = console.warn, prevError = console.error, prevGroup = console.group, prevGroupCollapsed = console.groupCollapsed, prevGroupEnd = console.groupEnd;
            var props = {
              configurable: !0,
              enumerable: !0,
              value: disabledLog,
              writable: !0
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          if (disabledDepth--, disabledDepth === 0) {
            var props = {
              configurable: !0,
              enumerable: !0,
              writable: !0
            };
            Object.defineProperties(console, {
              log: assign({}, props, {
                value: prevLog
              }),
              info: assign({}, props, {
                value: prevInfo
              }),
              warn: assign({}, props, {
                value: prevWarn
              }),
              error: assign({}, props, {
                value: prevError
              }),
              group: assign({}, props, {
                value: prevGroup
              }),
              groupCollapsed: assign({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: assign({}, props, {
                value: prevGroupEnd
              })
            });
          }
          disabledDepth < 0 && error2("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
      }
      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher, prefix;
      function describeBuiltInComponentFrame(name, source2, ownerFn) {
        {
          if (prefix === void 0)
            try {
              throw Error();
            } catch (x2) {
              var match = x2.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
            }
          return `
` + prefix + name;
        }
      }
      var reentry = !1, componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap == "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap();
      }
      function describeNativeComponentFrame(fn, construct4) {
        if (!fn || reentry)
          return "";
        {
          var frame = componentFrameCache.get(fn);
          if (frame !== void 0)
            return frame;
        }
        var control;
        reentry = !0;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var previousDispatcher;
        previousDispatcher = ReactCurrentDispatcher.current, ReactCurrentDispatcher.current = null, disableLogs();
        try {
          if (construct4) {
            var Fake = function() {
              throw Error();
            };
            if (Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x2) {
                control = x2;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x2) {
                control = x2;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x2) {
              control = x2;
            }
            fn();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack == "string") {
            for (var sampleLines = sample.stack.split(`
`), controlLines = control.stack.split(`
`), s3 = sampleLines.length - 1, c4 = controlLines.length - 1; s3 >= 1 && c4 >= 0 && sampleLines[s3] !== controlLines[c4]; )
              c4--;
            for (; s3 >= 1 && c4 >= 0; s3--, c4--)
              if (sampleLines[s3] !== controlLines[c4]) {
                if (s3 !== 1 || c4 !== 1)
                  do
                    if (s3--, c4--, c4 < 0 || sampleLines[s3] !== controlLines[c4]) {
                      var _frame = `
` + sampleLines[s3].replace(" at new ", " at ");
                      return fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName)), typeof fn == "function" && componentFrameCache.set(fn, _frame), _frame;
                    }
                  while (s3 >= 1 && c4 >= 0);
                break;
              }
          }
        } finally {
          reentry = !1, ReactCurrentDispatcher.current = previousDispatcher, reenableLogs(), Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name = fn ? fn.displayName || fn.name : "", syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
        return typeof fn == "function" && componentFrameCache.set(fn, syntheticFrame), syntheticFrame;
      }
      function describeFunctionComponentFrame(fn, source2, ownerFn) {
        return describeNativeComponentFrame(fn, !1);
      }
      function shouldConstruct(Component3) {
        var prototype = Component3.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type2, source2, ownerFn) {
        if (type2 == null)
          return "";
        if (typeof type2 == "function")
          return describeNativeComponentFrame(type2, shouldConstruct(type2));
        if (typeof type2 == "string")
          return describeBuiltInComponentFrame(type2);
        switch (type2) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type2 == "object")
          switch (type2.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type2.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type2.type, source2, ownerFn);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type2, payload = lazyComponent._payload, init4 = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init4(payload), source2, ownerFn);
              } catch {
              }
            }
          }
        return "";
      }
      var hasOwnProperty2 = Object.prototype.hasOwnProperty, loggedTypeFailures = {}, ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        if (element) {
          var owner = element._owner, stack2 = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
          ReactDebugCurrentFrame.setExtraStackFrame(stack2);
        } else
          ReactDebugCurrentFrame.setExtraStackFrame(null);
      }
      function checkPropTypes(typeSpecs, values, location, componentName, element) {
        {
          var has = Function.call.bind(hasOwnProperty2);
          for (var typeSpecName in typeSpecs)
            if (has(typeSpecs, typeSpecName)) {
              var error$1 = void 0;
              try {
                if (typeof typeSpecs[typeSpecName] != "function") {
                  var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw err.name = "Invariant Violation", err;
                }
                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex) {
                error$1 = ex;
              }
              error$1 && !(error$1 instanceof Error) && (setCurrentlyValidatingElement(element), error2("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1), setCurrentlyValidatingElement(null)), error$1 instanceof Error && !(error$1.message in loggedTypeFailures) && (loggedTypeFailures[error$1.message] = !0, setCurrentlyValidatingElement(element), error2("Failed %s type: %s", location, error$1.message), setCurrentlyValidatingElement(null));
            }
        }
      }
      var isArrayImpl = Array.isArray;
      function isArray3(a3) {
        return isArrayImpl(a3);
      }
      function typeName(value2) {
        {
          var hasToStringTag = typeof Symbol == "function" && Symbol.toStringTag, type2 = hasToStringTag && value2[Symbol.toStringTag] || value2.constructor.name || "Object";
          return type2;
        }
      }
      function willCoercionThrow(value2) {
        try {
          return testStringCoercion(value2), !1;
        } catch {
          return !0;
        }
      }
      function testStringCoercion(value2) {
        return "" + value2;
      }
      function checkKeyStringCoercion(value2) {
        if (willCoercionThrow(value2))
          return error2("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value2)), testStringCoercion(value2);
      }
      var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner, RESERVED_PROPS = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
      }, specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
      didWarnAboutStringRefs = {};
      function hasValidRef(config2) {
        if (hasOwnProperty2.call(config2, "ref")) {
          var getter = Object.getOwnPropertyDescriptor(config2, "ref").get;
          if (getter && getter.isReactWarning)
            return !1;
        }
        return config2.ref !== void 0;
      }
      function hasValidKey(config2) {
        if (hasOwnProperty2.call(config2, "key")) {
          var getter = Object.getOwnPropertyDescriptor(config2, "key").get;
          if (getter && getter.isReactWarning)
            return !1;
        }
        return config2.key !== void 0;
      }
      function warnIfStringRefCannotBeAutoConverted(config2, self) {
        if (typeof config2.ref == "string" && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {
          var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
          didWarnAboutStringRefs[componentName] || (error2('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config2.ref), didWarnAboutStringRefs[componentName] = !0);
        }
      }
      function defineKeyPropWarningGetter(props, displayName) {
        {
          var warnAboutAccessingKey = function() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = !0, error2("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName));
          };
          warnAboutAccessingKey.isReactWarning = !0, Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: !0
          });
        }
      }
      function defineRefPropWarningGetter(props, displayName) {
        {
          var warnAboutAccessingRef = function() {
            specialPropRefWarningShown || (specialPropRefWarningShown = !0, error2("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName));
          };
          warnAboutAccessingRef.isReactWarning = !0, Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: !0
          });
        }
      }
      var ReactElement = function(type2, key2, ref, self, source2, owner, props) {
        var element = {
          $$typeof: REACT_ELEMENT_TYPE,
          type: type2,
          key: key2,
          ref,
          props,
          _owner: owner
        };
        return element._store = {}, Object.defineProperty(element._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: !1
        }), Object.defineProperty(element, "_self", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: self
        }), Object.defineProperty(element, "_source", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: source2
        }), Object.freeze && (Object.freeze(element.props), Object.freeze(element)), element;
      };
      function jsxDEV46(type2, config2, maybeKey, source2, self) {
        {
          var propName, props = {}, key2 = null, ref = null;
          maybeKey !== void 0 && (checkKeyStringCoercion(maybeKey), key2 = "" + maybeKey), hasValidKey(config2) && (checkKeyStringCoercion(config2.key), key2 = "" + config2.key), hasValidRef(config2) && (ref = config2.ref, warnIfStringRefCannotBeAutoConverted(config2, self));
          for (propName in config2)
            hasOwnProperty2.call(config2, propName) && !RESERVED_PROPS.hasOwnProperty(propName) && (props[propName] = config2[propName]);
          if (type2 && type2.defaultProps) {
            var defaultProps = type2.defaultProps;
            for (propName in defaultProps)
              props[propName] === void 0 && (props[propName] = defaultProps[propName]);
          }
          if (key2 || ref) {
            var displayName = typeof type2 == "function" ? type2.displayName || type2.name || "Unknown" : type2;
            key2 && defineKeyPropWarningGetter(props, displayName), ref && defineRefPropWarningGetter(props, displayName);
          }
          return ReactElement(type2, key2, ref, self, source2, ReactCurrentOwner.current, props);
        }
      }
      var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner, ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement$1(element) {
        if (element) {
          var owner = element._owner, stack2 = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
          ReactDebugCurrentFrame$1.setExtraStackFrame(stack2);
        } else
          ReactDebugCurrentFrame$1.setExtraStackFrame(null);
      }
      var propTypesMisspellWarningShown;
      propTypesMisspellWarningShown = !1;
      function isValidElement4(object) {
        return typeof object == "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      function getDeclarationErrorAddendum() {
        {
          if (ReactCurrentOwner$1.current) {
            var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);
            if (name)
              return `

Check the render method of \`` + name + "`.";
          }
          return "";
        }
      }
      function getSourceInfoErrorAddendum(source2) {
        {
          if (source2 !== void 0) {
            var fileName = source2.fileName.replace(/^.*[\\\/]/, ""), lineNumber = source2.lineNumber;
            return `

Check your code at ` + fileName + ":" + lineNumber + ".";
          }
          return "";
        }
      }
      var ownerHasKeyUseWarning = {};
      function getCurrentComponentErrorInfo(parentType) {
        {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType == "string" ? parentType : parentType.displayName || parentType.name;
            parentName && (info = `

Check the top-level render call using <` + parentName + ">.");
          }
          return info;
        }
      }
      function validateExplicitKey(element, parentType) {
        {
          if (!element._store || element._store.validated || element.key != null)
            return;
          element._store.validated = !0;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo])
            return;
          ownerHasKeyUseWarning[currentComponentErrorInfo] = !0;
          var childOwner = "";
          element && element._owner && element._owner !== ReactCurrentOwner$1.current && (childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + "."), setCurrentlyValidatingElement$1(element), error2('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner), setCurrentlyValidatingElement$1(null);
        }
      }
      function validateChildKeys(node, parentType) {
        {
          if (typeof node != "object")
            return;
          if (isArray3(node))
            for (var i3 = 0; i3 < node.length; i3++) {
              var child = node[i3];
              isValidElement4(child) && validateExplicitKey(child, parentType);
            }
          else if (isValidElement4(node))
            node._store && (node._store.validated = !0);
          else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn == "function" && iteratorFn !== node.entries)
              for (var iterator = iteratorFn.call(node), step; !(step = iterator.next()).done; )
                isValidElement4(step.value) && validateExplicitKey(step.value, parentType);
          }
        }
      }
      function validatePropTypes(element) {
        {
          var type2 = element.type;
          if (type2 == null || typeof type2 == "string")
            return;
          var propTypes;
          if (typeof type2 == "function")
            propTypes = type2.propTypes;
          else if (typeof type2 == "object" && (type2.$$typeof === REACT_FORWARD_REF_TYPE || type2.$$typeof === REACT_MEMO_TYPE))
            propTypes = type2.propTypes;
          else
            return;
          if (propTypes) {
            var name = getComponentNameFromType(type2);
            checkPropTypes(propTypes, element.props, "prop", name, element);
          } else if (type2.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
            propTypesMisspellWarningShown = !0;
            var _name = getComponentNameFromType(type2);
            error2("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
          }
          typeof type2.getDefaultProps == "function" && !type2.getDefaultProps.isReactClassApproved && error2("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
        }
      }
      function validateFragmentProps(fragment) {
        {
          for (var keys2 = Object.keys(fragment.props), i3 = 0; i3 < keys2.length; i3++) {
            var key2 = keys2[i3];
            if (key2 !== "children" && key2 !== "key") {
              setCurrentlyValidatingElement$1(fragment), error2("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key2), setCurrentlyValidatingElement$1(null);
              break;
            }
          }
          fragment.ref !== null && (setCurrentlyValidatingElement$1(fragment), error2("Invalid attribute `ref` supplied to `React.Fragment`."), setCurrentlyValidatingElement$1(null));
        }
      }
      function jsxWithValidation(type2, props, key2, isStaticChildren, source2, self) {
        {
          var validType = isValidElementType(type2);
          if (!validType) {
            var info = "";
            (type2 === void 0 || typeof type2 == "object" && type2 !== null && Object.keys(type2).length === 0) && (info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
            var sourceInfo = getSourceInfoErrorAddendum(source2);
            sourceInfo ? info += sourceInfo : info += getDeclarationErrorAddendum();
            var typeString;
            type2 === null ? typeString = "null" : isArray3(type2) ? typeString = "array" : type2 !== void 0 && type2.$$typeof === REACT_ELEMENT_TYPE ? (typeString = "<" + (getComponentNameFromType(type2.type) || "Unknown") + " />", info = " Did you accidentally export a JSX literal instead of a component?") : typeString = typeof type2, error2("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
          }
          var element = jsxDEV46(type2, props, key2, source2, self);
          if (element == null)
            return element;
          if (validType) {
            var children = props.children;
            if (children !== void 0)
              if (isStaticChildren)
                if (isArray3(children)) {
                  for (var i3 = 0; i3 < children.length; i3++)
                    validateChildKeys(children[i3], type2);
                  Object.freeze && Object.freeze(children);
                } else
                  error2("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
              else
                validateChildKeys(children, type2);
          }
          return type2 === REACT_FRAGMENT_TYPE ? validateFragmentProps(element) : validatePropTypes(element), element;
        }
      }
      var jsxDEV$1 = jsxWithValidation;
      exports.Fragment = REACT_FRAGMENT_TYPE, exports.jsxDEV = jsxDEV$1;
    })();
  }
});

// node_modules/react/jsx-dev-runtime.js
var require_jsx_dev_runtime = __commonJS({
  "node_modules/react/jsx-dev-runtime.js"(exports, module2) {
    "use strict";
    module2.exports = require_react_jsx_dev_runtime_development();
  }
});

// node_modules/framer-motion/node_modules/@emotion/memoize/dist/memoize.esm.js
function memoize(fn) {
  var cache = {};
  return function(arg) {
    return cache[arg] === void 0 && (cache[arg] = fn(arg)), cache[arg];
  };
}
var memoize_esm_default, init_memoize_esm = __esm({
  "node_modules/framer-motion/node_modules/@emotion/memoize/dist/memoize.esm.js"() {
    memoize_esm_default = memoize;
  }
});

// node_modules/framer-motion/node_modules/@emotion/is-prop-valid/dist/is-prop-valid.esm.js
var is_prop_valid_esm_exports = {};
__export(is_prop_valid_esm_exports, {
  default: () => is_prop_valid_esm_default
});
var reactPropsRegex, index, is_prop_valid_esm_default, init_is_prop_valid_esm = __esm({
  "node_modules/framer-motion/node_modules/@emotion/is-prop-valid/dist/is-prop-valid.esm.js"() {
    init_memoize_esm();
    reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|inert|itemProp|itemScope|itemType|itemID|itemRef|on|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, index = memoize_esm_default(
      function(prop) {
        return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
      }
    ), is_prop_valid_esm_default = index;
  }
});

// node_modules/@remix-run/react/dist/_virtual/_rollupPluginBabelHelpers.js
var require_rollupPluginBabelHelpers = __commonJS({
  "node_modules/@remix-run/react/dist/_virtual/_rollupPluginBabelHelpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    function _extends7() {
      return _extends7 = Object.assign ? Object.assign.bind() : function(target) {
        for (var i3 = 1; i3 < arguments.length; i3++) {
          var source2 = arguments[i3];
          for (var key2 in source2)
            Object.prototype.hasOwnProperty.call(source2, key2) && (target[key2] = source2[key2]);
        }
        return target;
      }, _extends7.apply(this, arguments);
    }
    exports.extends = _extends7;
  }
});

// node_modules/@remix-run/react/dist/errorBoundaries.js
var require_errorBoundaries = __commonJS({
  "node_modules/@remix-run/react/dist/errorBoundaries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var React17 = require_react(), reactRouterDom = (init_dist2(), __toCommonJS(dist_exports));
    function _interopDefaultLegacy(e3) {
      return e3 && typeof e3 == "object" && "default" in e3 ? e3 : { default: e3 };
    }
    var React__default3 = /* @__PURE__ */ _interopDefaultLegacy(React17), RemixErrorBoundary2 = class extends React__default3.default.Component {
      constructor(props) {
        super(props), this.state = {
          error: props.error || null,
          location: props.location
        };
      }
      static getDerivedStateFromError(error2) {
        return {
          error: error2
        };
      }
      static getDerivedStateFromProps(props, state) {
        return state.location !== props.location ? {
          error: props.error || null,
          location: props.location
        } : {
          error: props.error || state.error,
          location: state.location
        };
      }
      render() {
        return this.state.error ? /* @__PURE__ */ React__default3.default.createElement(this.props.component, {
          error: this.state.error
        }) : this.props.children;
      }
    };
    function RemixRootDefaultErrorBoundary2({
      error: error2
    }) {
      return console.error(error2), /* @__PURE__ */ React__default3.default.createElement("html", {
        lang: "en"
      }, /* @__PURE__ */ React__default3.default.createElement("head", null, /* @__PURE__ */ React__default3.default.createElement("meta", {
        charSet: "utf-8"
      }), /* @__PURE__ */ React__default3.default.createElement("meta", {
        name: "viewport",
        content: "width=device-width,initial-scale=1,viewport-fit=cover"
      }), /* @__PURE__ */ React__default3.default.createElement("title", null, "Application Error!")), /* @__PURE__ */ React__default3.default.createElement("body", null, /* @__PURE__ */ React__default3.default.createElement("main", {
        style: {
          fontFamily: "system-ui, sans-serif",
          padding: "2rem"
        }
      }, /* @__PURE__ */ React__default3.default.createElement("h1", {
        style: {
          fontSize: "24px"
        }
      }, "Application Error"), /* @__PURE__ */ React__default3.default.createElement("pre", {
        style: {
          padding: "2rem",
          background: "hsla(10, 50%, 50%, 0.1)",
          color: "red",
          overflow: "auto"
        }
      }, error2.stack)), /* @__PURE__ */ React__default3.default.createElement("script", {
        dangerouslySetInnerHTML: {
          __html: `
              console.log(
                "\u{1F4BF} Hey developer\u{1F44B}. You can provide a way better UX than this when your app throws errors. Check out https://remix.run/guides/errors for more information."
              );
            `
        }
      })));
    }
    function V2_RemixRootDefaultErrorBoundary2() {
      let error2 = reactRouterDom.useRouteError();
      if (reactRouterDom.isRouteErrorResponse(error2))
        return /* @__PURE__ */ React__default3.default.createElement(RemixRootDefaultCatchBoundaryImpl2, {
          caught: error2
        });
      if (error2 instanceof Error)
        return /* @__PURE__ */ React__default3.default.createElement(RemixRootDefaultErrorBoundary2, {
          error: error2
        });
      {
        let errorString = error2 == null ? "Unknown Error" : typeof error2 == "object" && "toString" in error2 ? error2.toString() : JSON.stringify(error2);
        return /* @__PURE__ */ React__default3.default.createElement(RemixRootDefaultErrorBoundary2, {
          error: new Error(errorString)
        });
      }
    }
    var RemixCatchContext2 = /* @__PURE__ */ React__default3.default.createContext(void 0);
    function useCatch2() {
      return React17.useContext(RemixCatchContext2);
    }
    function RemixCatchBoundary2({
      catch: catchVal,
      component: Component3,
      children
    }) {
      return catchVal ? /* @__PURE__ */ React__default3.default.createElement(RemixCatchContext2.Provider, {
        value: catchVal
      }, /* @__PURE__ */ React__default3.default.createElement(Component3, null)) : /* @__PURE__ */ React__default3.default.createElement(React__default3.default.Fragment, null, children);
    }
    function RemixRootDefaultCatchBoundary2() {
      let caught = useCatch2();
      return /* @__PURE__ */ React__default3.default.createElement(RemixRootDefaultCatchBoundaryImpl2, {
        caught
      });
    }
    function RemixRootDefaultCatchBoundaryImpl2({
      caught
    }) {
      return /* @__PURE__ */ React__default3.default.createElement("html", {
        lang: "en"
      }, /* @__PURE__ */ React__default3.default.createElement("head", null, /* @__PURE__ */ React__default3.default.createElement("meta", {
        charSet: "utf-8"
      }), /* @__PURE__ */ React__default3.default.createElement("meta", {
        name: "viewport",
        content: "width=device-width,initial-scale=1,viewport-fit=cover"
      }), /* @__PURE__ */ React__default3.default.createElement("title", null, "Unhandled Thrown Response!")), /* @__PURE__ */ React__default3.default.createElement("body", null, /* @__PURE__ */ React__default3.default.createElement("h1", {
        style: {
          fontFamily: "system-ui, sans-serif",
          padding: "2rem"
        }
      }, caught.status, " ", caught.statusText), /* @__PURE__ */ React__default3.default.createElement("script", {
        dangerouslySetInnerHTML: {
          __html: `
              console.log(
                "\u{1F4BF} Hey developer\u{1F44B}. You can provide a way better UX than this when your app throws 404s (and other responses). Check out https://remix.run/guides/not-found for more information."
              );
            `
        }
      })));
    }
    exports.RemixCatchBoundary = RemixCatchBoundary2;
    exports.RemixErrorBoundary = RemixErrorBoundary2;
    exports.RemixRootDefaultCatchBoundary = RemixRootDefaultCatchBoundary2;
    exports.RemixRootDefaultErrorBoundary = RemixRootDefaultErrorBoundary2;
    exports.V2_RemixRootDefaultErrorBoundary = V2_RemixRootDefaultErrorBoundary2;
    exports.useCatch = useCatch2;
  }
});

// node_modules/@remix-run/react/dist/invariant.js
var require_invariant = __commonJS({
  "node_modules/@remix-run/react/dist/invariant.js"(exports, module2) {
    "use strict";
    function invariant5(value2, message) {
      if (value2 === !1 || value2 === null || typeof value2 > "u")
        throw new Error(message);
    }
    module2.exports = invariant5;
  }
});

// node_modules/@remix-run/react/dist/routeModules.js
var require_routeModules = __commonJS({
  "node_modules/@remix-run/react/dist/routeModules.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    function _interopNamespace(e3) {
      if (e3 && e3.__esModule)
        return e3;
      var n3 = /* @__PURE__ */ Object.create(null);
      return e3 && Object.keys(e3).forEach(function(k2) {
        if (k2 !== "default") {
          var d2 = Object.getOwnPropertyDescriptor(e3, k2);
          Object.defineProperty(n3, k2, d2.get ? d2 : {
            enumerable: !0,
            get: function() {
              return e3[k2];
            }
          });
        }
      }), n3.default = e3, Object.freeze(n3);
    }
    async function loadRouteModule2(route, routeModulesCache) {
      if (route.id in routeModulesCache)
        return routeModulesCache[route.id];
      try {
        let routeModule = await function(t4) {
          return Promise.resolve().then(function() {
            return /* @__PURE__ */ _interopNamespace(__require(t4));
          });
        }(route.module);
        return routeModulesCache[route.id] = routeModule, routeModule;
      } catch {
        return window.location.reload(), new Promise(() => {
        });
      }
    }
    exports.loadRouteModule = loadRouteModule2;
  }
});

// node_modules/@remix-run/react/dist/links.js
var require_links = __commonJS({
  "node_modules/@remix-run/react/dist/links.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var reactRouterDom = (init_dist2(), __toCommonJS(dist_exports)), routeModules = require_routeModules();
    function getLinksForMatches2(matches, routeModules2, manifest) {
      let descriptors = matches.map((match) => {
        var _module$links;
        let module3 = routeModules2[match.route.id];
        return ((_module$links = module3.links) === null || _module$links === void 0 ? void 0 : _module$links.call(module3)) || [];
      }).flat(1), preloads = getCurrentPageModulePreloadHrefs2(matches, manifest);
      return dedupe3(descriptors, preloads);
    }
    async function prefetchStyleLinks2(routeModule) {
      if (!routeModule.links)
        return;
      let descriptors = routeModule.links();
      if (!descriptors)
        return;
      let styleLinks = [];
      for (let descriptor of descriptors)
        !isPageLinkDescriptor2(descriptor) && descriptor.rel === "stylesheet" && styleLinks.push({
          ...descriptor,
          rel: "preload",
          as: "style"
        });
      let matchingLinks = styleLinks.filter((link) => !link.media || window.matchMedia(link.media).matches);
      await Promise.all(matchingLinks.map(prefetchStyleLink2));
    }
    async function prefetchStyleLink2(descriptor) {
      return new Promise((resolve2) => {
        let link = document.createElement("link");
        Object.assign(link, descriptor);
        function removeLink() {
          document.head.contains(link) && document.head.removeChild(link);
        }
        link.onload = () => {
          removeLink(), resolve2();
        }, link.onerror = () => {
          removeLink(), resolve2();
        }, document.head.appendChild(link);
      });
    }
    function isPageLinkDescriptor2(object) {
      return object != null && typeof object.page == "string";
    }
    function isHtmlLinkDescriptor2(object) {
      return object == null ? !1 : object.href == null ? object.rel === "preload" && (typeof object.imageSrcSet == "string" || typeof object.imagesrcset == "string") && (typeof object.imageSizes == "string" || typeof object.imagesizes == "string") : typeof object.rel == "string" && typeof object.href == "string";
    }
    async function getStylesheetPrefetchLinks2(matches, manifest, routeModules$1) {
      return (await Promise.all(matches.map(async (match) => {
        let mod = await routeModules.loadRouteModule(manifest.routes[match.route.id], routeModules$1);
        return mod.links ? mod.links() : [];
      }))).flat(1).filter(isHtmlLinkDescriptor2).filter((link) => link.rel === "stylesheet" || link.rel === "preload").map((link) => link.rel === "preload" ? {
        ...link,
        rel: "prefetch"
      } : {
        ...link,
        rel: "prefetch",
        as: "style"
      });
    }
    function getNewMatchesForLinks2(page, nextMatches, currentMatches, manifest, location, mode) {
      let path2 = parsePathPatch2(page), isNew = (match, index2) => currentMatches[index2] ? match.route.id !== currentMatches[index2].route.id : !0, matchPathChanged = (match, index2) => {
        var _currentMatches$index;
        return currentMatches[index2].pathname !== match.pathname || ((_currentMatches$index = currentMatches[index2].route.path) === null || _currentMatches$index === void 0 ? void 0 : _currentMatches$index.endsWith("*")) && currentMatches[index2].params["*"] !== match.params["*"];
      };
      return mode === "data" && location.search !== path2.search ? nextMatches.filter((match, index2) => {
        if (!manifest.routes[match.route.id].hasLoader)
          return !1;
        if (isNew(match, index2) || matchPathChanged(match, index2))
          return !0;
        if (match.route.shouldRevalidate) {
          var _currentMatches$;
          let routeChoice = match.route.shouldRevalidate({
            currentUrl: new URL(location.pathname + location.search + location.hash, window.origin),
            currentParams: ((_currentMatches$ = currentMatches[0]) === null || _currentMatches$ === void 0 ? void 0 : _currentMatches$.params) || {},
            nextUrl: new URL(page, window.origin),
            nextParams: match.params,
            defaultShouldRevalidate: !0
          });
          if (typeof routeChoice == "boolean")
            return routeChoice;
        }
        return !0;
      }) : nextMatches.filter((match, index2) => {
        let manifestRoute = manifest.routes[match.route.id];
        return (mode === "assets" || manifestRoute.hasLoader) && (isNew(match, index2) || matchPathChanged(match, index2));
      });
    }
    function getDataLinkHrefs2(page, matches, manifest) {
      let path2 = parsePathPatch2(page);
      return dedupeHrefs2(matches.filter((match) => manifest.routes[match.route.id].hasLoader).map((match) => {
        let {
          pathname,
          search
        } = path2, searchParams = new URLSearchParams(search);
        return searchParams.set("_data", match.route.id), `${pathname}?${searchParams}`;
      }));
    }
    function getModuleLinkHrefs2(matches, manifestPatch) {
      return dedupeHrefs2(matches.map((match) => {
        let route = manifestPatch.routes[match.route.id], hrefs = [route.module];
        return route.imports && (hrefs = hrefs.concat(route.imports)), hrefs;
      }).flat(1));
    }
    function getCurrentPageModulePreloadHrefs2(matches, manifest) {
      return dedupeHrefs2(matches.map((match) => {
        let route = manifest.routes[match.route.id], hrefs = [route.module];
        return route.imports && (hrefs = hrefs.concat(route.imports)), hrefs;
      }).flat(1));
    }
    function dedupeHrefs2(hrefs) {
      return [...new Set(hrefs)];
    }
    function dedupe3(descriptors, preloads) {
      let set2 = /* @__PURE__ */ new Set(), preloadsSet = new Set(preloads);
      return descriptors.reduce((deduped, descriptor) => {
        if (!isPageLinkDescriptor2(descriptor) && descriptor.as === "script" && descriptor.href && preloadsSet.has(descriptor.href))
          return deduped;
        let str2 = JSON.stringify(descriptor);
        return set2.has(str2) || (set2.add(str2), deduped.push(descriptor)), deduped;
      }, []);
    }
    function parsePathPatch2(href) {
      let path2 = reactRouterDom.parsePath(href);
      return path2.search === void 0 && (path2.search = ""), path2;
    }
    exports.dedupe = dedupe3;
    exports.getDataLinkHrefs = getDataLinkHrefs2;
    exports.getLinksForMatches = getLinksForMatches2;
    exports.getModuleLinkHrefs = getModuleLinkHrefs2;
    exports.getNewMatchesForLinks = getNewMatchesForLinks2;
    exports.getStylesheetPrefetchLinks = getStylesheetPrefetchLinks2;
    exports.isHtmlLinkDescriptor = isHtmlLinkDescriptor2;
    exports.isPageLinkDescriptor = isPageLinkDescriptor2;
    exports.prefetchStyleLinks = prefetchStyleLinks2;
  }
});

// node_modules/@remix-run/react/dist/markup.js
var require_markup = __commonJS({
  "node_modules/@remix-run/react/dist/markup.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var ESCAPE_LOOKUP3 = {
      "&": "\\u0026",
      ">": "\\u003e",
      "<": "\\u003c",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    }, ESCAPE_REGEX3 = /[&><\u2028\u2029]/g;
    function escapeHtml3(html) {
      return html.replace(ESCAPE_REGEX3, (match) => ESCAPE_LOOKUP3[match]);
    }
    function createHtml2(html) {
      return {
        __html: html
      };
    }
    exports.createHtml = createHtml2;
    exports.escapeHtml = escapeHtml3;
  }
});

// node_modules/@remix-run/react/dist/transition.js
var require_transition = __commonJS({
  "node_modules/@remix-run/react/dist/transition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var IDLE_TRANSITION2 = {
      state: "idle",
      submission: void 0,
      location: void 0,
      type: "idle"
    }, IDLE_FETCHER3 = {
      state: "idle",
      type: "init",
      data: void 0,
      formMethod: void 0,
      formAction: void 0,
      formData: void 0,
      formEncType: void 0,
      submission: void 0
    };
    exports.IDLE_FETCHER = IDLE_FETCHER3;
    exports.IDLE_TRANSITION = IDLE_TRANSITION2;
  }
});

// node_modules/@remix-run/react/dist/warnings.js
var require_warnings = __commonJS({
  "node_modules/@remix-run/react/dist/warnings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var alreadyWarned5 = {};
    function logDeprecationOnce2(message, key2 = message) {
      alreadyWarned5[key2] || (alreadyWarned5[key2] = !0, console.warn(message));
    }
    exports.logDeprecationOnce = logDeprecationOnce2;
  }
});

// node_modules/@remix-run/react/dist/components.js
var require_components = __commonJS({
  "node_modules/@remix-run/react/dist/components.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var _rollupPluginBabelHelpers = require_rollupPluginBabelHelpers(), React17 = require_react(), reactRouterDom = (init_dist2(), __toCommonJS(dist_exports)), errorBoundaries = require_errorBoundaries(), invariant5 = require_invariant(), links2 = require_links(), markup = require_markup(), transition = require_transition(), warnings = require_warnings();
    function _interopNamespace(e3) {
      if (e3 && e3.__esModule)
        return e3;
      var n3 = /* @__PURE__ */ Object.create(null);
      return e3 && Object.keys(e3).forEach(function(k2) {
        if (k2 !== "default") {
          var d2 = Object.getOwnPropertyDescriptor(e3, k2);
          Object.defineProperty(n3, k2, d2.get ? d2 : {
            enumerable: !0,
            get: function() {
              return e3[k2];
            }
          });
        }
      }), n3.default = e3, Object.freeze(n3);
    }
    var React__namespace = /* @__PURE__ */ _interopNamespace(React17);
    function useDataRouterContext4() {
      let context = React__namespace.useContext(reactRouterDom.UNSAFE_DataRouterContext);
      return invariant5(context, "You must render this element inside a <DataRouterContext.Provider> element"), context;
    }
    function useDataRouterStateContext2() {
      let context = React__namespace.useContext(reactRouterDom.UNSAFE_DataRouterStateContext);
      return invariant5(context, "You must render this element inside a <DataRouterStateContext.Provider> element"), context;
    }
    var RemixContext2 = /* @__PURE__ */ React__namespace.createContext(void 0);
    RemixContext2.displayName = "Remix";
    function useRemixContext2() {
      let context = React__namespace.useContext(RemixContext2);
      return invariant5(context, "You must render this element inside a <Remix> element"), context;
    }
    function RemixRoute2({
      id: id4
    }) {
      let {
        routeModules
      } = useRemixContext2();
      invariant5(routeModules, `Cannot initialize 'routeModules'. This normally occurs when you have server code in your client modules.
Check this link for more details:
https://remix.run/pages/gotchas#server-code-in-client-bundles`);
      let {
        default: Component3
      } = routeModules[id4];
      return invariant5(Component3, `Route "${id4}" has no component! Please go add a \`default\` export in the route module file.
If you were trying to navigate or submit to a resource route, use \`<a>\` instead of \`<Link>\` or \`<Form reloadDocument>\`.`), /* @__PURE__ */ React__namespace.createElement(Component3, null);
    }
    function RemixRouteError2({
      id: id4
    }) {
      let {
        future: future2,
        routeModules
      } = useRemixContext2();
      invariant5(routeModules, `Cannot initialize 'routeModules'. This normally occurs when you have server code in your client modules.
Check this link for more details:
https://remix.run/pages/gotchas#server-code-in-client-bundles`);
      let error2 = reactRouterDom.useRouteError(), {
        CatchBoundary,
        ErrorBoundary
      } = routeModules[id4];
      if (future2.v2_errorBoundary) {
        if (id4 === "root" && (ErrorBoundary || (ErrorBoundary = errorBoundaries.V2_RemixRootDefaultErrorBoundary)), ErrorBoundary)
          return /* @__PURE__ */ React__namespace.createElement(ErrorBoundary, null);
        throw error2;
      }
      if (id4 === "root" && (CatchBoundary || (CatchBoundary = errorBoundaries.RemixRootDefaultCatchBoundary), ErrorBoundary || (ErrorBoundary = errorBoundaries.RemixRootDefaultErrorBoundary)), reactRouterDom.isRouteErrorResponse(error2)) {
        let tError = error2;
        if ((tError == null ? void 0 : tError.error) instanceof Error && tError.status !== 404 && ErrorBoundary)
          return /* @__PURE__ */ React__namespace.createElement(ErrorBoundary, {
            error: tError.error
          });
        if (CatchBoundary)
          return /* @__PURE__ */ React__namespace.createElement(errorBoundaries.RemixCatchBoundary, {
            component: CatchBoundary,
            catch: error2
          });
      }
      if (error2 instanceof Error && ErrorBoundary)
        return /* @__PURE__ */ React__namespace.createElement(ErrorBoundary, {
          error: error2
        });
      throw error2;
    }
    function usePrefetchBehavior2(prefetch, theirElementProps) {
      let [maybePrefetch, setMaybePrefetch] = React__namespace.useState(!1), [shouldPrefetch, setShouldPrefetch] = React__namespace.useState(!1), {
        onFocus,
        onBlur,
        onMouseEnter,
        onMouseLeave,
        onTouchStart: onTouchStart2
      } = theirElementProps;
      React__namespace.useEffect(() => {
        prefetch === "render" && setShouldPrefetch(!0);
      }, [prefetch]);
      let setIntent = () => {
        prefetch === "intent" && setMaybePrefetch(!0);
      }, cancelIntent = () => {
        prefetch === "intent" && (setMaybePrefetch(!1), setShouldPrefetch(!1));
      };
      return React__namespace.useEffect(() => {
        if (maybePrefetch) {
          let id4 = setTimeout(() => {
            setShouldPrefetch(!0);
          }, 100);
          return () => {
            clearTimeout(id4);
          };
        }
      }, [maybePrefetch]), [shouldPrefetch, {
        onFocus: composeEventHandlers2(onFocus, setIntent),
        onBlur: composeEventHandlers2(onBlur, cancelIntent),
        onMouseEnter: composeEventHandlers2(onMouseEnter, setIntent),
        onMouseLeave: composeEventHandlers2(onMouseLeave, cancelIntent),
        onTouchStart: composeEventHandlers2(onTouchStart2, setIntent)
      }];
    }
    var ABSOLUTE_URL_REGEX4 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, NavLink3 = /* @__PURE__ */ React__namespace.forwardRef(({
      to,
      prefetch = "none",
      ...props
    }, forwardedRef) => {
      let isAbsolute2 = typeof to == "string" && ABSOLUTE_URL_REGEX4.test(to), href = reactRouterDom.useHref(to), [shouldPrefetch, prefetchHandlers] = usePrefetchBehavior2(prefetch, props);
      return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(reactRouterDom.NavLink, _rollupPluginBabelHelpers.extends({
        ref: forwardedRef,
        to
      }, props, prefetchHandlers)), shouldPrefetch && !isAbsolute2 ? /* @__PURE__ */ React__namespace.createElement(PrefetchPageLinks2, {
        page: href
      }) : null);
    });
    NavLink3.displayName = "NavLink";
    var Link4 = /* @__PURE__ */ React__namespace.forwardRef(({
      to,
      prefetch = "none",
      ...props
    }, forwardedRef) => {
      let isAbsolute2 = typeof to == "string" && ABSOLUTE_URL_REGEX4.test(to), href = reactRouterDom.useHref(to), [shouldPrefetch, prefetchHandlers] = usePrefetchBehavior2(prefetch, props);
      return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(reactRouterDom.Link, _rollupPluginBabelHelpers.extends({
        ref: forwardedRef,
        to
      }, props, prefetchHandlers)), shouldPrefetch && !isAbsolute2 ? /* @__PURE__ */ React__namespace.createElement(PrefetchPageLinks2, {
        page: href
      }) : null);
    });
    Link4.displayName = "Link";
    function composeEventHandlers2(theirHandler, ourHandler) {
      return (event2) => {
        theirHandler && theirHandler(event2), event2.defaultPrevented || ourHandler(event2);
      };
    }
    var linksWarning2 = "\u26A0\uFE0F REMIX FUTURE CHANGE: The behavior of links `imagesizes` and `imagesrcset` will be changing in v2. Only the React camel case versions will be valid. Please change to `imageSizes` and `imageSrcSet`.For instructions on making this change see https://remix.run/docs/en/v1.15.0/pages/v2#links-imagesizes-and-imagesrcset", useTransitionWarning2 = "\u26A0\uFE0F REMIX FUTURE CHANGE: `useTransition` will be removed in v2 in favor of `useNavigation`. You can prepare for this change at your convenience by updating to `useNavigation`.For instructions on making this change see https://remix.run/docs/en/v1.15.0/pages/v2#usetransition", fetcherTypeWarning2 = "\u26A0\uFE0F REMIX FUTURE CHANGE: `fetcher.type` will be removed in v2. Please use `fetcher.state`, `fetcher.formData`, and `fetcher.data` to achieve the same UX.For instructions on making this change see https://remix.run/docs/en/v1.15.0/pages/v2#usefetcher", fetcherSubmissionWarning2 = "\u26A0\uFE0F REMIX FUTURE CHANGE : `fetcher.submission` will be removed in v2. The submission fields are now part of the fetcher object itself (`fetcher.formData`). For instructions on making this change see https://remix.run/docs/en/v1.15.0/pages/v2#usefetcher";
    function Links2() {
      let {
        manifest,
        routeModules
      } = useRemixContext2(), {
        matches
      } = useDataRouterStateContext2(), links$1 = React__namespace.useMemo(() => links2.getLinksForMatches(matches, routeModules, manifest), [matches, routeModules, manifest]);
      return React__namespace.useEffect(() => {
        links$1.some((link) => "imagesizes" in link || "imagesrcset" in link) && warnings.logDeprecationOnce(linksWarning2);
      }, [links$1]), /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, links$1.map((link) => {
        if (links2.isPageLinkDescriptor(link))
          return /* @__PURE__ */ React__namespace.createElement(PrefetchPageLinks2, _rollupPluginBabelHelpers.extends({
            key: link.page
          }, link));
        let imageSrcSet = null;
        return "useId" in React__namespace ? (link.imagesrcset && (link.imageSrcSet = imageSrcSet = link.imagesrcset, delete link.imagesrcset), link.imagesizes && (link.imageSizes = link.imagesizes, delete link.imagesizes)) : (link.imageSrcSet && (link.imagesrcset = imageSrcSet = link.imageSrcSet, delete link.imageSrcSet), link.imageSizes && (link.imagesizes = link.imageSizes, delete link.imageSizes)), /* @__PURE__ */ React__namespace.createElement("link", _rollupPluginBabelHelpers.extends({
          key: link.rel + (link.href || "") + (imageSrcSet || "")
        }, link));
      }));
    }
    function PrefetchPageLinks2({
      page,
      ...dataLinkProps
    }) {
      let {
        router: router2
      } = useDataRouterContext4(), matches = React__namespace.useMemo(() => reactRouterDom.matchRoutes(router2.routes, page), [router2.routes, page]);
      return matches ? /* @__PURE__ */ React__namespace.createElement(PrefetchPageLinksImpl2, _rollupPluginBabelHelpers.extends({
        page,
        matches
      }, dataLinkProps)) : (console.warn(`Tried to prefetch ${page} but no routes matched.`), null);
    }
    function usePrefetchedStylesheets2(matches) {
      let {
        manifest,
        routeModules
      } = useRemixContext2(), [styleLinks, setStyleLinks] = React__namespace.useState([]);
      return React__namespace.useEffect(() => {
        let interrupted = !1;
        return links2.getStylesheetPrefetchLinks(matches, manifest, routeModules).then((links3) => {
          interrupted || setStyleLinks(links3);
        }), () => {
          interrupted = !0;
        };
      }, [matches, manifest, routeModules]), styleLinks;
    }
    function PrefetchPageLinksImpl2({
      page,
      matches: nextMatches,
      ...linkProps
    }) {
      let location = reactRouterDom.useLocation(), {
        manifest
      } = useRemixContext2(), {
        matches
      } = useDataRouterStateContext2(), newMatchesForData = React__namespace.useMemo(() => links2.getNewMatchesForLinks(page, nextMatches, matches, manifest, location, "data"), [page, nextMatches, matches, manifest, location]), newMatchesForAssets = React__namespace.useMemo(() => links2.getNewMatchesForLinks(page, nextMatches, matches, manifest, location, "assets"), [page, nextMatches, matches, manifest, location]), dataHrefs = React__namespace.useMemo(() => links2.getDataLinkHrefs(page, newMatchesForData, manifest), [newMatchesForData, page, manifest]), moduleHrefs = React__namespace.useMemo(() => links2.getModuleLinkHrefs(newMatchesForAssets, manifest), [newMatchesForAssets, manifest]), styleLinks = usePrefetchedStylesheets2(newMatchesForAssets);
      return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, dataHrefs.map((href) => /* @__PURE__ */ React__namespace.createElement("link", _rollupPluginBabelHelpers.extends({
        key: href,
        rel: "prefetch",
        as: "fetch",
        href
      }, linkProps))), moduleHrefs.map((href) => /* @__PURE__ */ React__namespace.createElement("link", _rollupPluginBabelHelpers.extends({
        key: href,
        rel: "modulepreload",
        href
      }, linkProps))), styleLinks.map((link) => /* @__PURE__ */ React__namespace.createElement("link", _rollupPluginBabelHelpers.extends({
        key: link.href
      }, link))));
    }
    function V1Meta2() {
      let {
        routeModules
      } = useRemixContext2(), {
        matches,
        loaderData
      } = useDataRouterStateContext2(), location = reactRouterDom.useLocation(), meta2 = {}, parentsData = {};
      for (let match of matches) {
        let routeId = match.route.id, data2 = loaderData[routeId], params = match.params, routeModule = routeModules[routeId];
        if (routeModule.meta) {
          let routeMeta = typeof routeModule.meta == "function" ? routeModule.meta({
            data: data2,
            parentsData,
            params,
            location
          }) : routeModule.meta;
          if (routeMeta && Array.isArray(routeMeta))
            throw new Error(
              "The route at " + match.route.path + " returns an array. This is only supported with the `v2_meta` future flag in the Remix config. Either set the flag to `true` or update the route's meta function to return an object.\n\nTo reference the v1 meta function API, see https://remix.run/route/meta"
            );
          Object.assign(meta2, routeMeta);
        }
        parentsData[routeId] = data2;
      }
      return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, Object.entries(meta2).map(([name, value2]) => {
        if (!value2)
          return null;
        if (["charset", "charSet"].includes(name))
          return /* @__PURE__ */ React__namespace.createElement("meta", {
            key: "charSet",
            charSet: value2
          });
        if (name === "title")
          return /* @__PURE__ */ React__namespace.createElement("title", {
            key: "title"
          }, String(value2));
        let isOpenGraphTag = /^(og|music|video|article|book|profile|fb):.+$/.test(name);
        return [value2].flat().map((content) => isOpenGraphTag ? /* @__PURE__ */ React__namespace.createElement("meta", {
          property: name,
          content,
          key: name + content
        }) : typeof content == "string" ? /* @__PURE__ */ React__namespace.createElement("meta", {
          name,
          content,
          key: name + content
        }) : /* @__PURE__ */ React__namespace.createElement("meta", _rollupPluginBabelHelpers.extends({
          key: name + JSON.stringify(content)
        }, content)));
      }));
    }
    function V2Meta2() {
      let {
        routeModules
      } = useRemixContext2(), {
        matches: _matches,
        loaderData
      } = useDataRouterStateContext2(), location = reactRouterDom.useLocation(), meta2 = [], leafMeta = null, matches = [];
      for (let i3 = 0; i3 < _matches.length; i3++) {
        let _match = _matches[i3], routeId = _match.route.id, data2 = loaderData[routeId], params = _match.params, routeModule = routeModules[routeId], routeMeta = [], match = {
          id: routeId,
          data: data2,
          meta: [],
          params: _match.params,
          pathname: _match.pathname,
          handle: _match.route.handle,
          get route() {
            return console.warn("The meta function in " + _match.route.path + " accesses the `route` property on `matches`. This is deprecated and will be removed in Remix version 2. See"), _match.route;
          }
        };
        if (matches[i3] = match, routeModule != null && routeModule.meta ? routeMeta = typeof routeModule.meta == "function" ? routeModule.meta({
          data: data2,
          params,
          location,
          matches
        }) : Array.isArray(routeModule.meta) ? [...routeModule.meta] : routeModule.meta : leafMeta && (routeMeta = [...leafMeta]), routeMeta = routeMeta || [], !Array.isArray(routeMeta))
          throw new Error("The `v2_meta` API is enabled in the Remix config, but the route at " + _match.route.path + ` returns an invalid value. In v2, all route meta functions must return an array of meta objects.

To reference the v1 meta function API, see https://remix.run/route/meta`);
        match.meta = routeMeta, matches[i3] = match, meta2 = [...routeMeta], leafMeta = meta2;
      }
      return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, meta2.flat().map((metaProps) => {
        if (!metaProps)
          return null;
        if ("tagName" in metaProps) {
          let tagName = metaProps.tagName;
          if (delete metaProps.tagName, !isValidMetaTag2(tagName))
            return console.warn(`A meta object uses an invalid tagName: ${tagName}. Expected either 'link' or 'meta'`), null;
          let Comp = tagName;
          return /* @__PURE__ */ React__namespace.createElement(Comp, _rollupPluginBabelHelpers.extends({
            key: JSON.stringify(metaProps)
          }, metaProps));
        }
        if ("title" in metaProps)
          return /* @__PURE__ */ React__namespace.createElement("title", {
            key: "title"
          }, String(metaProps.title));
        if ("charset" in metaProps && (metaProps.charSet ?? (metaProps.charSet = metaProps.charset), delete metaProps.charset), "charSet" in metaProps && metaProps.charSet != null)
          return typeof metaProps.charSet == "string" ? /* @__PURE__ */ React__namespace.createElement("meta", {
            key: "charSet",
            charSet: metaProps.charSet
          }) : null;
        if ("script:ld+json" in metaProps) {
          let json9 = null;
          try {
            json9 = JSON.stringify(metaProps["script:ld+json"]);
          } catch {
          }
          return json9 != null && /* @__PURE__ */ React__namespace.createElement("script", {
            key: "script:ld+json",
            type: "application/ld+json",
            dangerouslySetInnerHTML: {
              __html: JSON.stringify(metaProps["script:ld+json"])
            }
          });
        }
        return /* @__PURE__ */ React__namespace.createElement("meta", _rollupPluginBabelHelpers.extends({
          key: JSON.stringify(metaProps)
        }, metaProps));
      }));
    }
    function isValidMetaTag2(tagName) {
      return typeof tagName == "string" && /^(meta|link)$/.test(tagName);
    }
    function Meta2() {
      let {
        future: future2
      } = useRemixContext2();
      return future2 != null && future2.v2_meta ? /* @__PURE__ */ React__namespace.createElement(V2Meta2, null) : /* @__PURE__ */ React__namespace.createElement(V1Meta2, null);
    }
    function Await3(props) {
      return /* @__PURE__ */ React__namespace.createElement(reactRouterDom.Await, props);
    }
    var isHydrated2 = !1;
    function Scripts2(props) {
      let {
        manifest,
        serverHandoffString,
        abortDelay
      } = useRemixContext2(), {
        router: router2,
        static: isStatic,
        staticContext
      } = useDataRouterContext4(), {
        matches
      } = useDataRouterStateContext2(), navigation = reactRouterDom.useNavigation();
      React__namespace.useEffect(() => {
        isHydrated2 = !0;
      }, []);
      let deferredScripts = [], initialScripts = React__namespace.useMemo(() => {
        var _manifest$hmr;
        let contextScript = staticContext ? `window.__remixContext = ${serverHandoffString};` : " ", activeDeferreds = staticContext == null ? void 0 : staticContext.activeDeferreds;
        contextScript += activeDeferreds ? ["__remixContext.p = function(v,e,p,x) {", "  if (typeof e !== 'undefined') {", `    x=new Error(e.message);
    x.stack=e.stack;`, "    p=Promise.reject(x);", "  } else {", "    p=Promise.resolve(v);", "  }", "  return p;", "};", "__remixContext.n = function(i,k) {", "  __remixContext.t = __remixContext.t || {};", "  __remixContext.t[i] = __remixContext.t[i] || {};", "  let p = new Promise((r, e) => {__remixContext.t[i][k] = {r:(v)=>{r(v);},e:(v)=>{e(v);}};});", typeof abortDelay == "number" ? `setTimeout(() => {if(typeof p._error !== "undefined" || typeof p._data !== "undefined"){return;} __remixContext.t[i][k].e(new Error("Server timeout."))}, ${abortDelay});` : "", "  return p;", "};", "__remixContext.r = function(i,k,v,e,p,x) {", "  p = __remixContext.t[i][k];", "  if (typeof e !== 'undefined') {", `    x=new Error(e.message);
    x.stack=e.stack;`, "    p.e(x);", "  } else {", "    p.r(v);", "  }", "};"].join(`
`) + Object.entries(activeDeferreds).map(([routeId, deferredData]) => {
          let pendingKeys = new Set(deferredData.pendingKeys), promiseKeyValues = deferredData.deferredKeys.map((key2) => {
            if (pendingKeys.has(key2))
              return deferredScripts.push(/* @__PURE__ */ React__namespace.createElement(DeferredHydrationScript2, {
                key: `${routeId} | ${key2}`,
                deferredData,
                routeId,
                dataKey: key2
              })), `${JSON.stringify(key2)}:__remixContext.n(${JSON.stringify(routeId)}, ${JSON.stringify(key2)})`;
            {
              let trackedPromise = deferredData.data[key2];
              if (typeof trackedPromise._error < "u") {
                let toSerialize = {
                  message: trackedPromise._error.message,
                  stack: trackedPromise._error.stack
                };
                return `${JSON.stringify(key2)}:__remixContext.p(!1, ${markup.escapeHtml(JSON.stringify(toSerialize))})`;
              } else {
                if (typeof trackedPromise._data > "u")
                  throw new Error(`The deferred data for ${key2} was not resolved, did you forget to return data from a deferred promise?`);
                return `${JSON.stringify(key2)}:__remixContext.p(${markup.escapeHtml(JSON.stringify(trackedPromise._data))})`;
              }
            }
          }).join(`,
`);
          return `Object.assign(__remixContext.state.loaderData[${JSON.stringify(routeId)}], {${promiseKeyValues}});`;
        }).join(`
`) + (deferredScripts.length > 0 ? `__remixContext.a=${deferredScripts.length};` : "") : "";
        let routeModulesScript = isStatic ? `${(_manifest$hmr = manifest.hmr) !== null && _manifest$hmr !== void 0 && _manifest$hmr.runtime ? `import ${JSON.stringify(manifest.hmr.runtime)};` : ""}import ${JSON.stringify(manifest.url)};
${matches.map((match, index2) => `import * as route${index2} from ${JSON.stringify(manifest.routes[match.route.id].module)};`).join(`
`)}
window.__remixRouteModules = {${matches.map((match, index2) => `${JSON.stringify(match.route.id)}:route${index2}`).join(",")}};

import(${JSON.stringify(manifest.entry.module)});` : " ";
        return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement("script", _rollupPluginBabelHelpers.extends({}, props, {
          suppressHydrationWarning: !0,
          dangerouslySetInnerHTML: markup.createHtml(contextScript),
          type: void 0
        })), /* @__PURE__ */ React__namespace.createElement("script", _rollupPluginBabelHelpers.extends({}, props, {
          suppressHydrationWarning: !0,
          dangerouslySetInnerHTML: markup.createHtml(routeModulesScript),
          type: "module",
          async: !0
        })));
      }, []);
      if (!isStatic && typeof __remixContext == "object" && __remixContext.a)
        for (let i3 = 0; i3 < __remixContext.a; i3++)
          deferredScripts.push(/* @__PURE__ */ React__namespace.createElement(DeferredHydrationScript2, {
            key: i3
          }));
      let nextMatches = React__namespace.useMemo(() => {
        if (navigation.location) {
          let matches2 = reactRouterDom.matchRoutes(router2.routes, navigation.location);
          return invariant5(matches2, `No routes match path "${navigation.location.pathname}"`), matches2;
        }
        return [];
      }, [navigation.location, router2.routes]), routePreloads = matches.concat(nextMatches).map((match) => {
        let route = manifest.routes[match.route.id];
        return (route.imports || []).concat([route.module]);
      }).flat(1), preloads = isHydrated2 ? [] : manifest.entry.imports.concat(routePreloads);
      return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement("link", {
        rel: "modulepreload",
        href: manifest.url,
        crossOrigin: props.crossOrigin
      }), /* @__PURE__ */ React__namespace.createElement("link", {
        rel: "modulepreload",
        href: manifest.entry.module,
        crossOrigin: props.crossOrigin
      }), dedupe3(preloads).map((path2) => /* @__PURE__ */ React__namespace.createElement("link", {
        key: path2,
        rel: "modulepreload",
        href: path2,
        crossOrigin: props.crossOrigin
      })), !isHydrated2 && initialScripts, !isHydrated2 && deferredScripts);
    }
    function DeferredHydrationScript2({
      dataKey,
      deferredData,
      routeId
    }) {
      return typeof document > "u" && deferredData && dataKey && routeId && invariant5(deferredData.pendingKeys.includes(dataKey), `Deferred data for route ${routeId} with key ${dataKey} was not pending but tried to render a script for it.`), /* @__PURE__ */ React__namespace.createElement(React__namespace.Suspense, {
        fallback: typeof document > "u" && deferredData && dataKey && routeId ? null : /* @__PURE__ */ React__namespace.createElement("script", {
          async: !0,
          suppressHydrationWarning: !0,
          dangerouslySetInnerHTML: {
            __html: " "
          }
        })
      }, typeof document > "u" && deferredData && dataKey && routeId ? /* @__PURE__ */ React__namespace.createElement(Await3, {
        resolve: deferredData.data[dataKey],
        errorElement: /* @__PURE__ */ React__namespace.createElement(ErrorDeferredHydrationScript2, {
          dataKey,
          routeId
        }),
        children: (data2) => /* @__PURE__ */ React__namespace.createElement("script", {
          async: !0,
          suppressHydrationWarning: !0,
          dangerouslySetInnerHTML: {
            __html: `__remixContext.r(${JSON.stringify(routeId)}, ${JSON.stringify(dataKey)}, ${markup.escapeHtml(JSON.stringify(data2))});`
          }
        })
      }) : /* @__PURE__ */ React__namespace.createElement("script", {
        async: !0,
        suppressHydrationWarning: !0,
        dangerouslySetInnerHTML: {
          __html: " "
        }
      }));
    }
    function ErrorDeferredHydrationScript2({
      dataKey,
      routeId
    }) {
      let error2 = reactRouterDom.useAsyncError(), toSerialize = {
        message: error2.message,
        stack: error2.stack
      };
      return /* @__PURE__ */ React__namespace.createElement("script", {
        suppressHydrationWarning: !0,
        dangerouslySetInnerHTML: {
          __html: `__remixContext.r(${JSON.stringify(routeId)}, ${JSON.stringify(dataKey)}, !1, ${markup.escapeHtml(JSON.stringify(toSerialize))});`
        }
      });
    }
    function dedupe3(array) {
      return [...new Set(array)];
    }
    function useMatches3() {
      let {
        routeModules
      } = useRemixContext2(), matches = reactRouterDom.useMatches();
      return React__namespace.useMemo(() => matches.map((match) => ({
        id: match.id,
        pathname: match.pathname,
        params: match.params,
        data: match.data,
        handle: routeModules[match.id].handle
      })), [matches, routeModules]);
    }
    function useLoaderData5() {
      return reactRouterDom.useLoaderData();
    }
    function useActionData4() {
      return reactRouterDom.useActionData();
    }
    function useTransition2() {
      let navigation = reactRouterDom.useNavigation();
      return React__namespace.useEffect(() => {
        warnings.logDeprecationOnce(useTransitionWarning2);
      }, []), React__namespace.useMemo(() => convertNavigationToTransition2(navigation), [navigation]);
    }
    function convertNavigationToTransition2(navigation) {
      let {
        location,
        state,
        formMethod,
        formAction,
        formEncType,
        formData
      } = navigation;
      if (!location)
        return transition.IDLE_TRANSITION;
      let isActionSubmission = formMethod != null && ["POST", "PUT", "PATCH", "DELETE"].includes(formMethod.toUpperCase());
      if (state === "submitting" && formMethod && formAction && formEncType && formData) {
        if (isActionSubmission)
          return {
            location,
            state,
            submission: {
              method: formMethod.toUpperCase(),
              action: formAction,
              encType: formEncType,
              formData,
              key: ""
            },
            type: "actionSubmission"
          };
        invariant5(!1, "Encountered an unexpected navigation scenario in useTransition()");
      }
      if (state === "loading") {
        let {
          _isRedirect,
          _isFetchActionRedirect
        } = location.state || {};
        if (formMethod && formAction && formEncType && formData) {
          if (_isRedirect)
            return isActionSubmission ? {
              location,
              state,
              submission: {
                method: formMethod.toUpperCase(),
                action: formAction,
                encType: formEncType,
                formData,
                key: ""
              },
              type: "actionRedirect"
            } : {
              location,
              state,
              submission: {
                method: formMethod.toUpperCase(),
                action: formAction,
                encType: formEncType,
                formData,
                key: ""
              },
              type: "loaderSubmissionRedirect"
            };
          if (isActionSubmission)
            return {
              location,
              state,
              submission: {
                method: formMethod.toUpperCase(),
                action: formAction,
                encType: formEncType,
                formData,
                key: ""
              },
              type: "actionReload"
            };
          {
            let url = new URL(formAction, window.location.origin);
            return url.search = new URLSearchParams(formData.entries()).toString(), {
              location,
              state: "submitting",
              submission: {
                method: formMethod.toUpperCase(),
                action: url.pathname + url.search,
                encType: formEncType,
                formData,
                key: ""
              },
              type: "loaderSubmission"
            };
          }
        } else if (_isRedirect)
          return _isFetchActionRedirect ? {
            location,
            state,
            submission: void 0,
            type: "fetchActionRedirect"
          } : {
            location,
            state,
            submission: void 0,
            type: "normalRedirect"
          };
      }
      return {
        location,
        state: "loading",
        submission: void 0,
        type: "normalLoad"
      };
    }
    function useFetchers3() {
      return reactRouterDom.useFetchers().map((f2) => {
        let fetcher = convertRouterFetcherToRemixFetcher2({
          state: f2.state,
          data: f2.data,
          formMethod: f2.formMethod,
          formAction: f2.formAction,
          formData: f2.formData,
          formEncType: f2.formEncType,
          " _hasFetcherDoneAnything ": f2[" _hasFetcherDoneAnything "]
        });
        return addFetcherDeprecationWarnings2(fetcher), fetcher;
      });
    }
    function useFetcher3() {
      let fetcherRR = reactRouterDom.useFetcher();
      return React__namespace.useMemo(() => {
        let fetcherWithComponents = {
          ...convertRouterFetcherToRemixFetcher2({
            state: fetcherRR.state,
            data: fetcherRR.data,
            formMethod: fetcherRR.formMethod,
            formAction: fetcherRR.formAction,
            formData: fetcherRR.formData,
            formEncType: fetcherRR.formEncType,
            " _hasFetcherDoneAnything ": fetcherRR[" _hasFetcherDoneAnything "]
          }),
          load: fetcherRR.load,
          submit: fetcherRR.submit,
          Form: fetcherRR.Form
        };
        return addFetcherDeprecationWarnings2(fetcherWithComponents), fetcherWithComponents;
      }, [fetcherRR]);
    }
    function addFetcherDeprecationWarnings2(fetcher) {
      let type2 = fetcher.type;
      Object.defineProperty(fetcher, "type", {
        get() {
          return warnings.logDeprecationOnce(fetcherTypeWarning2), type2;
        },
        set(value2) {
          type2 = value2;
        },
        configurable: !0,
        enumerable: !0
      });
      let submission = fetcher.submission;
      Object.defineProperty(fetcher, "submission", {
        get() {
          return warnings.logDeprecationOnce(fetcherSubmissionWarning2), submission;
        },
        set(value2) {
          submission = value2;
        },
        configurable: !0,
        enumerable: !0
      });
    }
    function convertRouterFetcherToRemixFetcher2(fetcherRR) {
      let {
        state,
        formMethod,
        formAction,
        formEncType,
        formData,
        data: data2
      } = fetcherRR, isActionSubmission = formMethod != null && ["POST", "PUT", "PATCH", "DELETE"].includes(formMethod.toUpperCase());
      if (state === "idle")
        return fetcherRR[" _hasFetcherDoneAnything "] === !0 ? {
          state: "idle",
          type: "done",
          formMethod: void 0,
          formAction: void 0,
          formData: void 0,
          formEncType: void 0,
          submission: void 0,
          data: data2
        } : transition.IDLE_FETCHER;
      if (state === "submitting" && formMethod && formAction && formEncType && formData) {
        if (isActionSubmission)
          return {
            state,
            type: "actionSubmission",
            formMethod: formMethod.toUpperCase(),
            formAction,
            formEncType,
            formData,
            submission: {
              method: formMethod.toUpperCase(),
              action: formAction,
              encType: formEncType,
              formData,
              key: ""
            },
            data: data2
          };
        invariant5(!1, "Encountered an unexpected fetcher scenario in useFetcher()");
      }
      if (state === "loading" && formMethod && formAction && formEncType && formData) {
        if (isActionSubmission)
          return data2 ? {
            state,
            type: "actionReload",
            formMethod: formMethod.toUpperCase(),
            formAction,
            formEncType,
            formData,
            submission: {
              method: formMethod.toUpperCase(),
              action: formAction,
              encType: formEncType,
              formData,
              key: ""
            },
            data: data2
          } : {
            state,
            type: "actionRedirect",
            formMethod: formMethod.toUpperCase(),
            formAction,
            formEncType,
            formData,
            submission: {
              method: formMethod.toUpperCase(),
              action: formAction,
              encType: formEncType,
              formData,
              key: ""
            },
            data: void 0
          };
        {
          let url = new URL(formAction, window.location.origin);
          return url.search = new URLSearchParams(formData.entries()).toString(), {
            state: "submitting",
            type: "loaderSubmission",
            formMethod: formMethod.toUpperCase(),
            formAction,
            formEncType,
            formData,
            submission: {
              method: formMethod.toUpperCase(),
              action: url.pathname + url.search,
              encType: formEncType,
              formData,
              key: ""
            },
            data: data2
          };
        }
      }
      return {
        state: "loading",
        type: "normalLoad",
        formMethod: void 0,
        formAction: void 0,
        formData: void 0,
        formEncType: void 0,
        submission: void 0,
        data: data2
      };
    }
    var LiveReload3 = function({
      port = Number(8002),
      timeoutMs = 1e3,
      nonce = void 0
    }) {
      let js = String.raw;
      return /* @__PURE__ */ React__namespace.createElement("script", {
        nonce,
        suppressHydrationWarning: !0,
        dangerouslySetInnerHTML: {
          __html: js`
                function remixLiveReloadConnect(config) {
                  let protocol = location.protocol === "https:" ? "wss:" : "ws:";
                  let host = location.hostname;
                  let port = (window.__remixContext && window.__remixContext.dev && window.__remixContext.dev.liveReloadPort) || ${String(port)};
                  let socketPath = protocol + "//" + host + ":" + port + "/socket";
                  let ws = new WebSocket(socketPath);
                  ws.onmessage = async (message) => {
                    let event = JSON.parse(message.data);
                    if (event.type === "LOG") {
                      console.log(event.message);
                    }
                    if (event.type === "RELOAD") {
                      console.log(" Reloading window ...");
                      window.location.reload();
                    }
                    if (event.type === "HMR") {
                      if (!window.__hmr__ || !window.__hmr__.contexts) {
                        console.log(" [HMR] No HMR context, reloading window ...");
                        window.location.reload();
                        return;
                      }
                      if (!event.updates || !event.updates.length) return;
                      let updateAccepted = false;
                      for (let update of event.updates) {
                        console.log("[HMR] " + update.reason + " [" + update.id +"]")
                        if (update.revalidate) {
                          console.log("[HMR] Revalidating [" + update.id + "]");
                        }
                        let imported = await import(update.url +  '?t=' + event.assetsManifest.hmr.timestamp);
                        if (window.__hmr__.contexts[update.id]) {
                          let accepted = window.__hmr__.contexts[update.id].emit(
                            imported
                          );
                          if (accepted) {
                            console.log("[HMR] Updated accepted by", update.id);
                            updateAccepted = true;
                          }
                        }
                      }
                      if (event.assetsManifest && window.__hmr__.contexts["remix:manifest"]) {
                        let accepted = window.__hmr__.contexts["remix:manifest"].emit(
                          event.assetsManifest
                        );
                        if (accepted) {
                          console.log("[HMR] Updated accepted by", "remix:manifest");
                          updateAccepted = true;
                        }
                      }
                      if (!updateAccepted) {
                        console.log("[HMR] Updated rejected, reloading...");
                        window.location.reload();
                      }
                    }
                  };
                  ws.onopen = () => {
                    if (config && typeof config.onOpen === "function") {
                      config.onOpen();
                    }
                  };
                  ws.onclose = (event) => {
                    if (event.code === 1006) {
                      console.log("Remix dev asset server web socket closed. Reconnecting...");
                      setTimeout(
                        () =>
                          remixLiveReloadConnect({
                            onOpen: () => window.location.reload(),
                          }),
                      ${String(timeoutMs)}
                      );
                    }
                  };
                  ws.onerror = (error) => {
                    console.log("Remix dev asset server web socket error:");
                    console.error(error);
                  };
                }
                remixLiveReloadConnect();
              `
        }
      });
    };
    exports.Await = Await3;
    exports.Link = Link4;
    exports.Links = Links2;
    exports.LiveReload = LiveReload3;
    exports.Meta = Meta2;
    exports.NavLink = NavLink3;
    exports.PrefetchPageLinks = PrefetchPageLinks2;
    exports.RemixContext = RemixContext2;
    exports.RemixRoute = RemixRoute2;
    exports.RemixRouteError = RemixRouteError2;
    exports.Scripts = Scripts2;
    exports.composeEventHandlers = composeEventHandlers2;
    exports.useActionData = useActionData4;
    exports.useFetcher = useFetcher3;
    exports.useFetchers = useFetchers3;
    exports.useLoaderData = useLoaderData5;
    exports.useMatches = useMatches3;
    exports.useTransition = useTransition2;
  }
});

// node_modules/@remix-run/cloudflare-pages/dist/esm/worker.js
var import_cloudflare = __toESM(require_dist());
function createRequestHandler2({
  build,
  getLoadContext,
  mode
}) {
  let handleRequest3 = (0, import_cloudflare.createRequestHandler)(build, mode);
  return (context) => {
    let loadContext = getLoadContext == null ? void 0 : getLoadContext(context);
    return handleRequest3(context.request, loadContext);
  };
}
function createPagesFunctionHandler({
  build,
  getLoadContext,
  mode
}) {
  let handleRequest3 = createRequestHandler2({
    build,
    getLoadContext,
    mode
  }), handleFetch = async (context) => {
    let response;
    context.request.headers.delete("if-none-match");
    try {
      response = await context.env.ASSETS.fetch(context.request.url, context.request.clone()), response = response && response.status >= 200 && response.status < 400 ? new Response(response.body, response) : void 0;
    } catch {
    }
    return response || (response = await handleRequest3(context)), response;
  };
  return async (context) => {
    try {
      return await handleFetch(context);
    } catch (error2) {
      return error2 instanceof Error ? (console.error(error2), new Response(error2.message || error2.toString(), {
        status: 500
      })) : new Response("Internal Error", {
        status: 500
      });
    }
  };
}

// server-entry-module:@remix-run/dev/server-build
var server_build_exports = {};
__export(server_build_exports, {
  assets: () => assets_manifest_default,
  assetsBuildDirectory: () => assetsBuildDirectory,
  entry: () => entry,
  future: () => future,
  publicPath: () => publicPath,
  routes: () => routes
});

// app/entry.server.tsx
var entry_server_exports = {};
__export(entry_server_exports, {
  default: () => handleRequest
});
init_esm2();

// node_modules/i18next-fs-backend/esm/utils.js
var arr = [], each = arr.forEach, slice = arr.slice;
function defaults(obj) {
  return each.call(slice.call(arguments, 1), function(source2) {
    if (source2)
      for (var prop in source2)
        obj[prop] === void 0 && (obj[prop] = source2[prop]);
  }), obj;
}
function debounce(func, wait, immediate) {
  var timeout2;
  return function() {
    var context = this, args = arguments, later = function() {
      timeout2 = null, immediate || func.apply(context, args);
    }, callNow = immediate && !timeout2;
    clearTimeout(timeout2), timeout2 = setTimeout(later, wait), callNow && func.apply(context, args);
  };
}
function getLastOfPath(object, path2, Empty) {
  function cleanKey(key3) {
    return key3 && key3.indexOf("###") > -1 ? key3.replace(/###/g, ".") : key3;
  }
  for (var stack2 = typeof path2 != "string" ? [].concat(path2) : path2.split("."); stack2.length > 1; ) {
    if (!object)
      return {};
    var key2 = cleanKey(stack2.shift());
    !object[key2] && Empty && (object[key2] = new Empty()), object = object[key2];
  }
  return object ? {
    obj: object,
    k: cleanKey(stack2.shift())
  } : {};
}
function setPath(object, path2, newValue) {
  var _getLastOfPath = getLastOfPath(object, path2, Object), obj = _getLastOfPath.obj, k2 = _getLastOfPath.k;
  obj[k2] = newValue;
}
function pushPath(object, path2, newValue, concat2) {
  var _getLastOfPath2 = getLastOfPath(object, path2, Object), obj = _getLastOfPath2.obj, k2 = _getLastOfPath2.k;
  obj[k2] = obj[k2] || [], concat2 && (obj[k2] = obj[k2].concat(newValue)), concat2 || obj[k2].push(newValue);
}
function getPath(object, path2) {
  var _getLastOfPath3 = getLastOfPath(object, path2), obj = _getLastOfPath3.obj, k2 = _getLastOfPath3.k;
  if (!!obj)
    return obj[k2];
}

// node_modules/i18next-fs-backend/esm/formats/json5.js
function _createForOfIteratorHelper(o2, allowArrayLike) {
  var it = typeof Symbol < "u" && o2[Symbol.iterator] || o2["@@iterator"];
  if (!it) {
    if (Array.isArray(o2) || (it = _unsupportedIterableToArray(o2)) || allowArrayLike && o2 && typeof o2.length == "number") {
      it && (o2 = it);
      var i3 = 0, F2 = function() {
      };
      return { s: F2, n: function() {
        return i3 >= o2.length ? { done: !0 } : { done: !1, value: o2[i3++] };
      }, e: function(_e2) {
        throw _e2;
      }, f: F2 };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  var normalCompletion = !0, didErr = !1, err;
  return { s: function() {
    it = it.call(o2);
  }, n: function() {
    var step = it.next();
    return normalCompletion = step.done, step;
  }, e: function(_e2) {
    didErr = !0, err = _e2;
  }, f: function() {
    try {
      !normalCompletion && it.return != null && it.return();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray(o2, minLen) {
  if (!!o2) {
    if (typeof o2 == "string")
      return _arrayLikeToArray(o2, minLen);
    var n3 = Object.prototype.toString.call(o2).slice(8, -1);
    if (n3 === "Object" && o2.constructor && (n3 = o2.constructor.name), n3 === "Map" || n3 === "Set")
      return Array.from(o2);
    if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3))
      return _arrayLikeToArray(o2, minLen);
  }
}
function _arrayLikeToArray(arr2, len) {
  (len == null || len > arr2.length) && (len = arr2.length);
  for (var i3 = 0, arr22 = new Array(len); i3 < len; i3++)
    arr22[i3] = arr2[i3];
  return arr22;
}
function _typeof(obj) {
  return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
var Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/, ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/, ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/, unicode = {
  Space_Separator,
  ID_Start,
  ID_Continue
}, util = {
  isSpaceSeparator: function(c4) {
    return typeof c4 == "string" && unicode.Space_Separator.test(c4);
  },
  isIdStartChar: function(c4) {
    return typeof c4 == "string" && (c4 >= "a" && c4 <= "z" || c4 >= "A" && c4 <= "Z" || c4 === "$" || c4 === "_" || unicode.ID_Start.test(c4));
  },
  isIdContinueChar: function(c4) {
    return typeof c4 == "string" && (c4 >= "a" && c4 <= "z" || c4 >= "A" && c4 <= "Z" || c4 >= "0" && c4 <= "9" || c4 === "$" || c4 === "_" || c4 === "\u200C" || c4 === "\u200D" || unicode.ID_Continue.test(c4));
  },
  isDigit: function(c4) {
    return typeof c4 == "string" && /[0-9]/.test(c4);
  },
  isHexDigit: function(c4) {
    return typeof c4 == "string" && /[0-9A-Fa-f]/.test(c4);
  }
}, source, parseState, stack, pos, line, column, token, key, root, parse2 = function(text, reviver) {
  source = String(text), parseState = "start", stack = [], pos = 0, line = 1, column = 0, token = void 0, key = void 0, root = void 0;
  do
    token = lex(), parseStates[parseState]();
  while (token.type !== "eof");
  return typeof reviver == "function" ? internalize({
    "": root
  }, "", reviver) : root;
};
function internalize(holder, name, reviver) {
  var value2 = holder[name];
  if (value2 != null && _typeof(value2) === "object")
    for (var _key in value2) {
      var replacement = internalize(value2, _key, reviver);
      replacement === void 0 ? delete value2[_key] : value2[_key] = replacement;
    }
  return reviver.call(holder, name, value2);
}
var lexState, buffer, doubleQuote, _sign, c;
function lex() {
  for (lexState = "default", buffer = "", doubleQuote = !1, _sign = 1; ; ) {
    c = peek();
    var _token = lexStates[lexState]();
    if (_token)
      return _token;
  }
}
function peek() {
  if (source[pos])
    return String.fromCodePoint(source.codePointAt(pos));
}
function read() {
  var c4 = peek();
  return c4 === `
` ? (line++, column = 0) : c4 ? column += c4.length : column++, c4 && (pos += c4.length), c4;
}
var lexStates = {
  default: function() {
    switch (c) {
      case "	":
      case "\v":
      case "\f":
      case " ":
      case "\xA0":
      case "\uFEFF":
      case `
`:
      case "\r":
      case "\u2028":
      case "\u2029":
        read();
        return;
      case "/":
        read(), lexState = "comment";
        return;
      case void 0:
        return read(), newToken("eof");
    }
    if (util.isSpaceSeparator(c)) {
      read();
      return;
    }
    return lexStates[parseState]();
  },
  comment: function() {
    switch (c) {
      case "*":
        read(), lexState = "multiLineComment";
        return;
      case "/":
        read(), lexState = "singleLineComment";
        return;
    }
    throw invalidChar(read());
  },
  multiLineComment: function() {
    switch (c) {
      case "*":
        read(), lexState = "multiLineCommentAsterisk";
        return;
      case void 0:
        throw invalidChar(read());
    }
    read();
  },
  multiLineCommentAsterisk: function() {
    switch (c) {
      case "*":
        read();
        return;
      case "/":
        read(), lexState = "default";
        return;
      case void 0:
        throw invalidChar(read());
    }
    read(), lexState = "multiLineComment";
  },
  singleLineComment: function() {
    switch (c) {
      case `
`:
      case "\r":
      case "\u2028":
      case "\u2029":
        read(), lexState = "default";
        return;
      case void 0:
        return read(), newToken("eof");
    }
    read();
  },
  value: function() {
    switch (c) {
      case "{":
      case "[":
        return newToken("punctuator", read());
      case "n":
        return read(), literal("ull"), newToken("null", null);
      case "t":
        return read(), literal("rue"), newToken("boolean", !0);
      case "f":
        return read(), literal("alse"), newToken("boolean", !1);
      case "-":
      case "+":
        read() === "-" && (_sign = -1), lexState = "sign";
        return;
      case ".":
        buffer = read(), lexState = "decimalPointLeading";
        return;
      case "0":
        buffer = read(), lexState = "zero";
        return;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        buffer = read(), lexState = "decimalInteger";
        return;
      case "I":
        return read(), literal("nfinity"), newToken("numeric", 1 / 0);
      case "N":
        return read(), literal("aN"), newToken("numeric", NaN);
      case '"':
      case "'":
        doubleQuote = read() === '"', buffer = "", lexState = "string";
        return;
    }
    throw invalidChar(read());
  },
  identifierNameStartEscape: function() {
    if (c !== "u")
      throw invalidChar(read());
    read();
    var u2 = unicodeEscape();
    switch (u2) {
      case "$":
      case "_":
        break;
      default:
        if (!util.isIdStartChar(u2))
          throw invalidIdentifier();
        break;
    }
    buffer += u2, lexState = "identifierName";
  },
  identifierName: function() {
    switch (c) {
      case "$":
      case "_":
      case "\u200C":
      case "\u200D":
        buffer += read();
        return;
      case "\\":
        read(), lexState = "identifierNameEscape";
        return;
    }
    if (util.isIdContinueChar(c)) {
      buffer += read();
      return;
    }
    return newToken("identifier", buffer);
  },
  identifierNameEscape: function() {
    if (c !== "u")
      throw invalidChar(read());
    read();
    var u2 = unicodeEscape();
    switch (u2) {
      case "$":
      case "_":
      case "\u200C":
      case "\u200D":
        break;
      default:
        if (!util.isIdContinueChar(u2))
          throw invalidIdentifier();
        break;
    }
    buffer += u2, lexState = "identifierName";
  },
  sign: function() {
    switch (c) {
      case ".":
        buffer = read(), lexState = "decimalPointLeading";
        return;
      case "0":
        buffer = read(), lexState = "zero";
        return;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        buffer = read(), lexState = "decimalInteger";
        return;
      case "I":
        return read(), literal("nfinity"), newToken("numeric", _sign * (1 / 0));
      case "N":
        return read(), literal("aN"), newToken("numeric", NaN);
    }
    throw invalidChar(read());
  },
  zero: function() {
    switch (c) {
      case ".":
        buffer += read(), lexState = "decimalPoint";
        return;
      case "e":
      case "E":
        buffer += read(), lexState = "decimalExponent";
        return;
      case "x":
      case "X":
        buffer += read(), lexState = "hexadecimal";
        return;
    }
    return newToken("numeric", _sign * 0);
  },
  decimalInteger: function() {
    switch (c) {
      case ".":
        buffer += read(), lexState = "decimalPoint";
        return;
      case "e":
      case "E":
        buffer += read(), lexState = "decimalExponent";
        return;
    }
    if (util.isDigit(c)) {
      buffer += read();
      return;
    }
    return newToken("numeric", _sign * Number(buffer));
  },
  decimalPointLeading: function() {
    if (util.isDigit(c)) {
      buffer += read(), lexState = "decimalFraction";
      return;
    }
    throw invalidChar(read());
  },
  decimalPoint: function() {
    switch (c) {
      case "e":
      case "E":
        buffer += read(), lexState = "decimalExponent";
        return;
    }
    if (util.isDigit(c)) {
      buffer += read(), lexState = "decimalFraction";
      return;
    }
    return newToken("numeric", _sign * Number(buffer));
  },
  decimalFraction: function() {
    switch (c) {
      case "e":
      case "E":
        buffer += read(), lexState = "decimalExponent";
        return;
    }
    if (util.isDigit(c)) {
      buffer += read();
      return;
    }
    return newToken("numeric", _sign * Number(buffer));
  },
  decimalExponent: function() {
    switch (c) {
      case "+":
      case "-":
        buffer += read(), lexState = "decimalExponentSign";
        return;
    }
    if (util.isDigit(c)) {
      buffer += read(), lexState = "decimalExponentInteger";
      return;
    }
    throw invalidChar(read());
  },
  decimalExponentSign: function() {
    if (util.isDigit(c)) {
      buffer += read(), lexState = "decimalExponentInteger";
      return;
    }
    throw invalidChar(read());
  },
  decimalExponentInteger: function() {
    if (util.isDigit(c)) {
      buffer += read();
      return;
    }
    return newToken("numeric", _sign * Number(buffer));
  },
  hexadecimal: function() {
    if (util.isHexDigit(c)) {
      buffer += read(), lexState = "hexadecimalInteger";
      return;
    }
    throw invalidChar(read());
  },
  hexadecimalInteger: function() {
    if (util.isHexDigit(c)) {
      buffer += read();
      return;
    }
    return newToken("numeric", _sign * Number(buffer));
  },
  string: function() {
    switch (c) {
      case "\\":
        read(), buffer += escape2();
        return;
      case '"':
        if (doubleQuote)
          return read(), newToken("string", buffer);
        buffer += read();
        return;
      case "'":
        if (!doubleQuote)
          return read(), newToken("string", buffer);
        buffer += read();
        return;
      case `
`:
      case "\r":
        throw invalidChar(read());
      case "\u2028":
      case "\u2029":
        separatorChar(c);
        break;
      case void 0:
        throw invalidChar(read());
    }
    buffer += read();
  },
  start: function() {
    switch (c) {
      case "{":
      case "[":
        return newToken("punctuator", read());
    }
    lexState = "value";
  },
  beforePropertyName: function() {
    switch (c) {
      case "$":
      case "_":
        buffer = read(), lexState = "identifierName";
        return;
      case "\\":
        read(), lexState = "identifierNameStartEscape";
        return;
      case "}":
        return newToken("punctuator", read());
      case '"':
      case "'":
        doubleQuote = read() === '"', lexState = "string";
        return;
    }
    if (util.isIdStartChar(c)) {
      buffer += read(), lexState = "identifierName";
      return;
    }
    throw invalidChar(read());
  },
  afterPropertyName: function() {
    if (c === ":")
      return newToken("punctuator", read());
    throw invalidChar(read());
  },
  beforePropertyValue: function() {
    lexState = "value";
  },
  afterPropertyValue: function() {
    switch (c) {
      case ",":
      case "}":
        return newToken("punctuator", read());
    }
    throw invalidChar(read());
  },
  beforeArrayValue: function() {
    if (c === "]")
      return newToken("punctuator", read());
    lexState = "value";
  },
  afterArrayValue: function() {
    switch (c) {
      case ",":
      case "]":
        return newToken("punctuator", read());
    }
    throw invalidChar(read());
  },
  end: function() {
    throw invalidChar(read());
  }
};
function newToken(type2, value2) {
  return {
    type: type2,
    value: value2,
    line,
    column
  };
}
function literal(s3) {
  var _iterator = _createForOfIteratorHelper(s3), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var _c = _step.value, p = peek();
      if (p !== _c)
        throw invalidChar(read());
      read();
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}
function escape2() {
  var c4 = peek();
  switch (c4) {
    case "b":
      return read(), "\b";
    case "f":
      return read(), "\f";
    case "n":
      return read(), `
`;
    case "r":
      return read(), "\r";
    case "t":
      return read(), "	";
    case "v":
      return read(), "\v";
    case "0":
      if (read(), util.isDigit(peek()))
        throw invalidChar(read());
      return "\0";
    case "x":
      return read(), hexEscape();
    case "u":
      return read(), unicodeEscape();
    case `
`:
    case "\u2028":
    case "\u2029":
      return read(), "";
    case "\r":
      return read(), peek() === `
` && read(), "";
    case "1":
    case "2":
    case "3":
    case "4":
    case "5":
    case "6":
    case "7":
    case "8":
    case "9":
      throw invalidChar(read());
    case void 0:
      throw invalidChar(read());
  }
  return read();
}
function hexEscape() {
  var buffer2 = "", c4 = peek();
  if (!util.isHexDigit(c4) || (buffer2 += read(), c4 = peek(), !util.isHexDigit(c4)))
    throw invalidChar(read());
  return buffer2 += read(), String.fromCodePoint(parseInt(buffer2, 16));
}
function unicodeEscape() {
  for (var buffer2 = "", count = 4; count-- > 0; ) {
    var _c2 = peek();
    if (!util.isHexDigit(_c2))
      throw invalidChar(read());
    buffer2 += read();
  }
  return String.fromCodePoint(parseInt(buffer2, 16));
}
var parseStates = {
  start: function() {
    if (token.type === "eof")
      throw invalidEOF();
    push();
  },
  beforePropertyName: function() {
    switch (token.type) {
      case "identifier":
      case "string":
        key = token.value, parseState = "afterPropertyName";
        return;
      case "punctuator":
        pop();
        return;
      case "eof":
        throw invalidEOF();
    }
  },
  afterPropertyName: function() {
    if (token.type === "eof")
      throw invalidEOF();
    parseState = "beforePropertyValue";
  },
  beforePropertyValue: function() {
    if (token.type === "eof")
      throw invalidEOF();
    push();
  },
  beforeArrayValue: function() {
    if (token.type === "eof")
      throw invalidEOF();
    if (token.type === "punctuator" && token.value === "]") {
      pop();
      return;
    }
    push();
  },
  afterPropertyValue: function() {
    if (token.type === "eof")
      throw invalidEOF();
    switch (token.value) {
      case ",":
        parseState = "beforePropertyName";
        return;
      case "}":
        pop();
    }
  },
  afterArrayValue: function() {
    if (token.type === "eof")
      throw invalidEOF();
    switch (token.value) {
      case ",":
        parseState = "beforeArrayValue";
        return;
      case "]":
        pop();
    }
  },
  end: function() {
  }
};
function push() {
  var value2;
  switch (token.type) {
    case "punctuator":
      switch (token.value) {
        case "{":
          value2 = {};
          break;
        case "[":
          value2 = [];
          break;
      }
      break;
    case "null":
    case "boolean":
    case "numeric":
    case "string":
      value2 = token.value;
      break;
  }
  if (root === void 0)
    root = value2;
  else {
    var parent = stack[stack.length - 1];
    Array.isArray(parent) ? parent.push(value2) : parent[key] = value2;
  }
  if (value2 !== null && _typeof(value2) === "object")
    stack.push(value2), Array.isArray(value2) ? parseState = "beforeArrayValue" : parseState = "beforePropertyName";
  else {
    var current = stack[stack.length - 1];
    current == null ? parseState = "end" : Array.isArray(current) ? parseState = "afterArrayValue" : parseState = "afterPropertyValue";
  }
}
function pop() {
  stack.pop();
  var current = stack[stack.length - 1];
  current == null ? parseState = "end" : Array.isArray(current) ? parseState = "afterArrayValue" : parseState = "afterPropertyValue";
}
function invalidChar(c4) {
  return syntaxError(c4 === void 0 ? "JSON5: invalid end of input at ".concat(line, ":").concat(column) : "JSON5: invalid character '".concat(formatChar(c4), "' at ").concat(line, ":").concat(column));
}
function invalidEOF() {
  return syntaxError("JSON5: invalid end of input at ".concat(line, ":").concat(column));
}
function invalidIdentifier() {
  return column -= 5, syntaxError("JSON5: invalid identifier character at ".concat(line, ":").concat(column));
}
function separatorChar(c4) {
  console.warn("JSON5: '".concat(formatChar(c4), "' in strings is not valid ECMAScript; consider escaping"));
}
function formatChar(c4) {
  var replacements = {
    "'": "\\'",
    '"': '\\"',
    "\\": "\\\\",
    "\b": "\\b",
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t",
    "\v": "\\v",
    "\0": "\\0",
    "\u2028": "\\u2028",
    "\u2029": "\\u2029"
  };
  if (replacements[c4])
    return replacements[c4];
  if (c4 < " ") {
    var hexString = c4.charCodeAt(0).toString(16);
    return "\\x" + ("00" + hexString).substring(hexString.length);
  }
  return c4;
}
function syntaxError(message) {
  var err = new SyntaxError(message);
  return err.lineNumber = line, err.columnNumber = column, err;
}
var stringify = function(value2, replacer, space) {
  var stack2 = [], indent = "", propertyList, replacerFunc, gap = "", quote;
  if (replacer != null && _typeof(replacer) === "object" && !Array.isArray(replacer) && (space = replacer.space, quote = replacer.quote, replacer = replacer.replacer), typeof replacer == "function")
    replacerFunc = replacer;
  else if (Array.isArray(replacer)) {
    propertyList = [];
    var _iterator2 = _createForOfIteratorHelper(replacer), _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
        var v2 = _step2.value, item = void 0;
        typeof v2 == "string" ? item = v2 : (typeof v2 == "number" || v2 instanceof String || v2 instanceof Number) && (item = String(v2)), item !== void 0 && propertyList.indexOf(item) < 0 && propertyList.push(item);
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }
  return space instanceof Number ? space = Number(space) : space instanceof String && (space = String(space)), typeof space == "number" ? space > 0 && (space = Math.min(10, Math.floor(space)), gap = "          ".substr(0, space)) : typeof space == "string" && (gap = space.substr(0, 10)), serializeProperty("", {
    "": value2
  });
  function serializeProperty(key2, holder) {
    var value3 = holder[key2];
    switch (value3 != null && (typeof value3.toJSON5 == "function" ? value3 = value3.toJSON5(key2) : typeof value3.toJSON == "function" && (value3 = value3.toJSON(key2))), replacerFunc && (value3 = replacerFunc.call(holder, key2, value3)), value3 instanceof Number ? value3 = Number(value3) : value3 instanceof String ? value3 = String(value3) : value3 instanceof Boolean && (value3 = value3.valueOf()), value3) {
      case null:
        return "null";
      case !0:
        return "true";
      case !1:
        return "false";
    }
    if (typeof value3 == "string")
      return quoteString(value3, !1);
    if (typeof value3 == "number")
      return String(value3);
    if (_typeof(value3) === "object")
      return Array.isArray(value3) ? serializeArray(value3) : serializeObject(value3);
  }
  function quoteString(value3) {
    for (var quotes = {
      "'": 0.1,
      '"': 0.2
    }, replacements = {
      "'": "\\'",
      '"': '\\"',
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t",
      "\v": "\\v",
      "\0": "\\0",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    }, product = "", i3 = 0; i3 < value3.length; i3++) {
      var _c3 = value3[i3];
      switch (_c3) {
        case "'":
        case '"':
          quotes[_c3]++, product += _c3;
          continue;
        case "\0":
          if (util.isDigit(value3[i3 + 1])) {
            product += "\\x00";
            continue;
          }
      }
      if (replacements[_c3]) {
        product += replacements[_c3];
        continue;
      }
      if (_c3 < " ") {
        var hexString = _c3.charCodeAt(0).toString(16);
        product += "\\x" + ("00" + hexString).substring(hexString.length);
        continue;
      }
      product += _c3;
    }
    var quoteChar = quote || Object.keys(quotes).reduce(function(a3, b2) {
      return quotes[a3] < quotes[b2] ? a3 : b2;
    });
    return product = product.replace(new RegExp(quoteChar, "g"), replacements[quoteChar]), quoteChar + product + quoteChar;
  }
  function serializeObject(value3) {
    if (stack2.indexOf(value3) >= 0)
      throw TypeError("Converting circular structure to JSON5");
    stack2.push(value3);
    var stepback = indent;
    indent = indent + gap;
    var keys2 = propertyList || Object.keys(value3), partial = [], _iterator3 = _createForOfIteratorHelper(keys2), _step3;
    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
        var _key2 = _step3.value, propertyString = serializeProperty(_key2, value3);
        if (propertyString !== void 0) {
          var member = serializeKey(_key2) + ":";
          gap !== "" && (member += " "), member += propertyString, partial.push(member);
        }
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }
    var final;
    if (partial.length === 0)
      final = "{}";
    else {
      var properties;
      if (gap === "")
        properties = partial.join(","), final = "{" + properties + "}";
      else {
        var separator = `,
` + indent;
        properties = partial.join(separator), final = `{
` + indent + properties + `,
` + stepback + "}";
      }
    }
    return stack2.pop(), indent = stepback, final;
  }
  function serializeKey(key2) {
    if (key2.length === 0)
      return quoteString(key2, !0);
    var firstChar = String.fromCodePoint(key2.codePointAt(0));
    if (!util.isIdStartChar(firstChar))
      return quoteString(key2, !0);
    for (var i3 = firstChar.length; i3 < key2.length; i3++)
      if (!util.isIdContinueChar(String.fromCodePoint(key2.codePointAt(i3))))
        return quoteString(key2, !0);
    return key2;
  }
  function serializeArray(value3) {
    if (stack2.indexOf(value3) >= 0)
      throw TypeError("Converting circular structure to JSON5");
    stack2.push(value3);
    var stepback = indent;
    indent = indent + gap;
    for (var partial = [], i3 = 0; i3 < value3.length; i3++) {
      var propertyString = serializeProperty(String(i3), value3);
      partial.push(propertyString !== void 0 ? propertyString : "null");
    }
    var final;
    if (partial.length === 0)
      final = "[]";
    else if (gap === "") {
      var properties = partial.join(",");
      final = "[" + properties + "]";
    } else {
      var separator = `,
` + indent, _properties = partial.join(separator);
      final = `[
` + indent + _properties + `,
` + stepback + "]";
    }
    return stack2.pop(), indent = stepback, final;
  }
}, JSON5 = {
  parse: parse2,
  stringify
}, lib = JSON5, json5_default = lib;

// node_modules/i18next-fs-backend/esm/formats/yaml.js
function _typeof2(obj) {
  return _typeof2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof2(obj);
}
function isNothing(subject) {
  return typeof subject > "u" || subject === null;
}
function isObject(subject) {
  return _typeof2(subject) === "object" && subject !== null;
}
function toArray(sequence) {
  return Array.isArray(sequence) ? sequence : isNothing(sequence) ? [] : [sequence];
}
function extend(target, source2) {
  var index2, length, key2, sourceKeys;
  if (source2)
    for (sourceKeys = Object.keys(source2), index2 = 0, length = sourceKeys.length; index2 < length; index2 += 1)
      key2 = sourceKeys[index2], target[key2] = source2[key2];
  return target;
}
function repeat(string2, count) {
  var result2 = "", cycle;
  for (cycle = 0; cycle < count; cycle += 1)
    result2 += string2;
  return result2;
}
function isNegativeZero(number4) {
  return number4 === 0 && Number.NEGATIVE_INFINITY === 1 / number4;
}
var isNothing_1 = isNothing, isObject_1 = isObject, toArray_1 = toArray, repeat_1 = repeat, isNegativeZero_1 = isNegativeZero, extend_1 = extend, common = {
  isNothing: isNothing_1,
  isObject: isObject_1,
  toArray: toArray_1,
  repeat: repeat_1,
  isNegativeZero: isNegativeZero_1,
  extend: extend_1
};
function formatError(exception2, compact) {
  var where = "", message = exception2.reason || "(unknown reason)";
  return exception2.mark ? (exception2.mark.name && (where += 'in "' + exception2.mark.name + '" '), where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")", !compact && exception2.mark.snippet && (where += `

` + exception2.mark.snippet), message + " " + where) : message;
}
function YAMLException$1(reason, mark) {
  Error.call(this), this.name = "YAMLException", this.reason = reason, this.mark = mark, this.message = formatError(this, !1), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
}
YAMLException$1.prototype = Object.create(Error.prototype);
YAMLException$1.prototype.constructor = YAMLException$1;
YAMLException$1.prototype.toString = function(compact) {
  return this.name + ": " + formatError(this, compact);
};
var exception = YAMLException$1;
function getLine(buffer2, lineStart, lineEnd, position, maxLineLength) {
  var head = "", tail = "", maxHalfLength = Math.floor(maxLineLength / 2) - 1;
  return position - lineStart > maxHalfLength && (head = " ... ", lineStart = position - maxHalfLength + head.length), lineEnd - position > maxHalfLength && (tail = " ...", lineEnd = position + maxHalfLength - tail.length), {
    str: head + buffer2.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
    pos: position - lineStart + head.length
  };
}
function padStart(string2, max) {
  return common.repeat(" ", max - string2.length) + string2;
}
function makeSnippet(mark, options2) {
  if (options2 = Object.create(options2 || null), !mark.buffer)
    return null;
  options2.maxLength || (options2.maxLength = 79), typeof options2.indent != "number" && (options2.indent = 1), typeof options2.linesBefore != "number" && (options2.linesBefore = 3), typeof options2.linesAfter != "number" && (options2.linesAfter = 2);
  for (var re2 = /\r?\n|\r|\0/g, lineStarts = [0], lineEnds = [], match, foundLineNo = -1; match = re2.exec(mark.buffer); )
    lineEnds.push(match.index), lineStarts.push(match.index + match[0].length), mark.position <= match.index && foundLineNo < 0 && (foundLineNo = lineStarts.length - 2);
  foundLineNo < 0 && (foundLineNo = lineStarts.length - 1);
  var result2 = "", i3, line2, lineNoLength = Math.min(mark.line + options2.linesAfter, lineEnds.length).toString().length, maxLineLength = options2.maxLength - (options2.indent + lineNoLength + 3);
  for (i3 = 1; i3 <= options2.linesBefore && !(foundLineNo - i3 < 0); i3++)
    line2 = getLine(mark.buffer, lineStarts[foundLineNo - i3], lineEnds[foundLineNo - i3], mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i3]), maxLineLength), result2 = common.repeat(" ", options2.indent) + padStart((mark.line - i3 + 1).toString(), lineNoLength) + " | " + line2.str + `
` + result2;
  for (line2 = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength), result2 += common.repeat(" ", options2.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line2.str + `
`, result2 += common.repeat("-", options2.indent + lineNoLength + 3 + line2.pos) + `^
`, i3 = 1; i3 <= options2.linesAfter && !(foundLineNo + i3 >= lineEnds.length); i3++)
    line2 = getLine(mark.buffer, lineStarts[foundLineNo + i3], lineEnds[foundLineNo + i3], mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i3]), maxLineLength), result2 += common.repeat(" ", options2.indent) + padStart((mark.line + i3 + 1).toString(), lineNoLength) + " | " + line2.str + `
`;
  return result2.replace(/\n$/, "");
}
var snippet = makeSnippet, TYPE_CONSTRUCTOR_OPTIONS = ["kind", "multi", "resolve", "construct", "instanceOf", "predicate", "represent", "representName", "defaultStyle", "styleAliases"], YAML_NODE_KINDS = ["scalar", "sequence", "mapping"];
function compileStyleAliases(map2) {
  var result2 = {};
  return map2 !== null && Object.keys(map2).forEach(function(style) {
    map2[style].forEach(function(alias) {
      result2[String(alias)] = style;
    });
  }), result2;
}
function Type$1(tag, options2) {
  if (options2 = options2 || {}, Object.keys(options2).forEach(function(name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1)
      throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
  }), this.options = options2, this.tag = tag, this.kind = options2.kind || null, this.resolve = options2.resolve || function() {
    return !0;
  }, this.construct = options2.construct || function(data2) {
    return data2;
  }, this.instanceOf = options2.instanceOf || null, this.predicate = options2.predicate || null, this.represent = options2.represent || null, this.representName = options2.representName || null, this.defaultStyle = options2.defaultStyle || null, this.multi = options2.multi || !1, this.styleAliases = compileStyleAliases(options2.styleAliases || null), YAML_NODE_KINDS.indexOf(this.kind) === -1)
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
}
var type = Type$1;
function compileList(schema2, name) {
  var result2 = [];
  return schema2[name].forEach(function(currentType) {
    var newIndex = result2.length;
    result2.forEach(function(previousType, previousIndex) {
      previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi && (newIndex = previousIndex);
    }), result2[newIndex] = currentType;
  }), result2;
}
function compileMap() {
  var result2 = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, index2, length;
  function collectType(type2) {
    type2.multi ? (result2.multi[type2.kind].push(type2), result2.multi.fallback.push(type2)) : result2[type2.kind][type2.tag] = result2.fallback[type2.tag] = type2;
  }
  for (index2 = 0, length = arguments.length; index2 < length; index2 += 1)
    arguments[index2].forEach(collectType);
  return result2;
}
function Schema$1(definition) {
  return this.extend(definition);
}
Schema$1.prototype.extend = function(definition) {
  var implicit = [], explicit = [];
  if (definition instanceof type)
    explicit.push(definition);
  else if (Array.isArray(definition))
    explicit = explicit.concat(definition);
  else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit)))
    definition.implicit && (implicit = implicit.concat(definition.implicit)), definition.explicit && (explicit = explicit.concat(definition.explicit));
  else
    throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  implicit.forEach(function(type$1) {
    if (!(type$1 instanceof type))
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    if (type$1.loadKind && type$1.loadKind !== "scalar")
      throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    if (type$1.multi)
      throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
  }), explicit.forEach(function(type$1) {
    if (!(type$1 instanceof type))
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
  });
  var result2 = Object.create(Schema$1.prototype);
  return result2.implicit = (this.implicit || []).concat(implicit), result2.explicit = (this.explicit || []).concat(explicit), result2.compiledImplicit = compileList(result2, "implicit"), result2.compiledExplicit = compileList(result2, "explicit"), result2.compiledTypeMap = compileMap(result2.compiledImplicit, result2.compiledExplicit), result2;
};
var schema = Schema$1, str = new type("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(data2) {
    return data2 !== null ? data2 : "";
  }
}), seq = new type("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(data2) {
    return data2 !== null ? data2 : [];
  }
}), map = new type("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(data2) {
    return data2 !== null ? data2 : {};
  }
}), failsafe = new schema({
  explicit: [str, seq, map]
});
function resolveYamlNull(data2) {
  if (data2 === null)
    return !0;
  var max = data2.length;
  return max === 1 && data2 === "~" || max === 4 && (data2 === "null" || data2 === "Null" || data2 === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull(object) {
  return object === null;
}
var _null = new type("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
});
function resolveYamlBoolean(data2) {
  if (data2 === null)
    return !1;
  var max = data2.length;
  return max === 4 && (data2 === "true" || data2 === "True" || data2 === "TRUE") || max === 5 && (data2 === "false" || data2 === "False" || data2 === "FALSE");
}
function constructYamlBoolean(data2) {
  return data2 === "true" || data2 === "True" || data2 === "TRUE";
}
function isBoolean(object) {
  return Object.prototype.toString.call(object) === "[object Boolean]";
}
var bool = new type("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function(object) {
      return object ? "true" : "false";
    },
    uppercase: function(object) {
      return object ? "TRUE" : "FALSE";
    },
    camelcase: function(object) {
      return object ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
function isHexCode(c4) {
  return 48 <= c4 && c4 <= 57 || 65 <= c4 && c4 <= 70 || 97 <= c4 && c4 <= 102;
}
function isOctCode(c4) {
  return 48 <= c4 && c4 <= 55;
}
function isDecCode(c4) {
  return 48 <= c4 && c4 <= 57;
}
function resolveYamlInteger(data2) {
  if (data2 === null)
    return !1;
  var max = data2.length, index2 = 0, hasDigits = !1, ch;
  if (!max)
    return !1;
  if (ch = data2[index2], (ch === "-" || ch === "+") && (ch = data2[++index2]), ch === "0") {
    if (index2 + 1 === max)
      return !0;
    if (ch = data2[++index2], ch === "b") {
      for (index2++; index2 < max; index2++)
        if (ch = data2[index2], ch !== "_") {
          if (ch !== "0" && ch !== "1")
            return !1;
          hasDigits = !0;
        }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      for (index2++; index2 < max; index2++)
        if (ch = data2[index2], ch !== "_") {
          if (!isHexCode(data2.charCodeAt(index2)))
            return !1;
          hasDigits = !0;
        }
      return hasDigits && ch !== "_";
    }
    if (ch === "o") {
      for (index2++; index2 < max; index2++)
        if (ch = data2[index2], ch !== "_") {
          if (!isOctCode(data2.charCodeAt(index2)))
            return !1;
          hasDigits = !0;
        }
      return hasDigits && ch !== "_";
    }
  }
  if (ch === "_")
    return !1;
  for (; index2 < max; index2++)
    if (ch = data2[index2], ch !== "_") {
      if (!isDecCode(data2.charCodeAt(index2)))
        return !1;
      hasDigits = !0;
    }
  return !(!hasDigits || ch === "_");
}
function constructYamlInteger(data2) {
  var value2 = data2, sign2 = 1, ch;
  if (value2.indexOf("_") !== -1 && (value2 = value2.replace(/_/g, "")), ch = value2[0], (ch === "-" || ch === "+") && (ch === "-" && (sign2 = -1), value2 = value2.slice(1), ch = value2[0]), value2 === "0")
    return 0;
  if (ch === "0") {
    if (value2[1] === "b")
      return sign2 * parseInt(value2.slice(2), 2);
    if (value2[1] === "x")
      return sign2 * parseInt(value2.slice(2), 16);
    if (value2[1] === "o")
      return sign2 * parseInt(value2.slice(2), 8);
  }
  return sign2 * parseInt(value2, 10);
}
function isInteger(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && object % 1 === 0 && !common.isNegativeZero(object);
}
var int = new type("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary: function(obj) {
      return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
    },
    octal: function(obj) {
      return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
    },
    decimal: function(obj) {
      return obj.toString(10);
    },
    hexadecimal: function(obj) {
      return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
}), YAML_FLOAT_PATTERN = new RegExp(
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function resolveYamlFloat(data2) {
  return !(data2 === null || !YAML_FLOAT_PATTERN.test(data2) || data2[data2.length - 1] === "_");
}
function constructYamlFloat(data2) {
  var value2, sign2;
  return value2 = data2.replace(/_/g, "").toLowerCase(), sign2 = value2[0] === "-" ? -1 : 1, "+-".indexOf(value2[0]) >= 0 && (value2 = value2.slice(1)), value2 === ".inf" ? sign2 === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : value2 === ".nan" ? NaN : sign2 * parseFloat(value2, 10);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object, style) {
  var res;
  if (isNaN(object))
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  else if (Number.POSITIVE_INFINITY === object)
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  else if (Number.NEGATIVE_INFINITY === object)
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  else if (common.isNegativeZero(object))
    return "-0.0";
  return res = object.toString(10), SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function isFloat(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
}
var float = new type("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: "lowercase"
}), json4 = failsafe.extend({
  implicit: [_null, bool, int, float]
}), core = json4, YAML_DATE_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"), YAML_TIMESTAMP_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$");
function resolveYamlTimestamp(data2) {
  return data2 === null ? !1 : YAML_DATE_REGEXP.exec(data2) !== null || YAML_TIMESTAMP_REGEXP.exec(data2) !== null;
}
function constructYamlTimestamp(data2) {
  var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date3;
  if (match = YAML_DATE_REGEXP.exec(data2), match === null && (match = YAML_TIMESTAMP_REGEXP.exec(data2)), match === null)
    throw new Error("Date resolve error");
  if (year = +match[1], month = +match[2] - 1, day = +match[3], !match[4])
    return new Date(Date.UTC(year, month, day));
  if (hour = +match[4], minute = +match[5], second = +match[6], match[7]) {
    for (fraction = match[7].slice(0, 3); fraction.length < 3; )
      fraction += "0";
    fraction = +fraction;
  }
  return match[9] && (tz_hour = +match[10], tz_minute = +(match[11] || 0), delta = (tz_hour * 60 + tz_minute) * 6e4, match[9] === "-" && (delta = -delta)), date3 = new Date(Date.UTC(year, month, day, hour, minute, second, fraction)), delta && date3.setTime(date3.getTime() - delta), date3;
}
function representYamlTimestamp(object) {
  return object.toISOString();
}
var timestamp = new type("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});
function resolveYamlMerge(data2) {
  return data2 === "<<" || data2 === null;
}
var merge = new type("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: resolveYamlMerge
}), BASE64_MAP = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
function resolveYamlBinary(data2) {
  if (data2 === null)
    return !1;
  var code, idx, bitlen = 0, max = data2.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++)
    if (code = map2.indexOf(data2.charAt(idx)), !(code > 64)) {
      if (code < 0)
        return !1;
      bitlen += 6;
    }
  return bitlen % 8 === 0;
}
function constructYamlBinary(data2) {
  var idx, tailbits, input = data2.replace(/[\r\n=]/g, ""), max = input.length, map2 = BASE64_MAP, bits = 0, result2 = [];
  for (idx = 0; idx < max; idx++)
    idx % 4 === 0 && idx && (result2.push(bits >> 16 & 255), result2.push(bits >> 8 & 255), result2.push(bits & 255)), bits = bits << 6 | map2.indexOf(input.charAt(idx));
  return tailbits = max % 4 * 6, tailbits === 0 ? (result2.push(bits >> 16 & 255), result2.push(bits >> 8 & 255), result2.push(bits & 255)) : tailbits === 18 ? (result2.push(bits >> 10 & 255), result2.push(bits >> 2 & 255)) : tailbits === 12 && result2.push(bits >> 4 & 255), new Uint8Array(result2);
}
function representYamlBinary(object) {
  var result2 = "", bits = 0, idx, tail, max = object.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++)
    idx % 3 === 0 && idx && (result2 += map2[bits >> 18 & 63], result2 += map2[bits >> 12 & 63], result2 += map2[bits >> 6 & 63], result2 += map2[bits & 63]), bits = (bits << 8) + object[idx];
  return tail = max % 3, tail === 0 ? (result2 += map2[bits >> 18 & 63], result2 += map2[bits >> 12 & 63], result2 += map2[bits >> 6 & 63], result2 += map2[bits & 63]) : tail === 2 ? (result2 += map2[bits >> 10 & 63], result2 += map2[bits >> 4 & 63], result2 += map2[bits << 2 & 63], result2 += map2[64]) : tail === 1 && (result2 += map2[bits >> 2 & 63], result2 += map2[bits << 4 & 63], result2 += map2[64], result2 += map2[64]), result2;
}
function isBinary(obj) {
  return Object.prototype.toString.call(obj) === "[object Uint8Array]";
}
var binary2 = new type("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
}), _hasOwnProperty$3 = Object.prototype.hasOwnProperty, _toString$2 = Object.prototype.toString;
function resolveYamlOmap(data2) {
  if (data2 === null)
    return !0;
  var objectKeys = [], index2, length, pair, pairKey, pairHasKey, object = data2;
  for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
    if (pair = object[index2], pairHasKey = !1, _toString$2.call(pair) !== "[object Object]")
      return !1;
    for (pairKey in pair)
      if (_hasOwnProperty$3.call(pair, pairKey))
        if (!pairHasKey)
          pairHasKey = !0;
        else
          return !1;
    if (!pairHasKey)
      return !1;
    if (objectKeys.indexOf(pairKey) === -1)
      objectKeys.push(pairKey);
    else
      return !1;
  }
  return !0;
}
function constructYamlOmap(data2) {
  return data2 !== null ? data2 : [];
}
var omap = new type("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
}), _toString$1 = Object.prototype.toString;
function resolveYamlPairs(data2) {
  if (data2 === null)
    return !0;
  var index2, length, pair, keys2, result2, object = data2;
  for (result2 = new Array(object.length), index2 = 0, length = object.length; index2 < length; index2 += 1) {
    if (pair = object[index2], _toString$1.call(pair) !== "[object Object]" || (keys2 = Object.keys(pair), keys2.length !== 1))
      return !1;
    result2[index2] = [keys2[0], pair[keys2[0]]];
  }
  return !0;
}
function constructYamlPairs(data2) {
  if (data2 === null)
    return [];
  var index2, length, pair, keys2, result2, object = data2;
  for (result2 = new Array(object.length), index2 = 0, length = object.length; index2 < length; index2 += 1)
    pair = object[index2], keys2 = Object.keys(pair), result2[index2] = [keys2[0], pair[keys2[0]]];
  return result2;
}
var pairs = new type("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
}), _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function resolveYamlSet(data2) {
  if (data2 === null)
    return !0;
  var key2, object = data2;
  for (key2 in object)
    if (_hasOwnProperty$2.call(object, key2) && object[key2] !== null)
      return !1;
  return !0;
}
function constructYamlSet(data2) {
  return data2 !== null ? data2 : {};
}
var set = new type("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: resolveYamlSet,
  construct: constructYamlSet
}), _default2 = core.extend({
  implicit: [timestamp, merge],
  explicit: [binary2, omap, pairs, set]
}), _hasOwnProperty$1 = Object.prototype.hasOwnProperty, CONTEXT_FLOW_IN = 1, CONTEXT_FLOW_OUT = 2, CONTEXT_BLOCK_IN = 3, CONTEXT_BLOCK_OUT = 4, CHOMPING_CLIP = 1, CHOMPING_STRIP = 2, CHOMPING_KEEP = 3, PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/, PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/, PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i, PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL(c4) {
  return c4 === 10 || c4 === 13;
}
function is_WHITE_SPACE(c4) {
  return c4 === 9 || c4 === 32;
}
function is_WS_OR_EOL(c4) {
  return c4 === 9 || c4 === 32 || c4 === 10 || c4 === 13;
}
function is_FLOW_INDICATOR(c4) {
  return c4 === 44 || c4 === 91 || c4 === 93 || c4 === 123 || c4 === 125;
}
function fromHexCode(c4) {
  var lc;
  return 48 <= c4 && c4 <= 57 ? c4 - 48 : (lc = c4 | 32, 97 <= lc && lc <= 102 ? lc - 97 + 10 : -1);
}
function escapedHexLen(c4) {
  return c4 === 120 ? 2 : c4 === 117 ? 4 : c4 === 85 ? 8 : 0;
}
function fromDecimalCode(c4) {
  return 48 <= c4 && c4 <= 57 ? c4 - 48 : -1;
}
function simpleEscapeSequence(c4) {
  return c4 === 48 ? "\0" : c4 === 97 ? "\x07" : c4 === 98 ? "\b" : c4 === 116 || c4 === 9 ? "	" : c4 === 110 ? `
` : c4 === 118 ? "\v" : c4 === 102 ? "\f" : c4 === 114 ? "\r" : c4 === 101 ? "\x1B" : c4 === 32 ? " " : c4 === 34 ? '"' : c4 === 47 ? "/" : c4 === 92 ? "\\" : c4 === 78 ? "\x85" : c4 === 95 ? "\xA0" : c4 === 76 ? "\u2028" : c4 === 80 ? "\u2029" : "";
}
function charFromCodepoint(c4) {
  return c4 <= 65535 ? String.fromCharCode(c4) : String.fromCharCode((c4 - 65536 >> 10) + 55296, (c4 - 65536 & 1023) + 56320);
}
var simpleEscapeCheck = new Array(256), simpleEscapeMap = new Array(256);
for (i3 = 0; i3 < 256; i3++)
  simpleEscapeCheck[i3] = simpleEscapeSequence(i3) ? 1 : 0, simpleEscapeMap[i3] = simpleEscapeSequence(i3);
var i3;
function State$1(input, options2) {
  this.input = input, this.filename = options2.filename || null, this.schema = options2.schema || _default2, this.onWarning = options2.onWarning || null, this.legacy = options2.legacy || !1, this.json = options2.json || !1, this.listener = options2.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = input.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.firstTabInLine = -1, this.documents = [];
}
function generateError(state, message) {
  var mark = {
    name: state.filename,
    buffer: state.input.slice(0, -1),
    position: state.position,
    line: state.line,
    column: state.position - state.lineStart
  };
  return mark.snippet = snippet(mark), new exception(message, mark);
}
function throwError(state, message) {
  throw generateError(state, message);
}
function throwWarning(state, message) {
  state.onWarning && state.onWarning.call(null, generateError(state, message));
}
var directiveHandlers = {
  YAML: function(state, name, args) {
    var match, major, minor;
    state.version !== null && throwError(state, "duplication of %YAML directive"), args.length !== 1 && throwError(state, "YAML directive accepts exactly one argument"), match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]), match === null && throwError(state, "ill-formed argument of the YAML directive"), major = parseInt(match[1], 10), minor = parseInt(match[2], 10), major !== 1 && throwError(state, "unacceptable YAML version of the document"), state.version = args[0], state.checkLineBreaks = minor < 2, minor !== 1 && minor !== 2 && throwWarning(state, "unsupported YAML version of the document");
  },
  TAG: function(state, name, args) {
    var handle2, prefix;
    args.length !== 2 && throwError(state, "TAG directive accepts exactly two arguments"), handle2 = args[0], prefix = args[1], PATTERN_TAG_HANDLE.test(handle2) || throwError(state, "ill-formed tag handle (first argument) of the TAG directive"), _hasOwnProperty$1.call(state.tagMap, handle2) && throwError(state, 'there is a previously declared suffix for "' + handle2 + '" tag handle'), PATTERN_TAG_URI.test(prefix) || throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
    try {
      prefix = decodeURIComponent(prefix);
    } catch {
      throwError(state, "tag prefix is malformed: " + prefix);
    }
    state.tagMap[handle2] = prefix;
  }
};
function captureSegment(state, start3, end3, checkJson) {
  var _position, _length, _character, _result;
  if (start3 < end3) {
    if (_result = state.input.slice(start3, end3), checkJson)
      for (_position = 0, _length = _result.length; _position < _length; _position += 1)
        _character = _result.charCodeAt(_position), _character === 9 || 32 <= _character && _character <= 1114111 || throwError(state, "expected valid JSON character");
    else
      PATTERN_NON_PRINTABLE.test(_result) && throwError(state, "the stream contains non-printable characters");
    state.result += _result;
  }
}
function mergeMappings(state, destination, source2, overridableKeys) {
  var sourceKeys, key2, index2, quantity;
  for (common.isObject(source2) || throwError(state, "cannot merge mappings; the provided source object is unacceptable"), sourceKeys = Object.keys(source2), index2 = 0, quantity = sourceKeys.length; index2 < quantity; index2 += 1)
    key2 = sourceKeys[index2], _hasOwnProperty$1.call(destination, key2) || (destination[key2] = source2[key2], overridableKeys[key2] = !0);
}
function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
  var index2, quantity;
  if (Array.isArray(keyNode))
    for (keyNode = Array.prototype.slice.call(keyNode), index2 = 0, quantity = keyNode.length; index2 < quantity; index2 += 1)
      Array.isArray(keyNode[index2]) && throwError(state, "nested arrays are not supported inside keys"), _typeof2(keyNode) === "object" && _class(keyNode[index2]) === "[object Object]" && (keyNode[index2] = "[object Object]");
  if (_typeof2(keyNode) === "object" && _class(keyNode) === "[object Object]" && (keyNode = "[object Object]"), keyNode = String(keyNode), _result === null && (_result = {}), keyTag === "tag:yaml.org,2002:merge")
    if (Array.isArray(valueNode))
      for (index2 = 0, quantity = valueNode.length; index2 < quantity; index2 += 1)
        mergeMappings(state, _result, valueNode[index2], overridableKeys);
    else
      mergeMappings(state, _result, valueNode, overridableKeys);
  else
    !state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode) && (state.line = startLine || state.line, state.lineStart = startLineStart || state.lineStart, state.position = startPos || state.position, throwError(state, "duplicated mapping key")), keyNode === "__proto__" ? Object.defineProperty(_result, keyNode, {
      configurable: !0,
      enumerable: !0,
      writable: !0,
      value: valueNode
    }) : _result[keyNode] = valueNode, delete overridableKeys[keyNode];
  return _result;
}
function readLineBreak(state) {
  var ch;
  ch = state.input.charCodeAt(state.position), ch === 10 ? state.position++ : ch === 13 ? (state.position++, state.input.charCodeAt(state.position) === 10 && state.position++) : throwError(state, "a line break is expected"), state.line += 1, state.lineStart = state.position, state.firstTabInLine = -1;
}
function skipSeparationSpace(state, allowComments, checkIndent) {
  for (var lineBreaks = 0, ch = state.input.charCodeAt(state.position); ch !== 0; ) {
    for (; is_WHITE_SPACE(ch); )
      ch === 9 && state.firstTabInLine === -1 && (state.firstTabInLine = state.position), ch = state.input.charCodeAt(++state.position);
    if (allowComments && ch === 35)
      do
        ch = state.input.charCodeAt(++state.position);
      while (ch !== 10 && ch !== 13 && ch !== 0);
    if (is_EOL(ch))
      for (readLineBreak(state), ch = state.input.charCodeAt(state.position), lineBreaks++, state.lineIndent = 0; ch === 32; )
        state.lineIndent++, ch = state.input.charCodeAt(++state.position);
    else
      break;
  }
  return checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent && throwWarning(state, "deficient indentation"), lineBreaks;
}
function testDocumentSeparator(state) {
  var _position = state.position, ch;
  return ch = state.input.charCodeAt(_position), !!((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2) && (_position += 3, ch = state.input.charCodeAt(_position), ch === 0 || is_WS_OR_EOL(ch)));
}
function writeFoldedLines(state, count) {
  count === 1 ? state.result += " " : count > 1 && (state.result += common.repeat(`
`, count - 1));
}
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
  if (ch = state.input.charCodeAt(state.position), is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96 || (ch === 63 || ch === 45) && (following = state.input.charCodeAt(state.position + 1), is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)))
    return !1;
  for (state.kind = "scalar", state.result = "", captureStart = captureEnd = state.position, hasPendingContent = !1; ch !== 0; ) {
    if (ch === 58) {
      if (following = state.input.charCodeAt(state.position + 1), is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following))
        break;
    } else if (ch === 35) {
      if (preceding = state.input.charCodeAt(state.position - 1), is_WS_OR_EOL(preceding))
        break;
    } else {
      if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch))
        break;
      if (is_EOL(ch))
        if (_line = state.line, _lineStart = state.lineStart, _lineIndent = state.lineIndent, skipSeparationSpace(state, !1, -1), state.lineIndent >= nodeIndent) {
          hasPendingContent = !0, ch = state.input.charCodeAt(state.position);
          continue;
        } else {
          state.position = captureEnd, state.line = _line, state.lineStart = _lineStart, state.lineIndent = _lineIndent;
          break;
        }
    }
    hasPendingContent && (captureSegment(state, captureStart, captureEnd, !1), writeFoldedLines(state, state.line - _line), captureStart = captureEnd = state.position, hasPendingContent = !1), is_WHITE_SPACE(ch) || (captureEnd = state.position + 1), ch = state.input.charCodeAt(++state.position);
  }
  return captureSegment(state, captureStart, captureEnd, !1), state.result ? !0 : (state.kind = _kind, state.result = _result, !1);
}
function readSingleQuotedScalar(state, nodeIndent) {
  var ch, captureStart, captureEnd;
  if (ch = state.input.charCodeAt(state.position), ch !== 39)
    return !1;
  for (state.kind = "scalar", state.result = "", state.position++, captureStart = captureEnd = state.position; (ch = state.input.charCodeAt(state.position)) !== 0; )
    if (ch === 39)
      if (captureSegment(state, captureStart, state.position, !0), ch = state.input.charCodeAt(++state.position), ch === 39)
        captureStart = state.position, state.position++, captureEnd = state.position;
      else
        return !0;
    else
      is_EOL(ch) ? (captureSegment(state, captureStart, captureEnd, !0), writeFoldedLines(state, skipSeparationSpace(state, !1, nodeIndent)), captureStart = captureEnd = state.position) : state.position === state.lineStart && testDocumentSeparator(state) ? throwError(state, "unexpected end of the document within a single quoted scalar") : (state.position++, captureEnd = state.position);
  throwError(state, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
  if (ch = state.input.charCodeAt(state.position), ch !== 34)
    return !1;
  for (state.kind = "scalar", state.result = "", state.position++, captureStart = captureEnd = state.position; (ch = state.input.charCodeAt(state.position)) !== 0; ) {
    if (ch === 34)
      return captureSegment(state, captureStart, state.position, !0), state.position++, !0;
    if (ch === 92) {
      if (captureSegment(state, captureStart, state.position, !0), ch = state.input.charCodeAt(++state.position), is_EOL(ch))
        skipSeparationSpace(state, !1, nodeIndent);
      else if (ch < 256 && simpleEscapeCheck[ch])
        state.result += simpleEscapeMap[ch], state.position++;
      else if ((tmp = escapedHexLen(ch)) > 0) {
        for (hexLength = tmp, hexResult = 0; hexLength > 0; hexLength--)
          ch = state.input.charCodeAt(++state.position), (tmp = fromHexCode(ch)) >= 0 ? hexResult = (hexResult << 4) + tmp : throwError(state, "expected hexadecimal character");
        state.result += charFromCodepoint(hexResult), state.position++;
      } else
        throwError(state, "unknown escape sequence");
      captureStart = captureEnd = state.position;
    } else
      is_EOL(ch) ? (captureSegment(state, captureStart, captureEnd, !0), writeFoldedLines(state, skipSeparationSpace(state, !1, nodeIndent)), captureStart = captureEnd = state.position) : state.position === state.lineStart && testDocumentSeparator(state) ? throwError(state, "unexpected end of the document within a double quoted scalar") : (state.position++, captureEnd = state.position);
  }
  throwError(state, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state, nodeIndent) {
  var readNext = !0, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
  if (ch = state.input.charCodeAt(state.position), ch === 91)
    terminator = 93, isMapping = !1, _result = [];
  else if (ch === 123)
    terminator = 125, isMapping = !0, _result = {};
  else
    return !1;
  for (state.anchor !== null && (state.anchorMap[state.anchor] = _result), ch = state.input.charCodeAt(++state.position); ch !== 0; ) {
    if (skipSeparationSpace(state, !0, nodeIndent), ch = state.input.charCodeAt(state.position), ch === terminator)
      return state.position++, state.tag = _tag, state.anchor = _anchor, state.kind = isMapping ? "mapping" : "sequence", state.result = _result, !0;
    readNext ? ch === 44 && throwError(state, "expected the node content, but found ','") : throwError(state, "missed comma between flow collection entries"), keyTag = keyNode = valueNode = null, isPair = isExplicitPair = !1, ch === 63 && (following = state.input.charCodeAt(state.position + 1), is_WS_OR_EOL(following) && (isPair = isExplicitPair = !0, state.position++, skipSeparationSpace(state, !0, nodeIndent))), _line = state.line, _lineStart = state.lineStart, _pos = state.position, composeNode(state, nodeIndent, CONTEXT_FLOW_IN, !1, !0), keyTag = state.tag, keyNode = state.result, skipSeparationSpace(state, !0, nodeIndent), ch = state.input.charCodeAt(state.position), (isExplicitPair || state.line === _line) && ch === 58 && (isPair = !0, ch = state.input.charCodeAt(++state.position), skipSeparationSpace(state, !0, nodeIndent), composeNode(state, nodeIndent, CONTEXT_FLOW_IN, !1, !0), valueNode = state.result), isMapping ? storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos) : isPair ? _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos)) : _result.push(keyNode), skipSeparationSpace(state, !0, nodeIndent), ch = state.input.charCodeAt(state.position), ch === 44 ? (readNext = !0, ch = state.input.charCodeAt(++state.position)) : readNext = !1;
  }
  throwError(state, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = !1, detectedIndent = !1, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = !1, tmp, ch;
  if (ch = state.input.charCodeAt(state.position), ch === 124)
    folding = !1;
  else if (ch === 62)
    folding = !0;
  else
    return !1;
  for (state.kind = "scalar", state.result = ""; ch !== 0; )
    if (ch = state.input.charCodeAt(++state.position), ch === 43 || ch === 45)
      CHOMPING_CLIP === chomping ? chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP : throwError(state, "repeat of a chomping mode identifier");
    else if ((tmp = fromDecimalCode(ch)) >= 0)
      tmp === 0 ? throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one") : detectedIndent ? throwError(state, "repeat of an indentation width identifier") : (textIndent = nodeIndent + tmp - 1, detectedIndent = !0);
    else
      break;
  if (is_WHITE_SPACE(ch)) {
    do
      ch = state.input.charCodeAt(++state.position);
    while (is_WHITE_SPACE(ch));
    if (ch === 35)
      do
        ch = state.input.charCodeAt(++state.position);
      while (!is_EOL(ch) && ch !== 0);
  }
  for (; ch !== 0; ) {
    for (readLineBreak(state), state.lineIndent = 0, ch = state.input.charCodeAt(state.position); (!detectedIndent || state.lineIndent < textIndent) && ch === 32; )
      state.lineIndent++, ch = state.input.charCodeAt(++state.position);
    if (!detectedIndent && state.lineIndent > textIndent && (textIndent = state.lineIndent), is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state.lineIndent < textIndent) {
      chomping === CHOMPING_KEEP ? state.result += common.repeat(`
`, didReadContent ? 1 + emptyLines : emptyLines) : chomping === CHOMPING_CLIP && didReadContent && (state.result += `
`);
      break;
    }
    for (folding ? is_WHITE_SPACE(ch) ? (atMoreIndented = !0, state.result += common.repeat(`
`, didReadContent ? 1 + emptyLines : emptyLines)) : atMoreIndented ? (atMoreIndented = !1, state.result += common.repeat(`
`, emptyLines + 1)) : emptyLines === 0 ? didReadContent && (state.result += " ") : state.result += common.repeat(`
`, emptyLines) : state.result += common.repeat(`
`, didReadContent ? 1 + emptyLines : emptyLines), didReadContent = !0, detectedIndent = !0, emptyLines = 0, captureStart = state.position; !is_EOL(ch) && ch !== 0; )
      ch = state.input.charCodeAt(++state.position);
    captureSegment(state, captureStart, state.position, !1);
  }
  return !0;
}
function readBlockSequence(state, nodeIndent) {
  var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = !1, ch;
  if (state.firstTabInLine !== -1)
    return !1;
  for (state.anchor !== null && (state.anchorMap[state.anchor] = _result), ch = state.input.charCodeAt(state.position); ch !== 0 && (state.firstTabInLine !== -1 && (state.position = state.firstTabInLine, throwError(state, "tab characters must not be used in indentation")), !(ch !== 45 || (following = state.input.charCodeAt(state.position + 1), !is_WS_OR_EOL(following)))); ) {
    if (detected = !0, state.position++, skipSeparationSpace(state, !0, -1) && state.lineIndent <= nodeIndent) {
      _result.push(null), ch = state.input.charCodeAt(state.position);
      continue;
    }
    if (_line = state.line, composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, !1, !0), _result.push(state.result), skipSeparationSpace(state, !0, -1), ch = state.input.charCodeAt(state.position), (state.line === _line || state.lineIndent > nodeIndent) && ch !== 0)
      throwError(state, "bad indentation of a sequence entry");
    else if (state.lineIndent < nodeIndent)
      break;
  }
  return detected ? (state.tag = _tag, state.anchor = _anchor, state.kind = "sequence", state.result = _result, !0) : !1;
}
function readBlockMapping(state, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = !1, detected = !1, ch;
  if (state.firstTabInLine !== -1)
    return !1;
  for (state.anchor !== null && (state.anchorMap[state.anchor] = _result), ch = state.input.charCodeAt(state.position); ch !== 0; ) {
    if (!atExplicitKey && state.firstTabInLine !== -1 && (state.position = state.firstTabInLine, throwError(state, "tab characters must not be used in indentation")), following = state.input.charCodeAt(state.position + 1), _line = state.line, (ch === 63 || ch === 58) && is_WS_OR_EOL(following))
      ch === 63 ? (atExplicitKey && (storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos), keyTag = keyNode = valueNode = null), detected = !0, atExplicitKey = !0, allowCompact = !0) : atExplicitKey ? (atExplicitKey = !1, allowCompact = !0) : throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), state.position += 1, ch = following;
    else {
      if (_keyLine = state.line, _keyLineStart = state.lineStart, _keyPos = state.position, !composeNode(state, flowIndent, CONTEXT_FLOW_OUT, !1, !0))
        break;
      if (state.line === _line) {
        for (ch = state.input.charCodeAt(state.position); is_WHITE_SPACE(ch); )
          ch = state.input.charCodeAt(++state.position);
        if (ch === 58)
          ch = state.input.charCodeAt(++state.position), is_WS_OR_EOL(ch) || throwError(state, "a whitespace character is expected after the key-value separator within a block mapping"), atExplicitKey && (storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos), keyTag = keyNode = valueNode = null), detected = !0, atExplicitKey = !1, allowCompact = !1, keyTag = state.tag, keyNode = state.result;
        else if (detected)
          throwError(state, "can not read an implicit mapping pair; a colon is missed");
        else
          return state.tag = _tag, state.anchor = _anchor, !0;
      } else if (detected)
        throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
      else
        return state.tag = _tag, state.anchor = _anchor, !0;
    }
    if ((state.line === _line || state.lineIndent > nodeIndent) && (atExplicitKey && (_keyLine = state.line, _keyLineStart = state.lineStart, _keyPos = state.position), composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, !0, allowCompact) && (atExplicitKey ? keyNode = state.result : valueNode = state.result), atExplicitKey || (storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos), keyTag = keyNode = valueNode = null), skipSeparationSpace(state, !0, -1), ch = state.input.charCodeAt(state.position)), (state.line === _line || state.lineIndent > nodeIndent) && ch !== 0)
      throwError(state, "bad indentation of a mapping entry");
    else if (state.lineIndent < nodeIndent)
      break;
  }
  return atExplicitKey && storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos), detected && (state.tag = _tag, state.anchor = _anchor, state.kind = "mapping", state.result = _result), detected;
}
function readTagProperty(state) {
  var _position, isVerbatim = !1, isNamed = !1, tagHandle, tagName, ch;
  if (ch = state.input.charCodeAt(state.position), ch !== 33)
    return !1;
  if (state.tag !== null && throwError(state, "duplication of a tag property"), ch = state.input.charCodeAt(++state.position), ch === 60 ? (isVerbatim = !0, ch = state.input.charCodeAt(++state.position)) : ch === 33 ? (isNamed = !0, tagHandle = "!!", ch = state.input.charCodeAt(++state.position)) : tagHandle = "!", _position = state.position, isVerbatim) {
    do
      ch = state.input.charCodeAt(++state.position);
    while (ch !== 0 && ch !== 62);
    state.position < state.length ? (tagName = state.input.slice(_position, state.position), ch = state.input.charCodeAt(++state.position)) : throwError(state, "unexpected end of the stream within a verbatim tag");
  } else {
    for (; ch !== 0 && !is_WS_OR_EOL(ch); )
      ch === 33 && (isNamed ? throwError(state, "tag suffix cannot contain exclamation marks") : (tagHandle = state.input.slice(_position - 1, state.position + 1), PATTERN_TAG_HANDLE.test(tagHandle) || throwError(state, "named tag handle cannot contain such characters"), isNamed = !0, _position = state.position + 1)), ch = state.input.charCodeAt(++state.position);
    tagName = state.input.slice(_position, state.position), PATTERN_FLOW_INDICATORS.test(tagName) && throwError(state, "tag suffix cannot contain flow indicator characters");
  }
  tagName && !PATTERN_TAG_URI.test(tagName) && throwError(state, "tag name cannot contain such characters: " + tagName);
  try {
    tagName = decodeURIComponent(tagName);
  } catch {
    throwError(state, "tag name is malformed: " + tagName);
  }
  return isVerbatim ? state.tag = tagName : _hasOwnProperty$1.call(state.tagMap, tagHandle) ? state.tag = state.tagMap[tagHandle] + tagName : tagHandle === "!" ? state.tag = "!" + tagName : tagHandle === "!!" ? state.tag = "tag:yaml.org,2002:" + tagName : throwError(state, 'undeclared tag handle "' + tagHandle + '"'), !0;
}
function readAnchorProperty(state) {
  var _position, ch;
  if (ch = state.input.charCodeAt(state.position), ch !== 38)
    return !1;
  for (state.anchor !== null && throwError(state, "duplication of an anchor property"), ch = state.input.charCodeAt(++state.position), _position = state.position; ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch); )
    ch = state.input.charCodeAt(++state.position);
  return state.position === _position && throwError(state, "name of an anchor node must contain at least one character"), state.anchor = state.input.slice(_position, state.position), !0;
}
function readAlias(state) {
  var _position, alias, ch;
  if (ch = state.input.charCodeAt(state.position), ch !== 42)
    return !1;
  for (ch = state.input.charCodeAt(++state.position), _position = state.position; ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch); )
    ch = state.input.charCodeAt(++state.position);
  return state.position === _position && throwError(state, "name of an alias node must contain at least one character"), alias = state.input.slice(_position, state.position), _hasOwnProperty$1.call(state.anchorMap, alias) || throwError(state, 'unidentified alias "' + alias + '"'), state.result = state.anchorMap[alias], skipSeparationSpace(state, !0, -1), !0;
}
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = !1, hasContent = !1, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
  if (state.listener !== null && state.listener("open", state), state.tag = null, state.anchor = null, state.kind = null, state.result = null, allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext, allowToSeek && skipSeparationSpace(state, !0, -1) && (atNewLine = !0, state.lineIndent > parentIndent ? indentStatus = 1 : state.lineIndent === parentIndent ? indentStatus = 0 : state.lineIndent < parentIndent && (indentStatus = -1)), indentStatus === 1)
    for (; readTagProperty(state) || readAnchorProperty(state); )
      skipSeparationSpace(state, !0, -1) ? (atNewLine = !0, allowBlockCollections = allowBlockStyles, state.lineIndent > parentIndent ? indentStatus = 1 : state.lineIndent === parentIndent ? indentStatus = 0 : state.lineIndent < parentIndent && (indentStatus = -1)) : allowBlockCollections = !1;
  if (allowBlockCollections && (allowBlockCollections = atNewLine || allowCompact), (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) && (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext ? flowIndent = parentIndent : flowIndent = parentIndent + 1, blockIndent = state.position - state.lineStart, indentStatus === 1 ? allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent) ? hasContent = !0 : (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent) ? hasContent = !0 : readAlias(state) ? (hasContent = !0, (state.tag !== null || state.anchor !== null) && throwError(state, "alias node should not have any properties")) : readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext) && (hasContent = !0, state.tag === null && (state.tag = "?")), state.anchor !== null && (state.anchorMap[state.anchor] = state.result)) : indentStatus === 0 && (hasContent = allowBlockCollections && readBlockSequence(state, blockIndent))), state.tag === null)
    state.anchor !== null && (state.anchorMap[state.anchor] = state.result);
  else if (state.tag === "?") {
    for (state.result !== null && state.kind !== "scalar" && throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"'), typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1)
      if (type2 = state.implicitTypes[typeIndex], type2.resolve(state.result)) {
        state.result = type2.construct(state.result), state.tag = type2.tag, state.anchor !== null && (state.anchorMap[state.anchor] = state.result);
        break;
      }
  } else if (state.tag !== "!") {
    if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag))
      type2 = state.typeMap[state.kind || "fallback"][state.tag];
    else
      for (type2 = null, typeList = state.typeMap.multi[state.kind || "fallback"], typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1)
        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type2 = typeList[typeIndex];
          break;
        }
    type2 || throwError(state, "unknown tag !<" + state.tag + ">"), state.result !== null && type2.kind !== state.kind && throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"'), type2.resolve(state.result, state.tag) ? (state.result = type2.construct(state.result, state.tag), state.anchor !== null && (state.anchorMap[state.anchor] = state.result)) : throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
  }
  return state.listener !== null && state.listener("close", state), state.tag !== null || state.anchor !== null || hasContent;
}
function readDocument(state) {
  var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = !1, ch;
  for (state.version = null, state.checkLineBreaks = state.legacy, state.tagMap = /* @__PURE__ */ Object.create(null), state.anchorMap = /* @__PURE__ */ Object.create(null); (ch = state.input.charCodeAt(state.position)) !== 0 && (skipSeparationSpace(state, !0, -1), ch = state.input.charCodeAt(state.position), !(state.lineIndent > 0 || ch !== 37)); ) {
    for (hasDirectives = !0, ch = state.input.charCodeAt(++state.position), _position = state.position; ch !== 0 && !is_WS_OR_EOL(ch); )
      ch = state.input.charCodeAt(++state.position);
    for (directiveName = state.input.slice(_position, state.position), directiveArgs = [], directiveName.length < 1 && throwError(state, "directive name must not be less than one character in length"); ch !== 0; ) {
      for (; is_WHITE_SPACE(ch); )
        ch = state.input.charCodeAt(++state.position);
      if (ch === 35) {
        do
          ch = state.input.charCodeAt(++state.position);
        while (ch !== 0 && !is_EOL(ch));
        break;
      }
      if (is_EOL(ch))
        break;
      for (_position = state.position; ch !== 0 && !is_WS_OR_EOL(ch); )
        ch = state.input.charCodeAt(++state.position);
      directiveArgs.push(state.input.slice(_position, state.position));
    }
    ch !== 0 && readLineBreak(state), _hasOwnProperty$1.call(directiveHandlers, directiveName) ? directiveHandlers[directiveName](state, directiveName, directiveArgs) : throwWarning(state, 'unknown document directive "' + directiveName + '"');
  }
  if (skipSeparationSpace(state, !0, -1), state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45 ? (state.position += 3, skipSeparationSpace(state, !0, -1)) : hasDirectives && throwError(state, "directives end mark is expected"), composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, !1, !0), skipSeparationSpace(state, !0, -1), state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position)) && throwWarning(state, "non-ASCII line breaks are interpreted as content"), state.documents.push(state.result), state.position === state.lineStart && testDocumentSeparator(state)) {
    state.input.charCodeAt(state.position) === 46 && (state.position += 3, skipSeparationSpace(state, !0, -1));
    return;
  }
  if (state.position < state.length - 1)
    throwError(state, "end of the stream or a document separator is expected");
  else
    return;
}
function loadDocuments(input, options2) {
  input = String(input), options2 = options2 || {}, input.length !== 0 && (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13 && (input += `
`), input.charCodeAt(0) === 65279 && (input = input.slice(1)));
  var state = new State$1(input, options2), nullpos = input.indexOf("\0");
  for (nullpos !== -1 && (state.position = nullpos, throwError(state, "null byte is not allowed in input")), state.input += "\0"; state.input.charCodeAt(state.position) === 32; )
    state.lineIndent += 1, state.position += 1;
  for (; state.position < state.length - 1; )
    readDocument(state);
  return state.documents;
}
function loadAll$1(input, iterator, options2) {
  iterator !== null && _typeof2(iterator) === "object" && typeof options2 > "u" && (options2 = iterator, iterator = null);
  var documents = loadDocuments(input, options2);
  if (typeof iterator != "function")
    return documents;
  for (var index2 = 0, length = documents.length; index2 < length; index2 += 1)
    iterator(documents[index2]);
}
function load$1(input, options2) {
  var documents = loadDocuments(input, options2);
  if (documents.length !== 0) {
    if (documents.length === 1)
      return documents[0];
    throw new exception("expected a single document in the stream, but found more");
  }
}
var loadAll_1 = loadAll$1, load_1 = load$1, loader = {
  loadAll: loadAll_1,
  load: load_1
}, _toString = Object.prototype.toString, _hasOwnProperty = Object.prototype.hasOwnProperty, CHAR_BOM = 65279, CHAR_TAB = 9, CHAR_LINE_FEED = 10, CHAR_CARRIAGE_RETURN = 13, CHAR_SPACE = 32, CHAR_EXCLAMATION = 33, CHAR_DOUBLE_QUOTE = 34, CHAR_SHARP = 35, CHAR_PERCENT = 37, CHAR_AMPERSAND = 38, CHAR_SINGLE_QUOTE = 39, CHAR_ASTERISK = 42, CHAR_COMMA = 44, CHAR_MINUS = 45, CHAR_COLON = 58, CHAR_EQUALS = 61, CHAR_GREATER_THAN = 62, CHAR_QUESTION = 63, CHAR_COMMERCIAL_AT = 64, CHAR_LEFT_SQUARE_BRACKET = 91, CHAR_RIGHT_SQUARE_BRACKET = 93, CHAR_GRAVE_ACCENT = 96, CHAR_LEFT_CURLY_BRACKET = 123, CHAR_VERTICAL_LINE = 124, CHAR_RIGHT_CURLY_BRACKET = 125, ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0] = "\\0";
ESCAPE_SEQUENCES[7] = "\\a";
ESCAPE_SEQUENCES[8] = "\\b";
ESCAPE_SEQUENCES[9] = "\\t";
ESCAPE_SEQUENCES[10] = "\\n";
ESCAPE_SEQUENCES[11] = "\\v";
ESCAPE_SEQUENCES[12] = "\\f";
ESCAPE_SEQUENCES[13] = "\\r";
ESCAPE_SEQUENCES[27] = "\\e";
ESCAPE_SEQUENCES[34] = '\\"';
ESCAPE_SEQUENCES[92] = "\\\\";
ESCAPE_SEQUENCES[133] = "\\N";
ESCAPE_SEQUENCES[160] = "\\_";
ESCAPE_SEQUENCES[8232] = "\\L";
ESCAPE_SEQUENCES[8233] = "\\P";
var DEPRECATED_BOOLEANS_SYNTAX = ["y", "Y", "yes", "Yes", "YES", "on", "On", "ON", "n", "N", "no", "No", "NO", "off", "Off", "OFF"], DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function compileStyleMap(schema2, map2) {
  var result2, keys2, index2, length, tag, style, type2;
  if (map2 === null)
    return {};
  for (result2 = {}, keys2 = Object.keys(map2), index2 = 0, length = keys2.length; index2 < length; index2 += 1)
    tag = keys2[index2], style = String(map2[tag]), tag.slice(0, 2) === "!!" && (tag = "tag:yaml.org,2002:" + tag.slice(2)), type2 = schema2.compiledTypeMap.fallback[tag], type2 && _hasOwnProperty.call(type2.styleAliases, style) && (style = type2.styleAliases[style]), result2[tag] = style;
  return result2;
}
function encodeHex(character) {
  var string2, handle2, length;
  if (string2 = character.toString(16).toUpperCase(), character <= 255)
    handle2 = "x", length = 2;
  else if (character <= 65535)
    handle2 = "u", length = 4;
  else if (character <= 4294967295)
    handle2 = "U", length = 8;
  else
    throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
  return "\\" + handle2 + common.repeat("0", length - string2.length) + string2;
}
var QUOTING_TYPE_SINGLE = 1, QUOTING_TYPE_DOUBLE = 2;
function State(options2) {
  this.schema = options2.schema || _default2, this.indent = Math.max(1, options2.indent || 2), this.noArrayIndent = options2.noArrayIndent || !1, this.skipInvalid = options2.skipInvalid || !1, this.flowLevel = common.isNothing(options2.flowLevel) ? -1 : options2.flowLevel, this.styleMap = compileStyleMap(this.schema, options2.styles || null), this.sortKeys = options2.sortKeys || !1, this.lineWidth = options2.lineWidth || 80, this.noRefs = options2.noRefs || !1, this.noCompatMode = options2.noCompatMode || !1, this.condenseFlow = options2.condenseFlow || !1, this.quotingType = options2.quotingType === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE, this.forceQuotes = options2.forceQuotes || !1, this.replacer = typeof options2.replacer == "function" ? options2.replacer : null, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
}
function indentString(string2, spaces) {
  for (var ind = common.repeat(" ", spaces), position = 0, next = -1, result2 = "", line2, length = string2.length; position < length; )
    next = string2.indexOf(`
`, position), next === -1 ? (line2 = string2.slice(position), position = length) : (line2 = string2.slice(position, next + 1), position = next + 1), line2.length && line2 !== `
` && (result2 += ind), result2 += line2;
  return result2;
}
function generateNextLine(state, level) {
  return `
` + common.repeat(" ", state.indent * level);
}
function testImplicitResolving(state, str2) {
  var index2, length, type2;
  for (index2 = 0, length = state.implicitTypes.length; index2 < length; index2 += 1)
    if (type2 = state.implicitTypes[index2], type2.resolve(str2))
      return !0;
  return !1;
}
function isWhitespace(c4) {
  return c4 === CHAR_SPACE || c4 === CHAR_TAB;
}
function isPrintable(c4) {
  return 32 <= c4 && c4 <= 126 || 161 <= c4 && c4 <= 55295 && c4 !== 8232 && c4 !== 8233 || 57344 <= c4 && c4 <= 65533 && c4 !== CHAR_BOM || 65536 <= c4 && c4 <= 1114111;
}
function isNsCharOrWhitespace(c4) {
  return isPrintable(c4) && c4 !== CHAR_BOM && c4 !== CHAR_CARRIAGE_RETURN && c4 !== CHAR_LINE_FEED;
}
function isPlainSafe(c4, prev, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c4), cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c4);
  return (inblock ? cIsNsCharOrWhitespace : cIsNsCharOrWhitespace && c4 !== CHAR_COMMA && c4 !== CHAR_LEFT_SQUARE_BRACKET && c4 !== CHAR_RIGHT_SQUARE_BRACKET && c4 !== CHAR_LEFT_CURLY_BRACKET && c4 !== CHAR_RIGHT_CURLY_BRACKET) && c4 !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c4 === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar;
}
function isPlainSafeFirst(c4) {
  return isPrintable(c4) && c4 !== CHAR_BOM && !isWhitespace(c4) && c4 !== CHAR_MINUS && c4 !== CHAR_QUESTION && c4 !== CHAR_COLON && c4 !== CHAR_COMMA && c4 !== CHAR_LEFT_SQUARE_BRACKET && c4 !== CHAR_RIGHT_SQUARE_BRACKET && c4 !== CHAR_LEFT_CURLY_BRACKET && c4 !== CHAR_RIGHT_CURLY_BRACKET && c4 !== CHAR_SHARP && c4 !== CHAR_AMPERSAND && c4 !== CHAR_ASTERISK && c4 !== CHAR_EXCLAMATION && c4 !== CHAR_VERTICAL_LINE && c4 !== CHAR_EQUALS && c4 !== CHAR_GREATER_THAN && c4 !== CHAR_SINGLE_QUOTE && c4 !== CHAR_DOUBLE_QUOTE && c4 !== CHAR_PERCENT && c4 !== CHAR_COMMERCIAL_AT && c4 !== CHAR_GRAVE_ACCENT;
}
function isPlainSafeLast(c4) {
  return !isWhitespace(c4) && c4 !== CHAR_COLON;
}
function codePointAt(string2, pos2) {
  var first = string2.charCodeAt(pos2), second;
  return first >= 55296 && first <= 56319 && pos2 + 1 < string2.length && (second = string2.charCodeAt(pos2 + 1), second >= 56320 && second <= 57343) ? (first - 55296) * 1024 + second - 56320 + 65536 : first;
}
function needIndentIndicator(string2) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string2);
}
var STYLE_PLAIN = 1, STYLE_SINGLE = 2, STYLE_LITERAL = 3, STYLE_FOLDED = 4, STYLE_DOUBLE = 5;
function chooseScalarStyle(string2, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
  var i3, char = 0, prevChar = null, hasLineBreak = !1, hasFoldableLine = !1, shouldTrackWidth = lineWidth !== -1, previousLineBreak = -1, plain = isPlainSafeFirst(codePointAt(string2, 0)) && isPlainSafeLast(codePointAt(string2, string2.length - 1));
  if (singleLineOnly || forceQuotes)
    for (i3 = 0; i3 < string2.length; char >= 65536 ? i3 += 2 : i3++) {
      if (char = codePointAt(string2, i3), !isPrintable(char))
        return STYLE_DOUBLE;
      plain = plain && isPlainSafe(char, prevChar, inblock), prevChar = char;
    }
  else {
    for (i3 = 0; i3 < string2.length; char >= 65536 ? i3 += 2 : i3++) {
      if (char = codePointAt(string2, i3), char === CHAR_LINE_FEED)
        hasLineBreak = !0, shouldTrackWidth && (hasFoldableLine = hasFoldableLine || i3 - previousLineBreak - 1 > lineWidth && string2[previousLineBreak + 1] !== " ", previousLineBreak = i3);
      else if (!isPrintable(char))
        return STYLE_DOUBLE;
      plain = plain && isPlainSafe(char, prevChar, inblock), prevChar = char;
    }
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && i3 - previousLineBreak - 1 > lineWidth && string2[previousLineBreak + 1] !== " ";
  }
  return !hasLineBreak && !hasFoldableLine ? plain && !forceQuotes && !testAmbiguousType(string2) ? STYLE_PLAIN : quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE : indentPerLevel > 9 && needIndentIndicator(string2) ? STYLE_DOUBLE : forceQuotes ? quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE : hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
}
function writeScalar(state, string2, level, iskey, inblock) {
  state.dump = function() {
    if (string2.length === 0)
      return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    if (!state.noCompatMode && (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string2) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string2)))
      return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string2 + '"' : "'" + string2 + "'";
    var indent = state.indent * Math.max(1, level), lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent), singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
    function testAmbiguity(string3) {
      return testImplicitResolving(state, string3);
    }
    switch (chooseScalarStyle(string2, singleLineOnly, state.indent, lineWidth, testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)) {
      case STYLE_PLAIN:
        return string2;
      case STYLE_SINGLE:
        return "'" + string2.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return "|" + blockHeader(string2, state.indent) + dropEndingNewline(indentString(string2, indent));
      case STYLE_FOLDED:
        return ">" + blockHeader(string2, state.indent) + dropEndingNewline(indentString(foldString(string2, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string2) + '"';
      default:
        throw new exception("impossible error: invalid scalar style");
    }
  }();
}
function blockHeader(string2, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string2) ? String(indentPerLevel) : "", clip = string2[string2.length - 1] === `
`, keep = clip && (string2[string2.length - 2] === `
` || string2 === `
`), chomp = keep ? "+" : clip ? "" : "-";
  return indentIndicator + chomp + `
`;
}
function dropEndingNewline(string2) {
  return string2[string2.length - 1] === `
` ? string2.slice(0, -1) : string2;
}
function foldString(string2, width) {
  for (var lineRe = /(\n+)([^\n]*)/g, result2 = function() {
    var nextLF = string2.indexOf(`
`);
    return nextLF = nextLF !== -1 ? nextLF : string2.length, lineRe.lastIndex = nextLF, foldLine(string2.slice(0, nextLF), width);
  }(), prevMoreIndented = string2[0] === `
` || string2[0] === " ", moreIndented, match; match = lineRe.exec(string2); ) {
    var prefix = match[1], line2 = match[2];
    moreIndented = line2[0] === " ", result2 += prefix + (!prevMoreIndented && !moreIndented && line2 !== "" ? `
` : "") + foldLine(line2, width), prevMoreIndented = moreIndented;
  }
  return result2;
}
function foldLine(line2, width) {
  if (line2 === "" || line2[0] === " ")
    return line2;
  for (var breakRe = / [^ ]/g, match, start3 = 0, end3, curr = 0, next = 0, result2 = ""; match = breakRe.exec(line2); )
    next = match.index, next - start3 > width && (end3 = curr > start3 ? curr : next, result2 += `
` + line2.slice(start3, end3), start3 = end3 + 1), curr = next;
  return result2 += `
`, line2.length - start3 > width && curr > start3 ? result2 += line2.slice(start3, curr) + `
` + line2.slice(curr + 1) : result2 += line2.slice(start3), result2.slice(1);
}
function escapeString(string2) {
  for (var result2 = "", char = 0, escapeSeq, i3 = 0; i3 < string2.length; char >= 65536 ? i3 += 2 : i3++)
    char = codePointAt(string2, i3), escapeSeq = ESCAPE_SEQUENCES[char], !escapeSeq && isPrintable(char) ? (result2 += string2[i3], char >= 65536 && (result2 += string2[i3 + 1])) : result2 += escapeSeq || encodeHex(char);
  return result2;
}
function writeFlowSequence(state, level, object) {
  var _result = "", _tag = state.tag, index2, length, value2;
  for (index2 = 0, length = object.length; index2 < length; index2 += 1)
    value2 = object[index2], state.replacer && (value2 = state.replacer.call(object, String(index2), value2)), (writeNode(state, level, value2, !1, !1) || typeof value2 > "u" && writeNode(state, level, null, !1, !1)) && (_result !== "" && (_result += "," + (state.condenseFlow ? "" : " ")), _result += state.dump);
  state.tag = _tag, state.dump = "[" + _result + "]";
}
function writeBlockSequence(state, level, object, compact) {
  var _result = "", _tag = state.tag, index2, length, value2;
  for (index2 = 0, length = object.length; index2 < length; index2 += 1)
    value2 = object[index2], state.replacer && (value2 = state.replacer.call(object, String(index2), value2)), (writeNode(state, level + 1, value2, !0, !0, !1, !0) || typeof value2 > "u" && writeNode(state, level + 1, null, !0, !0, !1, !0)) && ((!compact || _result !== "") && (_result += generateNextLine(state, level)), state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0) ? _result += "-" : _result += "- ", _result += state.dump);
  state.tag = _tag, state.dump = _result || "[]";
}
function writeFlowMapping(state, level, object) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index2, length, objectKey, objectValue, pairBuffer;
  for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1)
    pairBuffer = "", _result !== "" && (pairBuffer += ", "), state.condenseFlow && (pairBuffer += '"'), objectKey = objectKeyList[index2], objectValue = object[objectKey], state.replacer && (objectValue = state.replacer.call(object, objectKey, objectValue)), writeNode(state, level, objectKey, !1, !1) && (state.dump.length > 1024 && (pairBuffer += "? "), pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " "), writeNode(state, level, objectValue, !1, !1) && (pairBuffer += state.dump, _result += pairBuffer));
  state.tag = _tag, state.dump = "{" + _result + "}";
}
function writeBlockMapping(state, level, object, compact) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index2, length, objectKey, objectValue, explicitPair, pairBuffer;
  if (state.sortKeys === !0)
    objectKeyList.sort();
  else if (typeof state.sortKeys == "function")
    objectKeyList.sort(state.sortKeys);
  else if (state.sortKeys)
    throw new exception("sortKeys must be a boolean or a function");
  for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1)
    pairBuffer = "", (!compact || _result !== "") && (pairBuffer += generateNextLine(state, level)), objectKey = objectKeyList[index2], objectValue = object[objectKey], state.replacer && (objectValue = state.replacer.call(object, objectKey, objectValue)), writeNode(state, level + 1, objectKey, !0, !0, !0) && (explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024, explicitPair && (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0) ? pairBuffer += "?" : pairBuffer += "? "), pairBuffer += state.dump, explicitPair && (pairBuffer += generateNextLine(state, level)), writeNode(state, level + 1, objectValue, !0, explicitPair) && (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0) ? pairBuffer += ":" : pairBuffer += ": ", pairBuffer += state.dump, _result += pairBuffer));
  state.tag = _tag, state.dump = _result || "{}";
}
function detectType(state, object, explicit) {
  var _result, typeList, index2, length, type2, style;
  for (typeList = explicit ? state.explicitTypes : state.implicitTypes, index2 = 0, length = typeList.length; index2 < length; index2 += 1)
    if (type2 = typeList[index2], (type2.instanceOf || type2.predicate) && (!type2.instanceOf || _typeof2(object) === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
      if (explicit ? type2.multi && type2.representName ? state.tag = type2.representName(object) : state.tag = type2.tag : state.tag = "?", type2.represent) {
        if (style = state.styleMap[type2.tag] || type2.defaultStyle, _toString.call(type2.represent) === "[object Function]")
          _result = type2.represent(object, style);
        else if (_hasOwnProperty.call(type2.represent, style))
          _result = type2.represent[style](object, style);
        else
          throw new exception("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
        state.dump = _result;
      }
      return !0;
    }
  return !1;
}
function writeNode(state, level, object, block, compact, iskey, isblockseq) {
  state.tag = null, state.dump = object, detectType(state, object, !1) || detectType(state, object, !0);
  var type2 = _toString.call(state.dump), inblock = block, tagStr;
  block && (block = state.flowLevel < 0 || state.flowLevel > level);
  var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
  if (objectOrArray && (duplicateIndex = state.duplicates.indexOf(object), duplicate = duplicateIndex !== -1), (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) && (compact = !1), duplicate && state.usedDuplicates[duplicateIndex])
    state.dump = "*ref_" + duplicateIndex;
  else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex] && (state.usedDuplicates[duplicateIndex] = !0), type2 === "[object Object]")
      block && Object.keys(state.dump).length !== 0 ? (writeBlockMapping(state, level, state.dump, compact), duplicate && (state.dump = "&ref_" + duplicateIndex + state.dump)) : (writeFlowMapping(state, level, state.dump), duplicate && (state.dump = "&ref_" + duplicateIndex + " " + state.dump));
    else if (type2 === "[object Array]")
      block && state.dump.length !== 0 ? (state.noArrayIndent && !isblockseq && level > 0 ? writeBlockSequence(state, level - 1, state.dump, compact) : writeBlockSequence(state, level, state.dump, compact), duplicate && (state.dump = "&ref_" + duplicateIndex + state.dump)) : (writeFlowSequence(state, level, state.dump), duplicate && (state.dump = "&ref_" + duplicateIndex + " " + state.dump));
    else if (type2 === "[object String]")
      state.tag !== "?" && writeScalar(state, state.dump, level, iskey, inblock);
    else {
      if (type2 === "[object Undefined]")
        return !1;
      if (state.skipInvalid)
        return !1;
      throw new exception("unacceptable kind of an object to dump " + type2);
    }
    state.tag !== null && state.tag !== "?" && (tagStr = encodeURI(state.tag[0] === "!" ? state.tag.slice(1) : state.tag).replace(/!/g, "%21"), state.tag[0] === "!" ? tagStr = "!" + tagStr : tagStr.slice(0, 18) === "tag:yaml.org,2002:" ? tagStr = "!!" + tagStr.slice(18) : tagStr = "!<" + tagStr + ">", state.dump = tagStr + " " + state.dump);
  }
  return !0;
}
function getDuplicateReferences(object, state) {
  var objects = [], duplicatesIndexes = [], index2, length;
  for (inspectNode(object, objects, duplicatesIndexes), index2 = 0, length = duplicatesIndexes.length; index2 < length; index2 += 1)
    state.duplicates.push(objects[duplicatesIndexes[index2]]);
  state.usedDuplicates = new Array(length);
}
function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList, index2, length;
  if (object !== null && _typeof2(object) === "object")
    if (index2 = objects.indexOf(object), index2 !== -1)
      duplicatesIndexes.indexOf(index2) === -1 && duplicatesIndexes.push(index2);
    else if (objects.push(object), Array.isArray(object))
      for (index2 = 0, length = object.length; index2 < length; index2 += 1)
        inspectNode(object[index2], objects, duplicatesIndexes);
    else
      for (objectKeyList = Object.keys(object), index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1)
        inspectNode(object[objectKeyList[index2]], objects, duplicatesIndexes);
}
function dump$1(input, options2) {
  options2 = options2 || {};
  var state = new State(options2);
  state.noRefs || getDuplicateReferences(input, state);
  var value2 = input;
  return state.replacer && (value2 = state.replacer.call({
    "": value2
  }, "", value2)), writeNode(state, 0, value2, !0, !0) ? state.dump + `
` : "";
}
var dump_1 = dump$1, dumper = {
  dump: dump_1
};
function renamed(from2, to) {
  return function() {
    throw new Error("Function yaml." + from2 + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
  };
}
var Type = type, Schema = schema, FAILSAFE_SCHEMA = failsafe, JSON_SCHEMA = json4, CORE_SCHEMA = core, DEFAULT_SCHEMA = _default2, load = loader.load, loadAll = loader.loadAll, dump = dumper.dump, YAMLException = exception, types = {
  binary: binary2,
  float,
  map,
  null: _null,
  pairs,
  set,
  timestamp,
  bool,
  int,
  merge,
  omap,
  seq,
  str
}, safeLoad = renamed("safeLoad", "load"), safeLoadAll = renamed("safeLoadAll", "loadAll"), safeDump = renamed("safeDump", "dump"), jsYaml = {
  Type,
  Schema,
  FAILSAFE_SCHEMA,
  JSON_SCHEMA,
  CORE_SCHEMA,
  DEFAULT_SCHEMA,
  load,
  loadAll,
  dump,
  YAMLException,
  types,
  safeLoad,
  safeLoadAll,
  safeDump
}, yaml_default = jsYaml;

// node_modules/i18next-fs-backend/esm/readFile.js
var fsMod = __toESM(require_fs2(), 1), pathMod = __toESM(require_path2(), 1);

// node_modules/i18next-fs-backend/esm/extname.js
var extname_default = function(filename) {
  if (!(filename.indexOf(".") < 0))
    return ".".concat(filename.split(".").pop());
};

// node_modules/i18next-fs-backend/esm/readFile.js
var isDeno = typeof Deno < "u", YAML = typeof yaml_default < "u" && yaml_default.load ? yaml_default : void 0, fs = fsMod ? fsMod.default || fsMod : void 0, path = pathMod ? pathMod.default || pathMod : void 0, readFileInNodeSync = function(filename) {
  var data2 = fs.readFileSync(filename, "utf8"), stat;
  try {
    stat = fs.statSync(filename);
  } catch {
  }
  return {
    data: data2,
    stat
  };
}, readFileInNode = function(filename) {
  return new Promise(function(resolve2, reject) {
    fs.readFile(filename, "utf8", function(err, data2) {
      if (err)
        return reject(err);
      fs.stat(filename, function(err2, stat) {
        return resolve2(err2 ? {
          data: data2
        } : {
          data: data2,
          stat
        });
      });
    });
  });
}, readFileInDenoSync = function(filename) {
  var decoder = new TextDecoder("utf-8"), d2 = Deno.readFileSync(filename), data2 = decoder.decode(d2), stat;
  try {
    stat = Deno.statSync(filename);
  } catch {
  }
  return {
    data: data2,
    stat
  };
}, readFileInDeno = function(filename) {
  return new Promise(function(resolve2, reject) {
    var decoder = new TextDecoder("utf-8");
    Deno.readFile(filename).then(function(d2) {
      var data2 = decoder.decode(d2);
      Deno.stat(filename).then(function(stat) {
        return resolve2({
          data: data2,
          stat
        });
      }).catch(function() {
        return resolve2({
          data: data2
        });
      });
    }).catch(reject);
  });
}, replaceLast = function(str2, find, replace) {
  var index2 = str2.lastIndexOf(find);
  return index2 > -1 ? str2.substring(0, index2) + replace + str2.substring(index2 + find.length) : str2.toString();
}, parseData2 = function parseData(extension, data, options) {
  data = data.replace(/^\uFEFF/, "");
  var result = {};
  switch (extension) {
    case ".js":
    case ".ts":
      typeof module > "u" && (data.indexOf("exports") > -1 ? data = "(".concat(replaceLast(data.substring(data.indexOf("=") + 1), "};", ""), ")") : data.indexOf("export default ") > -1 && (data = "(".concat(replaceLast(data.substring(data.indexOf("export default ") + 15), "};", ""), ")"))), result = eval(data);
      break;
    case ".json5":
      result = json5_default.parse(data);
      break;
    case ".yml":
    case ".yaml":
      result = YAML.load(data);
      break;
    default:
      result = options.parse(data);
  }
  return result;
}, resolvePath2 = function resolvePath3(filename) {
  return !path.isAbsolute(filename) && typeof process < "u" && process.cwd && !fs.existsSync(filename) ? path.join(process.cwd(), filename) : filename;
};
function readFileSync(filename, options2) {
  var ext = extname_default(filename);
  if ([".js", ".ts"].indexOf(ext) > -1 && typeof __require < "u")
    return __require(resolvePath2(filename));
  var data2, stat;
  if (isDeno) {
    var ret = readFileInDenoSync(filename);
    data2 = ret.data, stat = ret.stat;
  } else {
    var _ret = readFileInNodeSync(filename);
    data2 = _ret.data, stat = _ret.stat;
  }
  return {
    data: parseData2(ext, data2, options2),
    stat
  };
}
function readFile(filename) {
  var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    parse: JSON.parse
  }, ext = extname_default(filename);
  if ([".js", ".ts"].indexOf(ext) > -1 && typeof __require < "u")
    return new Promise(function(resolve2, reject) {
      try {
        resolve2({
          data: __require(resolvePath2(filename))
        });
      } catch (err) {
        reject(err);
      }
    });
  var fn = isDeno ? readFileInDeno : readFileInNode;
  return new Promise(function(resolve2, reject) {
    fn(filename).then(function(_ref) {
      var data2 = _ref.data, stat = _ref.stat;
      try {
        var ret = parseData2(ext, data2, options2);
        resolve2({
          data: ret,
          stat
        });
      } catch (err) {
        err.message = "error parsing " + filename + ": " + err.message, reject(err);
      }
    }).catch(reject);
  });
}

// node_modules/i18next-fs-backend/esm/writeFile.js
var fsMod2 = __toESM(require_fs2(), 1);
var isDeno2 = typeof Deno < "u", YAML2 = typeof yaml_default < "u" && yaml_default.load ? yaml_default : void 0, fs2 = fsMod2 ? fsMod2.default || fsMod2 : void 0;
function dirname2(path2) {
  if (path2.length === 0)
    return ".";
  for (var code = path2.charCodeAt(0), hasRoot = code === 47, end3 = -1, matchedSlash = !0, i3 = path2.length - 1; i3 >= 1; --i3)
    if (code = path2.charCodeAt(i3), code === 47) {
      if (!matchedSlash) {
        end3 = i3;
        break;
      }
    } else
      matchedSlash = !1;
  return end3 === -1 ? hasRoot ? "/" : "." : hasRoot && end3 === 1 ? "//" : path2.slice(0, end3);
}
var writeFileInNode = function(filename, payload) {
  return new Promise(function(resolve2, reject) {
    fs2.mkdir(dirname2(filename), {
      recursive: !0
    }, function() {
      fs2.writeFile(filename, payload, "utf8", function(err, data2) {
        return err ? reject(err) : resolve2(data2);
      });
    });
  });
};
var removeFileInNode = function(filename) {
  return new Promise(function(resolve2, reject) {
    return fs2.unlink(filename, function(err) {
      return err ? reject(err) : resolve2();
    });
  });
};
var writeFileInDeno = function(filename, payload) {
  var encoder = new TextEncoder(), data2 = encoder.encode(payload);
  return new Promise(function(resolve2, reject) {
    Deno.mkdir(dirname2(filename), {
      recursive: !0
    }).then(function() {
      Deno.writeFile(filename, data2).then(resolve2, reject);
    }).catch(function() {
      Deno.writeFile(filename, data2).then(resolve2, reject);
    });
  });
};
var removeFileInDeno = function(filename) {
  return Deno.remove(filename);
}, stringifyData = function(extension2, data2, options2) {
  var result2 = "";
  switch (extension2) {
    case ".js":
    case ".ts":
      typeof module > "u" ? result2 = "export default ".concat(options2.stringify(data2, null, options2.ident)) : result2 = "module.exports = ".concat(options2.stringify(data2, null, options2.ident));
      break;
    case ".json5":
      result2 = json5_default.stringify(data2, null, options2.ident);
      break;
    case ".yml":
    case ".yaml":
      result2 = YAML2.dump(data2, {
        ident: options2.indent
      });
      break;
    default:
      result2 = options2.stringify(data2, null, options2.ident);
  }
  return result2;
};
function writeFile(filename, payload) {
  var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
    stringify: JSON.stringify,
    ident: 2
  }, ext = extname_default(filename), data2;
  try {
    data2 = stringifyData(ext, payload, options2);
  } catch (err) {
    throw err.message = "error stringifying " + filename + ": " + err.message, err;
  }
  var fn = isDeno2 ? writeFileInDeno : writeFileInNode;
  return fn(filename, data2);
}
function removeFile(filename) {
  var fn = isDeno2 ? removeFileInDeno : removeFileInNode;
  return fn(filename);
}

// node_modules/i18next-fs-backend/esm/index.js
function _classCallCheck(instance2, Constructor) {
  if (!(instance2 instanceof Constructor))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
  for (var i3 = 0; i3 < props.length; i3++) {
    var descriptor = props[i3];
    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Object.defineProperty(Constructor, "prototype", { writable: !1 }), Constructor;
}
var getDefaults = function() {
  return {
    loadPath: "/locales/{{lng}}/{{ns}}.json",
    addPath: "/locales/{{lng}}/{{ns}}.missing.json",
    ident: 2,
    parse: JSON.parse,
    stringify: JSON.stringify
  };
}, Backend = function() {
  function Backend2(services) {
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, allOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    _classCallCheck(this, Backend2), this.services = services, this.options = options2, this.allOptions = allOptions, this.type = "backend", this.init(services, options2, allOptions);
  }
  return _createClass(Backend2, [{
    key: "init",
    value: function(services) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, allOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      this.services = services, this.options = defaults(options2, this.options || {}, getDefaults()), this.allOptions = allOptions, this.queuedWrites = {}, this.debouncedWrite = debounce(this.write, 250);
    }
  }, {
    key: "read",
    value: function(language, namespace, callback) {
      var _this = this, loadPath = this.options.loadPath;
      typeof this.options.loadPath == "function" && (loadPath = this.options.loadPath(language, namespace));
      var filename = this.services.interpolator.interpolate(loadPath, {
        lng: language,
        ns: namespace
      });
      if (this.allOptions.initImmediate === !1) {
        try {
          var _readFileSync = readFileSync(filename, this.options), data2 = _readFileSync.data, stat = _readFileSync.stat;
          if (this.options.expirationTime && stat && stat.mtime && stat.mtime.getTime() + this.options.expirationTime < Date.now())
            return this.removeFile(language, namespace), callback(new Error("File expired!"), !1);
          callback(null, data2);
        } catch (err) {
          callback(err, !1);
        }
        return;
      }
      readFile(filename, this.options).then(function(_ref) {
        var data3 = _ref.data, stat2 = _ref.stat;
        if (_this.options.expirationTime && stat2 && stat2.mtime && stat2.mtime.getTime() + _this.options.expirationTime < Date.now())
          return _this.removeFile(language, namespace), callback(new Error("File expired!"), !1);
        callback(null, data3);
      }).catch(function(err) {
        return callback(err, !1);
      });
    }
  }, {
    key: "create",
    value: function(languages, namespace, key2, fallbackValue, callback) {
      var _this2 = this;
      callback || (callback = function() {
      }), typeof languages == "string" && (languages = [languages]);
      var todo = languages.length, done2 = function() {
        --todo || callback();
      };
      languages.forEach(function(lng2) {
        _this2.queue.call(_this2, lng2, namespace, key2, fallbackValue, done2);
      });
    }
  }, {
    key: "save",
    value: function(language, namespace, data2, callback) {
      var _this3 = this;
      callback || (callback = function() {
      });
      var keys2 = Object.keys(data2), todo = keys2.length, done2 = function() {
        --todo || callback();
      };
      keys2.forEach(function(key2) {
        _this3.queue.call(_this3, language, namespace, key2, data2[key2], done2);
      });
    }
  }, {
    key: "removeFile",
    value: function(language, namespace) {
      var addPath = this.options.addPath;
      typeof this.options.addPath == "function" && (addPath = this.options.addPath(language, namespace));
      var filename = this.services.interpolator.interpolate(addPath, {
        lng: language,
        ns: namespace
      });
      removeFile(filename, this.options).then(function() {
      }).catch(function() {
      });
    }
  }, {
    key: "write",
    value: function() {
      for (var lng2 in this.queuedWrites) {
        var namespaces = this.queuedWrites[lng2];
        if (lng2 !== "locks")
          for (var ns in namespaces)
            this.writeFile(lng2, ns);
      }
    }
  }, {
    key: "writeFile",
    value: function(lng2, namespace) {
      var _this4 = this, lock = getPath(this.queuedWrites, ["locks", lng2, namespace]);
      if (!lock) {
        var addPath = this.options.addPath;
        typeof this.options.addPath == "function" && (addPath = this.options.addPath(lng2, namespace));
        var filename = this.services.interpolator.interpolate(addPath, {
          lng: lng2,
          ns: namespace
        }), missings = getPath(this.queuedWrites, [lng2, namespace]);
        if (setPath(this.queuedWrites, [lng2, namespace], []), missings.length) {
          setPath(this.queuedWrites, ["locks", lng2, namespace], !0);
          var proceed = function(_ref2) {
            var data2 = _ref2.data;
            missings.forEach(function(missing) {
              var path2 = _this4.allOptions.keySeparator === !1 ? [missing.key] : missing.key.split(_this4.allOptions.keySeparator || ".");
              setPath(data2, path2, missing.fallbackValue);
            });
            var proceedWrite = function() {
              setPath(_this4.queuedWrites, ["locks", lng2, namespace], !1), missings.forEach(function(missing) {
                missing.callback && missing.callback();
              }), _this4.debouncedWrite();
            };
            writeFile(filename, data2, _this4.options).then(proceedWrite).catch(proceedWrite);
          };
          readFile(filename, this.options).then(proceed).catch(function() {
            return proceed({
              data: {}
            });
          });
        }
      }
    }
  }, {
    key: "queue",
    value: function(lng2, namespace, key2, fallbackValue, callback) {
      pushPath(this.queuedWrites, [lng2, namespace], {
        key: key2,
        fallbackValue: fallbackValue || "",
        callback
      }), this.debouncedWrite();
    }
  }]), Backend2;
}();
Backend.type = "backend";
var esm_default = Backend;

// app/entry.server.tsx
init_path();
var import_server4 = __toESM(require_server_browser());
init_es();

// app/i18n/i18n.ts
var i18n_default = {
  supportedLngs: ["en", "th"],
  fallbackLng: "th",
  defaultNS: "common",
  react: { useSuspense: !1 }
};

// app/i18n/i18next.server.ts
init_path();
var import_remix_i18next = __toESM(require_build());
var i18next = new import_remix_i18next.RemixI18Next({
  detection: {
    supportedLanguages: i18n_default.supportedLngs,
    fallbackLanguage: i18n_default.fallbackLng
  },
  i18next: {
    ...i18n_default,
    backend: {
      loadPath: resolve("./public/locales/{{lng}}/{{ns}}.json")
    }
  }
}), i18next_server_default = i18next;

// node_modules/styled-components/dist/styled-components.esm.js
var import_react_is = __toESM(require_react_is()), import_react9 = __toESM(require_react()), import_shallowequal = __toESM(require_shallowequal());

// node_modules/@emotion/stylis/dist/stylis.esm.js
function stylis_min(W2) {
  function M2(d2, c4, e3, h, a3) {
    for (var m2 = 0, b2 = 0, v2 = 0, n3 = 0, q2, g2, x2 = 0, K2 = 0, k2, u2 = k2 = q2 = 0, l2 = 0, r3 = 0, I2 = 0, t4 = 0, B3 = e3.length, J2 = B3 - 1, y2, f2 = "", p = "", F3 = "", G3 = "", C2; l2 < B3; ) {
      if (g2 = e3.charCodeAt(l2), l2 === J2 && b2 + n3 + v2 + m2 !== 0 && (b2 !== 0 && (g2 = b2 === 47 ? 10 : 47), n3 = v2 = m2 = 0, B3++, J2++), b2 + n3 + v2 + m2 === 0) {
        if (l2 === J2 && (0 < r3 && (f2 = f2.replace(N2, "")), 0 < f2.trim().length)) {
          switch (g2) {
            case 32:
            case 9:
            case 59:
            case 13:
            case 10:
              break;
            default:
              f2 += e3.charAt(l2);
          }
          g2 = 59;
        }
        switch (g2) {
          case 123:
            for (f2 = f2.trim(), q2 = f2.charCodeAt(0), k2 = 1, t4 = ++l2; l2 < B3; ) {
              switch (g2 = e3.charCodeAt(l2)) {
                case 123:
                  k2++;
                  break;
                case 125:
                  k2--;
                  break;
                case 47:
                  switch (g2 = e3.charCodeAt(l2 + 1)) {
                    case 42:
                    case 47:
                      a: {
                        for (u2 = l2 + 1; u2 < J2; ++u2)
                          switch (e3.charCodeAt(u2)) {
                            case 47:
                              if (g2 === 42 && e3.charCodeAt(u2 - 1) === 42 && l2 + 2 !== u2) {
                                l2 = u2 + 1;
                                break a;
                              }
                              break;
                            case 10:
                              if (g2 === 47) {
                                l2 = u2 + 1;
                                break a;
                              }
                          }
                        l2 = u2;
                      }
                  }
                  break;
                case 91:
                  g2++;
                case 40:
                  g2++;
                case 34:
                case 39:
                  for (; l2++ < J2 && e3.charCodeAt(l2) !== g2; )
                    ;
              }
              if (k2 === 0)
                break;
              l2++;
            }
            switch (k2 = e3.substring(t4, l2), q2 === 0 && (q2 = (f2 = f2.replace(ca, "").trim()).charCodeAt(0)), q2) {
              case 64:
                switch (0 < r3 && (f2 = f2.replace(N2, "")), g2 = f2.charCodeAt(1), g2) {
                  case 100:
                  case 109:
                  case 115:
                  case 45:
                    r3 = c4;
                    break;
                  default:
                    r3 = O2;
                }
                if (k2 = M2(c4, r3, k2, g2, a3 + 1), t4 = k2.length, 0 < A && (r3 = X2(O2, f2, I2), C2 = H2(3, k2, r3, c4, D2, z2, t4, g2, a3, h), f2 = r3.join(""), C2 !== void 0 && (t4 = (k2 = C2.trim()).length) === 0 && (g2 = 0, k2 = "")), 0 < t4)
                  switch (g2) {
                    case 115:
                      f2 = f2.replace(da, ea);
                    case 100:
                    case 109:
                    case 45:
                      k2 = f2 + "{" + k2 + "}";
                      break;
                    case 107:
                      f2 = f2.replace(fa, "$1 $2"), k2 = f2 + "{" + k2 + "}", k2 = w2 === 1 || w2 === 2 && L2("@" + k2, 3) ? "@-webkit-" + k2 + "@" + k2 : "@" + k2;
                      break;
                    default:
                      k2 = f2 + k2, h === 112 && (k2 = (p += k2, ""));
                  }
                else
                  k2 = "";
                break;
              default:
                k2 = M2(c4, X2(c4, f2, I2), k2, h, a3 + 1);
            }
            F3 += k2, k2 = I2 = r3 = u2 = q2 = 0, f2 = "", g2 = e3.charCodeAt(++l2);
            break;
          case 125:
          case 59:
            if (f2 = (0 < r3 ? f2.replace(N2, "") : f2).trim(), 1 < (t4 = f2.length))
              switch (u2 === 0 && (q2 = f2.charCodeAt(0), q2 === 45 || 96 < q2 && 123 > q2) && (t4 = (f2 = f2.replace(" ", ":")).length), 0 < A && (C2 = H2(1, f2, c4, d2, D2, z2, p.length, h, a3, h)) !== void 0 && (t4 = (f2 = C2.trim()).length) === 0 && (f2 = "\0\0"), q2 = f2.charCodeAt(0), g2 = f2.charCodeAt(1), q2) {
                case 0:
                  break;
                case 64:
                  if (g2 === 105 || g2 === 99) {
                    G3 += f2 + e3.charAt(l2);
                    break;
                  }
                default:
                  f2.charCodeAt(t4 - 1) !== 58 && (p += P(f2, q2, g2, f2.charCodeAt(2)));
              }
            I2 = r3 = u2 = q2 = 0, f2 = "", g2 = e3.charCodeAt(++l2);
        }
      }
      switch (g2) {
        case 13:
        case 10:
          b2 === 47 ? b2 = 0 : 1 + q2 === 0 && h !== 107 && 0 < f2.length && (r3 = 1, f2 += "\0"), 0 < A * Y2 && H2(0, f2, c4, d2, D2, z2, p.length, h, a3, h), z2 = 1, D2++;
          break;
        case 59:
        case 125:
          if (b2 + n3 + v2 + m2 === 0) {
            z2++;
            break;
          }
        default:
          switch (z2++, y2 = e3.charAt(l2), g2) {
            case 9:
            case 32:
              if (n3 + m2 + b2 === 0)
                switch (x2) {
                  case 44:
                  case 58:
                  case 9:
                  case 32:
                    y2 = "";
                    break;
                  default:
                    g2 !== 32 && (y2 = " ");
                }
              break;
            case 0:
              y2 = "\\0";
              break;
            case 12:
              y2 = "\\f";
              break;
            case 11:
              y2 = "\\v";
              break;
            case 38:
              n3 + b2 + m2 === 0 && (r3 = I2 = 1, y2 = "\f" + y2);
              break;
            case 108:
              if (n3 + b2 + m2 + E2 === 0 && 0 < u2)
                switch (l2 - u2) {
                  case 2:
                    x2 === 112 && e3.charCodeAt(l2 - 3) === 58 && (E2 = x2);
                  case 8:
                    K2 === 111 && (E2 = K2);
                }
              break;
            case 58:
              n3 + b2 + m2 === 0 && (u2 = l2);
              break;
            case 44:
              b2 + v2 + n3 + m2 === 0 && (r3 = 1, y2 += "\r");
              break;
            case 34:
            case 39:
              b2 === 0 && (n3 = n3 === g2 ? 0 : n3 === 0 ? g2 : n3);
              break;
            case 91:
              n3 + b2 + v2 === 0 && m2++;
              break;
            case 93:
              n3 + b2 + v2 === 0 && m2--;
              break;
            case 41:
              n3 + b2 + m2 === 0 && v2--;
              break;
            case 40:
              if (n3 + b2 + m2 === 0) {
                if (q2 === 0)
                  switch (2 * x2 + 3 * K2) {
                    case 533:
                      break;
                    default:
                      q2 = 1;
                  }
                v2++;
              }
              break;
            case 64:
              b2 + v2 + n3 + m2 + u2 + k2 === 0 && (k2 = 1);
              break;
            case 42:
            case 47:
              if (!(0 < n3 + m2 + v2))
                switch (b2) {
                  case 0:
                    switch (2 * g2 + 3 * e3.charCodeAt(l2 + 1)) {
                      case 235:
                        b2 = 47;
                        break;
                      case 220:
                        t4 = l2, b2 = 42;
                    }
                    break;
                  case 42:
                    g2 === 47 && x2 === 42 && t4 + 2 !== l2 && (e3.charCodeAt(t4 + 2) === 33 && (p += e3.substring(t4, l2 + 1)), y2 = "", b2 = 0);
                }
          }
          b2 === 0 && (f2 += y2);
      }
      K2 = x2, x2 = g2, l2++;
    }
    if (t4 = p.length, 0 < t4) {
      if (r3 = c4, 0 < A && (C2 = H2(2, p, r3, d2, D2, z2, t4, h, a3, h), C2 !== void 0 && (p = C2).length === 0))
        return G3 + p + F3;
      if (p = r3.join(",") + "{" + p + "}", w2 * E2 !== 0) {
        switch (w2 !== 2 || L2(p, 2) || (E2 = 0), E2) {
          case 111:
            p = p.replace(ha, ":-moz-$1") + p;
            break;
          case 112:
            p = p.replace(Q2, "::-webkit-input-$1") + p.replace(Q2, "::-moz-$1") + p.replace(Q2, ":-ms-input-$1") + p;
        }
        E2 = 0;
      }
    }
    return G3 + p + F3;
  }
  function X2(d2, c4, e3) {
    var h = c4.trim().split(ia);
    c4 = h;
    var a3 = h.length, m2 = d2.length;
    switch (m2) {
      case 0:
      case 1:
        var b2 = 0;
        for (d2 = m2 === 0 ? "" : d2[0] + " "; b2 < a3; ++b2)
          c4[b2] = Z2(d2, c4[b2], e3).trim();
        break;
      default:
        var v2 = b2 = 0;
        for (c4 = []; b2 < a3; ++b2)
          for (var n3 = 0; n3 < m2; ++n3)
            c4[v2++] = Z2(d2[n3] + " ", h[b2], e3).trim();
    }
    return c4;
  }
  function Z2(d2, c4, e3) {
    var h = c4.charCodeAt(0);
    switch (33 > h && (h = (c4 = c4.trim()).charCodeAt(0)), h) {
      case 38:
        return c4.replace(F2, "$1" + d2.trim());
      case 58:
        return d2.trim() + c4.replace(F2, "$1" + d2.trim());
      default:
        if (0 < 1 * e3 && 0 < c4.indexOf("\f"))
          return c4.replace(F2, (d2.charCodeAt(0) === 58 ? "" : "$1") + d2.trim());
    }
    return d2 + c4;
  }
  function P(d2, c4, e3, h) {
    var a3 = d2 + ";", m2 = 2 * c4 + 3 * e3 + 4 * h;
    if (m2 === 944) {
      d2 = a3.indexOf(":", 9) + 1;
      var b2 = a3.substring(d2, a3.length - 1).trim();
      return b2 = a3.substring(0, d2).trim() + b2 + ";", w2 === 1 || w2 === 2 && L2(b2, 1) ? "-webkit-" + b2 + b2 : b2;
    }
    if (w2 === 0 || w2 === 2 && !L2(a3, 1))
      return a3;
    switch (m2) {
      case 1015:
        return a3.charCodeAt(10) === 97 ? "-webkit-" + a3 + a3 : a3;
      case 951:
        return a3.charCodeAt(3) === 116 ? "-webkit-" + a3 + a3 : a3;
      case 963:
        return a3.charCodeAt(5) === 110 ? "-webkit-" + a3 + a3 : a3;
      case 1009:
        if (a3.charCodeAt(4) !== 100)
          break;
      case 969:
      case 942:
        return "-webkit-" + a3 + a3;
      case 978:
        return "-webkit-" + a3 + "-moz-" + a3 + a3;
      case 1019:
      case 983:
        return "-webkit-" + a3 + "-moz-" + a3 + "-ms-" + a3 + a3;
      case 883:
        if (a3.charCodeAt(8) === 45)
          return "-webkit-" + a3 + a3;
        if (0 < a3.indexOf("image-set(", 11))
          return a3.replace(ja, "$1-webkit-$2") + a3;
        break;
      case 932:
        if (a3.charCodeAt(4) === 45)
          switch (a3.charCodeAt(5)) {
            case 103:
              return "-webkit-box-" + a3.replace("-grow", "") + "-webkit-" + a3 + "-ms-" + a3.replace("grow", "positive") + a3;
            case 115:
              return "-webkit-" + a3 + "-ms-" + a3.replace("shrink", "negative") + a3;
            case 98:
              return "-webkit-" + a3 + "-ms-" + a3.replace("basis", "preferred-size") + a3;
          }
        return "-webkit-" + a3 + "-ms-" + a3 + a3;
      case 964:
        return "-webkit-" + a3 + "-ms-flex-" + a3 + a3;
      case 1023:
        if (a3.charCodeAt(8) !== 99)
          break;
        return b2 = a3.substring(a3.indexOf(":", 15)).replace("flex-", "").replace("space-between", "justify"), "-webkit-box-pack" + b2 + "-webkit-" + a3 + "-ms-flex-pack" + b2 + a3;
      case 1005:
        return ka.test(a3) ? a3.replace(aa, ":-webkit-") + a3.replace(aa, ":-moz-") + a3 : a3;
      case 1e3:
        switch (b2 = a3.substring(13).trim(), c4 = b2.indexOf("-") + 1, b2.charCodeAt(0) + b2.charCodeAt(c4)) {
          case 226:
            b2 = a3.replace(G2, "tb");
            break;
          case 232:
            b2 = a3.replace(G2, "tb-rl");
            break;
          case 220:
            b2 = a3.replace(G2, "lr");
            break;
          default:
            return a3;
        }
        return "-webkit-" + a3 + "-ms-" + b2 + a3;
      case 1017:
        if (a3.indexOf("sticky", 9) === -1)
          break;
      case 975:
        switch (c4 = (a3 = d2).length - 10, b2 = (a3.charCodeAt(c4) === 33 ? a3.substring(0, c4) : a3).substring(d2.indexOf(":", 7) + 1).trim(), m2 = b2.charCodeAt(0) + (b2.charCodeAt(7) | 0)) {
          case 203:
            if (111 > b2.charCodeAt(8))
              break;
          case 115:
            a3 = a3.replace(b2, "-webkit-" + b2) + ";" + a3;
            break;
          case 207:
          case 102:
            a3 = a3.replace(b2, "-webkit-" + (102 < m2 ? "inline-" : "") + "box") + ";" + a3.replace(b2, "-webkit-" + b2) + ";" + a3.replace(b2, "-ms-" + b2 + "box") + ";" + a3;
        }
        return a3 + ";";
      case 938:
        if (a3.charCodeAt(5) === 45)
          switch (a3.charCodeAt(6)) {
            case 105:
              return b2 = a3.replace("-items", ""), "-webkit-" + a3 + "-webkit-box-" + b2 + "-ms-flex-" + b2 + a3;
            case 115:
              return "-webkit-" + a3 + "-ms-flex-item-" + a3.replace(ba, "") + a3;
            default:
              return "-webkit-" + a3 + "-ms-flex-line-pack" + a3.replace("align-content", "").replace(ba, "") + a3;
          }
        break;
      case 973:
      case 989:
        if (a3.charCodeAt(3) !== 45 || a3.charCodeAt(4) === 122)
          break;
      case 931:
      case 953:
        if (la.test(d2) === !0)
          return (b2 = d2.substring(d2.indexOf(":") + 1)).charCodeAt(0) === 115 ? P(d2.replace("stretch", "fill-available"), c4, e3, h).replace(":fill-available", ":stretch") : a3.replace(b2, "-webkit-" + b2) + a3.replace(b2, "-moz-" + b2.replace("fill-", "")) + a3;
        break;
      case 962:
        if (a3 = "-webkit-" + a3 + (a3.charCodeAt(5) === 102 ? "-ms-" + a3 : "") + a3, e3 + h === 211 && a3.charCodeAt(13) === 105 && 0 < a3.indexOf("transform", 10))
          return a3.substring(0, a3.indexOf(";", 27) + 1).replace(ma, "$1-webkit-$2") + a3;
    }
    return a3;
  }
  function L2(d2, c4) {
    var e3 = d2.indexOf(c4 === 1 ? ":" : "{"), h = d2.substring(0, c4 !== 3 ? e3 : 10);
    return e3 = d2.substring(e3 + 1, d2.length - 1), R2(c4 !== 2 ? h : h.replace(na, "$1"), e3, c4);
  }
  function ea(d2, c4) {
    var e3 = P(c4, c4.charCodeAt(0), c4.charCodeAt(1), c4.charCodeAt(2));
    return e3 !== c4 + ";" ? e3.replace(oa, " or ($1)").substring(4) : "(" + c4 + ")";
  }
  function H2(d2, c4, e3, h, a3, m2, b2, v2, n3, q2) {
    for (var g2 = 0, x2 = c4, w3; g2 < A; ++g2)
      switch (w3 = S2[g2].call(B2, d2, x2, e3, h, a3, m2, b2, v2, n3, q2)) {
        case void 0:
        case !1:
        case !0:
        case null:
          break;
        default:
          x2 = w3;
      }
    if (x2 !== c4)
      return x2;
  }
  function T2(d2) {
    switch (d2) {
      case void 0:
      case null:
        A = S2.length = 0;
        break;
      default:
        if (typeof d2 == "function")
          S2[A++] = d2;
        else if (typeof d2 == "object")
          for (var c4 = 0, e3 = d2.length; c4 < e3; ++c4)
            T2(d2[c4]);
        else
          Y2 = !!d2 | 0;
    }
    return T2;
  }
  function U2(d2) {
    return d2 = d2.prefix, d2 !== void 0 && (R2 = null, d2 ? typeof d2 != "function" ? w2 = 1 : (w2 = 2, R2 = d2) : w2 = 0), U2;
  }
  function B2(d2, c4) {
    var e3 = d2;
    if (33 > e3.charCodeAt(0) && (e3 = e3.trim()), V2 = e3, e3 = [V2], 0 < A) {
      var h = H2(-1, c4, e3, e3, D2, z2, 0, 0, 0, 0);
      h !== void 0 && typeof h == "string" && (c4 = h);
    }
    var a3 = M2(O2, e3, c4, 0, 0);
    return 0 < A && (h = H2(-2, a3, e3, e3, D2, z2, a3.length, 0, 0, 0), h !== void 0 && (a3 = h)), V2 = "", E2 = 0, z2 = D2 = 1, a3;
  }
  var ca = /^\0+/g, N2 = /[\0\r\f]/g, aa = /: */g, ka = /zoo|gra/, ma = /([,: ])(transform)/g, ia = /,\r+?/g, F2 = /([\t\r\n ])*\f?&/g, fa = /@(k\w+)\s*(\S*)\s*/, Q2 = /::(place)/g, ha = /:(read-only)/g, G2 = /[svh]\w+-[tblr]{2}/, da = /\(\s*(.*)\s*\)/g, oa = /([\s\S]*?);/g, ba = /-self|flex-/g, na = /[^]*?(:[rp][el]a[\w-]+)[^]*/, la = /stretch|:\s*\w+\-(?:conte|avail)/, ja = /([^-])(image-set\()/, z2 = 1, D2 = 1, E2 = 0, w2 = 1, O2 = [], S2 = [], A = 0, R2 = null, Y2 = 0, V2 = "";
  return B2.use = T2, B2.set = U2, W2 !== void 0 && U2(W2), B2;
}
var stylis_esm_default = stylis_min;

// node_modules/@emotion/unitless/dist/unitless.esm.js
var unitlessKeys = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, unitless_esm_default = unitlessKeys;

// node_modules/styled-components/dist/styled-components.esm.js
var import_is_prop_valid = __toESM(require_emotion_is_prop_valid_cjs()), import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs());
function v() {
  return (v = Object.assign || function(e3) {
    for (var t4 = 1; t4 < arguments.length; t4++) {
      var n3 = arguments[t4];
      for (var r3 in n3)
        Object.prototype.hasOwnProperty.call(n3, r3) && (e3[r3] = n3[r3]);
    }
    return e3;
  }).apply(this, arguments);
}
var y = function(e3, t4) {
  for (var n3 = [e3[0]], r3 = 0, o2 = t4.length; r3 < o2; r3 += 1)
    n3.push(t4[r3], e3[r3 + 1]);
  return n3;
}, g = function(t4) {
  return t4 !== null && typeof t4 == "object" && (t4.toString ? t4.toString() : Object.prototype.toString.call(t4)) === "[object Object]" && !(0, import_react_is.typeOf)(t4);
}, S = Object.freeze([]), w = Object.freeze({});
function E(e3) {
  return typeof e3 == "function";
}
function b(e3) {
  return typeof e3 == "string" && e3 || e3.displayName || e3.name || "Component";
}
function _(e3) {
  return e3 && typeof e3.styledComponentId == "string";
}
var N = typeof process < "u" && process.env !== void 0 && (process.env.REACT_APP_SC_ATTR || process.env.SC_ATTR) || "data-styled";
var C = typeof window < "u" && "HTMLElement" in window, I = Boolean(typeof SC_DISABLE_SPEEDY == "boolean" ? SC_DISABLE_SPEEDY : typeof process < "u" && process.env !== void 0 && (process.env.REACT_APP_SC_DISABLE_SPEEDY !== void 0 && process.env.REACT_APP_SC_DISABLE_SPEEDY !== "" ? process.env.REACT_APP_SC_DISABLE_SPEEDY !== "false" && process.env.REACT_APP_SC_DISABLE_SPEEDY : process.env.SC_DISABLE_SPEEDY !== void 0 && process.env.SC_DISABLE_SPEEDY !== "" ? process.env.SC_DISABLE_SPEEDY !== "false" && process.env.SC_DISABLE_SPEEDY : !0));
var O = { 1: `Cannot create styled-component for component: %s.

`, 2: `Can't collect styles once you've consumed a \`ServerStyleSheet\`'s styles! \`ServerStyleSheet\` is a one off instance for each server-side render cycle.

- Are you trying to reuse it across renders?
- Are you accidentally calling collectStyles twice?

`, 3: `Streaming SSR is only supported in a Node.js environment; Please do not try to call this method in the browser.

`, 4: `The \`StyleSheetManager\` expects a valid target or sheet prop!

- Does this error occur on the client and is your target falsy?
- Does this error occur on the server and is the sheet falsy?

`, 5: `The clone method cannot be used on the client!

- Are you running in a client-like environment on the server?
- Are you trying to run SSR on the client?

`, 6: `Trying to insert a new style tag, but the given Node is unmounted!

- Are you using a custom target that isn't mounted?
- Does your document not have a valid head element?
- Have you accidentally removed a style tag manually?

`, 7: 'ThemeProvider: Please return an object from your "theme" prop function, e.g.\n\n```js\ntheme={() => ({})}\n```\n\n', 8: `ThemeProvider: Please make your "theme" prop an object.

`, 9: "Missing document `<head>`\n\n", 10: `Cannot find a StyleSheet instance. Usually this happens if there are multiple copies of styled-components loaded at once. Check out this issue for how to troubleshoot and fix the common cases where this situation can happen: https://github.com/styled-components/styled-components/issues/1941#issuecomment-417862021

`, 11: `_This error was replaced with a dev-time warning, it will be deleted for v4 final._ [createGlobalStyle] received children which will not be rendered. Please use the component without passing children elements.

`, 12: "It seems you are interpolating a keyframe declaration (%s) into an untagged string. This was supported in styled-components v3, but is not longer supported in v4 as keyframes are now injected on-demand. Please wrap your string in the css\\`\\` helper which ensures the styles are injected correctly. See https://www.styled-components.com/docs/api#css\n\n", 13: `%s is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.

`, 14: `ThemeProvider: "theme" prop is required.

`, 15: "A stylis plugin has been supplied that is not named. We need a name for each plugin to be able to prevent styling collisions between different stylis configurations within the same app. Before you pass your plugin to `<StyleSheetManager stylisPlugins={[]}>`, please make sure each plugin is uniquely-named, e.g.\n\n```js\nObject.defineProperty(importedPlugin, 'name', { value: 'some-unique-name' });\n```\n\n", 16: `Reached the limit of how many styled components may be created at group %s.
You may only create up to 1,073,741,824 components. If you're creating components dynamically,
as for instance in your render method then you may be running into this limitation.

`, 17: `CSSStyleSheet could not be found on HTMLStyleElement.
Has styled-components' style tag been unmounted or altered by another script?
` };
function R() {
  for (var e3 = arguments.length <= 0 ? void 0 : arguments[0], t4 = [], n3 = 1, r3 = arguments.length; n3 < r3; n3 += 1)
    t4.push(n3 < 0 || arguments.length <= n3 ? void 0 : arguments[n3]);
  return t4.forEach(function(t5) {
    e3 = e3.replace(/%[a-z]/, t5);
  }), e3;
}
function D(e3) {
  for (var t4 = arguments.length, n3 = new Array(t4 > 1 ? t4 - 1 : 0), r3 = 1; r3 < t4; r3++)
    n3[r3 - 1] = arguments[r3];
  throw new Error(R.apply(void 0, [O[e3]].concat(n3)).trim());
}
var j = function() {
  function e3(e4) {
    this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = e4;
  }
  var t4 = e3.prototype;
  return t4.indexOfGroup = function(e4) {
    for (var t5 = 0, n3 = 0; n3 < e4; n3++)
      t5 += this.groupSizes[n3];
    return t5;
  }, t4.insertRules = function(e4, t5) {
    if (e4 >= this.groupSizes.length) {
      for (var n3 = this.groupSizes, r3 = n3.length, o2 = r3; e4 >= o2; )
        (o2 <<= 1) < 0 && D(16, "" + e4);
      this.groupSizes = new Uint32Array(o2), this.groupSizes.set(n3), this.length = o2;
      for (var s3 = r3; s3 < o2; s3++)
        this.groupSizes[s3] = 0;
    }
    for (var i3 = this.indexOfGroup(e4 + 1), a3 = 0, c4 = t5.length; a3 < c4; a3++)
      this.tag.insertRule(i3, t5[a3]) && (this.groupSizes[e4]++, i3++);
  }, t4.clearGroup = function(e4) {
    if (e4 < this.length) {
      var t5 = this.groupSizes[e4], n3 = this.indexOfGroup(e4), r3 = n3 + t5;
      this.groupSizes[e4] = 0;
      for (var o2 = n3; o2 < r3; o2++)
        this.tag.deleteRule(n3);
    }
  }, t4.getGroup = function(e4) {
    var t5 = "";
    if (e4 >= this.length || this.groupSizes[e4] === 0)
      return t5;
    for (var n3 = this.groupSizes[e4], r3 = this.indexOfGroup(e4), o2 = r3 + n3, s3 = r3; s3 < o2; s3++)
      t5 += this.tag.getRule(s3) + `/*!sc*/
`;
    return t5;
  }, e3;
}(), T = /* @__PURE__ */ new Map(), x = /* @__PURE__ */ new Map(), k = 1, V = function(e3) {
  if (T.has(e3))
    return T.get(e3);
  for (; x.has(k); )
    k++;
  var t4 = k++;
  return ((0 | t4) < 0 || t4 > 1 << 30) && D(16, "" + t4), T.set(e3, t4), x.set(t4, e3), t4;
}, z = function(e3) {
  return x.get(e3);
}, B = function(e3, t4) {
  t4 >= k && (k = t4 + 1), T.set(e3, t4), x.set(t4, e3);
}, M = "style[" + N + '][data-styled-version="5.3.9"]', G = new RegExp("^" + N + '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)'), L = function(e3, t4, n3) {
  for (var r3, o2 = n3.split(","), s3 = 0, i3 = o2.length; s3 < i3; s3++)
    (r3 = o2[s3]) && e3.registerName(t4, r3);
}, F = function(e3, t4) {
  for (var n3 = (t4.textContent || "").split(`/*!sc*/
`), r3 = [], o2 = 0, s3 = n3.length; o2 < s3; o2++) {
    var i3 = n3[o2].trim();
    if (i3) {
      var a3 = i3.match(G);
      if (a3) {
        var c4 = 0 | parseInt(a3[1], 10), u2 = a3[2];
        c4 !== 0 && (B(u2, c4), L(e3, u2, a3[3]), e3.getTag().insertRules(c4, r3)), r3.length = 0;
      } else
        r3.push(i3);
    }
  }
}, Y = function() {
  return typeof __webpack_nonce__ < "u" ? __webpack_nonce__ : null;
}, q = function(e3) {
  var t4 = document.head, n3 = e3 || t4, r3 = document.createElement("style"), o2 = function(e4) {
    for (var t5 = e4.childNodes, n4 = t5.length; n4 >= 0; n4--) {
      var r4 = t5[n4];
      if (r4 && r4.nodeType === 1 && r4.hasAttribute(N))
        return r4;
    }
  }(n3), s3 = o2 !== void 0 ? o2.nextSibling : null;
  r3.setAttribute(N, "active"), r3.setAttribute("data-styled-version", "5.3.9");
  var i3 = Y();
  return i3 && r3.setAttribute("nonce", i3), n3.insertBefore(r3, s3), r3;
}, H = function() {
  function e3(e4) {
    var t5 = this.element = q(e4);
    t5.appendChild(document.createTextNode("")), this.sheet = function(e5) {
      if (e5.sheet)
        return e5.sheet;
      for (var t6 = document.styleSheets, n3 = 0, r3 = t6.length; n3 < r3; n3++) {
        var o2 = t6[n3];
        if (o2.ownerNode === e5)
          return o2;
      }
      D(17);
    }(t5), this.length = 0;
  }
  var t4 = e3.prototype;
  return t4.insertRule = function(e4, t5) {
    try {
      return this.sheet.insertRule(t5, e4), this.length++, !0;
    } catch {
      return !1;
    }
  }, t4.deleteRule = function(e4) {
    this.sheet.deleteRule(e4), this.length--;
  }, t4.getRule = function(e4) {
    var t5 = this.sheet.cssRules[e4];
    return t5 !== void 0 && typeof t5.cssText == "string" ? t5.cssText : "";
  }, e3;
}(), $ = function() {
  function e3(e4) {
    var t5 = this.element = q(e4);
    this.nodes = t5.childNodes, this.length = 0;
  }
  var t4 = e3.prototype;
  return t4.insertRule = function(e4, t5) {
    if (e4 <= this.length && e4 >= 0) {
      var n3 = document.createTextNode(t5), r3 = this.nodes[e4];
      return this.element.insertBefore(n3, r3 || null), this.length++, !0;
    }
    return !1;
  }, t4.deleteRule = function(e4) {
    this.element.removeChild(this.nodes[e4]), this.length--;
  }, t4.getRule = function(e4) {
    return e4 < this.length ? this.nodes[e4].textContent : "";
  }, e3;
}(), W = function() {
  function e3(e4) {
    this.rules = [], this.length = 0;
  }
  var t4 = e3.prototype;
  return t4.insertRule = function(e4, t5) {
    return e4 <= this.length && (this.rules.splice(e4, 0, t5), this.length++, !0);
  }, t4.deleteRule = function(e4) {
    this.rules.splice(e4, 1), this.length--;
  }, t4.getRule = function(e4) {
    return e4 < this.length ? this.rules[e4] : "";
  }, e3;
}(), U = C, J = { isServer: !C, useCSSOMInjection: !I }, X = function() {
  function e3(e4, t5, n3) {
    e4 === void 0 && (e4 = w), t5 === void 0 && (t5 = {}), this.options = v({}, J, {}, e4), this.gs = t5, this.names = new Map(n3), this.server = !!e4.isServer, !this.server && C && U && (U = !1, function(e5) {
      for (var t6 = document.querySelectorAll(M), n4 = 0, r3 = t6.length; n4 < r3; n4++) {
        var o2 = t6[n4];
        o2 && o2.getAttribute(N) !== "active" && (F(e5, o2), o2.parentNode && o2.parentNode.removeChild(o2));
      }
    }(this));
  }
  e3.registerId = function(e4) {
    return V(e4);
  };
  var t4 = e3.prototype;
  return t4.reconstructWithOptions = function(t5, n3) {
    return n3 === void 0 && (n3 = !0), new e3(v({}, this.options, {}, t5), this.gs, n3 && this.names || void 0);
  }, t4.allocateGSInstance = function(e4) {
    return this.gs[e4] = (this.gs[e4] || 0) + 1;
  }, t4.getTag = function() {
    return this.tag || (this.tag = (n3 = (t5 = this.options).isServer, r3 = t5.useCSSOMInjection, o2 = t5.target, e4 = n3 ? new W(o2) : r3 ? new H(o2) : new $(o2), new j(e4)));
    var e4, t5, n3, r3, o2;
  }, t4.hasNameForId = function(e4, t5) {
    return this.names.has(e4) && this.names.get(e4).has(t5);
  }, t4.registerName = function(e4, t5) {
    if (V(e4), this.names.has(e4))
      this.names.get(e4).add(t5);
    else {
      var n3 = /* @__PURE__ */ new Set();
      n3.add(t5), this.names.set(e4, n3);
    }
  }, t4.insertRules = function(e4, t5, n3) {
    this.registerName(e4, t5), this.getTag().insertRules(V(e4), n3);
  }, t4.clearNames = function(e4) {
    this.names.has(e4) && this.names.get(e4).clear();
  }, t4.clearRules = function(e4) {
    this.getTag().clearGroup(V(e4)), this.clearNames(e4);
  }, t4.clearTag = function() {
    this.tag = void 0;
  }, t4.toString = function() {
    return function(e4) {
      for (var t5 = e4.getTag(), n3 = t5.length, r3 = "", o2 = 0; o2 < n3; o2++) {
        var s3 = z(o2);
        if (s3 !== void 0) {
          var i3 = e4.names.get(s3), a3 = t5.getGroup(o2);
          if (i3 && a3 && i3.size) {
            var c4 = N + ".g" + o2 + '[id="' + s3 + '"]', u2 = "";
            i3 !== void 0 && i3.forEach(function(e5) {
              e5.length > 0 && (u2 += e5 + ",");
            }), r3 += "" + a3 + c4 + '{content:"' + u2 + `"}/*!sc*/
`;
          }
        }
      }
      return r3;
    }(this);
  }, e3;
}(), Z = /(a)(d)/gi, K = function(e3) {
  return String.fromCharCode(e3 + (e3 > 25 ? 39 : 97));
};
function Q(e3) {
  var t4, n3 = "";
  for (t4 = Math.abs(e3); t4 > 52; t4 = t4 / 52 | 0)
    n3 = K(t4 % 52) + n3;
  return (K(t4 % 52) + n3).replace(Z, "$1-$2");
}
var ee = function(e3, t4) {
  for (var n3 = t4.length; n3; )
    e3 = 33 * e3 ^ t4.charCodeAt(--n3);
  return e3;
}, te = function(e3) {
  return ee(5381, e3);
};
function ne(e3) {
  for (var t4 = 0; t4 < e3.length; t4 += 1) {
    var n3 = e3[t4];
    if (E(n3) && !_(n3))
      return !1;
  }
  return !0;
}
var re = te("5.3.9"), oe = function() {
  function e3(e4, t4, n3) {
    this.rules = e4, this.staticRulesId = "", this.isStatic = !1, this.componentId = t4, this.baseHash = ee(re, t4), this.baseStyle = n3, X.registerId(t4);
  }
  return e3.prototype.generateAndInjectStyles = function(e4, t4, n3) {
    var r3 = this.componentId, o2 = [];
    if (this.baseStyle && o2.push(this.baseStyle.generateAndInjectStyles(e4, t4, n3)), this.isStatic && !n3.hash)
      if (this.staticRulesId && t4.hasNameForId(r3, this.staticRulesId))
        o2.push(this.staticRulesId);
      else {
        var s3 = _e(this.rules, e4, t4, n3).join(""), i3 = Q(ee(this.baseHash, s3) >>> 0);
        if (!t4.hasNameForId(r3, i3)) {
          var a3 = n3(s3, "." + i3, void 0, r3);
          t4.insertRules(r3, i3, a3);
        }
        o2.push(i3), this.staticRulesId = i3;
      }
    else {
      for (var c4 = this.rules.length, u2 = ee(this.baseHash, n3.hash), l2 = "", d2 = 0; d2 < c4; d2++) {
        var h = this.rules[d2];
        if (typeof h == "string")
          l2 += h, u2 = ee(u2, h + d2);
        else if (h) {
          var p = _e(h, e4, t4, n3), f2 = Array.isArray(p) ? p.join("") : p;
          u2 = ee(u2, f2 + d2), l2 += f2;
        }
      }
      if (l2) {
        var m2 = Q(u2 >>> 0);
        if (!t4.hasNameForId(r3, m2)) {
          var v2 = n3(l2, "." + m2, void 0, r3);
          t4.insertRules(r3, m2, v2);
        }
        o2.push(m2);
      }
    }
    return o2.join(" ");
  }, e3;
}(), se = /^\s*\/\/.*$/gm, ie = [":", "[", ".", "#"];
function ae(e3) {
  var t4, n3, r3, o2, s3 = e3 === void 0 ? w : e3, i3 = s3.options, a3 = i3 === void 0 ? w : i3, c4 = s3.plugins, u2 = c4 === void 0 ? S : c4, l2 = new stylis_esm_default(a3), d2 = [], p = function(e4) {
    function t5(t6) {
      if (t6)
        try {
          e4(t6 + "}");
        } catch {
        }
    }
    return function(n4, r4, o3, s4, i4, a4, c5, u3, l3, d3) {
      switch (n4) {
        case 1:
          if (l3 === 0 && r4.charCodeAt(0) === 64)
            return e4(r4 + ";"), "";
          break;
        case 2:
          if (u3 === 0)
            return r4 + "/*|*/";
          break;
        case 3:
          switch (u3) {
            case 102:
            case 112:
              return e4(o3[0] + r4), "";
            default:
              return r4 + (d3 === 0 ? "/*|*/" : "");
          }
        case -2:
          r4.split("/*|*/}").forEach(t5);
      }
    };
  }(function(e4) {
    d2.push(e4);
  }), f2 = function(e4, r4, s4) {
    return r4 === 0 && ie.indexOf(s4[n3.length]) !== -1 || s4.match(o2) ? e4 : "." + t4;
  };
  function m2(e4, s4, i4, a4) {
    a4 === void 0 && (a4 = "&");
    var c5 = e4.replace(se, ""), u3 = s4 && i4 ? i4 + " " + s4 + " { " + c5 + " }" : c5;
    return t4 = a4, n3 = s4, r3 = new RegExp("\\" + n3 + "\\b", "g"), o2 = new RegExp("(\\" + n3 + "\\b){2,}"), l2(i4 || !s4 ? "" : s4, u3);
  }
  return l2.use([].concat(u2, [function(e4, t5, o3) {
    e4 === 2 && o3.length && o3[0].lastIndexOf(n3) > 0 && (o3[0] = o3[0].replace(r3, f2));
  }, p, function(e4) {
    if (e4 === -2) {
      var t5 = d2;
      return d2 = [], t5;
    }
  }])), m2.hash = u2.length ? u2.reduce(function(e4, t5) {
    return t5.name || D(15), ee(e4, t5.name);
  }, 5381).toString() : "", m2;
}
var ce = import_react9.default.createContext(), ue = ce.Consumer, le = import_react9.default.createContext(), de = (le.Consumer, new X()), he = ae();
function pe() {
  return (0, import_react9.useContext)(ce) || de;
}
function fe() {
  return (0, import_react9.useContext)(le) || he;
}
function me(e3) {
  var t4 = (0, import_react9.useState)(e3.stylisPlugins), n3 = t4[0], s3 = t4[1], c4 = pe(), u2 = (0, import_react9.useMemo)(function() {
    var t5 = c4;
    return e3.sheet ? t5 = e3.sheet : e3.target && (t5 = t5.reconstructWithOptions({ target: e3.target }, !1)), e3.disableCSSOMInjection && (t5 = t5.reconstructWithOptions({ useCSSOMInjection: !1 })), t5;
  }, [e3.disableCSSOMInjection, e3.sheet, e3.target]), l2 = (0, import_react9.useMemo)(function() {
    return ae({ options: { prefix: !e3.disableVendorPrefixes }, plugins: n3 });
  }, [e3.disableVendorPrefixes, n3]);
  return (0, import_react9.useEffect)(function() {
    (0, import_shallowequal.default)(n3, e3.stylisPlugins) || s3(e3.stylisPlugins);
  }, [e3.stylisPlugins]), import_react9.default.createElement(ce.Provider, { value: u2 }, import_react9.default.createElement(le.Provider, { value: l2 }, import_react9.default.Children.only(e3.children)));
}
var ve = function() {
  function e3(e4, t4) {
    var n3 = this;
    this.inject = function(e5, t5) {
      t5 === void 0 && (t5 = he);
      var r3 = n3.name + t5.hash;
      e5.hasNameForId(n3.id, r3) || e5.insertRules(n3.id, r3, t5(n3.rules, r3, "@keyframes"));
    }, this.toString = function() {
      return D(12, String(n3.name));
    }, this.name = e4, this.id = "sc-keyframes-" + e4, this.rules = t4;
  }
  return e3.prototype.getName = function(e4) {
    return e4 === void 0 && (e4 = he), this.name + e4.hash;
  }, e3;
}(), ye = /([A-Z])/, ge = /([A-Z])/g, Se = /^ms-/, we = function(e3) {
  return "-" + e3.toLowerCase();
};
function Ee(e3) {
  return ye.test(e3) ? e3.replace(ge, we).replace(Se, "-ms-") : e3;
}
var be = function(e3) {
  return e3 == null || e3 === !1 || e3 === "";
};
function _e(e3, n3, r3, o2) {
  if (Array.isArray(e3)) {
    for (var s3, i3 = [], a3 = 0, c4 = e3.length; a3 < c4; a3 += 1)
      (s3 = _e(e3[a3], n3, r3, o2)) !== "" && (Array.isArray(s3) ? i3.push.apply(i3, s3) : i3.push(s3));
    return i3;
  }
  if (be(e3))
    return "";
  if (_(e3))
    return "." + e3.styledComponentId;
  if (E(e3)) {
    if (typeof (l2 = e3) != "function" || l2.prototype && l2.prototype.isReactComponent || !n3)
      return e3;
    var u2 = e3(n3);
    return (0, import_react_is.isElement)(u2) && console.warn(b(e3) + " is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details."), _e(u2, n3, r3, o2);
  }
  var l2;
  return e3 instanceof ve ? r3 ? (e3.inject(r3, o2), e3.getName(o2)) : e3 : g(e3) ? function e4(t4, n4) {
    var r4, o3, s4 = [];
    for (var i4 in t4)
      t4.hasOwnProperty(i4) && !be(t4[i4]) && (Array.isArray(t4[i4]) && t4[i4].isCss || E(t4[i4]) ? s4.push(Ee(i4) + ":", t4[i4], ";") : g(t4[i4]) ? s4.push.apply(s4, e4(t4[i4], i4)) : s4.push(Ee(i4) + ": " + (r4 = i4, (o3 = t4[i4]) == null || typeof o3 == "boolean" || o3 === "" ? "" : typeof o3 != "number" || o3 === 0 || r4 in unitless_esm_default ? String(o3).trim() : o3 + "px") + ";"));
    return n4 ? [n4 + " {"].concat(s4, ["}"]) : s4;
  }(e3) : e3.toString();
}
var Ne = function(e3) {
  return Array.isArray(e3) && (e3.isCss = !0), e3;
};
function Ae(e3) {
  for (var t4 = arguments.length, n3 = new Array(t4 > 1 ? t4 - 1 : 0), r3 = 1; r3 < t4; r3++)
    n3[r3 - 1] = arguments[r3];
  return E(e3) || g(e3) ? Ne(_e(y(S, [e3].concat(n3)))) : n3.length === 0 && e3.length === 1 && typeof e3[0] == "string" ? e3 : Ne(_e(y(e3, n3)));
}
var Ce = /invalid hook call/i, Ie = /* @__PURE__ */ new Set(), Pe = function(e3, t4) {
  var n3 = "The component " + e3 + (t4 ? ' with the id of "' + t4 + '"' : "") + ` has been created dynamically.
You may see this warning because you've called styled inside another component.
To resolve this only create new StyledComponents outside of any render method and function component.`, r3 = console.error;
  try {
    var o2 = !0;
    console.error = function(e4) {
      if (Ce.test(e4))
        o2 = !1, Ie.delete(n3);
      else {
        for (var t5 = arguments.length, s3 = new Array(t5 > 1 ? t5 - 1 : 0), i3 = 1; i3 < t5; i3++)
          s3[i3 - 1] = arguments[i3];
        r3.apply(void 0, [e4].concat(s3));
      }
    }, (0, import_react9.useRef)(), o2 && !Ie.has(n3) && (console.warn(n3), Ie.add(n3));
  } catch (e4) {
    Ce.test(e4.message) && Ie.delete(n3);
  } finally {
    console.error = r3;
  }
}, Oe = function(e3, t4, n3) {
  return n3 === void 0 && (n3 = w), e3.theme !== n3.theme && e3.theme || t4 || n3.theme;
}, Re = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g, De = /(^-|-$)/g;
function je(e3) {
  return e3.replace(Re, "-").replace(De, "");
}
var Te = function(e3) {
  return Q(te(e3) >>> 0);
};
function xe(e3) {
  return typeof e3 == "string" && e3.charAt(0) === e3.charAt(0).toLowerCase();
}
var ke = function(e3) {
  return typeof e3 == "function" || typeof e3 == "object" && e3 !== null && !Array.isArray(e3);
}, Ve = function(e3) {
  return e3 !== "__proto__" && e3 !== "constructor" && e3 !== "prototype";
};
function ze(e3, t4, n3) {
  var r3 = e3[n3];
  ke(t4) && ke(r3) ? Be(r3, t4) : e3[n3] = t4;
}
function Be(e3) {
  for (var t4 = arguments.length, n3 = new Array(t4 > 1 ? t4 - 1 : 0), r3 = 1; r3 < t4; r3++)
    n3[r3 - 1] = arguments[r3];
  for (var o2 = 0, s3 = n3; o2 < s3.length; o2++) {
    var i3 = s3[o2];
    if (ke(i3))
      for (var a3 in i3)
        Ve(a3) && ze(e3, i3[a3], a3);
  }
  return e3;
}
var Me = import_react9.default.createContext(), Ge = Me.Consumer;
function Le(e3) {
  var t4 = (0, import_react9.useContext)(Me), n3 = (0, import_react9.useMemo)(function() {
    return function(e4, t5) {
      if (!e4)
        return D(14);
      if (E(e4)) {
        var n4 = e4(t5);
        return n4 !== null && !Array.isArray(n4) && typeof n4 == "object" ? n4 : D(7);
      }
      return Array.isArray(e4) || typeof e4 != "object" ? D(8) : t5 ? v({}, t5, {}, e4) : e4;
    }(e3.theme, t4);
  }, [e3.theme, t4]);
  return e3.children ? import_react9.default.createElement(Me.Provider, { value: n3 }, e3.children) : null;
}
var Fe = {};
function Ye(e3, t4, n3) {
  var o2 = _(e3), i3 = !xe(e3), a3 = t4.attrs, c4 = a3 === void 0 ? S : a3, d2 = t4.componentId, h = d2 === void 0 ? function(e4, t5) {
    var n4 = typeof e4 != "string" ? "sc" : je(e4);
    Fe[n4] = (Fe[n4] || 0) + 1;
    var r3 = n4 + "-" + Te("5.3.9" + n4 + Fe[n4]);
    return t5 ? t5 + "-" + r3 : r3;
  }(t4.displayName, t4.parentComponentId) : d2, p = t4.displayName, y2 = p === void 0 ? function(e4) {
    return xe(e4) ? "styled." + e4 : "Styled(" + b(e4) + ")";
  }(e3) : p, g2 = t4.displayName && t4.componentId ? je(t4.displayName) + "-" + t4.componentId : t4.componentId || h, N2 = o2 && e3.attrs ? Array.prototype.concat(e3.attrs, c4).filter(Boolean) : c4, A = t4.shouldForwardProp;
  o2 && e3.shouldForwardProp && (A = t4.shouldForwardProp ? function(n4, r3, o3) {
    return e3.shouldForwardProp(n4, r3, o3) && t4.shouldForwardProp(n4, r3, o3);
  } : e3.shouldForwardProp);
  var C2, I2 = new oe(n3, g2, o2 ? e3.componentStyle : void 0), P = I2.isStatic && c4.length === 0, O2 = function(e4, t5) {
    return function(e5, t6, n4, r3) {
      var o3 = e5.attrs, i4 = e5.componentStyle, a4 = e5.defaultProps, c5 = e5.foldedComponentIds, d3 = e5.shouldForwardProp, h2 = e5.styledComponentId, p2 = e5.target;
      (0, import_react9.useDebugValue)(h2);
      var m2 = function(e6, t7, n5) {
        e6 === void 0 && (e6 = w);
        var r4 = v({}, t7, { theme: e6 }), o4 = {};
        return n5.forEach(function(e7) {
          var t8, n6, s3, i5 = e7;
          for (t8 in E(i5) && (i5 = i5(r4)), i5)
            r4[t8] = o4[t8] = t8 === "className" ? (n6 = o4[t8], s3 = i5[t8], n6 && s3 ? n6 + " " + s3 : n6 || s3) : i5[t8];
        }), [r4, o4];
      }(Oe(t6, (0, import_react9.useContext)(Me), a4) || w, t6, o3), y3 = m2[0], g3 = m2[1], S2 = function(e6, t7, n5, r4) {
        var o4 = pe(), s3 = fe(), i5 = t7 ? e6.generateAndInjectStyles(w, o4, s3) : e6.generateAndInjectStyles(n5, o4, s3);
        return (0, import_react9.useDebugValue)(i5), !t7 && r4 && r4(i5), i5;
      }(i4, r3, y3, e5.warnTooManyClasses), b2 = n4, _24 = g3.$as || t6.$as || g3.as || t6.as || p2, N3 = xe(_24), A2 = g3 !== t6 ? v({}, t6, {}, g3) : t6, C3 = {};
      for (var I3 in A2)
        I3[0] !== "$" && I3 !== "as" && (I3 === "forwardedAs" ? C3.as = A2[I3] : (d3 ? d3(I3, import_is_prop_valid.default, _24) : !N3 || (0, import_is_prop_valid.default)(I3)) && (C3[I3] = A2[I3]));
      return t6.style && g3.style !== t6.style && (C3.style = v({}, t6.style, {}, g3.style)), C3.className = Array.prototype.concat(c5, h2, S2 !== h2 ? S2 : null, t6.className, g3.className).filter(Boolean).join(" "), C3.ref = b2, (0, import_react9.createElement)(_24, C3);
    }(C2, e4, t5, P);
  };
  return O2.displayName = y2, (C2 = import_react9.default.forwardRef(O2)).attrs = N2, C2.componentStyle = I2, C2.displayName = y2, C2.shouldForwardProp = A, C2.foldedComponentIds = o2 ? Array.prototype.concat(e3.foldedComponentIds, e3.styledComponentId) : S, C2.styledComponentId = g2, C2.target = o2 ? e3.target : e3, C2.withComponent = function(e4) {
    var r3 = t4.componentId, o3 = function(e5, t5) {
      if (e5 == null)
        return {};
      var n4, r4, o4 = {}, s4 = Object.keys(e5);
      for (r4 = 0; r4 < s4.length; r4++)
        n4 = s4[r4], t5.indexOf(n4) >= 0 || (o4[n4] = e5[n4]);
      return o4;
    }(t4, ["componentId"]), s3 = r3 && r3 + "-" + (xe(e4) ? e4 : je(b(e4)));
    return Ye(e4, v({}, o3, { attrs: N2, componentId: s3 }), n3);
  }, Object.defineProperty(C2, "defaultProps", { get: function() {
    return this._foldedDefaultProps;
  }, set: function(t5) {
    this._foldedDefaultProps = o2 ? Be({}, e3.defaultProps, t5) : t5;
  } }), Pe(y2, g2), C2.warnTooManyClasses = function(e4, t5) {
    var n4 = {}, r3 = !1;
    return function(o3) {
      if (!r3 && (n4[o3] = !0, Object.keys(n4).length >= 200)) {
        var s3 = t5 ? ' with the id of "' + t5 + '"' : "";
        console.warn("Over 200 classes were generated for component " + e4 + s3 + `.
Consider using the attrs method, together with a style object for frequently changed styles.
Example:
  const Component = styled.div.attrs(props => ({
    style: {
      background: props.background,
    },
  }))\`width: 100%;\`

  <Component />`), r3 = !0, n4 = {};
      }
    };
  }(y2, g2), Object.defineProperty(C2, "toString", { value: function() {
    return "." + C2.styledComponentId;
  } }), i3 && (0, import_hoist_non_react_statics.default)(C2, e3, { attrs: !0, componentStyle: !0, displayName: !0, foldedComponentIds: !0, shouldForwardProp: !0, styledComponentId: !0, target: !0, withComponent: !0 }), C2;
}
var qe = function(e3) {
  return function e4(t4, r3, o2) {
    if (o2 === void 0 && (o2 = w), !(0, import_react_is.isValidElementType)(r3))
      return D(1, String(r3));
    var s3 = function() {
      return t4(r3, o2, Ae.apply(void 0, arguments));
    };
    return s3.withConfig = function(n3) {
      return e4(t4, r3, v({}, o2, {}, n3));
    }, s3.attrs = function(n3) {
      return e4(t4, r3, v({}, o2, { attrs: Array.prototype.concat(o2.attrs, n3).filter(Boolean) }));
    }, s3;
  }(Ye, e3);
};
["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "textPath", "tspan"].forEach(function(e3) {
  qe[e3] = qe(e3);
});
var He = function() {
  function e3(e4, t5) {
    this.rules = e4, this.componentId = t5, this.isStatic = ne(e4), X.registerId(this.componentId + 1);
  }
  var t4 = e3.prototype;
  return t4.createStyles = function(e4, t5, n3, r3) {
    var o2 = r3(_e(this.rules, t5, n3, r3).join(""), ""), s3 = this.componentId + e4;
    n3.insertRules(s3, s3, o2);
  }, t4.removeStyles = function(e4, t5) {
    t5.clearRules(this.componentId + e4);
  }, t4.renderStyles = function(e4, t5, n3, r3) {
    e4 > 2 && X.registerId(this.componentId + e4), this.removeStyles(e4, n3), this.createStyles(e4, t5, n3, r3);
  }, e3;
}();
var Ue = /^\s*<\/[a-z]/i, Je = function() {
  function e3() {
    var e4 = this;
    this._emitSheetCSS = function() {
      var t5 = e4.instance.toString();
      if (!t5)
        return "";
      var n3 = Y();
      return "<style " + [n3 && 'nonce="' + n3 + '"', N + '="true"', 'data-styled-version="5.3.9"'].filter(Boolean).join(" ") + ">" + t5 + "</style>";
    }, this.getStyleTags = function() {
      return e4.sealed ? D(2) : e4._emitSheetCSS();
    }, this.getStyleElement = function() {
      var t5;
      if (e4.sealed)
        return D(2);
      var n3 = ((t5 = {})[N] = "", t5["data-styled-version"] = "5.3.9", t5.dangerouslySetInnerHTML = { __html: e4.instance.toString() }, t5), o2 = Y();
      return o2 && (n3.nonce = o2), [import_react9.default.createElement("style", v({}, n3, { key: "sc-0-0" }))];
    }, this.seal = function() {
      e4.sealed = !0;
    }, this.instance = new X({ isServer: !0 }), this.sealed = !1;
  }
  var t4 = e3.prototype;
  return t4.collectStyles = function(e4) {
    return this.sealed ? D(2) : import_react9.default.createElement(me, { sheet: this.instance }, e4);
  }, t4.interleaveWithNodeStream = function(e4) {
    if (C)
      return D(3);
    if (this.sealed)
      return D(2);
    this.seal();
    var t5 = require_stream(), n3 = (t5.Readable, t5.Transform), r3 = e4, o2 = this.instance, s3 = this._emitSheetCSS, i3 = new n3({ transform: function(e5, t6, n4) {
      var r4 = e5.toString(), i4 = s3();
      if (o2.clearTag(), Ue.test(r4)) {
        var a3 = r4.indexOf(">") + 1, c4 = r4.slice(0, a3), u2 = r4.slice(a3);
        this.push(c4 + i4 + u2);
      } else
        this.push(i4 + r4);
      n4();
    } });
    return r3.on("error", function(e5) {
      i3.emit("error", e5);
    }), r3.pipe(i3);
  }, e3;
}();
typeof navigator < "u" && navigator.product === "ReactNative" && console.warn(`It looks like you've imported 'styled-components' on React Native.
Perhaps you're looking to import 'styled-components/native'?
Read more about this at https://www.styled-components.com/docs/basics#react-native`), typeof window < "u" && (window["__styled-components-init__"] = window["__styled-components-init__"] || 0, window["__styled-components-init__"] === 1 && console.warn(`It looks like there are several instances of 'styled-components' initialized in this application. This may cause dynamic styles to not render properly, errors during the rehydration process, a missing theme prop, and makes your application bigger without good reason.

See https://s-c.sh/2BAXzed for more info.`), window["__styled-components-init__"] += 1);
var styled_components_esm_default = qe;

// node_modules/i18next/dist/esm/i18next.js
init_typeof();
init_classCallCheck();
init_createClass();

// node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(self) {
  if (self === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return self;
}

// node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(o2, p) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(o3, p2) {
    return o3.__proto__ = p2, o3;
  }, _setPrototypeOf(o2, p);
}

// node_modules/@babel/runtime/helpers/esm/inherits.js
function _inherits(subClass, superClass) {
  if (typeof superClass != "function" && superClass !== null)
    throw new TypeError("Super expression must either be null or a function");
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(subClass, "prototype", {
    writable: !1
  }), superClass && _setPrototypeOf(subClass, superClass);
}

// node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
init_typeof();
function _possibleConstructorReturn(self, call) {
  if (call && (_typeof3(call) === "object" || typeof call == "function"))
    return call;
  if (call !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(self);
}

// node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function _getPrototypeOf(o2) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  }, _getPrototypeOf(o2);
}

// node_modules/i18next/dist/esm/i18next.js
init_defineProperty();

// node_modules/@babel/runtime/helpers/esm/toArray.js
init_arrayWithHoles();

// node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(iter) {
  if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}

// node_modules/@babel/runtime/helpers/esm/toArray.js
init_unsupportedIterableToArray();
init_nonIterableRest();
function _toArray(arr2) {
  return _arrayWithHoles(arr2) || _iterableToArray(arr2) || _unsupportedIterableToArray2(arr2) || _nonIterableRest();
}

// node_modules/i18next/dist/esm/i18next.js
function ownKeys6(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread6(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source2 = arguments[i3] != null ? arguments[i3] : {};
    i3 % 2 ? ownKeys6(Object(source2), !0).forEach(function(key2) {
      _defineProperty(target, key2, source2[key2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2)) : ownKeys6(Object(source2)).forEach(function(key2) {
      Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source2, key2));
    });
  }
  return target;
}
var consoleLogger = {
  type: "logger",
  log: function(args) {
    this.output("log", args);
  },
  warn: function(args) {
    this.output("warn", args);
  },
  error: function(args) {
    this.output("error", args);
  },
  output: function(type2, args) {
    console && console[type2] && console[type2].apply(console, args);
  }
}, Logger = function() {
  function Logger2(concreteLogger) {
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck2(this, Logger2), this.init(concreteLogger, options2);
  }
  return _createClass2(Logger2, [{
    key: "init",
    value: function(concreteLogger) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.prefix = options2.prefix || "i18next:", this.logger = concreteLogger || consoleLogger, this.options = options2, this.debug = options2.debug;
    }
  }, {
    key: "setDebug",
    value: function(bool2) {
      this.debug = bool2;
    }
  }, {
    key: "log",
    value: function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
        args[_key] = arguments[_key];
      return this.forward(args, "log", "", !0);
    }
  }, {
    key: "warn",
    value: function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++)
        args[_key2] = arguments[_key2];
      return this.forward(args, "warn", "", !0);
    }
  }, {
    key: "error",
    value: function() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++)
        args[_key3] = arguments[_key3];
      return this.forward(args, "error", "");
    }
  }, {
    key: "deprecate",
    value: function() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++)
        args[_key4] = arguments[_key4];
      return this.forward(args, "warn", "WARNING DEPRECATED: ", !0);
    }
  }, {
    key: "forward",
    value: function(args, lvl, prefix, debugOnly) {
      return debugOnly && !this.debug ? null : (typeof args[0] == "string" && (args[0] = "".concat(prefix).concat(this.prefix, " ").concat(args[0])), this.logger[lvl](args));
    }
  }, {
    key: "create",
    value: function(moduleName) {
      return new Logger2(this.logger, _objectSpread6(_objectSpread6({}, {
        prefix: "".concat(this.prefix, ":").concat(moduleName, ":")
      }), this.options));
    }
  }, {
    key: "clone",
    value: function(options2) {
      return options2 = options2 || this.options, options2.prefix = options2.prefix || this.prefix, new Logger2(this.logger, options2);
    }
  }]), Logger2;
}(), baseLogger = new Logger(), EventEmitter2 = function() {
  function EventEmitter3() {
    _classCallCheck2(this, EventEmitter3), this.observers = {};
  }
  return _createClass2(EventEmitter3, [{
    key: "on",
    value: function(events2, listener) {
      var _this = this;
      return events2.split(" ").forEach(function(event2) {
        _this.observers[event2] = _this.observers[event2] || [], _this.observers[event2].push(listener);
      }), this;
    }
  }, {
    key: "off",
    value: function(event2, listener) {
      if (!!this.observers[event2]) {
        if (!listener) {
          delete this.observers[event2];
          return;
        }
        this.observers[event2] = this.observers[event2].filter(function(l2) {
          return l2 !== listener;
        });
      }
    }
  }, {
    key: "emit",
    value: function(event2) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
        args[_key - 1] = arguments[_key];
      if (this.observers[event2]) {
        var cloned = [].concat(this.observers[event2]);
        cloned.forEach(function(observer) {
          observer.apply(void 0, args);
        });
      }
      if (this.observers["*"]) {
        var _cloned = [].concat(this.observers["*"]);
        _cloned.forEach(function(observer) {
          observer.apply(observer, [event2].concat(args));
        });
      }
    }
  }]), EventEmitter3;
}();
function defer4() {
  var res, rej, promise = new Promise(function(resolve2, reject) {
    res = resolve2, rej = reject;
  });
  return promise.resolve = res, promise.reject = rej, promise;
}
function makeString(object) {
  return object == null ? "" : "" + object;
}
function copy2(a3, s3, t4) {
  a3.forEach(function(m2) {
    s3[m2] && (t4[m2] = s3[m2]);
  });
}
function getLastOfPath2(object, path2, Empty) {
  function cleanKey(key3) {
    return key3 && key3.indexOf("###") > -1 ? key3.replace(/###/g, ".") : key3;
  }
  function canNotTraverseDeeper() {
    return !object || typeof object == "string";
  }
  for (var stack2 = typeof path2 != "string" ? [].concat(path2) : path2.split("."); stack2.length > 1; ) {
    if (canNotTraverseDeeper())
      return {};
    var key2 = cleanKey(stack2.shift());
    !object[key2] && Empty && (object[key2] = new Empty()), Object.prototype.hasOwnProperty.call(object, key2) ? object = object[key2] : object = {};
  }
  return canNotTraverseDeeper() ? {} : {
    obj: object,
    k: cleanKey(stack2.shift())
  };
}
function setPath2(object, path2, newValue) {
  var _getLastOfPath = getLastOfPath2(object, path2, Object), obj = _getLastOfPath.obj, k2 = _getLastOfPath.k;
  obj[k2] = newValue;
}
function pushPath2(object, path2, newValue, concat2) {
  var _getLastOfPath2 = getLastOfPath2(object, path2, Object), obj = _getLastOfPath2.obj, k2 = _getLastOfPath2.k;
  obj[k2] = obj[k2] || [], concat2 && (obj[k2] = obj[k2].concat(newValue)), concat2 || obj[k2].push(newValue);
}
function getPath2(object, path2) {
  var _getLastOfPath3 = getLastOfPath2(object, path2), obj = _getLastOfPath3.obj, k2 = _getLastOfPath3.k;
  if (!!obj)
    return obj[k2];
}
function getPathWithDefaults(data2, defaultData, key2) {
  var value2 = getPath2(data2, key2);
  return value2 !== void 0 ? value2 : getPath2(defaultData, key2);
}
function deepExtend(target, source2, overwrite) {
  for (var prop in source2)
    prop !== "__proto__" && prop !== "constructor" && (prop in target ? typeof target[prop] == "string" || target[prop] instanceof String || typeof source2[prop] == "string" || source2[prop] instanceof String ? overwrite && (target[prop] = source2[prop]) : deepExtend(target[prop], source2[prop], overwrite) : target[prop] = source2[prop]);
  return target;
}
function regexEscape(str2) {
  return str2.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
var _entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
function escape3(data2) {
  return typeof data2 == "string" ? data2.replace(/[&<>"'\/]/g, function(s3) {
    return _entityMap[s3];
  }) : data2;
}
var isIE10 = typeof window < "u" && window.navigator && typeof window.navigator.userAgentData > "u" && window.navigator.userAgent && window.navigator.userAgent.indexOf("MSIE") > -1, chars = [" ", ",", "?", "!", ";"];
function looksLikeObjectPath(key2, nsSeparator, keySeparator) {
  nsSeparator = nsSeparator || "", keySeparator = keySeparator || "";
  var possibleChars = chars.filter(function(c4) {
    return nsSeparator.indexOf(c4) < 0 && keySeparator.indexOf(c4) < 0;
  });
  if (possibleChars.length === 0)
    return !0;
  var r3 = new RegExp("(".concat(possibleChars.map(function(c4) {
    return c4 === "?" ? "\\?" : c4;
  }).join("|"), ")")), matched = !r3.test(key2);
  if (!matched) {
    var ki = key2.indexOf(keySeparator);
    ki > 0 && !r3.test(key2.substring(0, ki)) && (matched = !0);
  }
  return matched;
}
function ownKeys$1(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$1(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source2 = arguments[i3] != null ? arguments[i3] : {};
    i3 % 2 ? ownKeys$1(Object(source2), !0).forEach(function(key2) {
      _defineProperty(target, key2, source2[key2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2)) : ownKeys$1(Object(source2)).forEach(function(key2) {
      Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source2, key2));
    });
  }
  return target;
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function() {
    var Super = _getPrototypeOf(Derived), result2;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result2 = Reflect.construct(Super, arguments, NewTarget);
    } else
      result2 = Super.apply(this, arguments);
    return _possibleConstructorReturn(this, result2);
  };
}
function _isNativeReflectConstruct() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function deepFind(obj, path2) {
  var keySeparator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!!obj) {
    if (obj[path2])
      return obj[path2];
    for (var paths = path2.split(keySeparator), current = obj, i3 = 0; i3 < paths.length; ++i3) {
      if (!current || typeof current[paths[i3]] == "string" && i3 + 1 < paths.length)
        return;
      if (current[paths[i3]] === void 0) {
        for (var j2 = 2, p = paths.slice(i3, i3 + j2).join(keySeparator), mix2 = current[p]; mix2 === void 0 && paths.length > i3 + j2; )
          j2++, p = paths.slice(i3, i3 + j2).join(keySeparator), mix2 = current[p];
        if (mix2 === void 0)
          return;
        if (mix2 === null)
          return null;
        if (path2.endsWith(p)) {
          if (typeof mix2 == "string")
            return mix2;
          if (p && typeof mix2[p] == "string")
            return mix2[p];
        }
        var joinedPath = paths.slice(i3 + j2).join(keySeparator);
        return joinedPath ? deepFind(mix2, joinedPath, keySeparator) : void 0;
      }
      current = current[paths[i3]];
    }
    return current;
  }
}
var ResourceStore = function(_EventEmitter) {
  _inherits(ResourceStore2, _EventEmitter);
  var _super = _createSuper(ResourceStore2);
  function ResourceStore2(data2) {
    var _this, options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    return _classCallCheck2(this, ResourceStore2), _this = _super.call(this), isIE10 && EventEmitter2.call(_assertThisInitialized(_this)), _this.data = data2 || {}, _this.options = options2, _this.options.keySeparator === void 0 && (_this.options.keySeparator = "."), _this.options.ignoreJSONStructure === void 0 && (_this.options.ignoreJSONStructure = !0), _this;
  }
  return _createClass2(ResourceStore2, [{
    key: "addNamespaces",
    value: function(ns) {
      this.options.ns.indexOf(ns) < 0 && this.options.ns.push(ns);
    }
  }, {
    key: "removeNamespaces",
    value: function(ns) {
      var index2 = this.options.ns.indexOf(ns);
      index2 > -1 && this.options.ns.splice(index2, 1);
    }
  }, {
    key: "getResource",
    value: function(lng2, ns, key2) {
      var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, keySeparator = options2.keySeparator !== void 0 ? options2.keySeparator : this.options.keySeparator, ignoreJSONStructure = options2.ignoreJSONStructure !== void 0 ? options2.ignoreJSONStructure : this.options.ignoreJSONStructure, path2 = [lng2, ns];
      key2 && typeof key2 != "string" && (path2 = path2.concat(key2)), key2 && typeof key2 == "string" && (path2 = path2.concat(keySeparator ? key2.split(keySeparator) : key2)), lng2.indexOf(".") > -1 && (path2 = lng2.split("."));
      var result2 = getPath2(this.data, path2);
      return result2 || !ignoreJSONStructure || typeof key2 != "string" ? result2 : deepFind(this.data && this.data[lng2] && this.data[lng2][ns], key2, keySeparator);
    }
  }, {
    key: "addResource",
    value: function(lng2, ns, key2, value2) {
      var options2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
        silent: !1
      }, keySeparator = this.options.keySeparator;
      keySeparator === void 0 && (keySeparator = ".");
      var path2 = [lng2, ns];
      key2 && (path2 = path2.concat(keySeparator ? key2.split(keySeparator) : key2)), lng2.indexOf(".") > -1 && (path2 = lng2.split("."), value2 = ns, ns = path2[1]), this.addNamespaces(ns), setPath2(this.data, path2, value2), options2.silent || this.emit("added", lng2, ns, key2, value2);
    }
  }, {
    key: "addResources",
    value: function(lng2, ns, resources) {
      var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
        silent: !1
      };
      for (var m2 in resources)
        (typeof resources[m2] == "string" || Object.prototype.toString.apply(resources[m2]) === "[object Array]") && this.addResource(lng2, ns, m2, resources[m2], {
          silent: !0
        });
      options2.silent || this.emit("added", lng2, ns, resources);
    }
  }, {
    key: "addResourceBundle",
    value: function(lng2, ns, resources, deep, overwrite) {
      var options2 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
        silent: !1
      }, path2 = [lng2, ns];
      lng2.indexOf(".") > -1 && (path2 = lng2.split("."), deep = resources, resources = ns, ns = path2[1]), this.addNamespaces(ns);
      var pack = getPath2(this.data, path2) || {};
      deep ? deepExtend(pack, resources, overwrite) : pack = _objectSpread$1(_objectSpread$1({}, pack), resources), setPath2(this.data, path2, pack), options2.silent || this.emit("added", lng2, ns, resources);
    }
  }, {
    key: "removeResourceBundle",
    value: function(lng2, ns) {
      this.hasResourceBundle(lng2, ns) && delete this.data[lng2][ns], this.removeNamespaces(ns), this.emit("removed", lng2, ns);
    }
  }, {
    key: "hasResourceBundle",
    value: function(lng2, ns) {
      return this.getResource(lng2, ns) !== void 0;
    }
  }, {
    key: "getResourceBundle",
    value: function(lng2, ns) {
      return ns || (ns = this.options.defaultNS), this.options.compatibilityAPI === "v1" ? _objectSpread$1(_objectSpread$1({}, {}), this.getResource(lng2, ns)) : this.getResource(lng2, ns);
    }
  }, {
    key: "getDataByLanguage",
    value: function(lng2) {
      return this.data[lng2];
    }
  }, {
    key: "hasLanguageSomeTranslations",
    value: function(lng2) {
      var data2 = this.getDataByLanguage(lng2), n3 = data2 && Object.keys(data2) || [];
      return !!n3.find(function(v2) {
        return data2[v2] && Object.keys(data2[v2]).length > 0;
      });
    }
  }, {
    key: "toJSON",
    value: function() {
      return this.data;
    }
  }]), ResourceStore2;
}(EventEmitter2), postProcessor = {
  processors: {},
  addPostProcessor: function(module2) {
    this.processors[module2.name] = module2;
  },
  handle: function(processors, value2, key2, options2, translator) {
    var _this = this;
    return processors.forEach(function(processor) {
      _this.processors[processor] && (value2 = _this.processors[processor].process(value2, key2, options2, translator));
    }), value2;
  }
};
function ownKeys$2(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$2(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source2 = arguments[i3] != null ? arguments[i3] : {};
    i3 % 2 ? ownKeys$2(Object(source2), !0).forEach(function(key2) {
      _defineProperty(target, key2, source2[key2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2)) : ownKeys$2(Object(source2)).forEach(function(key2) {
      Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source2, key2));
    });
  }
  return target;
}
function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
  return function() {
    var Super = _getPrototypeOf(Derived), result2;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result2 = Reflect.construct(Super, arguments, NewTarget);
    } else
      result2 = Super.apply(this, arguments);
    return _possibleConstructorReturn(this, result2);
  };
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
var checkedLoadedFor = {}, Translator = function(_EventEmitter) {
  _inherits(Translator2, _EventEmitter);
  var _super = _createSuper$1(Translator2);
  function Translator2(services) {
    var _this, options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return _classCallCheck2(this, Translator2), _this = _super.call(this), isIE10 && EventEmitter2.call(_assertThisInitialized(_this)), copy2(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, _assertThisInitialized(_this)), _this.options = options2, _this.options.keySeparator === void 0 && (_this.options.keySeparator = "."), _this.logger = baseLogger.create("translator"), _this;
  }
  return _createClass2(Translator2, [{
    key: "changeLanguage",
    value: function(lng2) {
      lng2 && (this.language = lng2);
    }
  }, {
    key: "exists",
    value: function(key2) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      };
      if (key2 == null)
        return !1;
      var resolved = this.resolve(key2, options2);
      return resolved && resolved.res !== void 0;
    }
  }, {
    key: "extractFromKey",
    value: function(key2, options2) {
      var nsSeparator = options2.nsSeparator !== void 0 ? options2.nsSeparator : this.options.nsSeparator;
      nsSeparator === void 0 && (nsSeparator = ":");
      var keySeparator = options2.keySeparator !== void 0 ? options2.keySeparator : this.options.keySeparator, namespaces = options2.ns || this.options.defaultNS || [], wouldCheckForNsInKey = nsSeparator && key2.indexOf(nsSeparator) > -1, seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options2.keySeparator && !this.options.userDefinedNsSeparator && !options2.nsSeparator && !looksLikeObjectPath(key2, nsSeparator, keySeparator);
      if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
        var m2 = key2.match(this.interpolator.nestingRegexp);
        if (m2 && m2.length > 0)
          return {
            key: key2,
            namespaces
          };
        var parts = key2.split(nsSeparator);
        (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) && (namespaces = parts.shift()), key2 = parts.join(keySeparator);
      }
      return typeof namespaces == "string" && (namespaces = [namespaces]), {
        key: key2,
        namespaces
      };
    }
  }, {
    key: "translate",
    value: function(keys2, options2, lastKey) {
      var _this2 = this;
      if (_typeof3(options2) !== "object" && this.options.overloadTranslationOptionHandler && (options2 = this.options.overloadTranslationOptionHandler(arguments)), options2 || (options2 = {}), keys2 == null)
        return "";
      Array.isArray(keys2) || (keys2 = [String(keys2)]);
      var returnDetails = options2.returnDetails !== void 0 ? options2.returnDetails : this.options.returnDetails, keySeparator = options2.keySeparator !== void 0 ? options2.keySeparator : this.options.keySeparator, _this$extractFromKey = this.extractFromKey(keys2[keys2.length - 1], options2), key2 = _this$extractFromKey.key, namespaces = _this$extractFromKey.namespaces, namespace = namespaces[namespaces.length - 1], lng2 = options2.lng || this.language, appendNamespaceToCIMode = options2.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
      if (lng2 && lng2.toLowerCase() === "cimode") {
        if (appendNamespaceToCIMode) {
          var nsSeparator = options2.nsSeparator || this.options.nsSeparator;
          return returnDetails ? (resolved.res = "".concat(namespace).concat(nsSeparator).concat(key2), resolved) : "".concat(namespace).concat(nsSeparator).concat(key2);
        }
        return returnDetails ? (resolved.res = key2, resolved) : key2;
      }
      var resolved = this.resolve(keys2, options2), res = resolved && resolved.res, resUsedKey = resolved && resolved.usedKey || key2, resExactUsedKey = resolved && resolved.exactUsedKey || key2, resType = Object.prototype.toString.apply(res), noObject = ["[object Number]", "[object Function]", "[object RegExp]"], joinArrays = options2.joinArrays !== void 0 ? options2.joinArrays : this.options.joinArrays, handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject, handleAsObject = typeof res != "string" && typeof res != "boolean" && typeof res != "number";
      if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays == "string" && resType === "[object Array]")) {
        if (!options2.returnObjects && !this.options.returnObjects) {
          this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!");
          var r3 = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, _objectSpread$2(_objectSpread$2({}, options2), {}, {
            ns: namespaces
          })) : "key '".concat(key2, " (").concat(this.language, ")' returned an object instead of string.");
          return returnDetails ? (resolved.res = r3, resolved) : r3;
        }
        if (keySeparator) {
          var resTypeIsArray = resType === "[object Array]", copy3 = resTypeIsArray ? [] : {}, newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
          for (var m2 in res)
            if (Object.prototype.hasOwnProperty.call(res, m2)) {
              var deepKey = "".concat(newKeyToUse).concat(keySeparator).concat(m2);
              copy3[m2] = this.translate(deepKey, _objectSpread$2(_objectSpread$2({}, options2), {
                joinArrays: !1,
                ns: namespaces
              })), copy3[m2] === deepKey && (copy3[m2] = res[m2]);
            }
          res = copy3;
        }
      } else if (handleAsObjectInI18nFormat && typeof joinArrays == "string" && resType === "[object Array]")
        res = res.join(joinArrays), res && (res = this.extendTranslation(res, keys2, options2, lastKey));
      else {
        var usedDefault = !1, usedKey = !1, needsPluralHandling = options2.count !== void 0 && typeof options2.count != "string", hasDefaultValue = Translator2.hasDefaultValue(options2), defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng2, options2.count, options2) : "", defaultValue = options2["defaultValue".concat(defaultValueSuffix)] || options2.defaultValue;
        !this.isValidLookup(res) && hasDefaultValue && (usedDefault = !0, res = defaultValue), this.isValidLookup(res) || (usedKey = !0, res = key2);
        var missingKeyNoValueFallbackToKey = options2.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey, resForMissing = missingKeyNoValueFallbackToKey && usedKey ? void 0 : res, updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
        if (usedKey || usedDefault || updateMissing) {
          if (this.logger.log(updateMissing ? "updateKey" : "missingKey", lng2, namespace, key2, updateMissing ? defaultValue : res), keySeparator) {
            var fk = this.resolve(key2, _objectSpread$2(_objectSpread$2({}, options2), {}, {
              keySeparator: !1
            }));
            fk && fk.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
          }
          var lngs = [], fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options2.lng || this.language);
          if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0])
            for (var i3 = 0; i3 < fallbackLngs.length; i3++)
              lngs.push(fallbackLngs[i3]);
          else
            this.options.saveMissingTo === "all" ? lngs = this.languageUtils.toResolveHierarchy(options2.lng || this.language) : lngs.push(options2.lng || this.language);
          var send = function(l2, k2, specificDefaultValue) {
            var defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
            _this2.options.missingKeyHandler ? _this2.options.missingKeyHandler(l2, namespace, k2, defaultForMissing, updateMissing, options2) : _this2.backendConnector && _this2.backendConnector.saveMissing && _this2.backendConnector.saveMissing(l2, namespace, k2, defaultForMissing, updateMissing, options2), _this2.emit("missingKey", l2, namespace, k2, res);
          };
          this.options.saveMissing && (this.options.saveMissingPlurals && needsPluralHandling ? lngs.forEach(function(language) {
            _this2.pluralResolver.getSuffixes(language, options2).forEach(function(suffix) {
              send([language], key2 + suffix, options2["defaultValue".concat(suffix)] || defaultValue);
            });
          }) : send(lngs, key2, defaultValue));
        }
        res = this.extendTranslation(res, keys2, options2, resolved, lastKey), usedKey && res === key2 && this.options.appendNamespaceToMissingKey && (res = "".concat(namespace, ":").concat(key2)), (usedKey || usedDefault) && this.options.parseMissingKeyHandler && (this.options.compatibilityAPI !== "v1" ? res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? "".concat(namespace, ":").concat(key2) : key2, usedDefault ? res : void 0) : res = this.options.parseMissingKeyHandler(res));
      }
      return returnDetails ? (resolved.res = res, resolved) : res;
    }
  }, {
    key: "extendTranslation",
    value: function(res, key2, options2, resolved, lastKey) {
      var _this3 = this;
      if (this.i18nFormat && this.i18nFormat.parse)
        res = this.i18nFormat.parse(res, _objectSpread$2(_objectSpread$2({}, this.options.interpolation.defaultVariables), options2), resolved.usedLng, resolved.usedNS, resolved.usedKey, {
          resolved
        });
      else if (!options2.skipInterpolation) {
        options2.interpolation && this.interpolator.init(_objectSpread$2(_objectSpread$2({}, options2), {
          interpolation: _objectSpread$2(_objectSpread$2({}, this.options.interpolation), options2.interpolation)
        }));
        var skipOnVariables = typeof res == "string" && (options2 && options2.interpolation && options2.interpolation.skipOnVariables !== void 0 ? options2.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables), nestBef;
        if (skipOnVariables) {
          var nb = res.match(this.interpolator.nestingRegexp);
          nestBef = nb && nb.length;
        }
        var data2 = options2.replace && typeof options2.replace != "string" ? options2.replace : options2;
        if (this.options.interpolation.defaultVariables && (data2 = _objectSpread$2(_objectSpread$2({}, this.options.interpolation.defaultVariables), data2)), res = this.interpolator.interpolate(res, data2, options2.lng || this.language, options2), skipOnVariables) {
          var na = res.match(this.interpolator.nestingRegexp), nestAft = na && na.length;
          nestBef < nestAft && (options2.nest = !1);
        }
        options2.nest !== !1 && (res = this.interpolator.nest(res, function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
            args[_key] = arguments[_key];
          return lastKey && lastKey[0] === args[0] && !options2.context ? (_this3.logger.warn("It seems you are nesting recursively key: ".concat(args[0], " in key: ").concat(key2[0])), null) : _this3.translate.apply(_this3, args.concat([key2]));
        }, options2)), options2.interpolation && this.interpolator.reset();
      }
      var postProcess = options2.postProcess || this.options.postProcess, postProcessorNames = typeof postProcess == "string" ? [postProcess] : postProcess;
      return res != null && postProcessorNames && postProcessorNames.length && options2.applyPostProcessor !== !1 && (res = postProcessor.handle(postProcessorNames, res, key2, this.options && this.options.postProcessPassResolved ? _objectSpread$2({
        i18nResolved: resolved
      }, options2) : options2, this)), res;
    }
  }, {
    key: "resolve",
    value: function(keys2) {
      var _this4 = this, options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, found, usedKey, exactUsedKey, usedLng, usedNS;
      return typeof keys2 == "string" && (keys2 = [keys2]), keys2.forEach(function(k2) {
        if (!_this4.isValidLookup(found)) {
          var extracted = _this4.extractFromKey(k2, options2), key2 = extracted.key;
          usedKey = key2;
          var namespaces = extracted.namespaces;
          _this4.options.fallbackNS && (namespaces = namespaces.concat(_this4.options.fallbackNS));
          var needsPluralHandling = options2.count !== void 0 && typeof options2.count != "string", needsZeroSuffixLookup = needsPluralHandling && !options2.ordinal && options2.count === 0 && _this4.pluralResolver.shouldUseIntlApi(), needsContextHandling = options2.context !== void 0 && (typeof options2.context == "string" || typeof options2.context == "number") && options2.context !== "", codes = options2.lngs ? options2.lngs : _this4.languageUtils.toResolveHierarchy(options2.lng || _this4.language, options2.fallbackLng);
          namespaces.forEach(function(ns) {
            _this4.isValidLookup(found) || (usedNS = ns, !checkedLoadedFor["".concat(codes[0], "-").concat(ns)] && _this4.utils && _this4.utils.hasLoadedNamespace && !_this4.utils.hasLoadedNamespace(usedNS) && (checkedLoadedFor["".concat(codes[0], "-").concat(ns)] = !0, _this4.logger.warn('key "'.concat(usedKey, '" for languages "').concat(codes.join(", "), `" won't get resolved as namespace "`).concat(usedNS, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")), codes.forEach(function(code) {
              if (!_this4.isValidLookup(found)) {
                usedLng = code;
                var finalKeys = [key2];
                if (_this4.i18nFormat && _this4.i18nFormat.addLookupKeys)
                  _this4.i18nFormat.addLookupKeys(finalKeys, key2, code, ns, options2);
                else {
                  var pluralSuffix;
                  needsPluralHandling && (pluralSuffix = _this4.pluralResolver.getSuffix(code, options2.count, options2));
                  var zeroSuffix = "".concat(_this4.options.pluralSeparator, "zero");
                  if (needsPluralHandling && (finalKeys.push(key2 + pluralSuffix), needsZeroSuffixLookup && finalKeys.push(key2 + zeroSuffix)), needsContextHandling) {
                    var contextKey = "".concat(key2).concat(_this4.options.contextSeparator).concat(options2.context);
                    finalKeys.push(contextKey), needsPluralHandling && (finalKeys.push(contextKey + pluralSuffix), needsZeroSuffixLookup && finalKeys.push(contextKey + zeroSuffix));
                  }
                }
                for (var possibleKey; possibleKey = finalKeys.pop(); )
                  _this4.isValidLookup(found) || (exactUsedKey = possibleKey, found = _this4.getResource(code, ns, possibleKey, options2));
              }
            }));
          });
        }
      }), {
        res: found,
        usedKey,
        exactUsedKey,
        usedLng,
        usedNS
      };
    }
  }, {
    key: "isValidLookup",
    value: function(res) {
      return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
    }
  }, {
    key: "getResource",
    value: function(code, ns, key2) {
      var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      return this.i18nFormat && this.i18nFormat.getResource ? this.i18nFormat.getResource(code, ns, key2, options2) : this.resourceStore.getResource(code, ns, key2, options2);
    }
  }], [{
    key: "hasDefaultValue",
    value: function(options2) {
      var prefix = "defaultValue";
      for (var option in options2)
        if (Object.prototype.hasOwnProperty.call(options2, option) && prefix === option.substring(0, prefix.length) && options2[option] !== void 0)
          return !0;
      return !1;
    }
  }]), Translator2;
}(EventEmitter2);
function capitalize(string2) {
  return string2.charAt(0).toUpperCase() + string2.slice(1);
}
var LanguageUtil = function() {
  function LanguageUtil2(options2) {
    _classCallCheck2(this, LanguageUtil2), this.options = options2, this.supportedLngs = this.options.supportedLngs || !1, this.logger = baseLogger.create("languageUtils");
  }
  return _createClass2(LanguageUtil2, [{
    key: "getScriptPartFromCode",
    value: function(code) {
      if (!code || code.indexOf("-") < 0)
        return null;
      var p = code.split("-");
      return p.length === 2 || (p.pop(), p[p.length - 1].toLowerCase() === "x") ? null : this.formatLanguageCode(p.join("-"));
    }
  }, {
    key: "getLanguagePartFromCode",
    value: function(code) {
      if (!code || code.indexOf("-") < 0)
        return code;
      var p = code.split("-");
      return this.formatLanguageCode(p[0]);
    }
  }, {
    key: "formatLanguageCode",
    value: function(code) {
      if (typeof code == "string" && code.indexOf("-") > -1) {
        var specialCases = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"], p = code.split("-");
        return this.options.lowerCaseLng ? p = p.map(function(part) {
          return part.toLowerCase();
        }) : p.length === 2 ? (p[0] = p[0].toLowerCase(), p[1] = p[1].toUpperCase(), specialCases.indexOf(p[1].toLowerCase()) > -1 && (p[1] = capitalize(p[1].toLowerCase()))) : p.length === 3 && (p[0] = p[0].toLowerCase(), p[1].length === 2 && (p[1] = p[1].toUpperCase()), p[0] !== "sgn" && p[2].length === 2 && (p[2] = p[2].toUpperCase()), specialCases.indexOf(p[1].toLowerCase()) > -1 && (p[1] = capitalize(p[1].toLowerCase())), specialCases.indexOf(p[2].toLowerCase()) > -1 && (p[2] = capitalize(p[2].toLowerCase()))), p.join("-");
      }
      return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
    }
  }, {
    key: "isSupportedCode",
    value: function(code) {
      return (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) && (code = this.getLanguagePartFromCode(code)), !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
    }
  }, {
    key: "getBestMatchFromCodes",
    value: function(codes) {
      var _this = this;
      if (!codes)
        return null;
      var found;
      return codes.forEach(function(code) {
        if (!found) {
          var cleanedLng = _this.formatLanguageCode(code);
          (!_this.options.supportedLngs || _this.isSupportedCode(cleanedLng)) && (found = cleanedLng);
        }
      }), !found && this.options.supportedLngs && codes.forEach(function(code) {
        if (!found) {
          var lngOnly = _this.getLanguagePartFromCode(code);
          if (_this.isSupportedCode(lngOnly))
            return found = lngOnly;
          found = _this.options.supportedLngs.find(function(supportedLng) {
            if (supportedLng.indexOf(lngOnly) === 0)
              return supportedLng;
          });
        }
      }), found || (found = this.getFallbackCodes(this.options.fallbackLng)[0]), found;
    }
  }, {
    key: "getFallbackCodes",
    value: function(fallbacks, code) {
      if (!fallbacks)
        return [];
      if (typeof fallbacks == "function" && (fallbacks = fallbacks(code)), typeof fallbacks == "string" && (fallbacks = [fallbacks]), Object.prototype.toString.apply(fallbacks) === "[object Array]")
        return fallbacks;
      if (!code)
        return fallbacks.default || [];
      var found = fallbacks[code];
      return found || (found = fallbacks[this.getScriptPartFromCode(code)]), found || (found = fallbacks[this.formatLanguageCode(code)]), found || (found = fallbacks[this.getLanguagePartFromCode(code)]), found || (found = fallbacks.default), found || [];
    }
  }, {
    key: "toResolveHierarchy",
    value: function(code, fallbackCode) {
      var _this2 = this, fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code), codes = [], addCode = function(c4) {
        !c4 || (_this2.isSupportedCode(c4) ? codes.push(c4) : _this2.logger.warn("rejecting language code not found in supportedLngs: ".concat(c4)));
      };
      return typeof code == "string" && code.indexOf("-") > -1 ? (this.options.load !== "languageOnly" && addCode(this.formatLanguageCode(code)), this.options.load !== "languageOnly" && this.options.load !== "currentOnly" && addCode(this.getScriptPartFromCode(code)), this.options.load !== "currentOnly" && addCode(this.getLanguagePartFromCode(code))) : typeof code == "string" && addCode(this.formatLanguageCode(code)), fallbackCodes.forEach(function(fc) {
        codes.indexOf(fc) < 0 && addCode(_this2.formatLanguageCode(fc));
      }), codes;
    }
  }]), LanguageUtil2;
}(), sets = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}], _rulesPluralsTypes = {
  1: function(n3) {
    return Number(n3 > 1);
  },
  2: function(n3) {
    return Number(n3 != 1);
  },
  3: function(n3) {
    return 0;
  },
  4: function(n3) {
    return Number(n3 % 10 == 1 && n3 % 100 != 11 ? 0 : n3 % 10 >= 2 && n3 % 10 <= 4 && (n3 % 100 < 10 || n3 % 100 >= 20) ? 1 : 2);
  },
  5: function(n3) {
    return Number(n3 == 0 ? 0 : n3 == 1 ? 1 : n3 == 2 ? 2 : n3 % 100 >= 3 && n3 % 100 <= 10 ? 3 : n3 % 100 >= 11 ? 4 : 5);
  },
  6: function(n3) {
    return Number(n3 == 1 ? 0 : n3 >= 2 && n3 <= 4 ? 1 : 2);
  },
  7: function(n3) {
    return Number(n3 == 1 ? 0 : n3 % 10 >= 2 && n3 % 10 <= 4 && (n3 % 100 < 10 || n3 % 100 >= 20) ? 1 : 2);
  },
  8: function(n3) {
    return Number(n3 == 1 ? 0 : n3 == 2 ? 1 : n3 != 8 && n3 != 11 ? 2 : 3);
  },
  9: function(n3) {
    return Number(n3 >= 2);
  },
  10: function(n3) {
    return Number(n3 == 1 ? 0 : n3 == 2 ? 1 : n3 < 7 ? 2 : n3 < 11 ? 3 : 4);
  },
  11: function(n3) {
    return Number(n3 == 1 || n3 == 11 ? 0 : n3 == 2 || n3 == 12 ? 1 : n3 > 2 && n3 < 20 ? 2 : 3);
  },
  12: function(n3) {
    return Number(n3 % 10 != 1 || n3 % 100 == 11);
  },
  13: function(n3) {
    return Number(n3 !== 0);
  },
  14: function(n3) {
    return Number(n3 == 1 ? 0 : n3 == 2 ? 1 : n3 == 3 ? 2 : 3);
  },
  15: function(n3) {
    return Number(n3 % 10 == 1 && n3 % 100 != 11 ? 0 : n3 % 10 >= 2 && (n3 % 100 < 10 || n3 % 100 >= 20) ? 1 : 2);
  },
  16: function(n3) {
    return Number(n3 % 10 == 1 && n3 % 100 != 11 ? 0 : n3 !== 0 ? 1 : 2);
  },
  17: function(n3) {
    return Number(n3 == 1 || n3 % 10 == 1 && n3 % 100 != 11 ? 0 : 1);
  },
  18: function(n3) {
    return Number(n3 == 0 ? 0 : n3 == 1 ? 1 : 2);
  },
  19: function(n3) {
    return Number(n3 == 1 ? 0 : n3 == 0 || n3 % 100 > 1 && n3 % 100 < 11 ? 1 : n3 % 100 > 10 && n3 % 100 < 20 ? 2 : 3);
  },
  20: function(n3) {
    return Number(n3 == 1 ? 0 : n3 == 0 || n3 % 100 > 0 && n3 % 100 < 20 ? 1 : 2);
  },
  21: function(n3) {
    return Number(n3 % 100 == 1 ? 1 : n3 % 100 == 2 ? 2 : n3 % 100 == 3 || n3 % 100 == 4 ? 3 : 0);
  },
  22: function(n3) {
    return Number(n3 == 1 ? 0 : n3 == 2 ? 1 : (n3 < 0 || n3 > 10) && n3 % 10 == 0 ? 2 : 3);
  }
}, deprecatedJsonVersions = ["v1", "v2", "v3"], suffixesOrder = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
function createRules() {
  var rules = {};
  return sets.forEach(function(set2) {
    set2.lngs.forEach(function(l2) {
      rules[l2] = {
        numbers: set2.nr,
        plurals: _rulesPluralsTypes[set2.fc]
      };
    });
  }), rules;
}
var PluralResolver = function() {
  function PluralResolver2(languageUtils) {
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck2(this, PluralResolver2), this.languageUtils = languageUtils, this.options = options2, this.logger = baseLogger.create("pluralResolver"), (!this.options.compatibilityJSON || this.options.compatibilityJSON === "v4") && (typeof Intl > "u" || !Intl.PluralRules) && (this.options.compatibilityJSON = "v3", this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.")), this.rules = createRules();
  }
  return _createClass2(PluralResolver2, [{
    key: "addRule",
    value: function(lng2, obj) {
      this.rules[lng2] = obj;
    }
  }, {
    key: "getRule",
    value: function(code) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (this.shouldUseIntlApi())
        try {
          return new Intl.PluralRules(code, {
            type: options2.ordinal ? "ordinal" : "cardinal"
          });
        } catch {
          return;
        }
      return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
    }
  }, {
    key: "needsPlural",
    value: function(code) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, rule = this.getRule(code, options2);
      return this.shouldUseIntlApi() ? rule && rule.resolvedOptions().pluralCategories.length > 1 : rule && rule.numbers.length > 1;
    }
  }, {
    key: "getPluralFormsOfKey",
    value: function(code, key2) {
      var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return this.getSuffixes(code, options2).map(function(suffix) {
        return "".concat(key2).concat(suffix);
      });
    }
  }, {
    key: "getSuffixes",
    value: function(code) {
      var _this = this, options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, rule = this.getRule(code, options2);
      return rule ? this.shouldUseIntlApi() ? rule.resolvedOptions().pluralCategories.sort(function(pluralCategory1, pluralCategory2) {
        return suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2];
      }).map(function(pluralCategory) {
        return "".concat(_this.options.prepend).concat(pluralCategory);
      }) : rule.numbers.map(function(number4) {
        return _this.getSuffix(code, number4, options2);
      }) : [];
    }
  }, {
    key: "getSuffix",
    value: function(code, count) {
      var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, rule = this.getRule(code, options2);
      return rule ? this.shouldUseIntlApi() ? "".concat(this.options.prepend).concat(rule.select(count)) : this.getSuffixRetroCompatible(rule, count) : (this.logger.warn("no plural rule found for: ".concat(code)), "");
    }
  }, {
    key: "getSuffixRetroCompatible",
    value: function(rule, count) {
      var _this2 = this, idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count)), suffix = rule.numbers[idx];
      this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1 && (suffix === 2 ? suffix = "plural" : suffix === 1 && (suffix = ""));
      var returnSuffix = function() {
        return _this2.options.prepend && suffix.toString() ? _this2.options.prepend + suffix.toString() : suffix.toString();
      };
      return this.options.compatibilityJSON === "v1" ? suffix === 1 ? "" : typeof suffix == "number" ? "_plural_".concat(suffix.toString()) : returnSuffix() : this.options.compatibilityJSON === "v2" || this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1 ? returnSuffix() : this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
    }
  }, {
    key: "shouldUseIntlApi",
    value: function() {
      return !deprecatedJsonVersions.includes(this.options.compatibilityJSON);
    }
  }]), PluralResolver2;
}();
function ownKeys$3(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$3(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source2 = arguments[i3] != null ? arguments[i3] : {};
    i3 % 2 ? ownKeys$3(Object(source2), !0).forEach(function(key2) {
      _defineProperty(target, key2, source2[key2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2)) : ownKeys$3(Object(source2)).forEach(function(key2) {
      Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source2, key2));
    });
  }
  return target;
}
var Interpolator = function() {
  function Interpolator2() {
    var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck2(this, Interpolator2), this.logger = baseLogger.create("interpolator"), this.options = options2, this.format = options2.interpolation && options2.interpolation.format || function(value2) {
      return value2;
    }, this.init(options2);
  }
  return _createClass2(Interpolator2, [{
    key: "init",
    value: function() {
      var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      options2.interpolation || (options2.interpolation = {
        escapeValue: !0
      });
      var iOpts = options2.interpolation;
      this.escape = iOpts.escape !== void 0 ? iOpts.escape : escape3, this.escapeValue = iOpts.escapeValue !== void 0 ? iOpts.escapeValue : !0, this.useRawValueToEscape = iOpts.useRawValueToEscape !== void 0 ? iOpts.useRawValueToEscape : !1, this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || "{{", this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || "}}", this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",", this.unescapePrefix = iOpts.unescapeSuffix ? "" : iOpts.unescapePrefix || "-", this.unescapeSuffix = this.unescapePrefix ? "" : iOpts.unescapeSuffix || "", this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape("$t("), this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(")"), this.nestingOptionsSeparator = iOpts.nestingOptionsSeparator ? iOpts.nestingOptionsSeparator : iOpts.nestingOptionsSeparator || ",", this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1e3, this.alwaysFormat = iOpts.alwaysFormat !== void 0 ? iOpts.alwaysFormat : !1, this.resetRegExp();
    }
  }, {
    key: "reset",
    value: function() {
      this.options && this.init(this.options);
    }
  }, {
    key: "resetRegExp",
    value: function() {
      var regexpStr = "".concat(this.prefix, "(.+?)").concat(this.suffix);
      this.regexp = new RegExp(regexpStr, "g");
      var regexpUnescapeStr = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
      this.regexpUnescape = new RegExp(regexpUnescapeStr, "g");
      var nestingRegexpStr = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
      this.nestingRegexp = new RegExp(nestingRegexpStr, "g");
    }
  }, {
    key: "interpolate",
    value: function(str2, data2, lng2, options2) {
      var _this = this, match, value2, replaces, defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
      function regexSafe(val) {
        return val.replace(/\$/g, "$$$$");
      }
      var handleFormat = function(key2) {
        if (key2.indexOf(_this.formatSeparator) < 0) {
          var path2 = getPathWithDefaults(data2, defaultData, key2);
          return _this.alwaysFormat ? _this.format(path2, void 0, lng2, _objectSpread$3(_objectSpread$3(_objectSpread$3({}, options2), data2), {}, {
            interpolationkey: key2
          })) : path2;
        }
        var p = key2.split(_this.formatSeparator), k2 = p.shift().trim(), f2 = p.join(_this.formatSeparator).trim();
        return _this.format(getPathWithDefaults(data2, defaultData, k2), f2, lng2, _objectSpread$3(_objectSpread$3(_objectSpread$3({}, options2), data2), {}, {
          interpolationkey: k2
        }));
      };
      this.resetRegExp();
      var missingInterpolationHandler = options2 && options2.missingInterpolationHandler || this.options.missingInterpolationHandler, skipOnVariables = options2 && options2.interpolation && options2.interpolation.skipOnVariables !== void 0 ? options2.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables, todos = [{
        regex: this.regexpUnescape,
        safeValue: function(val) {
          return regexSafe(val);
        }
      }, {
        regex: this.regexp,
        safeValue: function(val) {
          return _this.escapeValue ? regexSafe(_this.escape(val)) : regexSafe(val);
        }
      }];
      return todos.forEach(function(todo) {
        for (replaces = 0; match = todo.regex.exec(str2); ) {
          var matchedVar = match[1].trim();
          if (value2 = handleFormat(matchedVar), value2 === void 0)
            if (typeof missingInterpolationHandler == "function") {
              var temp = missingInterpolationHandler(str2, match, options2);
              value2 = typeof temp == "string" ? temp : "";
            } else if (options2 && options2.hasOwnProperty(matchedVar))
              value2 = "";
            else if (skipOnVariables) {
              value2 = match[0];
              continue;
            } else
              _this.logger.warn("missed to pass in variable ".concat(matchedVar, " for interpolating ").concat(str2)), value2 = "";
          else
            typeof value2 != "string" && !_this.useRawValueToEscape && (value2 = makeString(value2));
          var safeValue = todo.safeValue(value2);
          if (str2 = str2.replace(match[0], safeValue), skipOnVariables ? (todo.regex.lastIndex += value2.length, todo.regex.lastIndex -= match[0].length) : todo.regex.lastIndex = 0, replaces++, replaces >= _this.maxReplaces)
            break;
        }
      }), str2;
    }
  }, {
    key: "nest",
    value: function(str2, fc) {
      var _this2 = this, options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, match, value2, clonedOptions = _objectSpread$3({}, options2);
      clonedOptions.applyPostProcessor = !1, delete clonedOptions.defaultValue;
      function handleHasOptions(key2, inheritedOptions) {
        var sep2 = this.nestingOptionsSeparator;
        if (key2.indexOf(sep2) < 0)
          return key2;
        var c4 = key2.split(new RegExp("".concat(sep2, "[ ]*{"))), optionsString = "{".concat(c4[1]);
        key2 = c4[0], optionsString = this.interpolate(optionsString, clonedOptions);
        var matchedSingleQuotes = optionsString.match(/'/g), matchedDoubleQuotes = optionsString.match(/"/g);
        (matchedSingleQuotes && matchedSingleQuotes.length % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) && (optionsString = optionsString.replace(/'/g, '"'));
        try {
          clonedOptions = JSON.parse(optionsString), inheritedOptions && (clonedOptions = _objectSpread$3(_objectSpread$3({}, inheritedOptions), clonedOptions));
        } catch (e3) {
          return this.logger.warn("failed parsing options string in nesting for key ".concat(key2), e3), "".concat(key2).concat(sep2).concat(optionsString);
        }
        return delete clonedOptions.defaultValue, key2;
      }
      for (; match = this.nestingRegexp.exec(str2); ) {
        var formatters = [], doReduce = !1;
        if (match[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match[1])) {
          var r3 = match[1].split(this.formatSeparator).map(function(elem) {
            return elem.trim();
          });
          match[1] = r3.shift(), formatters = r3, doReduce = !0;
        }
        if (value2 = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions), value2 && match[0] === str2 && typeof value2 != "string")
          return value2;
        typeof value2 != "string" && (value2 = makeString(value2)), value2 || (this.logger.warn("missed to resolve ".concat(match[1], " for nesting ").concat(str2)), value2 = ""), doReduce && (value2 = formatters.reduce(function(v2, f2) {
          return _this2.format(v2, f2, options2.lng, _objectSpread$3(_objectSpread$3({}, options2), {}, {
            interpolationkey: match[1].trim()
          }));
        }, value2.trim())), str2 = str2.replace(match[0], value2), this.regexp.lastIndex = 0;
      }
      return str2;
    }
  }]), Interpolator2;
}();
function ownKeys$4(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$4(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source2 = arguments[i3] != null ? arguments[i3] : {};
    i3 % 2 ? ownKeys$4(Object(source2), !0).forEach(function(key2) {
      _defineProperty(target, key2, source2[key2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2)) : ownKeys$4(Object(source2)).forEach(function(key2) {
      Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source2, key2));
    });
  }
  return target;
}
function parseFormatStr(formatStr) {
  var formatName = formatStr.toLowerCase().trim(), formatOptions = {};
  if (formatStr.indexOf("(") > -1) {
    var p = formatStr.split("(");
    formatName = p[0].toLowerCase().trim();
    var optStr = p[1].substring(0, p[1].length - 1);
    if (formatName === "currency" && optStr.indexOf(":") < 0)
      formatOptions.currency || (formatOptions.currency = optStr.trim());
    else if (formatName === "relativetime" && optStr.indexOf(":") < 0)
      formatOptions.range || (formatOptions.range = optStr.trim());
    else {
      var opts = optStr.split(";");
      opts.forEach(function(opt) {
        if (!!opt) {
          var _opt$split = opt.split(":"), _opt$split2 = _toArray(_opt$split), key2 = _opt$split2[0], rest = _opt$split2.slice(1), val = rest.join(":").trim().replace(/^'+|'+$/g, "");
          formatOptions[key2.trim()] || (formatOptions[key2.trim()] = val), val === "false" && (formatOptions[key2.trim()] = !1), val === "true" && (formatOptions[key2.trim()] = !0), isNaN(val) || (formatOptions[key2.trim()] = parseInt(val, 10));
        }
      });
    }
  }
  return {
    formatName,
    formatOptions
  };
}
function createCachedFormatter(fn) {
  var cache = {};
  return function(val, lng2, options2) {
    var key2 = lng2 + JSON.stringify(options2), formatter = cache[key2];
    return formatter || (formatter = fn(lng2, options2), cache[key2] = formatter), formatter(val);
  };
}
var Formatter = function() {
  function Formatter2() {
    var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck2(this, Formatter2), this.logger = baseLogger.create("formatter"), this.options = options2, this.formats = {
      number: createCachedFormatter(function(lng2, options3) {
        var formatter = new Intl.NumberFormat(lng2, options3);
        return function(val) {
          return formatter.format(val);
        };
      }),
      currency: createCachedFormatter(function(lng2, options3) {
        var formatter = new Intl.NumberFormat(lng2, _objectSpread$4(_objectSpread$4({}, options3), {}, {
          style: "currency"
        }));
        return function(val) {
          return formatter.format(val);
        };
      }),
      datetime: createCachedFormatter(function(lng2, options3) {
        var formatter = new Intl.DateTimeFormat(lng2, _objectSpread$4({}, options3));
        return function(val) {
          return formatter.format(val);
        };
      }),
      relativetime: createCachedFormatter(function(lng2, options3) {
        var formatter = new Intl.RelativeTimeFormat(lng2, _objectSpread$4({}, options3));
        return function(val) {
          return formatter.format(val, options3.range || "day");
        };
      }),
      list: createCachedFormatter(function(lng2, options3) {
        var formatter = new Intl.ListFormat(lng2, _objectSpread$4({}, options3));
        return function(val) {
          return formatter.format(val);
        };
      })
    }, this.init(options2);
  }
  return _createClass2(Formatter2, [{
    key: "init",
    value: function(services) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      }, iOpts = options2.interpolation;
      this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
    }
  }, {
    key: "add",
    value: function(name, fc) {
      this.formats[name.toLowerCase().trim()] = fc;
    }
  }, {
    key: "addCached",
    value: function(name, fc) {
      this.formats[name.toLowerCase().trim()] = createCachedFormatter(fc);
    }
  }, {
    key: "format",
    value: function(value2, _format, lng2, options2) {
      var _this = this, formats = _format.split(this.formatSeparator), result2 = formats.reduce(function(mem, f2) {
        var _parseFormatStr = parseFormatStr(f2), formatName = _parseFormatStr.formatName, formatOptions = _parseFormatStr.formatOptions;
        if (_this.formats[formatName]) {
          var formatted = mem;
          try {
            var valOptions = options2 && options2.formatParams && options2.formatParams[options2.interpolationkey] || {}, l2 = valOptions.locale || valOptions.lng || options2.locale || options2.lng || lng2;
            formatted = _this.formats[formatName](mem, l2, _objectSpread$4(_objectSpread$4(_objectSpread$4({}, formatOptions), options2), valOptions));
          } catch (error2) {
            _this.logger.warn(error2);
          }
          return formatted;
        } else
          _this.logger.warn("there was no format function for ".concat(formatName));
        return mem;
      }, value2);
      return result2;
    }
  }]), Formatter2;
}();
function ownKeys$5(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$5(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source2 = arguments[i3] != null ? arguments[i3] : {};
    i3 % 2 ? ownKeys$5(Object(source2), !0).forEach(function(key2) {
      _defineProperty(target, key2, source2[key2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2)) : ownKeys$5(Object(source2)).forEach(function(key2) {
      Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source2, key2));
    });
  }
  return target;
}
function _createSuper$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
  return function() {
    var Super = _getPrototypeOf(Derived), result2;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result2 = Reflect.construct(Super, arguments, NewTarget);
    } else
      result2 = Super.apply(this, arguments);
    return _possibleConstructorReturn(this, result2);
  };
}
function _isNativeReflectConstruct$2() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function removePending(q2, name) {
  q2.pending[name] !== void 0 && (delete q2.pending[name], q2.pendingCount--);
}
var Connector = function(_EventEmitter) {
  _inherits(Connector2, _EventEmitter);
  var _super = _createSuper$2(Connector2);
  function Connector2(backend, store, services) {
    var _this, options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    return _classCallCheck2(this, Connector2), _this = _super.call(this), isIE10 && EventEmitter2.call(_assertThisInitialized(_this)), _this.backend = backend, _this.store = store, _this.services = services, _this.languageUtils = services.languageUtils, _this.options = options2, _this.logger = baseLogger.create("backendConnector"), _this.waitingReads = [], _this.maxParallelReads = options2.maxParallelReads || 10, _this.readingCalls = 0, _this.maxRetries = options2.maxRetries >= 0 ? options2.maxRetries : 5, _this.retryTimeout = options2.retryTimeout >= 1 ? options2.retryTimeout : 350, _this.state = {}, _this.queue = [], _this.backend && _this.backend.init && _this.backend.init(services, options2.backend, options2), _this;
  }
  return _createClass2(Connector2, [{
    key: "queueLoad",
    value: function(languages, namespaces, options2, callback) {
      var _this2 = this, toLoad = {}, pending = {}, toLoadLanguages = {}, toLoadNamespaces = {};
      return languages.forEach(function(lng2) {
        var hasAllNamespaces = !0;
        namespaces.forEach(function(ns) {
          var name = "".concat(lng2, "|").concat(ns);
          !options2.reload && _this2.store.hasResourceBundle(lng2, ns) ? _this2.state[name] = 2 : _this2.state[name] < 0 || (_this2.state[name] === 1 ? pending[name] === void 0 && (pending[name] = !0) : (_this2.state[name] = 1, hasAllNamespaces = !1, pending[name] === void 0 && (pending[name] = !0), toLoad[name] === void 0 && (toLoad[name] = !0), toLoadNamespaces[ns] === void 0 && (toLoadNamespaces[ns] = !0)));
        }), hasAllNamespaces || (toLoadLanguages[lng2] = !0);
      }), (Object.keys(toLoad).length || Object.keys(pending).length) && this.queue.push({
        pending,
        pendingCount: Object.keys(pending).length,
        loaded: {},
        errors: [],
        callback
      }), {
        toLoad: Object.keys(toLoad),
        pending: Object.keys(pending),
        toLoadLanguages: Object.keys(toLoadLanguages),
        toLoadNamespaces: Object.keys(toLoadNamespaces)
      };
    }
  }, {
    key: "loaded",
    value: function(name, err, data2) {
      var s3 = name.split("|"), lng2 = s3[0], ns = s3[1];
      err && this.emit("failedLoading", lng2, ns, err), data2 && this.store.addResourceBundle(lng2, ns, data2), this.state[name] = err ? -1 : 2;
      var loaded2 = {};
      this.queue.forEach(function(q2) {
        pushPath2(q2.loaded, [lng2], ns), removePending(q2, name), err && q2.errors.push(err), q2.pendingCount === 0 && !q2.done && (Object.keys(q2.loaded).forEach(function(l2) {
          loaded2[l2] || (loaded2[l2] = {});
          var loadedKeys = q2.loaded[l2];
          loadedKeys.length && loadedKeys.forEach(function(ns2) {
            loaded2[l2][ns2] === void 0 && (loaded2[l2][ns2] = !0);
          });
        }), q2.done = !0, q2.errors.length ? q2.callback(q2.errors) : q2.callback());
      }), this.emit("loaded", loaded2), this.queue = this.queue.filter(function(q2) {
        return !q2.done;
      });
    }
  }, {
    key: "read",
    value: function(lng2, ns, fcName) {
      var _this3 = this, tried = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, wait = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout, callback = arguments.length > 5 ? arguments[5] : void 0;
      if (!lng2.length)
        return callback(null, {});
      if (this.readingCalls >= this.maxParallelReads) {
        this.waitingReads.push({
          lng: lng2,
          ns,
          fcName,
          tried,
          wait,
          callback
        });
        return;
      }
      return this.readingCalls++, this.backend[fcName](lng2, ns, function(err, data2) {
        if (_this3.readingCalls--, _this3.waitingReads.length > 0) {
          var next = _this3.waitingReads.shift();
          _this3.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);
        }
        if (err && data2 && tried < _this3.maxRetries) {
          setTimeout(function() {
            _this3.read.call(_this3, lng2, ns, fcName, tried + 1, wait * 2, callback);
          }, wait);
          return;
        }
        callback(err, data2);
      });
    }
  }, {
    key: "prepareLoading",
    value: function(languages, namespaces) {
      var _this4 = this, options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, callback = arguments.length > 3 ? arguments[3] : void 0;
      if (!this.backend)
        return this.logger.warn("No backend was added via i18next.use. Will not load resources."), callback && callback();
      typeof languages == "string" && (languages = this.languageUtils.toResolveHierarchy(languages)), typeof namespaces == "string" && (namespaces = [namespaces]);
      var toLoad = this.queueLoad(languages, namespaces, options2, callback);
      if (!toLoad.toLoad.length)
        return toLoad.pending.length || callback(), null;
      toLoad.toLoad.forEach(function(name) {
        _this4.loadOne(name);
      });
    }
  }, {
    key: "load",
    value: function(languages, namespaces, callback) {
      this.prepareLoading(languages, namespaces, {}, callback);
    }
  }, {
    key: "reload",
    value: function(languages, namespaces, callback) {
      this.prepareLoading(languages, namespaces, {
        reload: !0
      }, callback);
    }
  }, {
    key: "loadOne",
    value: function(name) {
      var _this5 = this, prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", s3 = name.split("|"), lng2 = s3[0], ns = s3[1];
      this.read(lng2, ns, "read", void 0, void 0, function(err, data2) {
        err && _this5.logger.warn("".concat(prefix, "loading namespace ").concat(ns, " for language ").concat(lng2, " failed"), err), !err && data2 && _this5.logger.log("".concat(prefix, "loaded namespace ").concat(ns, " for language ").concat(lng2), data2), _this5.loaded(name, err, data2);
      });
    }
  }, {
    key: "saveMissing",
    value: function(languages, namespace, key2, fallbackValue, isUpdate) {
      var options2 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
      if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
        this.logger.warn('did not save key "'.concat(key2, '" as the namespace "').concat(namespace, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        return;
      }
      key2 == null || key2 === "" || (this.backend && this.backend.create && this.backend.create(languages, namespace, key2, fallbackValue, null, _objectSpread$5(_objectSpread$5({}, options2), {}, {
        isUpdate
      })), !(!languages || !languages[0]) && this.store.addResource(languages[0], namespace, key2, fallbackValue));
    }
  }]), Connector2;
}(EventEmitter2);
function get() {
  return {
    debug: !1,
    initImmediate: !0,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: !1,
    supportedLngs: !1,
    nonExplicitSupportedLngs: !1,
    load: "all",
    preload: !1,
    simplifyPluralSuffix: !0,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: !1,
    saveMissing: !1,
    updateMissing: !1,
    saveMissingTo: "fallback",
    saveMissingPlurals: !0,
    missingKeyHandler: !1,
    missingInterpolationHandler: !1,
    postProcess: !1,
    postProcessPassResolved: !1,
    returnNull: !0,
    returnEmptyString: !0,
    returnObjects: !1,
    joinArrays: !1,
    returnedObjectHandler: !1,
    parseMissingKeyHandler: !1,
    appendNamespaceToMissingKey: !1,
    appendNamespaceToCIMode: !1,
    overloadTranslationOptionHandler: function(args) {
      var ret = {};
      if (_typeof3(args[1]) === "object" && (ret = args[1]), typeof args[1] == "string" && (ret.defaultValue = args[1]), typeof args[2] == "string" && (ret.tDescription = args[2]), _typeof3(args[2]) === "object" || _typeof3(args[3]) === "object") {
        var options2 = args[3] || args[2];
        Object.keys(options2).forEach(function(key2) {
          ret[key2] = options2[key2];
        });
      }
      return ret;
    },
    interpolation: {
      escapeValue: !0,
      format: function(value2, _format, lng2, options2) {
        return value2;
      },
      prefix: "{{",
      suffix: "}}",
      formatSeparator: ",",
      unescapePrefix: "-",
      nestingPrefix: "$t(",
      nestingSuffix: ")",
      nestingOptionsSeparator: ",",
      maxReplaces: 1e3,
      skipOnVariables: !0
    }
  };
}
function transformOptions(options2) {
  return typeof options2.ns == "string" && (options2.ns = [options2.ns]), typeof options2.fallbackLng == "string" && (options2.fallbackLng = [options2.fallbackLng]), typeof options2.fallbackNS == "string" && (options2.fallbackNS = [options2.fallbackNS]), options2.supportedLngs && options2.supportedLngs.indexOf("cimode") < 0 && (options2.supportedLngs = options2.supportedLngs.concat(["cimode"])), options2;
}
function ownKeys$6(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$6(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source2 = arguments[i3] != null ? arguments[i3] : {};
    i3 % 2 ? ownKeys$6(Object(source2), !0).forEach(function(key2) {
      _defineProperty(target, key2, source2[key2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2)) : ownKeys$6(Object(source2)).forEach(function(key2) {
      Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source2, key2));
    });
  }
  return target;
}
function _createSuper$3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
  return function() {
    var Super = _getPrototypeOf(Derived), result2;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result2 = Reflect.construct(Super, arguments, NewTarget);
    } else
      result2 = Super.apply(this, arguments);
    return _possibleConstructorReturn(this, result2);
  };
}
function _isNativeReflectConstruct$3() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function noop2() {
}
function bindMemberFunctions(inst) {
  var mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
  mems.forEach(function(mem) {
    typeof inst[mem] == "function" && (inst[mem] = inst[mem].bind(inst));
  });
}
var I18n = function(_EventEmitter) {
  _inherits(I18n2, _EventEmitter);
  var _super = _createSuper$3(I18n2);
  function I18n2() {
    var _this, options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, callback = arguments.length > 1 ? arguments[1] : void 0;
    if (_classCallCheck2(this, I18n2), _this = _super.call(this), isIE10 && EventEmitter2.call(_assertThisInitialized(_this)), _this.options = transformOptions(options2), _this.services = {}, _this.logger = baseLogger, _this.modules = {
      external: []
    }, bindMemberFunctions(_assertThisInitialized(_this)), callback && !_this.isInitialized && !options2.isClone) {
      if (!_this.options.initImmediate)
        return _this.init(options2, callback), _possibleConstructorReturn(_this, _assertThisInitialized(_this));
      setTimeout(function() {
        _this.init(options2, callback);
      }, 0);
    }
    return _this;
  }
  return _createClass2(I18n2, [{
    key: "init",
    value: function() {
      var _this2 = this, options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, callback = arguments.length > 1 ? arguments[1] : void 0;
      typeof options2 == "function" && (callback = options2, options2 = {}), !options2.defaultNS && options2.defaultNS !== !1 && options2.ns && (typeof options2.ns == "string" ? options2.defaultNS = options2.ns : options2.ns.indexOf("translation") < 0 && (options2.defaultNS = options2.ns[0]));
      var defOpts = get();
      this.options = _objectSpread$6(_objectSpread$6(_objectSpread$6({}, defOpts), this.options), transformOptions(options2)), this.options.compatibilityAPI !== "v1" && (this.options.interpolation = _objectSpread$6(_objectSpread$6({}, defOpts.interpolation), this.options.interpolation)), options2.keySeparator !== void 0 && (this.options.userDefinedKeySeparator = options2.keySeparator), options2.nsSeparator !== void 0 && (this.options.userDefinedNsSeparator = options2.nsSeparator);
      function createClassOnDemand(ClassOrObject) {
        return ClassOrObject ? typeof ClassOrObject == "function" ? new ClassOrObject() : ClassOrObject : null;
      }
      if (!this.options.isClone) {
        this.modules.logger ? baseLogger.init(createClassOnDemand(this.modules.logger), this.options) : baseLogger.init(null, this.options);
        var formatter;
        this.modules.formatter ? formatter = this.modules.formatter : typeof Intl < "u" && (formatter = Formatter);
        var lu = new LanguageUtil(this.options);
        this.store = new ResourceStore(this.options.resources, this.options);
        var s3 = this.services;
        s3.logger = baseLogger, s3.resourceStore = this.store, s3.languageUtils = lu, s3.pluralResolver = new PluralResolver(lu, {
          prepend: this.options.pluralSeparator,
          compatibilityJSON: this.options.compatibilityJSON,
          simplifyPluralSuffix: this.options.simplifyPluralSuffix
        }), formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format) && (s3.formatter = createClassOnDemand(formatter), s3.formatter.init(s3, this.options), this.options.interpolation.format = s3.formatter.format.bind(s3.formatter)), s3.interpolator = new Interpolator(this.options), s3.utils = {
          hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
        }, s3.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s3.resourceStore, s3, this.options), s3.backendConnector.on("*", function(event2) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
            args[_key - 1] = arguments[_key];
          _this2.emit.apply(_this2, [event2].concat(args));
        }), this.modules.languageDetector && (s3.languageDetector = createClassOnDemand(this.modules.languageDetector), s3.languageDetector.init(s3, this.options.detection, this.options)), this.modules.i18nFormat && (s3.i18nFormat = createClassOnDemand(this.modules.i18nFormat), s3.i18nFormat.init && s3.i18nFormat.init(this)), this.translator = new Translator(this.services, this.options), this.translator.on("*", function(event2) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)
            args[_key2 - 1] = arguments[_key2];
          _this2.emit.apply(_this2, [event2].concat(args));
        }), this.modules.external.forEach(function(m2) {
          m2.init && m2.init(_this2);
        });
      }
      if (this.format = this.options.interpolation.format, callback || (callback = noop2), this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
        var codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        codes.length > 0 && codes[0] !== "dev" && (this.options.lng = codes[0]);
      }
      !this.services.languageDetector && !this.options.lng && this.logger.warn("init: no languageDetector is used and no lng is defined");
      var storeApi = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
      storeApi.forEach(function(fcName) {
        _this2[fcName] = function() {
          var _this2$store;
          return (_this2$store = _this2.store)[fcName].apply(_this2$store, arguments);
        };
      });
      var storeApiChained = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
      storeApiChained.forEach(function(fcName) {
        _this2[fcName] = function() {
          var _this2$store2;
          return (_this2$store2 = _this2.store)[fcName].apply(_this2$store2, arguments), _this2;
        };
      });
      var deferred = defer4(), load2 = function() {
        var finish = function(err, t4) {
          _this2.isInitialized && !_this2.initializedStoreOnce && _this2.logger.warn("init: i18next is already initialized. You should call init just once!"), _this2.isInitialized = !0, _this2.options.isClone || _this2.logger.log("initialized", _this2.options), _this2.emit("initialized", _this2.options), deferred.resolve(t4), callback(err, t4);
        };
        if (_this2.languages && _this2.options.compatibilityAPI !== "v1" && !_this2.isInitialized)
          return finish(null, _this2.t.bind(_this2));
        _this2.changeLanguage(_this2.options.lng, finish);
      };
      return this.options.resources || !this.options.initImmediate ? load2() : setTimeout(load2, 0), deferred;
    }
  }, {
    key: "loadResources",
    value: function(language) {
      var _this3 = this, callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop2, usedCallback = callback, usedLng = typeof language == "string" ? language : this.language;
      if (typeof language == "function" && (usedCallback = language), !this.options.resources || this.options.partialBundledLanguages) {
        if (usedLng && usedLng.toLowerCase() === "cimode")
          return usedCallback();
        var toLoad = [], append = function(lng2) {
          if (!!lng2) {
            var lngs = _this3.services.languageUtils.toResolveHierarchy(lng2);
            lngs.forEach(function(l2) {
              toLoad.indexOf(l2) < 0 && toLoad.push(l2);
            });
          }
        };
        if (usedLng)
          append(usedLng);
        else {
          var fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
          fallbacks.forEach(function(l2) {
            return append(l2);
          });
        }
        this.options.preload && this.options.preload.forEach(function(l2) {
          return append(l2);
        }), this.services.backendConnector.load(toLoad, this.options.ns, function(e3) {
          !e3 && !_this3.resolvedLanguage && _this3.language && _this3.setResolvedLanguage(_this3.language), usedCallback(e3);
        });
      } else
        usedCallback(null);
    }
  }, {
    key: "reloadResources",
    value: function(lngs, ns, callback) {
      var deferred = defer4();
      return lngs || (lngs = this.languages), ns || (ns = this.options.ns), callback || (callback = noop2), this.services.backendConnector.reload(lngs, ns, function(err) {
        deferred.resolve(), callback(err);
      }), deferred;
    }
  }, {
    key: "use",
    value: function(module2) {
      if (!module2)
        throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
      if (!module2.type)
        throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
      return module2.type === "backend" && (this.modules.backend = module2), (module2.type === "logger" || module2.log && module2.warn && module2.error) && (this.modules.logger = module2), module2.type === "languageDetector" && (this.modules.languageDetector = module2), module2.type === "i18nFormat" && (this.modules.i18nFormat = module2), module2.type === "postProcessor" && postProcessor.addPostProcessor(module2), module2.type === "formatter" && (this.modules.formatter = module2), module2.type === "3rdParty" && this.modules.external.push(module2), this;
    }
  }, {
    key: "setResolvedLanguage",
    value: function(l2) {
      if (!(!l2 || !this.languages) && !(["cimode", "dev"].indexOf(l2) > -1))
        for (var li = 0; li < this.languages.length; li++) {
          var lngInLngs = this.languages[li];
          if (!(["cimode", "dev"].indexOf(lngInLngs) > -1) && this.store.hasLanguageSomeTranslations(lngInLngs)) {
            this.resolvedLanguage = lngInLngs;
            break;
          }
        }
    }
  }, {
    key: "changeLanguage",
    value: function(lng2, callback) {
      var _this4 = this;
      this.isLanguageChangingTo = lng2;
      var deferred = defer4();
      this.emit("languageChanging", lng2);
      var setLngProps = function(l2) {
        _this4.language = l2, _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l2), _this4.resolvedLanguage = void 0, _this4.setResolvedLanguage(l2);
      }, done2 = function(err, l2) {
        l2 ? (setLngProps(l2), _this4.translator.changeLanguage(l2), _this4.isLanguageChangingTo = void 0, _this4.emit("languageChanged", l2), _this4.logger.log("languageChanged", l2)) : _this4.isLanguageChangingTo = void 0, deferred.resolve(function() {
          return _this4.t.apply(_this4, arguments);
        }), callback && callback(err, function() {
          return _this4.t.apply(_this4, arguments);
        });
      }, setLng = function(lngs) {
        !lng2 && !lngs && _this4.services.languageDetector && (lngs = []);
        var l2 = typeof lngs == "string" ? lngs : _this4.services.languageUtils.getBestMatchFromCodes(lngs);
        l2 && (_this4.language || setLngProps(l2), _this4.translator.language || _this4.translator.changeLanguage(l2), _this4.services.languageDetector && _this4.services.languageDetector.cacheUserLanguage(l2)), _this4.loadResources(l2, function(err) {
          done2(err, l2);
        });
      };
      return !lng2 && this.services.languageDetector && !this.services.languageDetector.async ? setLng(this.services.languageDetector.detect()) : !lng2 && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect(setLng) : setLng(lng2), deferred;
    }
  }, {
    key: "getFixedT",
    value: function(lng2, ns, keyPrefix) {
      var _this5 = this, fixedT = function fixedT2(key2, opts) {
        var options2;
        if (_typeof3(opts) !== "object") {
          for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++)
            rest[_key3 - 2] = arguments[_key3];
          options2 = _this5.options.overloadTranslationOptionHandler([key2, opts].concat(rest));
        } else
          options2 = _objectSpread$6({}, opts);
        options2.lng = options2.lng || fixedT2.lng, options2.lngs = options2.lngs || fixedT2.lngs, options2.ns = options2.ns || fixedT2.ns, options2.keyPrefix = options2.keyPrefix || keyPrefix || fixedT2.keyPrefix;
        var keySeparator = _this5.options.keySeparator || ".", resultKey = options2.keyPrefix ? "".concat(options2.keyPrefix).concat(keySeparator).concat(key2) : key2;
        return _this5.t(resultKey, options2);
      };
      return typeof lng2 == "string" ? fixedT.lng = lng2 : fixedT.lngs = lng2, fixedT.ns = ns, fixedT.keyPrefix = keyPrefix, fixedT;
    }
  }, {
    key: "t",
    value: function() {
      var _this$translator;
      return this.translator && (_this$translator = this.translator).translate.apply(_this$translator, arguments);
    }
  }, {
    key: "exists",
    value: function() {
      var _this$translator2;
      return this.translator && (_this$translator2 = this.translator).exists.apply(_this$translator2, arguments);
    }
  }, {
    key: "setDefaultNamespace",
    value: function(ns) {
      this.options.defaultNS = ns;
    }
  }, {
    key: "hasLoadedNamespace",
    value: function(ns) {
      var _this6 = this, options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!this.isInitialized)
        return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages), !1;
      if (!this.languages || !this.languages.length)
        return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages), !1;
      var lng2 = this.resolvedLanguage || this.languages[0], fallbackLng = this.options ? this.options.fallbackLng : !1, lastLng = this.languages[this.languages.length - 1];
      if (lng2.toLowerCase() === "cimode")
        return !0;
      var loadNotPending = function(l2, n3) {
        var loadState = _this6.services.backendConnector.state["".concat(l2, "|").concat(n3)];
        return loadState === -1 || loadState === 2;
      };
      if (options2.precheck) {
        var preResult = options2.precheck(this, loadNotPending);
        if (preResult !== void 0)
          return preResult;
      }
      return !!(this.hasResourceBundle(lng2, ns) || !this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages || loadNotPending(lng2, ns) && (!fallbackLng || loadNotPending(lastLng, ns)));
    }
  }, {
    key: "loadNamespaces",
    value: function(ns, callback) {
      var _this7 = this, deferred = defer4();
      return this.options.ns ? (typeof ns == "string" && (ns = [ns]), ns.forEach(function(n3) {
        _this7.options.ns.indexOf(n3) < 0 && _this7.options.ns.push(n3);
      }), this.loadResources(function(err) {
        deferred.resolve(), callback && callback(err);
      }), deferred) : (callback && callback(), Promise.resolve());
    }
  }, {
    key: "loadLanguages",
    value: function(lngs, callback) {
      var deferred = defer4();
      typeof lngs == "string" && (lngs = [lngs]);
      var preloaded = this.options.preload || [], newLngs = lngs.filter(function(lng2) {
        return preloaded.indexOf(lng2) < 0;
      });
      return newLngs.length ? (this.options.preload = preloaded.concat(newLngs), this.loadResources(function(err) {
        deferred.resolve(), callback && callback(err);
      }), deferred) : (callback && callback(), Promise.resolve());
    }
  }, {
    key: "dir",
    value: function(lng2) {
      if (lng2 || (lng2 = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language)), !lng2)
        return "rtl";
      var rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"];
      return rtlLngs.indexOf(this.services.languageUtils.getLanguagePartFromCode(lng2)) > -1 || lng2.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
    }
  }, {
    key: "cloneInstance",
    value: function() {
      var _this8 = this, options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop2, mergedOptions = _objectSpread$6(_objectSpread$6(_objectSpread$6({}, this.options), options2), {
        isClone: !0
      }), clone = new I18n2(mergedOptions);
      (options2.debug !== void 0 || options2.prefix !== void 0) && (clone.logger = clone.logger.clone(options2));
      var membersToCopy = ["store", "services", "language"];
      return membersToCopy.forEach(function(m2) {
        clone[m2] = _this8[m2];
      }), clone.services = _objectSpread$6({}, this.services), clone.services.utils = {
        hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
      }, clone.translator = new Translator(clone.services, clone.options), clone.translator.on("*", function(event2) {
        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++)
          args[_key4 - 1] = arguments[_key4];
        clone.emit.apply(clone, [event2].concat(args));
      }), clone.init(mergedOptions, callback), clone.translator.options = clone.options, clone.translator.backendConnector.services.utils = {
        hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
      }, clone;
    }
  }, {
    key: "toJSON",
    value: function() {
      return {
        options: this.options,
        store: this.store,
        language: this.language,
        languages: this.languages,
        resolvedLanguage: this.resolvedLanguage
      };
    }
  }]), I18n2;
}(EventEmitter2);
_defineProperty(I18n, "createInstance", function() {
  var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, callback = arguments.length > 1 ? arguments[1] : void 0;
  return new I18n(options2, callback);
});
var instance = I18n.createInstance();
instance.createInstance = I18n.createInstance;
var createInstance = instance.createInstance, init3 = instance.init, loadResources = instance.loadResources, reloadResources = instance.reloadResources, use = instance.use, changeLanguage = instance.changeLanguage, getFixedT = instance.getFixedT, t3 = instance.t, exists = instance.exists, setDefaultNamespace = instance.setDefaultNamespace, hasLoadedNamespace2 = instance.hasLoadedNamespace, loadNamespaces2 = instance.loadNamespaces, loadLanguages = instance.loadLanguages;

// public/locales/en/common.ts
var common_default = {
  language: "English",
  greeting: "Hola",
  signIn: "Sign In",
  menu: {
    about: "About",
    privacy_policy: "Privacy policy",
    articles: "Articles",
    faq: "FAQ",
    news: "News",
    help: "Help"
  },
  copyright: "Copyright \xA9 2023 Upjob. All Rights Reserved."
};

// public/locales/en/home.ts
var home_default = {
  title: "Let\u2019s Find Your Job!",
  find_job: "Find job",
  find_employer: "Find employer",
  create_resume: "Create resume",
  search: "Search",
  companies: "Companies",
  job_title_keywords_or_company: "Job title, keywords, or company",
  dont_know_where_to_start: "Don't know where to start?",
  trending_searches: "Trending Searches",
  popular_companies: "Popular Companies",
  news: "News",
  articles: "Articles",
  see_more_companies: "See more companies",
  see_all_news: "See all news",
  see_all_articles: "See all articles",
  the_best_vacancies_are_only_with_us: "The best vacancies are only with us",
  convenient_service_for_finding_a_job: "Convenient service for finding a job."
};

// public/locales/en/auth.ts
var auth_default = {
  create_new_account_or_sign_in: "Create new Account or Sign in",
  enter_email: "Enter Email",
  enter_password: "Enter Password",
  enter_last_name: "Enter Last name",
  enter_first_name: "Enter First name",
  password_confirmation: "Password confirmation",
  sign_in_with_email: "Sign in with Email",
  or_register_with_social_accounts: "or register with social accounts",
  sign_with_google: "Sign with Google",
  sign_with_facebook: "Sign with Facebook",
  forgot_password: "Forgot password?",
  registration: "Registration",
  by_continuing_i_agree_to_the: "By continuing, I agree to the",
  and: "and",
  terms_of_use: "Terms of Use",
  privacy_policy: "Privacy Policy",
  subscribe_to_newsletter: "Subscribe to newsletter",
  i_accept_terms_of_use: "I accept Terms of Use",
  sign_up: "Sign up"
};

// public/locales/th/common.ts
var common_default2 = {
  language: "Thailand",
  greeting: "\u0E2A\u0E27\u0E31\u0E2A\u0E14\u0E35",
  signIn: "\u0E40\u0E02\u0E49\u0E32\u0E2A\u0E39\u0E48\u0E23\u0E30\u0E1A\u0E1A",
  menu: {
    about: "\u0E40\u0E01\u0E35\u0E48\u0E22\u0E27\u0E01\u0E31\u0E1A",
    privacy_policy: "\u0E19\u0E42\u0E22\u0E1A\u0E32\u0E22\u0E04\u0E27\u0E32\u0E21\u0E40\u0E1B\u0E47\u0E19\u0E2A\u0E48\u0E27\u0E19\u0E15\u0E31\u0E27",
    articles: "\u0E1A\u0E17\u0E04\u0E27\u0E32\u0E21",
    faq: "\u0E04\u0E33\u0E16\u0E32\u0E21\u0E17\u0E35\u0E48\u0E1E\u0E1A\u0E1A\u0E48\u0E2D\u0E22",
    news: "\u0E02\u0E48\u0E32\u0E27",
    help: "\u0E0A\u0E48\u0E27\u0E22"
  },
  copyright: "Copyright \xA9 2023 Upjob. All Rights Reserved."
};

// public/locales/th/home.ts
var home_default2 = {
  title: "\u0E21\u0E32\u0E2B\u0E32\u0E07\u0E32\u0E19\u0E02\u0E2D\u0E07\u0E04\u0E38\u0E13\u0E01\u0E31\u0E19\u0E40\u0E16\u0E2D\u0E30!",
  find_job: "\u0E04\u0E49\u0E19\u0E2B\u0E32\u0E07\u0E32\u0E19",
  find_employer: "\u0E04\u0E49\u0E19\u0E2B\u0E32\u0E1E\u0E19\u0E31\u0E01\u0E07\u0E32\u0E19",
  create_resume: "\u0E2A\u0E23\u0E49\u0E32\u0E07\u0E40\u0E23\u0E0B\u0E39\u0E40\u0E21\u0E48",
  search: "\u0E04\u0E49\u0E19\u0E2B\u0E32",
  companies: "\u0E1A\u0E23\u0E34\u0E29\u0E31\u0E17",
  job_title_keywords_or_company: "\u0E0A\u0E37\u0E48\u0E2D\u0E07\u0E32\u0E19 \u0E04\u0E33\u0E2B\u0E25\u0E31\u0E01 \u0E2B\u0E23\u0E37\u0E2D\u0E1A\u0E23\u0E34\u0E29\u0E31\u0E17",
  dont_know_where_to_start: "\u0E44\u0E21\u0E48\u0E17\u0E23\u0E32\u0E1A\u0E27\u0E48\u0E32\u0E08\u0E30\u0E40\u0E23\u0E34\u0E48\u0E21\u0E15\u0E49\u0E19?",
  trending_searches: "\u0E01\u0E32\u0E23\u0E04\u0E49\u0E19\u0E2B\u0E32\u0E17\u0E35\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A\u0E04\u0E27\u0E32\u0E21\u0E19\u0E34\u0E22\u0E21",
  popular_companies: "Popular Companies",
  news: "\u0E02\u0E48\u0E32\u0E27",
  articles: "\u0E1A\u0E17\u0E04\u0E27\u0E32\u0E21",
  see_more_companies: "\u0E14\u0E39\u0E1A\u0E23\u0E34\u0E29\u0E31\u0E17\u0E17\u0E31\u0E49\u0E07\u0E2B\u0E21\u0E14",
  see_all_news: "\u0E14\u0E39\u0E02\u0E48\u0E32\u0E27\u0E17\u0E31\u0E49\u0E07\u0E2B\u0E21\u0E14",
  see_all_articles: "\u0E14\u0E39\u0E1A\u0E17\u0E04\u0E27\u0E32\u0E21\u0E17\u0E31\u0E49\u0E07\u0E2B\u0E21\u0E14",
  the_best_vacancies_are_only_with_us: "The best vacancies are only with us",
  convenient_service_for_finding_a_job: "Convenient service for finding a job."
};

// public/locales/th/auth.ts
var auth_default2 = {
  create_new_account_or_sign_in: "Create new Account or Sign in",
  enter_email: "Enter Email",
  enter_password: "Enter Password",
  enter_last_name: "Enter Last name",
  enter_first_name: "Enter First name",
  password_confirmation: "Password confirmation",
  sign_in_with_email: "Sign in with Email",
  or_register_with_social_accounts: "or register with social accounts",
  sign_with_google: "Sign with Google",
  sign_with_facebook: "Sign with Facebook",
  forgot_password: "Forgot password?",
  registration: "Registration",
  by_continuing_i_agree_to_the: "By continuing, I agree to the",
  and: "and",
  terms_of_use: "Terms of Use",
  privacy_policy: "Privacy Policy",
  subscribe_to_newsletter: "Subscribe to newsletter",
  i_accept_terms_of_use: "I accept Terms of Use",
  sign_up: "Sign up"
};

// app/i18n/i18next.resources.ts
var i18next_resources_default = {
  en: {
    common: common_default,
    home: home_default,
    auth: auth_default
  },
  th: {
    common: common_default2,
    home: home_default2,
    auth: auth_default2
  }
};

// app/userContext.server.ts
var import_cloudflare2 = __toESM(require_dist());

// public/interfaces/iUserContext.ts
function isUserContext(userContext) {
  return !0;
}

// public/enums/languageEnum.ts
var LanguageEnum = {
  EN: "en",
  TH: "th"
};

// public/enums/themeEnum.ts
var ThemeEnum = {
  Light: "light",
  Dark: "dark",
  Dora: "dora"
};

// public/defaultUserContext.tsx
function defaultUserContext() {
  return {
    theme: ThemeEnum.Light,
    language: LanguageEnum.EN
  };
}

// app/userContext.server.ts
var SESSION_NAME = "userContext", userContextStorage = (0, import_cloudflare2.createCookieSessionStorage)({
  cookie: {
    name: "user_context",
    secure: !0,
    sameSite: "lax",
    path: "/",
    httpOnly: !0
  }
});
async function getUserContextSession(request) {
  let session = await userContextStorage.getSession(request.headers.get("Cookie"));
  return {
    getUserContext: () => {
      let rawSession = session.get(SESSION_NAME);
      if (!rawSession)
        return defaultUserContext();
      let userContext = JSON.parse(rawSession);
      return isUserContext(userContext) ? userContext : null;
    },
    setUserContext: (userContext) => session.set(SESSION_NAME, JSON.stringify(userContext)),
    commit: () => userContextStorage.commitSession(session)
  };
}

// app/entry.server.tsx
var import_jsx_dev_runtime = __toESM(require_jsx_dev_runtime());
async function handleRequest(request, statusCode, headers, context) {
  var _a;
  let instance2 = createInstance(), lng2 = ((_a = (await getUserContextSession(request)).getUserContext()) == null ? void 0 : _a.language) ?? LanguageEnum.EN, ns = i18next_server_default.getRouteNamespaces(context);
  await instance2.use(initReactI18next).use(esm_default).init({
    resources: i18next_resources_default,
    ...i18n_default,
    lng: lng2,
    ns,
    backend: {
      loadPath: resolve("./public/locales/{{lng}}/{{ns}}.json")
    }
  });
  let sheet = new Je(), markup = (0, import_server4.renderToString)(sheet.collectStyles(/* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(I18nextProvider, { i18n: instance2, children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(RemixServer, { context, url: request.url }, void 0, !1, {
    fileName: "app/entry.server.tsx",
    lineNumber: 30,
    columnNumber: 9
  }, this) }, void 0, !1, {
    fileName: "app/entry.server.tsx",
    lineNumber: 29,
    columnNumber: 51
  }, this))), styles = sheet.getStyleTags();
  return markup = markup.replace("__STYLES__", styles), headers.set("Content-Type", "text/html"), new Response("<!DOCTYPE html>" + markup, {
    status: statusCode,
    headers
  });
}

// app/root.tsx
var root_exports = {};
__export(root_exports, {
  default: () => AppWithProviders,
  links: () => links,
  loader: () => loader2,
  meta: () => meta
});
init_esm2();
var import_remix_i18next2 = __toESM(require_build());

// public/styles/tailwind.css
var tailwind_default = "/build/_assets/tailwind-ORUQSEUS.css";

// public/styles/globals.css
var globals_default = "/build/_assets/globals-Z66FSG4C.css";

// public/fonts/MeroThai/fonts.css
var fonts_default = "/build/_assets/fonts-DWEVJQVW.css";

// public/styles/constants.css
var constants_default = "/build/_assets/constants-DBHMTK7R.css";

// app/providers/userContextProvider.tsx
init_esm2();
var import_react12 = __toESM(require_react());

// shared/utils.ts
function isServer2() {
  return typeof document > "u";
}
function lng(en, th, lang) {
  switch (lang) {
    case LanguageEnum.EN:
      return en;
    case LanguageEnum.TH:
      return th;
    default:
      return en;
  }
}

// app/providers/userContextProvider.tsx
var import_jsx_dev_runtime2 = __toESM(require_jsx_dev_runtime()), UserContext = (0, import_react12.createContext)(void 0);
function UserContextProvider({
  children,
  specifiedUserContext
}) {
  let [userContext, setUserContext] = (0, import_react12.useState)(() => specifiedUserContext ? isUserContext(specifiedUserContext) ? specifiedUserContext : null : isServer2() ? null : defaultUserContext()), persistUserContext = useFetcher2(), persistUserContextRef = (0, import_react12.useRef)(persistUserContext);
  (0, import_react12.useEffect)(() => {
    persistUserContextRef.current = persistUserContext;
  }, [persistUserContext]);
  let mountRun = (0, import_react12.useRef)(!1);
  return (0, import_react12.useEffect)(() => {
    if (!mountRun.current) {
      mountRun.current = !0;
      return;
    }
    !userContext || persistUserContextRef.current.submit({
      context: JSON.stringify(userContext)
    }, {
      action: "actions/set-user-context",
      method: "POST"
    });
  }, [userContext]), /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)(UserContext.Provider, { value: [userContext, setUserContext], children }, void 0, !1, {
    fileName: "app/providers/userContextProvider.tsx",
    lineNumber: 51,
    columnNumber: 10
  }, this);
}

// app/hooks.tsx
var import_react13 = __toESM(require_react());

// app/themes/baseTheme.ts
function getTheme(palette) {
  return {
    backgroundColor: palette.neutral.neutral4,
    defaultTextColor: palette.darken.darken1.darken1_base,
    buttons: {
      primary: {
        backgroundColor: palette.accent.accent1.accent1_base,
        spanColor: palette.neutral.neutral1,
        focusBackgroundColor: palette.accent.accent2,
        iconColor: palette.neutral.neutral1,
        iconColorHover: palette.neutral.neutral1,
        iconDisable: palette.darken.darken2.darken2_variant2
      },
      secondary: {
        backgroundColor: palette.neutral.neutral1,
        spanColor: palette.darken.darken1.darken1_base,
        focusBackgroundColor: palette.neutral.neutral3,
        focusSpanColor: palette.accent.accent1.accent1_base,
        iconColor: palette.accent.accent1.accent1_base,
        iconColorHover: palette.neutral.neutral1,
        iconDisable: palette.darken.darken2.darken2_variant2
      },
      chips: {
        backgroundColor: palette.neutral.neutral3,
        spanColor: palette.darken.darken1.darken1_base,
        focusBackgroundColor: palette.darken.darken2.darken2_variant2,
        focusSpanColor: palette.accent.accent1.accent1_base,
        activeBorderColor: palette.accent.accent1.accent1_base
      },
      small: {
        backgroundColor: palette.neutral.neutral1,
        borderColor: palette.accent.accent1.accent1_base,
        pressedBacgroundColor: palette.accent.accent1.accent1_base,
        hoverBackgroundColor: palette.accent.accent1.accent1_variant1,
        hoverBorderColor: palette.accent.accent1.accent1_variant1,
        hoverBorderSpanColor: palette.neutral.neutral1,
        focusBorderColor: palette.accent.accent1.accent1_base,
        iconColor: palette.accent.accent1.accent1_base,
        iconColorHover: palette.neutral.neutral1,
        iconDisable: palette.darken.darken2.darken2_variant2
      }
    },
    inputs: {
      borderColor: palette.darken.darken1.darken1_variant1,
      borderFocusColor: palette.accent.accent1.accent1_base,
      backgroundDefaultColor: palette.neutral.neutral2
    },
    \u0441ards: {
      articlesTextColor: palette.darken.darken1.darken1_variant2,
      vacanciesTextColor: palette.accent.accent1.accent1_base,
      noVacanciesTextColor: palette.darken.darken1.darken1_variant2,
      imageBackground: palette.neutral.neutral3,
      cardContentBackground: palette.neutral.neutral1
    },
    search: {
      backgroundWrapper: palette.neutral.neutral1,
      svgColor: palette.darken.darken2.darken2_base,
      borderColor: palette.accent.accent1.accent1_variant3,
      middleBorderColor: palette.accent.accent1.accent1_variant3
    },
    tabs: {
      middleBorder: {
        backgroundColor: palette.accent.accent1.accent1_base
      },
      tabButton: {
        activeBackgroundColor: palette.neutral.neutral1,
        backgroundColor: palette.accent.accent1.accent1_variant5,
        focusBackgroundColor: palette.neutral.neutral1,
        focusActiveBackgroundColor: palette.neutral.neutral3,
        focusSpanBackgroundColor: palette.accent.accent1.accent1_base,
        focusSpanActiveBackgroundColor: palette.darken.darken1.darken1_base
      },
      tabContainer: {
        backgroundColor: palette.accent.accent1.accent1_variant5
      },
      activeTabColor: palette.darken.darken1.darken1_base,
      disabledTabColor: palette.darken.darken1.darken1_variant1
    },
    modal: {
      backgroundColor: palette.neutral.neutral2,
      svgColor: palette.darken.darken1.darken1_base
    },
    ui: {
      logoLinkColor: palette.darken.darken2.darken2_base,
      logoLinkHoverColor: palette.accent.accent1.accent1_base
    },
    slider: {
      backgroundBulletColor: palette.darken.darken1.darken1_variant2,
      backgroundBulletActiveColor: palette.accent.accent1.accent1_base,
      backgroundButtonArrowColor: palette.neutral.neutral3,
      buttonArrowColor: palette.accent.accent1.accent1_base,
      hoverButtonArrowColor: palette.neutral.neutral4
    },
    navbar: {
      logoColor: palette.darken.darken2.darken2_base,
      wrapperHeaderBackgroundColor: palette.neutral.neutral2,
      hoverColor: palette.accent.accent1.accent1_base,
      noHoverColor: palette.darken.darken2.darken2_base,
      textActiveLangColor: palette.darken.darken2.darken2_base,
      textNoActiveLangColor: palette.darken.darken2.darken2_variant1,
      svgColor: palette.darken.darken2.darken2_base
    },
    footer: {
      wrapperHeaderBackgroundColor: palette.neutral.neutral2,
      linkSpanColor: palette.accent.accent1.accent1_base,
      linkSpanColorMedia1024: palette.darken.darken2.darken2_base,
      boxCopirightSpanColorMedia1024: palette.darken.darken2.darken2_variant1,
      linkTextColor: palette.darken.darken1.darken1_variant1,
      borderColor: palette.darken.darken2.darken2_variant2
    },
    auth: {
      helpButtonColor: palette.accent.accent1.accent1_base,
      helpButtonHoverColor: palette.accent.accent1.accent1_variant2,
      helpButtonActiveColor: palette.accent.accent2,
      radioButtonColor: palette.accent.accent1.accent1_base,
      backgroundRegisterPage: palette.darken.darken2.darken2_variant2,
      backgroundRegisterContainerColor: palette.neutral.neutral2
    },
    mainPage: {
      headingColor: palette.neutral.neutral1,
      titleColor: palette.darken.darken1.darken1_base,
      backgroundSectionTrendingColor: palette.neutral.neutral2,
      backgroundSectionCompaniesColor: palette.darken.darken2.darken2_variant2,
      backgroundSectionArticlesColor: palette.neutral.neutral2,
      backgroundSectionNewsColor: palette.darken.darken2.darken2_variant2,
      benefitHeadingMobileColor: palette.accent.accent1.accent1_base,
      benefitHeaderColorSmall: palette.accent.accent1.accent1_base,
      benefitHeaderColor: palette.darken.darken2.darken2_base,
      benefitBodyColorSmall: palette.darken.darken2.darken2_base,
      benefitBodyColor: palette.darken.darken2.darken2_variant1
    }
  };
}

// app/themes/palettes/basePalette.ts
var basePalette = {
  neutral: {
    neutral1: "#FFFFFF",
    neutral2: "#FAFAFA",
    neutral3: "#EDEFF2",
    neutral4: "#D9DBDE"
  },
  darken: {
    darken1: {
      darken1_base: "#454857",
      darken1_variant1: "#7D7F89",
      darken1_variant2: "#A2A3AB"
    },
    darken2: {
      darken2_base: "#566178",
      darken2_variant1: "#9AA0AE",
      darken2_variant2: "#E4E6E9"
    }
  },
  accent: {
    accent1: {
      accent1_base: "#3C79F5",
      accent1_variant1: "#77A1F8",
      accent1_variant2: "#8AAFF9",
      accent1_variant3: "#B1C9FB",
      accent1_variant4: "#D8E4FD",
      accent1_variant5: "#ECF2FE",
      accent1_variant6: "#F5F8FF"
    },
    accent2: "#3B67C0",
    accent3: "#E5E8F9"
  }
};

// app/themes/palettes/darkPalette.ts
var darkPalette = {
  ...basePalette,
  neutral: {
    neutral1: "#444",
    neutral2: "#DDD",
    neutral3: "#BBB",
    neutral4: "#999"
  },
  accent: {
    accent1: {
      accent1_base: "#CCC",
      accent1_variant1: "#CCC"
    },
    accent2: "#CCC",
    accent3: "#CCC"
  }
};

// app/themes/darkTheme.ts
var darkTheme = {
  ...getTheme(darkPalette),
  type: ThemeEnum.Dark
};

// app/themes/palettes/doraPalette.ts
var doraPalette = {
  ...basePalette,
  neutral: {
    neutral1: "#FF38AF",
    neutral2: "#3B0D28",
    neutral3: "#FF38E2",
    neutral4: "#D786E0"
  }
};

// app/themes/doraTheme.ts
var doraTheme = {
  ...getTheme(doraPalette),
  type: ThemeEnum.Dora
};

// app/themes/palettes/lightPalette.ts
var lightPalette = {
  ...basePalette
};

// app/themes/lightTheme.ts
var lightTheme = {
  ...getTheme(lightPalette),
  type: ThemeEnum.Light
};

// app/i18n/utils.ts
function getUserTheme(type2) {
  if (!type2)
    return lightTheme;
  switch (type2.theme) {
    case ThemeEnum.Light:
      return lightTheme;
    case ThemeEnum.Dark:
      return darkTheme;
    case ThemeEnum.Dora:
      return doraTheme;
    default:
      return lightTheme;
  }
}

// app/hooks.tsx
init_es();
function useUserContext() {
  let context = (0, import_react13.useContext)(UserContext);
  if (context === void 0)
    throw new Error("useUserContext must be used within a UserContextProvider");
  return context;
}
function useApp() {
  let [userContext, setUserContext] = useUserContext(), theme = getUserTheme(userContext), {
    i18n,
    t: t4
  } = useTranslation();
  return {
    userContext,
    setUserContext,
    theme,
    t: t4,
    i18n
  };
}

// app/root.tsx
var import_jsx_dev_runtime3 = __toESM(require_jsx_dev_runtime()), loader2 = async ({
  request
}) => ({
  userContext: (await getUserContextSession(request)).getUserContext()
}), links = () => [{
  rel: "stylesheet",
  href: fonts_default
}, {
  rel: "stylesheet",
  href: constants_default
}, {
  rel: "stylesheet",
  href: tailwind_default
}, {
  rel: "stylesheet",
  href: globals_default
}, {
  rel: "stylesheet",
  href: constants_default
}, {
  rel: "stylesheet",
  href: "https://cdn.jsdelivr.net/npm/swiper@9/swiper-bundle.min.css"
}], meta = () => ({
  charset: "utf-8",
  title: "Search job app",
  viewport: "width=device-width,initial-scale=1"
});
function App() {
  let {
    userContext,
    theme,
    i18n
  } = useApp();
  return (0, import_remix_i18next2.useChangeLanguage)((userContext == null ? void 0 : userContext.language) ?? LanguageEnum.EN), /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)("html", { lang: userContext == null ? void 0 : userContext.language, dir: i18n.dir(), children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)("head", { children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)(Meta, {}, void 0, !1, {
        fileName: "app/root.tsx",
        lineNumber: 62,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)(Links, {}, void 0, !1, {
        fileName: "app/root.tsx",
        lineNumber: 63,
        columnNumber: 9
      }, this),
      typeof document > "u" ? "__STYLES__" : null
    ] }, void 0, !0, {
      fileName: "app/root.tsx",
      lineNumber: 61,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)("body", { children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)(Le, { theme, children: /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)(Outlet, {}, void 0, !1, {
        fileName: "app/root.tsx",
        lineNumber: 68,
        columnNumber: 11
      }, this) }, void 0, !1, {
        fileName: "app/root.tsx",
        lineNumber: 67,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)(ScrollRestoration2, {}, void 0, !1, {
        fileName: "app/root.tsx",
        lineNumber: 70,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)(Scripts, {}, void 0, !1, {
        fileName: "app/root.tsx",
        lineNumber: 71,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)(LiveReload, {}, void 0, !1, {
        fileName: "app/root.tsx",
        lineNumber: 72,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)("div", { id: "modal-container" }, void 0, !1, {
        fileName: "app/root.tsx",
        lineNumber: 73,
        columnNumber: 9
      }, this)
    ] }, void 0, !0, {
      fileName: "app/root.tsx",
      lineNumber: 66,
      columnNumber: 7
    }, this)
  ] }, void 0, !0, {
    fileName: "app/root.tsx",
    lineNumber: 60,
    columnNumber: 10
  }, this);
}
function AppWithProviders() {
  let data2 = useLoaderData2();
  return /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)(UserContextProvider, { specifiedUserContext: data2.userContext, children: /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)(App, {}, void 0, !1, {
    fileName: "app/root.tsx",
    lineNumber: 80,
    columnNumber: 7
  }, this) }, void 0, !1, {
    fileName: "app/root.tsx",
    lineNumber: 79,
    columnNumber: 10
  }, this);
}

// app/routes/actions/set-user-context.tsx
var set_user_context_exports = {};
__export(set_user_context_exports, {
  action: () => action,
  loader: () => loader3
});
var import_cloudflare3 = __toESM(require_dist()), import_cloudflare4 = __toESM(require_dist());
var action = async ({
  request
}) => {
  let userContextSession = await getUserContextSession(request), contextRaw = (await request.clone().formData()).get("context"), userContext = JSON.parse((contextRaw == null ? void 0 : contextRaw.toString()) ?? "");
  return isUserContext(userContext) ? (userContextSession.setUserContext(userContext), (0, import_cloudflare3.json)({
    success: !0
  }, {
    headers: {
      "Set-Cookie": await userContextSession.commit()
    }
  })) : (0, import_cloudflare3.json)({
    success: !1,
    message: `UserContext value of ${userContext} is not a valid UserContext`
  });
}, loader3 = () => (0, import_cloudflare4.redirect)("/", {
  status: 404
});

// app/routes/account/index.tsx
var account_exports = {};
__export(account_exports, {
  default: () => Index
});

// app/components/common/Text/enums.ts
var TextVariantEnum = {
  textHeading1: "textHeading1",
  textHeading2: "textHeading2",
  textHeading3: "textHeading3",
  textBody1: "textBody1",
  textBody1medium: "textBody1medium",
  textBody2: "textBody2",
  textBody2medium: "textBody2medium",
  textSmall: "textSmall",
  textSmallmedium: "textSmallmedium",
  textMini: "textMini"
};

// app/components/common/Text/index.tsx
var FONT_SIZES_MOB = {
  [TextVariantEnum.textHeading1]: "28px",
  [TextVariantEnum.textHeading2]: "24px",
  [TextVariantEnum.textHeading3]: "22px",
  [TextVariantEnum.textBody1]: "16px",
  [TextVariantEnum.textBody1medium]: "16px",
  [TextVariantEnum.textBody2]: "14px",
  [TextVariantEnum.textBody2medium]: "14px",
  [TextVariantEnum.textSmall]: "12px",
  [TextVariantEnum.textSmallmedium]: "12px",
  [TextVariantEnum.textMini]: "9px"
}, FONT_SIZES_TAB = {
  [TextVariantEnum.textHeading1]: "48px",
  [TextVariantEnum.textHeading2]: "32px",
  [TextVariantEnum.textHeading3]: "26px",
  [TextVariantEnum.textBody1]: "18px",
  [TextVariantEnum.textBody1medium]: "18px",
  [TextVariantEnum.textBody2]: "16px",
  [TextVariantEnum.textBody2medium]: "16px",
  [TextVariantEnum.textSmall]: "12px",
  [TextVariantEnum.textSmallmedium]: "12px",
  [TextVariantEnum.textMini]: "9px"
}, FONT_SIZES_DESC = {
  [TextVariantEnum.textHeading1]: "48px",
  [TextVariantEnum.textHeading2]: "32px",
  [TextVariantEnum.textHeading3]: "26px",
  [TextVariantEnum.textBody1]: "18px",
  [TextVariantEnum.textBody1medium]: "18px",
  [TextVariantEnum.textBody2]: "16px",
  [TextVariantEnum.textBody2medium]: "16px",
  [TextVariantEnum.textSmall]: "12px",
  [TextVariantEnum.textSmallmedium]: "12px",
  [TextVariantEnum.textMini]: "9px"
}, FONT_WEIGHTS_MOB = {
  [TextVariantEnum.textHeading1]: "700",
  [TextVariantEnum.textHeading2]: "700",
  [TextVariantEnum.textHeading3]: "700",
  [TextVariantEnum.textBody1]: "400",
  [TextVariantEnum.textBody1medium]: "500",
  [TextVariantEnum.textBody2]: "400",
  [TextVariantEnum.textBody2medium]: "500",
  [TextVariantEnum.textSmall]: "400",
  [TextVariantEnum.textSmallmedium]: "500",
  [TextVariantEnum.textMini]: "500"
}, FONT_WEIGHTS_TAB = {
  [TextVariantEnum.textHeading1]: "700",
  [TextVariantEnum.textHeading2]: "700",
  [TextVariantEnum.textHeading3]: "700",
  [TextVariantEnum.textBody1]: "400",
  [TextVariantEnum.textBody1medium]: "500",
  [TextVariantEnum.textBody2]: "400",
  [TextVariantEnum.textBody2medium]: "500",
  [TextVariantEnum.textSmall]: "400",
  [TextVariantEnum.textSmallmedium]: "500",
  [TextVariantEnum.textMini]: "500"
}, FONT_WEIGHTS_DESC = {
  [TextVariantEnum.textHeading1]: "700",
  [TextVariantEnum.textHeading2]: "700",
  [TextVariantEnum.textHeading3]: "700",
  [TextVariantEnum.textBody1]: "400",
  [TextVariantEnum.textBody1medium]: "500",
  [TextVariantEnum.textBody2]: "400",
  [TextVariantEnum.textBody2medium]: "500",
  [TextVariantEnum.textSmall]: "400",
  [TextVariantEnum.textSmallmedium]: "500",
  [TextVariantEnum.textMini]: "500"
}, LINE_HEIGHTS_MOB = {
  [TextVariantEnum.textHeading1]: "36px",
  [TextVariantEnum.textHeading2]: "30px",
  [TextVariantEnum.textHeading3]: "32px",
  [TextVariantEnum.textBody1]: "24px",
  [TextVariantEnum.textBody1medium]: "24px",
  [TextVariantEnum.textBody2]: "18px",
  [TextVariantEnum.textBody2medium]: "18px",
  [TextVariantEnum.textSmall]: "16px",
  [TextVariantEnum.textSmallmedium]: "16px",
  [TextVariantEnum.textMini]: "9px"
}, LINE_HEIGHTS_TAB = {
  [TextVariantEnum.textHeading1]: "56px",
  [TextVariantEnum.textHeading2]: "40px",
  [TextVariantEnum.textHeading3]: "32px",
  [TextVariantEnum.textBody1]: "24px",
  [TextVariantEnum.textBody1medium]: "24px",
  [TextVariantEnum.textBody2]: "24px",
  [TextVariantEnum.textBody2medium]: "24px",
  [TextVariantEnum.textSmall]: "24px",
  [TextVariantEnum.textSmallmedium]: "24px",
  [TextVariantEnum.textMini]: "12px"
}, LINE_HEIGHTS_DESC = {
  [TextVariantEnum.textHeading1]: "56px",
  [TextVariantEnum.textHeading2]: "40px",
  [TextVariantEnum.textHeading3]: "32px",
  [TextVariantEnum.textBody1]: "24px",
  [TextVariantEnum.textBody1medium]: "24px",
  [TextVariantEnum.textBody2]: "24px",
  [TextVariantEnum.textBody2medium]: "24px",
  [TextVariantEnum.textSmall]: "24px",
  [TextVariantEnum.textSmallmedium]: "24px",
  [TextVariantEnum.textMini]: "12px"
}, Text = styled_components_esm_default.span.withConfig({
  displayName: "Text",
  componentId: "sc-89rjml-0"
})(["color:", ";font-style:", ";letter-spacing:-0.026em;font-size:", ";font-weight:", ";line-height:", ";transition:all 0.08s ease-in;@media (min-width:768px){font-size:", ";font-weight:", ";line-height:", ";}@media (min-width:1024px){font-size:", ";font-weight:", ";line-height:", ";}"], ({
  color: color2,
  theme
}) => color2 || theme.defaultTextColor, (props) => props.fontStyle, ({
  variant = TextVariantEnum.textBody1
}) => FONT_SIZES_MOB[variant], ({
  variant = TextVariantEnum.textBody1
}) => FONT_WEIGHTS_MOB[variant], ({
  variant = TextVariantEnum.textBody1
}) => LINE_HEIGHTS_MOB[variant], ({
  variant = TextVariantEnum.textBody1
}) => FONT_SIZES_TAB[variant], ({
  variant = TextVariantEnum.textBody1
}) => FONT_WEIGHTS_TAB[variant], ({
  variant = TextVariantEnum.textBody1
}) => LINE_HEIGHTS_TAB[variant], ({
  variant = TextVariantEnum.textBody1
}) => FONT_SIZES_DESC[variant], ({
  variant = TextVariantEnum.textBody1
}) => FONT_WEIGHTS_DESC[variant], ({
  variant = TextVariantEnum.textBody1
}) => LINE_HEIGHTS_DESC[variant]);

// app/routes/account/index.tsx
var import_jsx_dev_runtime4 = __toESM(require_jsx_dev_runtime());
function Index() {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)(import_jsx_dev_runtime4.Fragment, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)(Text, { variant: "textHeading1", children: "THIS IS PERSONL ACCOUNT" }, void 0, !1, {
    fileName: "app/routes/account/index.tsx",
    lineNumber: 16,
    columnNumber: 7
  }, this) }, void 0, !1, {
    fileName: "app/routes/account/index.tsx",
    lineNumber: 15,
    columnNumber: 10
  }, this);
}

// app/routes/auth/login.ts
var login_exports = {};
__export(login_exports, {
  action: () => action2
});
var import_cloudflare6 = __toESM(require_dist());

// app/utils/request.server.ts
var import_cloudflare5 = __toESM(require_dist()), badRequest = (data2) => (0, import_cloudflare5.json)(data2, { status: 400 });

// app/routes/auth/login.ts
function validateEmail(email) {
  if (typeof email != "string" || email.length < 3 || !email.includes("@"))
    return "Usernames must be at least 3 characters long";
}
function validatePassword(password) {
  if (typeof password != "string" || password.length < 6)
    return "Passwords must be at least 6 characters long";
}
var action2 = async ({ request }) => {
  let form = await request.formData(), email = form.get("email"), password = form.get("password"), fields = { email, password };
  if (typeof email != "string" || typeof password != "string")
    return badRequest({
      fieldErrors: null,
      fields: null,
      formError: "Form not submitted correctly."
    });
  let fieldErrors = {
    email: validateEmail(email),
    password: validatePassword(password)
  };
  if (Object.values(fieldErrors).some(Boolean))
    return badRequest({ fieldErrors, fields, formError: null });
  try {
    let myHeaders = new Headers();
    myHeaders.append("Content-Type", "application/json");
    let requestOptions = {
      method: "POST",
      headers: myHeaders,
      body: JSON.stringify(fields),
      redirect: "follow"
    }, sessionCookie = (await fetch("https://upjob.com/api/v1/user-service/login", requestOptions)).headers.get("Set-Cookie");
    return (0, import_cloudflare6.redirect)("/account", {
      status: 302,
      headers: sessionCookie ? { "Set-Cookie": sessionCookie } : {}
    });
  } catch {
    return badRequest({
      fieldErrors: null,
      fields,
      formError: "Username/Password combination is incorrect"
    });
  }
};

// app/routes/register.tsx
var register_exports = {};
__export(register_exports, {
  default: () => Register
});

// app/components/pages/Auth/Register/index.tsx
init_esm2();
var import_react46 = __toESM(require_react());

// app/components/common/Input/index.tsx
var import_react15 = __toESM(require_react());

// app/components/common/Input/styles.ts
var WrapperInput = styled_components_esm_default.div`
  width: 100%;
  position: relative;
`, InputComponent = styled_components_esm_default.input`
  width: 100%;
  height: 100%;
  border: 1px solid ${({ theme }) => theme.inputs.borderColor};
  background-color: transparent;
  border-radius: 80px;
  padding: 11px 16px;
  font-size: ${FONT_SIZES_MOB.textBody2};
  line-height: 18px;

  &:focus::-webkit-textfield-decoration-container {
    visibility: hidden;
    pointer-events: none;
    position: absolute;
    border: 1px solid ${({ theme }) => theme.inputs.borderFocusColor};
  }

  @supports (not (-ms-ime-align: auto)) {
    &:focus + .placeholder,
    &:not(:placeholder-shown) + .placeholder {
      transform: translate(16px, -50px) scale(0.8);
      z-index: 1;
      padding: 0px 4px;
      padding: 0 4px;
      background: ${({ theme, backgrond }) => backgrond || theme.inputs.backgroundDefaultColor};
    }

    &:focus {
      border: 1px solid ${({ theme }) => theme.inputs.borderFocusColor};
    }

    &:active {
      border: 1px solid ${({ theme }) => theme.inputs.borderFocusColor};
    }
  }

  @media (min-width: 1024px) {
    padding: 16px;
    font-size: ${FONT_SIZES_DESC.textBody2};
    line-height: 24px;

    @supports (not (-ms-ime-align: auto)) {
      &:focus + .placeholder,
      &:not(:placeholder-shown) + .placeholder {
        transform: translate(16px, -62px) scale(0.8);
        padding: 0px 6px;
      }

      &:focus {
        border: 1px solid ${({ theme }) => theme.inputs.borderFocusColor};
      }
      &:active {
        border: 1px solid ${({ theme }) => theme.inputs.borderFocusColor};
      }
    }
  }
`, PlaceHolder = styled_components_esm_default.label`
  display: block;
  line-height: 0;
  color: grey;
  position: absolute;
  font-size: ${FONT_SIZES_MOB.textBody2};
  line-height: 18px;

  @supports (not (-ms-ime-align: auto)) {
    transform: translate(16px, -30px);
    transition: all 0.2s ease-out;
  }

  @media (min-width: 1024px) {
    font-size: ${FONT_SIZES_DESC.textBody2};

    @supports (not (-ms-ime-align: auto)) {
      transform: translate(16px, -36px);
    }
  }
`;

// app/components/common/Input/index.tsx
var import_jsx_dev_runtime5 = __toESM(require_jsx_dev_runtime()), Input = ({
  id: id4,
  value: value2,
  placeholder,
  className,
  errorText,
  style,
  disabled,
  inputClass,
  placeholderClass,
  textariaClass,
  name,
  htmlType = "text",
  variant,
  background
}) => {
  let [type2, setType] = (0, import_react15.useState)(htmlType), handlePassword = () => {
    setType(type2 === "password" ? () => "text" : () => "password");
  };
  return /* @__PURE__ */ (0, import_jsx_dev_runtime5.jsxDEV)(WrapperInput, { children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime5.jsxDEV)(InputComponent, { backgrond: background, type: type2, placeholder: " ", disabled, id: id4, name }, void 0, !1, {
      fileName: "app/components/common/Input/index.tsx",
      lineNumber: 62,
      columnNumber: 7
    }, this),
    placeholder && variant !== "search" && /* @__PURE__ */ (0, import_jsx_dev_runtime5.jsxDEV)(PlaceHolder, { htmlFor: id4, className: "placeholder", children: placeholder }, void 0, !1, {
      fileName: "app/components/common/Input/index.tsx",
      lineNumber: 63,
      columnNumber: 47
    }, this),
    Boolean(errorText) && /* @__PURE__ */ (0, import_jsx_dev_runtime5.jsxDEV)(Text, { children: errorText }, void 0, !1, {
      fileName: "app/components/common/Input/index.tsx",
      lineNumber: 66,
      columnNumber: 30
    }, this)
  ] }, void 0, !0, {
    fileName: "app/components/common/Input/index.tsx",
    lineNumber: 61,
    columnNumber: 10
  }, this);
};

// app/components/common/Button/enums.ts
var ButtonSizeEnum = {
  M: "M",
  S: "S"
}, ButtonColorEnum = {
  blue: "blue",
  white: "white"
}, ButtonPriorityEnum = {
  primary: "primary",
  secondary: "secondary",
  small: "small",
  chips: "chips"
};

// app/components/common/Button/styles.ts
var Button = styled_components_esm_default.button`
  cursor: pointer;
  border-radius: 80px;
  display: flex;
  flex-direction: row;
  gap: 8px;
  justify-content: center;
  align-items: center;
  width: ${({ fullwidth }) => fullwidth ? "100%" : "fit-content"};
  transition: all 0.1s ease-in;
  padding: ${({ size }) => size === ButtonSizeEnum.M ? "15px 32px 14px" : "12px 20px 10px"};
  &:hover,
  &:focus {
    transform: scale(0.95);
  }
  svg {
    transition: all 0.1s ease-in;
  }

  span {
    height: fit-content;
  }

  @media (min-width: 768px) {
    padding: ${({ size, iconName }) => {
  if (size === ButtonSizeEnum.M && iconName)
    return "15px 32px 14px 24px";
  if (size === ButtonSizeEnum.M && !iconName)
    return "15px 32px 14px";
  if (size === ButtonSizeEnum.S && iconName)
    return "12px 20px 10px 16px";
  if (size === ButtonSizeEnum.S && !iconName)
    return "12px 20px 10px";
}};
    &:hover {
      transform: scale(1);
    }
    &:active {
      transform: scale(0.95);
      span {
        font-weight: 600;
      }
    }
  }

  @media (min-width: 1024px) {
    cursor: pointer;
    padding: ${({ size, iconName }) => {
  if (size === ButtonSizeEnum.S && iconName)
    return "15px 32px 14px 56px";
  if (size === ButtonSizeEnum.S && !iconName)
    return "15px 32px 14px";
}};
  }

  ${({ priority = ButtonPriorityEnum.primary, size = ButtonSizeEnum.M }) => {
  switch (priority) {
    case ButtonPriorityEnum.primary:
      return Ae`
          background-color: ${({ theme }) => theme.buttons.primary.backgroundColor};
          span {
            color: ${({ theme }) => theme.buttons.primary.spanColor};
          }
          svg {
            color: ${({ theme }) => theme.buttons.primary.iconColor};
            &:hover,
            &:focus {
              color: ${({ theme }) => theme.buttons.primary.iconColorHover};
            }
          }
          &:hover,
          &:focus {
            background-color: ${({ theme }) => theme.buttons.primary.focusBackgroundColor};
          }
        `;
    case ButtonPriorityEnum.small:
      return Ae`
          background-color: ${({ theme }) => theme.buttons.small.backgroundColor};
          border: 1px solid ${({ theme }) => theme.buttons.small.borderColor};
          padding: 10px 20px;
          span {
            color: ${({ theme }) => theme.buttons.small.borderColor};
          }
          svg {
            color: ${({ theme }) => theme.buttons.small.iconColor};
          }
          &:hover {
            background-color: ${({ theme }) => theme.buttons.small.hoverBackgroundColor};
            border: 1px solid ${({ theme }) => theme.buttons.small.hoverBorderColor};
            span {
              color: ${({ theme }) => theme.buttons.small.hoverBorderSpanColor};
            }
            svg {
              color: ${({ theme }) => theme.buttons.small.iconColorHover};
            }
          }
          &:focus {
            border: 1px solid ${({ theme }) => theme.buttons.small.focusBorderColor};
          }
          &:active {
            background-color: ${({ theme }) => theme.buttons.small.pressedBacgroundColor};
          }
          @media (min-width: 1024px) {
            cursor: pointer;
            padding: 12px 20px 10px;
          }
        `;
    case ButtonPriorityEnum.secondary:
      return Ae`
          background-color: ${({ theme }) => theme.buttons.secondary.backgroundColor};
          span {
            color: ${({ theme }) => theme.buttons.secondary.spanColor};
          }
          svg {
            color: ${({ theme }) => theme.buttons.small.iconColor};
          }
          &:hover,
          &:focus {
            background-color: ${({ theme }) => theme.buttons.secondary.focusBackgroundColor};
            span {
              color: ${({ theme }) => theme.buttons.secondary.focusSpanColor};
            }
            svg {
              color: ${({ theme }) => theme.buttons.small.iconColorHover};
            }
          }
        `;
    case ButtonPriorityEnum.chips:
      return Ae`
          background-color: ${({ theme }) => theme.buttons.chips.backgroundColor};
          padding: 8px 14px 5px;

          span {
            color: ${({ theme }) => theme.buttons.chips.spanColor};
          }
          &:hover,
          &:focus {
            background-color: ${({ theme }) => theme.buttons.chips.focusBackgroundColor};
            span {
              color: ${({ theme }) => theme.buttons.chips.focusSpanColor};
            }
          }
          &:active {
            border: 1px solid ${({ theme }) => theme.buttons.chips.focusSpanColor};
            span {
              color: ${({ theme }) => theme.buttons.chips.focusSpanColor};
              font-weight: 600;
            }
          }
          @media (min-width: 768px) {
            padding: 12px 20px 8px;
          }
        `;
  }
}}
`;

// public/enums/iconEnum.ts
var IconEnum = {
  bell: "bell",
  bellPush: "bellPush",
  close: "close",
  down: "down",
  email: "email",
  emailPush: "emailPush",
  left: "left",
  leftLine: "leftLine",
  logo: "logo",
  map: "map",
  menu: "menu",
  pensil: "pensil",
  right: "right",
  rightLine: "rightLine",
  search: "search",
  show: "show",
  up: "up",
  google: "google",
  fb: "fb"
};

// app/components/common/Box/index.tsx
var Box = styled_components_esm_default.div.withConfig({
  displayName: "Box",
  componentId: "sc-1b0y2fu-0"
})(["display:", ";flex-direction:", ";justify-content:", ";align-items:", ";align-self:", ";flex-grow:", ";flex-wrap:", ";gap:", ";padding:", ";margin:", ";width:", ";min-width:", ";max-width:", ";height:", ";min-height:", ";max-height:", ";background-color:", ";border:", ";border-radius:", ";"], ({
  display = "flex"
}) => display, ({
  flexDirection
}) => flexDirection, ({
  justifyContent
}) => justifyContent, ({
  alignItems
}) => alignItems, ({
  alignSelf
}) => alignSelf, ({
  flexGrow
}) => flexGrow, ({
  flexWrap
}) => flexWrap, ({
  gap
}) => gap, ({
  padding
}) => padding, ({
  margin
}) => margin, ({
  width
}) => width, ({
  minWidth
}) => minWidth, ({
  maxWidth
}) => maxWidth, ({
  height
}) => height, ({
  minHeight
}) => minHeight, ({
  maxHeight
}) => maxHeight, ({
  backgroundColor
}) => backgroundColor, ({
  border
}) => border, ({
  borderRadius
}) => borderRadius);

// app/components/common/Icons/Bell.tsx
var import_jsx_dev_runtime6 = __toESM(require_jsx_dev_runtime()), SvgBell = (props) => /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)("path", { d: "M9 21h6M5.269 9.75A6.74 6.74 0 0 1 12.051 3c3.712.028 6.68 3.113 6.68 6.835v.665c0 3.358.703 5.306 1.322 6.371A.75.75 0 0 1 19.408 18H4.592a.749.749 0 0 1-.645-1.13c.62-1.064 1.322-3.013 1.322-6.37v-.75Z", stroke: "CurrentColor", strokeWidth: 1.44, strokeLinecap: "round", strokeLinejoin: "round" }, void 0, !1, {
  fileName: "app/components/common/Icons/Bell.tsx",
  lineNumber: 4,
  columnNumber: 5
}, this) }, void 0, !1, {
  fileName: "app/components/common/Icons/Bell.tsx",
  lineNumber: 3,
  columnNumber: 53
}, this), Bell_default = SvgBell;

// app/components/common/Icons/BellPush.tsx
var import_jsx_dev_runtime7 = __toESM(require_jsx_dev_runtime()), SvgBellPush = (props) => /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: [
  /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)("path", { d: "M9 21h6M5.269 9.75A6.74 6.74 0 0 1 12.051 3c3.712.028 6.68 3.113 6.68 6.835v.665c0 3.358.703 5.306 1.322 6.371A.75.75 0 0 1 19.408 18H4.592a.749.749 0 0 1-.645-1.13c.62-1.064 1.322-3.013 1.322-6.37v-.75Z", stroke: "CurrentColor", strokeWidth: 1.44, strokeLinecap: "round", strokeLinejoin: "round" }, void 0, !1, {
    fileName: "app/components/common/Icons/BellPush.tsx",
    lineNumber: 4,
    columnNumber: 5
  }, this),
  /* @__PURE__ */ (0, import_jsx_dev_runtime7.jsxDEV)("circle", { cx: 19, cy: 6, r: 4, fill: "#BA2320" }, void 0, !1, {
    fileName: "app/components/common/Icons/BellPush.tsx",
    lineNumber: 5,
    columnNumber: 5
  }, this)
] }, void 0, !0, {
  fileName: "app/components/common/Icons/BellPush.tsx",
  lineNumber: 3,
  columnNumber: 57
}, this), BellPush_default = SvgBellPush;

// app/components/common/Icons/Close.tsx
var import_jsx_dev_runtime8 = __toESM(require_jsx_dev_runtime()), SvgClose = (props) => /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: /* @__PURE__ */ (0, import_jsx_dev_runtime8.jsxDEV)("path", { d: "M18 18 6 6M18 6 6 18", stroke: "CurrentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }, void 0, !1, {
  fileName: "app/components/common/Icons/Close.tsx",
  lineNumber: 4,
  columnNumber: 5
}, this) }, void 0, !1, {
  fileName: "app/components/common/Icons/Close.tsx",
  lineNumber: 3,
  columnNumber: 54
}, this), Close_default = SvgClose;

// app/components/common/Icons/Down.tsx
var import_jsx_dev_runtime9 = __toESM(require_jsx_dev_runtime()), SvgDown = (props) => /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: /* @__PURE__ */ (0, import_jsx_dev_runtime9.jsxDEV)("path", { d: "m19 9-7 7-7-7", stroke: "CurrentColor", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }, void 0, !1, {
  fileName: "app/components/common/Icons/Down.tsx",
  lineNumber: 4,
  columnNumber: 5
}, this) }, void 0, !1, {
  fileName: "app/components/common/Icons/Down.tsx",
  lineNumber: 3,
  columnNumber: 53
}, this), Down_default = SvgDown;

// app/components/common/Icons/Email.tsx
var import_jsx_dev_runtime10 = __toESM(require_jsx_dev_runtime()), SvgEmail = (props) => /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: /* @__PURE__ */ (0, import_jsx_dev_runtime10.jsxDEV)("path", { d: "m20.5 6-7.177 6.332a2 2 0 0 1-2.646 0L3.5 6M5 5.25h14a2 2 0 0 1 2 2v9.5a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-9.5a2 2 0 0 1 2-2Z", stroke: "CurrentColor", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }, void 0, !1, {
  fileName: "app/components/common/Icons/Email.tsx",
  lineNumber: 4,
  columnNumber: 5
}, this) }, void 0, !1, {
  fileName: "app/components/common/Icons/Email.tsx",
  lineNumber: 3,
  columnNumber: 54
}, this), Email_default = SvgEmail;

// app/components/common/Icons/Left.tsx
var import_jsx_dev_runtime11 = __toESM(require_jsx_dev_runtime()), SvgLeft = (props) => /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: /* @__PURE__ */ (0, import_jsx_dev_runtime11.jsxDEV)("path", { d: "m15 19-7-7 7-7", stroke: "CurrentColor", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }, void 0, !1, {
  fileName: "app/components/common/Icons/Left.tsx",
  lineNumber: 4,
  columnNumber: 5
}, this) }, void 0, !1, {
  fileName: "app/components/common/Icons/Left.tsx",
  lineNumber: 3,
  columnNumber: 53
}, this), Left_default = SvgLeft;

// app/components/common/Icons/LeftLine.tsx
var import_jsx_dev_runtime12 = __toESM(require_jsx_dev_runtime()), SvgLeftLine = (props) => /* @__PURE__ */ (0, import_jsx_dev_runtime12.jsxDEV)("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: /* @__PURE__ */ (0, import_jsx_dev_runtime12.jsxDEV)("path", { d: "M19 12H5m0 0 6 6m-6-6 6-6", stroke: "CurrentColor", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }, void 0, !1, {
  fileName: "app/components/common/Icons/LeftLine.tsx",
  lineNumber: 4,
  columnNumber: 5
}, this) }, void 0, !1, {
  fileName: "app/components/common/Icons/LeftLine.tsx",
  lineNumber: 3,
  columnNumber: 57
}, this), LeftLine_default = SvgLeftLine;

// app/components/common/Icons/Map.tsx
var import_jsx_dev_runtime13 = __toESM(require_jsx_dev_runtime()), SvgMap = (props) => /* @__PURE__ */ (0, import_jsx_dev_runtime13.jsxDEV)("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: [
  /* @__PURE__ */ (0, import_jsx_dev_runtime13.jsxDEV)("path", { d: "M5 9.923c0 4.852 4.244 8.864 6.123 10.402.27.22.405.332.606.388.156.044.386.044.542 0 .201-.056.336-.167.606-.388C14.756 18.787 19 14.775 19 9.923a6.885 6.885 0 0 0-2.05-4.895A7.04 7.04 0 0 0 12 3a7.04 7.04 0 0 0-4.95 2.028A6.884 6.884 0 0 0 5 9.923Z", stroke: "CurrentColor", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }, void 0, !1, {
    fileName: "app/components/common/Icons/Map.tsx",
    lineNumber: 4,
    columnNumber: 5
  }, this),
  /* @__PURE__ */ (0, import_jsx_dev_runtime13.jsxDEV)("path", { d: "M10 9a2 2 0 1 0 4 0 2 2 0 0 0-4 0Z", stroke: "CurrentColor", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }, void 0, !1, {
    fileName: "app/components/common/Icons/Map.tsx",
    lineNumber: 5,
    columnNumber: 5
  }, this)
] }, void 0, !0, {
  fileName: "app/components/common/Icons/Map.tsx",
  lineNumber: 3,
  columnNumber: 52
}, this), Map_default = SvgMap;

// app/components/common/Icons/Menu.tsx
var import_jsx_dev_runtime14 = __toESM(require_jsx_dev_runtime()), SvgMenu = (props) => /* @__PURE__ */ (0, import_jsx_dev_runtime14.jsxDEV)("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: /* @__PURE__ */ (0, import_jsx_dev_runtime14.jsxDEV)("path", { d: "M1 12h22M1 4h22M1 20h22", stroke: "CurrentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }, void 0, !1, {
  fileName: "app/components/common/Icons/Menu.tsx",
  lineNumber: 4,
  columnNumber: 5
}, this) }, void 0, !1, {
  fileName: "app/components/common/Icons/Menu.tsx",
  lineNumber: 3,
  columnNumber: 53
}, this), Menu_default = SvgMenu;

// app/components/common/Icons/Pensil.tsx
var import_jsx_dev_runtime15 = __toESM(require_jsx_dev_runtime()), SvgPensil = (props) => /* @__PURE__ */ (0, import_jsx_dev_runtime15.jsxDEV)("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: /* @__PURE__ */ (0, import_jsx_dev_runtime15.jsxDEV)("path", { d: "M4 20h4L19.293 8.707a1 1 0 0 0 0-1.414l-2.586-2.586a1 1 0 0 0-1.414 0L4 16v4ZM12 8l4 4", stroke: "CurrentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" }, void 0, !1, {
  fileName: "app/components/common/Icons/Pensil.tsx",
  lineNumber: 4,
  columnNumber: 5
}, this) }, void 0, !1, {
  fileName: "app/components/common/Icons/Pensil.tsx",
  lineNumber: 3,
  columnNumber: 55
}, this), Pensil_default = SvgPensil;

// app/components/common/Icons/Right.tsx
var import_jsx_dev_runtime16 = __toESM(require_jsx_dev_runtime()), SvgRight = (props) => /* @__PURE__ */ (0, import_jsx_dev_runtime16.jsxDEV)("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: /* @__PURE__ */ (0, import_jsx_dev_runtime16.jsxDEV)("path", { d: "m9 5 7 7-7 7", stroke: "CurrentColor", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }, void 0, !1, {
  fileName: "app/components/common/Icons/Right.tsx",
  lineNumber: 4,
  columnNumber: 5
}, this) }, void 0, !1, {
  fileName: "app/components/common/Icons/Right.tsx",
  lineNumber: 3,
  columnNumber: 54
}, this), Right_default = SvgRight;

// app/components/common/Icons/Search.tsx
var import_jsx_dev_runtime17 = __toESM(require_jsx_dev_runtime()), SvgSearch = (props) => /* @__PURE__ */ (0, import_jsx_dev_runtime17.jsxDEV)("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: /* @__PURE__ */ (0, import_jsx_dev_runtime17.jsxDEV)("path", { d: "m15 15 6 6m-11-4a7 7 0 1 1 0-14 7 7 0 0 1 0 14Z", stroke: "CurrentColor", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }, void 0, !1, {
  fileName: "app/components/common/Icons/Search.tsx",
  lineNumber: 4,
  columnNumber: 5
}, this) }, void 0, !1, {
  fileName: "app/components/common/Icons/Search.tsx",
  lineNumber: 3,
  columnNumber: 55
}, this), Search_default = SvgSearch;

// app/components/common/Icons/Show.tsx
var import_jsx_dev_runtime18 = __toESM(require_jsx_dev_runtime()), SvgShow = (props) => /* @__PURE__ */ (0, import_jsx_dev_runtime18.jsxDEV)("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: [
  /* @__PURE__ */ (0, import_jsx_dev_runtime18.jsxDEV)("path", { d: "M3.587 13.779c1.78 1.769 4.883 4.22 8.413 4.22 3.53 0 6.634-2.451 8.413-4.22.47-.467.705-.7.854-1.159.107-.327.107-.913 0-1.24-.15-.458-.385-.692-.854-1.159C18.633 8.452 15.531 6 12 6c-3.53 0-6.634 2.452-8.413 4.221-.47.467-.705.7-.854 1.159-.107.327-.107.913 0 1.24.15.458.384.692.854 1.159Z", stroke: "CurrentColor", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }, void 0, !1, {
    fileName: "app/components/common/Icons/Show.tsx",
    lineNumber: 4,
    columnNumber: 5
  }, this),
  /* @__PURE__ */ (0, import_jsx_dev_runtime18.jsxDEV)("path", { d: "M10 12a2 2 0 1 0 4 0 2 2 0 0 0-4 0Z", stroke: "CurrentColor", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }, void 0, !1, {
    fileName: "app/components/common/Icons/Show.tsx",
    lineNumber: 5,
    columnNumber: 5
  }, this)
] }, void 0, !0, {
  fileName: "app/components/common/Icons/Show.tsx",
  lineNumber: 3,
  columnNumber: 53
}, this), Show_default = SvgShow;

// app/components/common/Icons/Up.tsx
var import_jsx_dev_runtime19 = __toESM(require_jsx_dev_runtime()), SvgUp = (props) => /* @__PURE__ */ (0, import_jsx_dev_runtime19.jsxDEV)("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: /* @__PURE__ */ (0, import_jsx_dev_runtime19.jsxDEV)("path", { d: "m5 16 7-7 7 7", stroke: "CurrentColor", strokeWidth: 1.5, strokeLinecap: "round", strokeLinejoin: "round" }, void 0, !1, {
  fileName: "app/components/common/Icons/Up.tsx",
  lineNumber: 4,
  columnNumber: 5
}, this) }, void 0, !1, {
  fileName: "app/components/common/Icons/Up.tsx",
  lineNumber: 3,
  columnNumber: 51
}, this), Up_default = SvgUp;

// app/components/common/Icons/Google.tsx
var import_jsx_dev_runtime20 = __toESM(require_jsx_dev_runtime()), SvgGoogle = (props) => /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)("svg", { width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: [
  /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)("g", { clipPath: "url(#a)", children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)("path", { d: "M24 12.275c0-.815-.067-1.635-.211-2.438H12.24v4.621h6.613a5.55 5.55 0 0 1-2.448 3.647v2.998h3.946C22.669 19.013 24 15.926 24 12.275Z", fill: "#4285F4" }, void 0, !1, {
      fileName: "app/components/common/Icons/Google.tsx",
      lineNumber: 5,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)("path", { d: "M12.24 24c3.303 0 6.088-1.063 8.116-2.897l-3.945-2.998c-1.098.732-2.515 1.146-4.166 1.146-3.194 0-5.902-2.112-6.873-4.951H1.3v3.09C3.38 21.444 7.612 24 12.24 24Z", fill: "#34A853" }, void 0, !1, {
      fileName: "app/components/common/Icons/Google.tsx",
      lineNumber: 6,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)("path", { d: "M5.367 14.3a7.053 7.053 0 0 1 0-4.595V6.614H1.3a11.797 11.797 0 0 0 0 10.776l4.067-3.09Z", fill: "#FBBC04" }, void 0, !1, {
      fileName: "app/components/common/Icons/Google.tsx",
      lineNumber: 7,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)("path", { d: "M12.24 4.749a6.727 6.727 0 0 1 4.697 1.799l3.496-3.426A11.9 11.9 0 0 0 12.24 0C7.61 0 3.379 2.557 1.3 6.614l4.066 3.091c.967-2.844 3.68-4.956 6.874-4.956Z", fill: "#EA4335" }, void 0, !1, {
      fileName: "app/components/common/Icons/Google.tsx",
      lineNumber: 8,
      columnNumber: 7
    }, this)
  ] }, void 0, !0, {
    fileName: "app/components/common/Icons/Google.tsx",
    lineNumber: 4,
    columnNumber: 5
  }, this),
  /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)("defs", { children: /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)("clipPath", { id: "a", children: /* @__PURE__ */ (0, import_jsx_dev_runtime20.jsxDEV)("path", { fill: "#fff", d: "M0 0h24v24H0z" }, void 0, !1, {
    fileName: "app/components/common/Icons/Google.tsx",
    lineNumber: 12,
    columnNumber: 9
  }, this) }, void 0, !1, {
    fileName: "app/components/common/Icons/Google.tsx",
    lineNumber: 11,
    columnNumber: 7
  }, this) }, void 0, !1, {
    fileName: "app/components/common/Icons/Google.tsx",
    lineNumber: 10,
    columnNumber: 5
  }, this)
] }, void 0, !0, {
  fileName: "app/components/common/Icons/Google.tsx",
  lineNumber: 3,
  columnNumber: 55
}, this), Google_default = SvgGoogle;

// app/components/common/Icons/Fb.tsx
var import_jsx_dev_runtime21 = __toESM(require_jsx_dev_runtime()), SvgFb = (props) => /* @__PURE__ */ (0, import_jsx_dev_runtime21.jsxDEV)("svg", { width: 25, height: 24, viewBox: "0 0 25 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: [
  /* @__PURE__ */ (0, import_jsx_dev_runtime21.jsxDEV)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M24.5 12c0-6.627-5.373-12-12-12S.5 5.373.5 12c0 5.989 4.388 10.954 10.125 11.855V15.47H7.577V12h3.048V9.356c0-3.008 1.792-4.67 4.533-4.67 1.313 0 2.686.235 2.686.235v2.953h-1.513c-1.49 0-1.956.925-1.956 1.875v2.25h3.328l-.532 3.47h-2.796v8.386C20.112 22.955 24.5 17.99 24.5 12Z", fill: "#1977F3" }, void 0, !1, {
    fileName: "app/components/common/Icons/Fb.tsx",
    lineNumber: 4,
    columnNumber: 5
  }, this),
  /* @__PURE__ */ (0, import_jsx_dev_runtime21.jsxDEV)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "m17.171 15.47.532-3.47h-3.328V9.749c0-.949.464-1.875 1.956-1.875h1.514V4.921s-1.374-.235-2.687-.235c-2.74 0-4.533 1.66-4.533 4.67V12H7.578v3.47h3.047v8.385a12.27 12.27 0 0 0 3.75 0V15.47h2.796Z", fill: "#fff" }, void 0, !1, {
    fileName: "app/components/common/Icons/Fb.tsx",
    lineNumber: 5,
    columnNumber: 5
  }, this)
] }, void 0, !0, {
  fileName: "app/components/common/Icons/Fb.tsx",
  lineNumber: 3,
  columnNumber: 51
}, this), Fb_default = SvgFb;

// app/components/common/Icon/index.tsx
var import_jsx_dev_runtime22 = __toESM(require_jsx_dev_runtime());
function Icon({
  name,
  color: color2,
  size,
  container = {},
  className
}) {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime22.jsxDEV)(Box, { display: "inline-flex", ...container, children: /* @__PURE__ */ (0, import_jsx_dev_runtime22.jsxDEV)(IconNamed, { name, color: color2, size, className }, void 0, !1, {
    fileName: "app/components/common/Icon/index.tsx",
    lineNumber: 40,
    columnNumber: 7
  }, this) }, void 0, !1, {
    fileName: "app/components/common/Icon/index.tsx",
    lineNumber: 36,
    columnNumber: 10
  }, this);
}
function IconNamed({
  name,
  color: color2,
  size = 24,
  className = ""
}) {
  let {
    theme
  } = useApp(), props = {
    width: size,
    height: size,
    color: color2 || theme.defaultTextColor,
    className
  };
  switch (name) {
    case IconEnum.bell:
      return /* @__PURE__ */ (0, import_jsx_dev_runtime22.jsxDEV)(Bell_default, { ...props }, void 0, !1, {
        fileName: "app/components/common/Icon/index.tsx",
        lineNumber: 60,
        columnNumber: 14
      }, this);
    case IconEnum.bellPush:
      return /* @__PURE__ */ (0, import_jsx_dev_runtime22.jsxDEV)(BellPush_default, { ...props }, void 0, !1, {
        fileName: "app/components/common/Icon/index.tsx",
        lineNumber: 62,
        columnNumber: 14
      }, this);
    case IconEnum.close:
      return /* @__PURE__ */ (0, import_jsx_dev_runtime22.jsxDEV)(Close_default, { ...props }, void 0, !1, {
        fileName: "app/components/common/Icon/index.tsx",
        lineNumber: 64,
        columnNumber: 14
      }, this);
    case IconEnum.down:
      return /* @__PURE__ */ (0, import_jsx_dev_runtime22.jsxDEV)(Down_default, { ...props }, void 0, !1, {
        fileName: "app/components/common/Icon/index.tsx",
        lineNumber: 66,
        columnNumber: 14
      }, this);
    case IconEnum.email:
      return /* @__PURE__ */ (0, import_jsx_dev_runtime22.jsxDEV)(Email_default, { ...props }, void 0, !1, {
        fileName: "app/components/common/Icon/index.tsx",
        lineNumber: 68,
        columnNumber: 14
      }, this);
    case IconEnum.emailPush:
      return /* @__PURE__ */ (0, import_jsx_dev_runtime22.jsxDEV)(Email_default, { ...props }, void 0, !1, {
        fileName: "app/components/common/Icon/index.tsx",
        lineNumber: 70,
        columnNumber: 14
      }, this);
    case IconEnum.left:
      return /* @__PURE__ */ (0, import_jsx_dev_runtime22.jsxDEV)(Left_default, { ...props }, void 0, !1, {
        fileName: "app/components/common/Icon/index.tsx",
        lineNumber: 72,
        columnNumber: 14
      }, this);
    case IconEnum.leftLine:
      return /* @__PURE__ */ (0, import_jsx_dev_runtime22.jsxDEV)(LeftLine_default, { ...props }, void 0, !1, {
        fileName: "app/components/common/Icon/index.tsx",
        lineNumber: 74,
        columnNumber: 14
      }, this);
    case IconEnum.map:
      return /* @__PURE__ */ (0, import_jsx_dev_runtime22.jsxDEV)(Map_default, { ...props }, void 0, !1, {
        fileName: "app/components/common/Icon/index.tsx",
        lineNumber: 76,
        columnNumber: 14
      }, this);
    case IconEnum.menu:
      return /* @__PURE__ */ (0, import_jsx_dev_runtime22.jsxDEV)(Menu_default, { ...props }, void 0, !1, {
        fileName: "app/components/common/Icon/index.tsx",
        lineNumber: 78,
        columnNumber: 14
      }, this);
    case IconEnum.pensil:
      return /* @__PURE__ */ (0, import_jsx_dev_runtime22.jsxDEV)(Pensil_default, { ...props }, void 0, !1, {
        fileName: "app/components/common/Icon/index.tsx",
        lineNumber: 80,
        columnNumber: 14
      }, this);
    case IconEnum.right:
      return /* @__PURE__ */ (0, import_jsx_dev_runtime22.jsxDEV)(Right_default, { ...props }, void 0, !1, {
        fileName: "app/components/common/Icon/index.tsx",
        lineNumber: 82,
        columnNumber: 14
      }, this);
    case IconEnum.rightLine:
      return /* @__PURE__ */ (0, import_jsx_dev_runtime22.jsxDEV)(Right_default, { ...props }, void 0, !1, {
        fileName: "app/components/common/Icon/index.tsx",
        lineNumber: 84,
        columnNumber: 14
      }, this);
    case IconEnum.search:
      return /* @__PURE__ */ (0, import_jsx_dev_runtime22.jsxDEV)(Search_default, { ...props }, void 0, !1, {
        fileName: "app/components/common/Icon/index.tsx",
        lineNumber: 86,
        columnNumber: 14
      }, this);
    case IconEnum.show:
      return /* @__PURE__ */ (0, import_jsx_dev_runtime22.jsxDEV)(Show_default, { ...props }, void 0, !1, {
        fileName: "app/components/common/Icon/index.tsx",
        lineNumber: 88,
        columnNumber: 14
      }, this);
    case IconEnum.up:
      return /* @__PURE__ */ (0, import_jsx_dev_runtime22.jsxDEV)(Up_default, { ...props }, void 0, !1, {
        fileName: "app/components/common/Icon/index.tsx",
        lineNumber: 90,
        columnNumber: 14
      }, this);
    case IconEnum.google:
      return /* @__PURE__ */ (0, import_jsx_dev_runtime22.jsxDEV)(Google_default, { ...props }, void 0, !1, {
        fileName: "app/components/common/Icon/index.tsx",
        lineNumber: 92,
        columnNumber: 14
      }, this);
    case IconEnum.fb:
      return /* @__PURE__ */ (0, import_jsx_dev_runtime22.jsxDEV)(Fb_default, { ...props }, void 0, !1, {
        fileName: "app/components/common/Icon/index.tsx",
        lineNumber: 94,
        columnNumber: 14
      }, this);
    default:
      return /* @__PURE__ */ (0, import_jsx_dev_runtime22.jsxDEV)(import_jsx_dev_runtime22.Fragment, {}, void 0, !1, {
        fileName: "app/components/common/Icon/index.tsx",
        lineNumber: 96,
        columnNumber: 14
      }, this);
  }
}

// app/components/common/Button/index.tsx
var import_jsx_dev_runtime23 = __toESM(require_jsx_dev_runtime()), ButtonComponent = ({
  className,
  size = ButtonSizeEnum.S,
  color: color2 = ButtonColorEnum.blue,
  priority = ButtonPriorityEnum.primary,
  children,
  disabled,
  iconName,
  iconColor,
  iconSize,
  fullwidth,
  ...other
}) => /* @__PURE__ */ (0, import_jsx_dev_runtime23.jsxDEV)(Button, { priority, className, size, color: color2, disabled, iconName, fullwidth, ...other, children: [
  iconName && /* @__PURE__ */ (0, import_jsx_dev_runtime23.jsxDEV)(Icon, { name: iconName, color: iconColor, size: iconSize }, void 0, !1, {
    fileName: "app/components/common/Button/index.tsx",
    lineNumber: 33,
    columnNumber: 20
  }, this),
  children
] }, void 0, !0, {
  fileName: "app/components/common/Button/index.tsx",
  lineNumber: 32,
  columnNumber: 10
}, this), Button_default = ButtonComponent;

// app/components/lib/Footer/index.tsx
var import_react16 = __toESM(require_react());

// app/components/lib/Footer/styles.ts
var WrapperFooter = styled_components_esm_default.div`
  width: 100%;
  background-color: ${({ theme }) => theme.footer.wrapperHeaderBackgroundColor};
  display: flex;
  justify-content: center;
`, ContainerFooter = styled_components_esm_default.div`
  display: flex;
  position: relative;
  flex-direction: column;
  justify-content: space-between;
  padding: 42px 16px;
  width: 100%;
  gap: 18px;
  max-width: 1200px;
  border-top: 1px solid ${({ theme }) => theme.footer.borderColor};
`, LinksWrapper = styled_components_esm_default.div`
  display: flex;
  flex-direction: row;
  flex-wrap: wrap;
  justify-content: center;
  gap: 48px;
  row-gap: 18px;

  @media (min-width: 768px) {
    justify-content: flex-start;
    span {
      font-size: 18px;
      line-height: 27px;
    }
  }
`, Link3 = styled_components_esm_default.a`
  cursor: pointer;
  span:hover {
    color: ${({ theme }) => theme.footer.linkSpanColor};
  }
  @media (min-width: 1024px) {
    span {
      color: ${({ theme }) => theme.footer.linkSpanColorMedia1024};
    }
  }
`, IconsWrapper = styled_components_esm_default.div`
  display: flex;
  flex-direction: row;
  justify-content: center;
  gap: 36px;

  img {
    width: 20px;
    transition: all 0.15s ease-in;
  }

  @media (min-width: 768px) {
    justify-content: flex-start;
    gap: 48px;
  }

  @media (min-width: 1024px) {
    position: absolute;
    right: 16px;
    margin-top: 4px;
  }
`, SosialImg = styled_components_esm_default.a`
  cursor: pointer;

  img:hover {
    transform: scale(1.05);
  }
`, BoxCopiright = styled_components_esm_default.div`
  display: flex;
  justify-content: center;

  @media (min-width: 768px) {
    justify-content: flex-start;
  }
  @media (min-width: 1024) {
    justify-content: flex-start;
    span {
      font-size: 16px;
      color: ${({ theme }) => theme.footer.boxCopirightSpanColorMedia1024};
    }
  }
`;

// app/components/lib/Footer/index.tsx
var import_jsx_dev_runtime24 = __toESM(require_jsx_dev_runtime()), Footer = (0, import_react16.memo)(function() {
  let {
    theme,
    t: t4
  } = useApp(), navlinks = [{
    id: "1",
    title: `${t4("menu.about")}`,
    href: "#"
  }, {
    id: "2",
    title: `${t4("menu.privacy_policy")}`,
    href: "#"
  }, {
    id: "3",
    title: `${t4("menu.articles")}`,
    href: "#"
  }, {
    id: "4",
    title: `${t4("menu.faq")}`,
    href: "#"
  }, {
    id: "5",
    title: `${t4("menu.news")}`,
    href: "#"
  }, {
    id: "6",
    title: `${t4("menu.help")}`,
    href: "#"
  }];
  return /* @__PURE__ */ (0, import_jsx_dev_runtime24.jsxDEV)(WrapperFooter, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime24.jsxDEV)(ContainerFooter, { children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime24.jsxDEV)(LinksWrapper, { children: navlinks.map(({
      href,
      id: id4,
      title: title2
    }) => /* @__PURE__ */ (0, import_jsx_dev_runtime24.jsxDEV)(Link3, { href, children: /* @__PURE__ */ (0, import_jsx_dev_runtime24.jsxDEV)(Text, { color: theme.footer.linkTextColor, children: title2 }, void 0, !1, {
      fileName: "app/components/lib/Footer/index.tsx",
      lineNumber: 51,
      columnNumber: 15
    }, this) }, id4, !1, {
      fileName: "app/components/lib/Footer/index.tsx",
      lineNumber: 50,
      columnNumber: 15
    }, this)) }, void 0, !1, {
      fileName: "app/components/lib/Footer/index.tsx",
      lineNumber: 45,
      columnNumber: 9
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime24.jsxDEV)(IconsWrapper, { children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime24.jsxDEV)(SosialImg, { href: "#", children: /* @__PURE__ */ (0, import_jsx_dev_runtime24.jsxDEV)("img", { src: "images/social/ln.jpg", alt: "line" }, void 0, !1, {
        fileName: "app/components/lib/Footer/index.tsx",
        lineNumber: 56,
        columnNumber: 13
      }, this) }, void 0, !1, {
        fileName: "app/components/lib/Footer/index.tsx",
        lineNumber: 55,
        columnNumber: 11
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime24.jsxDEV)(SosialImg, { href: "#", children: /* @__PURE__ */ (0, import_jsx_dev_runtime24.jsxDEV)("img", { src: "images/social/fb.jpg", alt: "facebook" }, void 0, !1, {
        fileName: "app/components/lib/Footer/index.tsx",
        lineNumber: 59,
        columnNumber: 13
      }, this) }, void 0, !1, {
        fileName: "app/components/lib/Footer/index.tsx",
        lineNumber: 58,
        columnNumber: 11
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime24.jsxDEV)(SosialImg, { href: "#", children: /* @__PURE__ */ (0, import_jsx_dev_runtime24.jsxDEV)("img", { src: "images/social/in.jpg", alt: "instagram" }, void 0, !1, {
        fileName: "app/components/lib/Footer/index.tsx",
        lineNumber: 62,
        columnNumber: 13
      }, this) }, void 0, !1, {
        fileName: "app/components/lib/Footer/index.tsx",
        lineNumber: 61,
        columnNumber: 11
      }, this)
    ] }, void 0, !0, {
      fileName: "app/components/lib/Footer/index.tsx",
      lineNumber: 54,
      columnNumber: 9
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime24.jsxDEV)(BoxCopiright, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime24.jsxDEV)(Text, { color: theme.footer.linkTextColor, children: t4("copyright") }, void 0, !1, {
      fileName: "app/components/lib/Footer/index.tsx",
      lineNumber: 66,
      columnNumber: 11
    }, this) }, void 0, !1, {
      fileName: "app/components/lib/Footer/index.tsx",
      lineNumber: 65,
      columnNumber: 9
    }, this)
  ] }, void 0, !0, {
    fileName: "app/components/lib/Footer/index.tsx",
    lineNumber: 44,
    columnNumber: 7
  }, this) }, void 0, !1, {
    fileName: "app/components/lib/Footer/index.tsx",
    lineNumber: 43,
    columnNumber: 10
  }, this);
});

// app/components/lib/Navbar/index.tsx
init_esm2();
var import_react44 = __toESM(require_react());

// app/components/common/Icons/Logo.tsx
var import_jsx_dev_runtime25 = __toESM(require_jsx_dev_runtime()), SvgLogo = (props) => /* @__PURE__ */ (0, import_jsx_dev_runtime25.jsxDEV)("svg", { width: 118, height: 48, viewBox: "0 0 118 48", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: /* @__PURE__ */ (0, import_jsx_dev_runtime25.jsxDEV)("path", { d: "M63.941 7.011v.821c0 5.199.02 10.4 0 15.598-.022 4.438-2.043 7.69-6.007 9.676-1.135.569-2.683.804-4.045.795l-.014-3.31c1.981-.05 4.421-1.303 5.605-3.056a6.42 6.42 0 0 0 1.163-3.628V10.315h-6.776V7c3.147.013 6.798.011 10.074.011ZM79.075 13.725c-2.013 0-3.98.592-5.653 1.7a10.107 10.107 0 0 0-3.748 4.528 10.008 10.008 0 0 0-.578 5.83 10.062 10.062 0 0 0 2.785 5.164 10.203 10.203 0 0 0 5.21 2.76c1.974.39 4.02.19 5.88-.574a10.157 10.157 0 0 0 4.565-3.717 10.026 10.026 0 0 0 1.714-5.605c0-2.675-1.073-5.24-2.981-7.132a10.22 10.22 0 0 0-7.194-2.954Zm0 16.93a6.982 6.982 0 0 1-3.856-1.158 6.893 6.893 0 0 1-2.557-3.087 6.825 6.825 0 0 1-.395-3.976 6.861 6.861 0 0 1 1.899-3.523 6.958 6.958 0 0 1 3.553-1.883 6.995 6.995 0 0 1 4.01.392 6.926 6.926 0 0 1 3.114 2.535 6.838 6.838 0 0 1 .642 6.456 6.872 6.872 0 0 1-1.503 2.233 6.94 6.94 0 0 1-2.251 1.492 6.989 6.989 0 0 1-2.656.524v-.004ZM7.117 7H4v4.857h3.117V7ZM23.983 7h-3.117v4.857h3.117V7ZM20.862 23.751a6.893 6.893 0 0 1-2.01 4.868 6.856 6.856 0 0 1-9.71 0 6.893 6.893 0 0 1-2.01-4.868v-3.3H4v3.5c.108 5.502 4.539 9.95 9.993 9.95 5.454 0 9.876-4.437 9.99-9.95v-3.5h-3.12v3.3ZM104.367 13.598a9.98 9.98 0 0 0-3.984.634 10.035 10.035 0 0 0-3.415 2.16V7h-3.135v16.828c.016 1.986.61 3.923 1.708 5.573a10.102 10.102 0 0 0 4.469 3.707c1.818.77 3.82.985 5.758.62a10.062 10.062 0 0 0 5.147-2.672 10.181 10.181 0 0 0 2.839-5.083 10.22 10.22 0 0 0-.405-5.818 10.152 10.152 0 0 0-3.515-4.634 10.038 10.038 0 0 0-5.467-1.923Zm-.523 17.05a6.846 6.846 0 0 1-3.822-1.168 6.92 6.92 0 0 1-2.533-3.11 6.975 6.975 0 0 1-.391-4.002 6.944 6.944 0 0 1 1.882-3.548 6.865 6.865 0 0 1 3.522-1.896 6.832 6.832 0 0 1 3.974.395 6.89 6.89 0 0 1 3.087 2.551 6.962 6.962 0 0 1-.857 8.745 6.854 6.854 0 0 1-4.862 2.028v.005ZM40.48 13.725a9.974 9.974 0 0 0-7.097 2.986 10.413 10.413 0 0 0-2.983 7.226V41h3.136v-9.517a10.03 10.03 0 0 0 4.233 2.458 9.874 9.874 0 0 0 4.867.145 9.998 9.998 0 0 0 4.366-2.204 10.295 10.295 0 0 0 2.845-4.037c.611-1.563.838-3.255.661-4.929a10.437 10.437 0 0 0-1.678-4.67 10.157 10.157 0 0 0-3.624-3.322 9.909 9.909 0 0 0-4.726-1.199Zm-.077 17.356a6.773 6.773 0 0 1-3.816-1.19 6.995 6.995 0 0 1-2.527-3.156 7.167 7.167 0 0 1-.386-4.058 7.073 7.073 0 0 1 1.885-3.594 6.832 6.832 0 0 1 3.52-1.919 6.74 6.74 0 0 1 3.971.402 6.91 6.91 0 0 1 3.084 2.588 7.135 7.135 0 0 1 1.158 3.901c.001.924-.176 1.838-.522 2.692a7.035 7.035 0 0 1-1.491 2.281 6.866 6.866 0 0 1-2.233 1.524 6.746 6.746 0 0 1-2.634.533l-.009-.004Z", fill: "CurrentColor" }, void 0, !1, {
  fileName: "app/components/common/Icons/Logo.tsx",
  lineNumber: 4,
  columnNumber: 5
}, this) }, void 0, !1, {
  fileName: "app/components/common/Icons/Logo.tsx",
  lineNumber: 3,
  columnNumber: 53
}, this), Logo_default = SvgLogo;

// app/components/common/Switcher/index.tsx
var import_jsx_dev_runtime26 = __toESM(require_jsx_dev_runtime()), Wrapper = styled_components_esm_default.div.withConfig({
  displayName: "Switcher__Wrapper",
  componentId: "sc-1ma1kbj-0"
})(["width:max-content;height:max-content;"]), Switch = styled_components_esm_default.label.withConfig({
  displayName: "Switcher__Switch",
  componentId: "sc-1ma1kbj-1"
})(["background:#ccc;display:block;border-radius:20px;position:relative;cursor:pointer;transition:background-color 0.2s ease-in;width:56px;height:32px;&::after{content:'';display:block;position:absolute;background:var(--white);border-radius:50%;left:4px;top:4px;width:24px;height:24px;transition:left 0.15s ease-in;left:", ";background:", ";background-position:center;background-size:cover;background-repeat:no-repeat;}"], ({
  checked: checked2
}) => checked2 && "28px", ({
  checked: checked2
}) => checked2 ? "url('images/flags/English.png')" : "url('images/flags/Thailand.png')"), Checkbox = styled_components_esm_default.input.withConfig({
  displayName: "Switcher__Checkbox",
  componentId: "sc-1ma1kbj-2"
})(["visibility:hidden;display:none;"]);
function Switcher({
  checked: checked2,
  onChange,
  htmlLabel,
  label,
  disabled
}) {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime26.jsxDEV)(Wrapper, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime26.jsxDEV)(Switch, { checked: checked2, htmlFor: htmlLabel, title: label, children: /* @__PURE__ */ (0, import_jsx_dev_runtime26.jsxDEV)(Checkbox, { disabled, id: htmlLabel, type: "checkbox", ...{
    onChange: (ev) => {
      onChange ? onChange(!ev.target.checked) : console.log(!ev.target.checked);
    }
  } }, void 0, !1, {
    fileName: "app/components/common/Switcher/index.tsx",
    lineNumber: 45,
    columnNumber: 9
  }, this) }, void 0, !1, {
    fileName: "app/components/common/Switcher/index.tsx",
    lineNumber: 44,
    columnNumber: 7
  }, this) }, void 0, !1, {
    fileName: "app/components/common/Switcher/index.tsx",
    lineNumber: 43,
    columnNumber: 10
  }, this);
}

// app/components/lib/Navbar/styles.ts
var WrapperHeader = styled_components_esm_default.div`
  width: 100%;
  background-color: ${({ theme }) => theme.navbar.wrapperHeaderBackgroundColor};
  display: flex;
  justify-content: center;
`, ContainerHeader = styled_components_esm_default.div`
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  padding: 22px 20px;
  width: 100%;
  @media (min-width: 1024px) {
    padding: 22px 40px;
  }
`, LogoWrapper = styled_components_esm_default.div`
  cursor: pointer;
  svg {
    max-width: 99px;
    height: 40px;
    transition: all 0.15s ease-in;
  }

  &:hover {
    svg {
      color: ${({ theme }) => theme.navbar.hoverColor};
    }
  }
`, BoxText = styled_components_esm_default.div`
  cursor: pointer;
  span:hover {
    color: ${({ lang, selectedLang, theme }) => lang !== selectedLang ? theme.navbar.hoverColor : theme.navbar.noHoverColor};
  }
`, MenuContainer = styled_components_esm_default.div`
  display: flex;
  flex-direction: row;
  gap: 25px;
`, LeftContainer = styled_components_esm_default.div`
  display: flex;
  flex-direction: row;
  gap: 25px;
`, TranslateBox = styled_components_esm_default.div`
  flex-direction: row;
  align-items: center;
  gap: 16px;
  display: none;
  @media (min-width: 768px) {
    display: flex;
  }
`, IconButton = styled_components_esm_default.button`
  cursor: pointer;
  transition: all 0.15s ease-in;
  &:hover {
    svg {
      color: ${({ theme }) => theme.navbar.hoverColor};
    }
  }
`, IconButtons = styled_components_esm_default.div`
  display: none;
  @media (min-width: 1024px) {
    display: flex;
    flex-direction: row;
    gap: 38px;
  }
`;

// app/components/pages/Auth/Login/index.tsx
var import_react41 = __toESM(require_react());
init_esm2();

// node_modules/framer-motion/dist/es/motion/index.mjs
var React8 = __toESM(require_react(), 1), import_react28 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/context/MotionConfigContext.mjs
var import_react17 = __toESM(require_react(), 1), MotionConfigContext = (0, import_react17.createContext)({
  transformPagePoint: (p) => p,
  isStatic: !1,
  reducedMotion: "never"
});

// node_modules/framer-motion/dist/es/context/MotionContext/index.mjs
var import_react18 = __toESM(require_react(), 1), MotionContext = (0, import_react18.createContext)({});

// node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs
var import_react22 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/context/PresenceContext.mjs
var import_react19 = __toESM(require_react(), 1), PresenceContext = (0, import_react19.createContext)(null);

// node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs
var import_react20 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/utils/is-browser.mjs
var isBrowser3 = typeof document < "u";

// node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs
var useIsomorphicLayoutEffect = isBrowser3 ? import_react20.useLayoutEffect : import_react20.useEffect;

// node_modules/framer-motion/dist/es/context/LazyContext.mjs
var import_react21 = __toESM(require_react(), 1), LazyContext = (0, import_react21.createContext)({ strict: !1 });

// node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs
function useVisualElement(Component3, visualState, props, createVisualElement) {
  let { visualElement: parent } = (0, import_react22.useContext)(MotionContext), lazyContext = (0, import_react22.useContext)(LazyContext), presenceContext = (0, import_react22.useContext)(PresenceContext), reducedMotionConfig = (0, import_react22.useContext)(MotionConfigContext).reducedMotion, visualElementRef = (0, import_react22.useRef)();
  createVisualElement = createVisualElement || lazyContext.renderer, !visualElementRef.current && createVisualElement && (visualElementRef.current = createVisualElement(Component3, {
    visualState,
    parent,
    props,
    presenceContext,
    blockInitialAnimation: presenceContext ? presenceContext.initial === !1 : !1,
    reducedMotionConfig
  }));
  let visualElement = visualElementRef.current;
  return (0, import_react22.useInsertionEffect)(() => {
    visualElement && visualElement.update(props, presenceContext);
  }), useIsomorphicLayoutEffect(() => {
    visualElement && visualElement.render();
  }), (0, import_react22.useEffect)(() => {
    visualElement && visualElement.updateFeatures();
  }), (window.HandoffAppearAnimations ? useIsomorphicLayoutEffect : import_react22.useEffect)(() => {
    visualElement && visualElement.animationState && visualElement.animationState.animateChanges();
  }), visualElement;
}

// node_modules/framer-motion/dist/es/motion/utils/use-motion-ref.mjs
var import_react23 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/utils/is-ref-object.mjs
function isRefObject(ref) {
  return typeof ref == "object" && Object.prototype.hasOwnProperty.call(ref, "current");
}

// node_modules/framer-motion/dist/es/motion/utils/use-motion-ref.mjs
function useMotionRef(visualState, visualElement, externalRef) {
  return (0, import_react23.useCallback)(
    (instance2) => {
      instance2 && visualState.mount && visualState.mount(instance2), visualElement && (instance2 ? visualElement.mount(instance2) : visualElement.unmount()), externalRef && (typeof externalRef == "function" ? externalRef(instance2) : isRefObject(externalRef) && (externalRef.current = instance2));
    },
    [visualElement]
  );
}

// node_modules/framer-motion/dist/es/context/MotionContext/create.mjs
var import_react24 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/render/utils/is-variant-label.mjs
function isVariantLabel(v2) {
  return typeof v2 == "string" || Array.isArray(v2);
}

// node_modules/framer-motion/dist/es/animation/utils/is-animation-controls.mjs
function isAnimationControls(v2) {
  return typeof v2 == "object" && typeof v2.start == "function";
}

// node_modules/framer-motion/dist/es/render/utils/variant-props.mjs
var variantPriorityOrder = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
], variantProps = ["initial", ...variantPriorityOrder];

// node_modules/framer-motion/dist/es/render/utils/is-controlling-variants.mjs
function isControllingVariants(props) {
  return isAnimationControls(props.animate) || variantProps.some((name) => isVariantLabel(props[name]));
}
function isVariantNode(props) {
  return Boolean(isControllingVariants(props) || props.variants);
}

// node_modules/framer-motion/dist/es/context/MotionContext/utils.mjs
function getCurrentTreeVariants(props, context) {
  if (isControllingVariants(props)) {
    let { initial, animate } = props;
    return {
      initial: initial === !1 || isVariantLabel(initial) ? initial : void 0,
      animate: isVariantLabel(animate) ? animate : void 0
    };
  }
  return props.inherit !== !1 ? context : {};
}

// node_modules/framer-motion/dist/es/context/MotionContext/create.mjs
function useCreateMotionContext(props) {
  let { initial, animate } = getCurrentTreeVariants(props, (0, import_react24.useContext)(MotionContext));
  return (0, import_react24.useMemo)(() => ({ initial, animate }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);
}
function variantLabelsAsDependency(prop) {
  return Array.isArray(prop) ? prop.join(" ") : prop;
}

// node_modules/framer-motion/dist/es/motion/features/definitions.mjs
var featureProps = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
}, featureDefinitions = {};
for (let key2 in featureProps)
  featureDefinitions[key2] = {
    isEnabled: (props) => featureProps[key2].some((name) => !!props[name])
  };

// node_modules/framer-motion/dist/es/motion/features/load-features.mjs
function loadFeatures(features) {
  for (let key2 in features)
    featureDefinitions[key2] = {
      ...featureDefinitions[key2],
      ...features[key2]
    };
}

// node_modules/framer-motion/dist/es/utils/use-constant.mjs
var import_react25 = __toESM(require_react(), 1);
function useConstant(init4) {
  let ref = (0, import_react25.useRef)(null);
  return ref.current === null && (ref.current = init4()), ref.current;
}

// node_modules/framer-motion/dist/es/projection/node/state.mjs
var globalProjectionState = {
  hasAnimatedSinceResize: !0,
  hasEverUpdated: !1
};

// node_modules/framer-motion/dist/es/projection/node/id.mjs
var id = 1;
function useProjectionId() {
  return useConstant(() => {
    if (globalProjectionState.hasEverUpdated)
      return id++;
  });
}

// node_modules/framer-motion/dist/es/context/LayoutGroupContext.mjs
var import_react26 = __toESM(require_react(), 1), LayoutGroupContext = (0, import_react26.createContext)({});

// node_modules/framer-motion/dist/es/context/SwitchLayoutGroupContext.mjs
var import_react27 = __toESM(require_react(), 1), SwitchLayoutGroupContext = (0, import_react27.createContext)({});

// node_modules/framer-motion/dist/es/motion/utils/symbol.mjs
var motionComponentSymbol = Symbol.for("motionComponentSymbol");

// node_modules/framer-motion/dist/es/motion/index.mjs
function createMotionComponent({ preloadedFeatures: preloadedFeatures2, createVisualElement, useRender, useVisualState, Component: Component3 }) {
  preloadedFeatures2 && loadFeatures(preloadedFeatures2);
  function MotionComponent(props, externalRef) {
    let MeasureLayout2, configAndProps = {
      ...(0, import_react28.useContext)(MotionConfigContext),
      ...props,
      layoutId: useLayoutId(props)
    }, { isStatic } = configAndProps, context = useCreateMotionContext(props), projectionId = isStatic ? void 0 : useProjectionId(), visualState = useVisualState(props, isStatic);
    if (!isStatic && isBrowser3) {
      context.visualElement = useVisualElement(Component3, visualState, configAndProps, createVisualElement);
      let initialLayoutGroupConfig = (0, import_react28.useContext)(SwitchLayoutGroupContext), isStrict = (0, import_react28.useContext)(LazyContext).strict;
      context.visualElement && (MeasureLayout2 = context.visualElement.loadFeatures(
        configAndProps,
        isStrict,
        preloadedFeatures2,
        projectionId,
        initialLayoutGroupConfig
      ));
    }
    return React8.createElement(
      MotionContext.Provider,
      { value: context },
      MeasureLayout2 && context.visualElement ? React8.createElement(MeasureLayout2, { visualElement: context.visualElement, ...configAndProps }) : null,
      useRender(Component3, props, projectionId, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement)
    );
  }
  let ForwardRefComponent = (0, import_react28.forwardRef)(MotionComponent);
  return ForwardRefComponent[motionComponentSymbol] = Component3, ForwardRefComponent;
}
function useLayoutId({ layoutId }) {
  let layoutGroupId = (0, import_react28.useContext)(LayoutGroupContext).id;
  return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
}

// node_modules/framer-motion/dist/es/render/dom/motion-proxy.mjs
function createMotionProxy(createConfig) {
  function custom(Component3, customMotionComponentConfig = {}) {
    return createMotionComponent(createConfig(Component3, customMotionComponentConfig));
  }
  if (typeof Proxy > "u")
    return custom;
  let componentCache = /* @__PURE__ */ new Map();
  return new Proxy(custom, {
    get: (_target, key2) => (componentCache.has(key2) || componentCache.set(key2, custom(key2)), componentCache.get(key2))
  });
}

// node_modules/framer-motion/dist/es/render/svg/lowercase-elements.mjs
var lowercaseSVGElements = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];

// node_modules/framer-motion/dist/es/render/dom/utils/is-svg-component.mjs
function isSVGComponent(Component3) {
  return typeof Component3 != "string" || Component3.includes("-") ? !1 : !!(lowercaseSVGElements.indexOf(Component3) > -1 || /[A-Z]/.test(Component3));
}

// node_modules/framer-motion/dist/es/render/dom/use-render.mjs
var import_react31 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/render/html/use-props.mjs
var import_react29 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/projection/styles/scale-correction.mjs
var scaleCorrectors = {};
function addScaleCorrector(correctors) {
  Object.assign(scaleCorrectors, correctors);
}

// node_modules/framer-motion/dist/es/render/html/utils/transform.mjs
var transformPropOrder = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
], transformProps = new Set(transformPropOrder);

// node_modules/framer-motion/dist/es/motion/utils/is-forced-motion-value.mjs
function isForcedMotionValue(key2, { layout: layout2, layoutId }) {
  return transformProps.has(key2) || key2.startsWith("origin") || (layout2 || layoutId !== void 0) && (!!scaleCorrectors[key2] || key2 === "opacity");
}

// node_modules/framer-motion/dist/es/value/utils/is-motion-value.mjs
var isMotionValue = (value2) => Boolean(value2 && value2.getVelocity);

// node_modules/framer-motion/dist/es/render/html/utils/build-transform.mjs
var translateAlias = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
}, numTransforms = transformPropOrder.length;
function buildTransform(transform, { enableHardwareAcceleration = !0, allowTransformNone = !0 }, transformIsDefault, transformTemplate) {
  let transformString = "";
  for (let i3 = 0; i3 < numTransforms; i3++) {
    let key2 = transformPropOrder[i3];
    if (transform[key2] !== void 0) {
      let transformName = translateAlias[key2] || key2;
      transformString += `${transformName}(${transform[key2]}) `;
    }
  }
  return enableHardwareAcceleration && !transform.z && (transformString += "translateZ(0)"), transformString = transformString.trim(), transformTemplate ? transformString = transformTemplate(transform, transformIsDefault ? "" : transformString) : allowTransformNone && transformIsDefault && (transformString = "none"), transformString;
}

// node_modules/framer-motion/dist/es/render/dom/utils/is-css-variable.mjs
var checkStringStartsWith = (token2) => (key2) => typeof key2 == "string" && key2.startsWith(token2), isCSSVariableName = checkStringStartsWith("--"), isCSSVariableToken = checkStringStartsWith("var(--");

// node_modules/framer-motion/dist/es/render/dom/value-types/get-as-type.mjs
var getValueAsType = (value2, type2) => type2 && typeof value2 == "number" ? type2.transform(value2) : value2;

// node_modules/framer-motion/dist/es/utils/clamp.mjs
var clamp = (min, max, v2) => Math.min(Math.max(v2, min), max);

// node_modules/framer-motion/dist/es/value/types/numbers/index.mjs
var number3 = {
  test: (v2) => typeof v2 == "number",
  parse: parseFloat,
  transform: (v2) => v2
}, alpha = {
  ...number3,
  transform: (v2) => clamp(0, 1, v2)
}, scale = {
  ...number3,
  default: 1
};

// node_modules/framer-motion/dist/es/value/types/utils.mjs
var sanitize = (v2) => Math.round(v2 * 1e5) / 1e5, floatRegex = /(-)?([\d]*\.?[\d])+/g, colorRegex = /(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi, singleColorRegex = /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;
function isString2(v2) {
  return typeof v2 == "string";
}

// node_modules/framer-motion/dist/es/value/types/numbers/units.mjs
var createUnitType = (unit) => ({
  test: (v2) => isString2(v2) && v2.endsWith(unit) && v2.split(" ").length === 1,
  parse: parseFloat,
  transform: (v2) => `${v2}${unit}`
}), degrees = createUnitType("deg"), percent = createUnitType("%"), px = createUnitType("px"), vh = createUnitType("vh"), vw = createUnitType("vw"), progressPercentage = {
  ...percent,
  parse: (v2) => percent.parse(v2) / 100,
  transform: (v2) => percent.transform(v2 * 100)
};

// node_modules/framer-motion/dist/es/render/dom/value-types/type-int.mjs
var int2 = {
  ...number3,
  transform: Math.round
};

// node_modules/framer-motion/dist/es/render/dom/value-types/number.mjs
var numberValueTypes = {
  borderWidth: px,
  borderTopWidth: px,
  borderRightWidth: px,
  borderBottomWidth: px,
  borderLeftWidth: px,
  borderRadius: px,
  radius: px,
  borderTopLeftRadius: px,
  borderTopRightRadius: px,
  borderBottomRightRadius: px,
  borderBottomLeftRadius: px,
  width: px,
  maxWidth: px,
  height: px,
  maxHeight: px,
  size: px,
  top: px,
  right: px,
  bottom: px,
  left: px,
  padding: px,
  paddingTop: px,
  paddingRight: px,
  paddingBottom: px,
  paddingLeft: px,
  margin: px,
  marginTop: px,
  marginRight: px,
  marginBottom: px,
  marginLeft: px,
  rotate: degrees,
  rotateX: degrees,
  rotateY: degrees,
  rotateZ: degrees,
  scale,
  scaleX: scale,
  scaleY: scale,
  scaleZ: scale,
  skew: degrees,
  skewX: degrees,
  skewY: degrees,
  distance: px,
  translateX: px,
  translateY: px,
  translateZ: px,
  x: px,
  y: px,
  z: px,
  perspective: px,
  transformPerspective: px,
  opacity: alpha,
  originX: progressPercentage,
  originY: progressPercentage,
  originZ: px,
  zIndex: int2,
  fillOpacity: alpha,
  strokeOpacity: alpha,
  numOctaves: int2
};

// node_modules/framer-motion/dist/es/render/html/utils/build-styles.mjs
function buildHTMLStyles(state, latestValues, options2, transformTemplate) {
  let { style, vars, transform, transformOrigin } = state, hasTransform2 = !1, hasTransformOrigin = !1, transformIsNone = !0;
  for (let key2 in latestValues) {
    let value2 = latestValues[key2];
    if (isCSSVariableName(key2)) {
      vars[key2] = value2;
      continue;
    }
    let valueType = numberValueTypes[key2], valueAsType = getValueAsType(value2, valueType);
    if (transformProps.has(key2)) {
      if (hasTransform2 = !0, transform[key2] = valueAsType, !transformIsNone)
        continue;
      value2 !== (valueType.default || 0) && (transformIsNone = !1);
    } else
      key2.startsWith("origin") ? (hasTransformOrigin = !0, transformOrigin[key2] = valueAsType) : style[key2] = valueAsType;
  }
  if (latestValues.transform || (hasTransform2 || transformTemplate ? style.transform = buildTransform(state.transform, options2, transformIsNone, transformTemplate) : style.transform && (style.transform = "none")), hasTransformOrigin) {
    let { originX = "50%", originY = "50%", originZ = 0 } = transformOrigin;
    style.transformOrigin = `${originX} ${originY} ${originZ}`;
  }
}

// node_modules/framer-motion/dist/es/render/html/utils/create-render-state.mjs
var createHtmlRenderState = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
});

// node_modules/framer-motion/dist/es/render/html/use-props.mjs
function copyRawValuesOnly(target, source2, props) {
  for (let key2 in source2)
    !isMotionValue(source2[key2]) && !isForcedMotionValue(key2, props) && (target[key2] = source2[key2]);
}
function useInitialMotionValues({ transformTemplate }, visualState, isStatic) {
  return (0, import_react29.useMemo)(() => {
    let state = createHtmlRenderState();
    return buildHTMLStyles(state, visualState, { enableHardwareAcceleration: !isStatic }, transformTemplate), Object.assign({}, state.vars, state.style);
  }, [visualState]);
}
function useStyle(props, visualState, isStatic) {
  let styleProp = props.style || {}, style = {};
  return copyRawValuesOnly(style, styleProp, props), Object.assign(style, useInitialMotionValues(props, visualState, isStatic)), props.transformValues ? props.transformValues(style) : style;
}
function useHTMLProps(props, visualState, isStatic) {
  let htmlProps = {}, style = useStyle(props, visualState, isStatic);
  return props.drag && props.dragListener !== !1 && (htmlProps.draggable = !1, style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = "none", style.touchAction = props.drag === !0 ? "none" : `pan-${props.drag === "x" ? "y" : "x"}`), props.tabIndex === void 0 && (props.onTap || props.onTapStart || props.whileTap) && (htmlProps.tabIndex = 0), htmlProps.style = style, htmlProps;
}

// node_modules/framer-motion/dist/es/motion/utils/valid-prop.mjs
var validMotionProps = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "transformValues",
  "custom",
  "inherit",
  "onLayoutAnimationStart",
  "onLayoutAnimationComplete",
  "onLayoutMeasure",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "ignoreStrict",
  "viewport"
]);
function isValidMotionProp(key2) {
  return key2.startsWith("while") || key2.startsWith("drag") && key2 !== "draggable" || key2.startsWith("layout") || key2.startsWith("onTap") || key2.startsWith("onPan") || validMotionProps.has(key2);
}

// node_modules/framer-motion/dist/es/render/dom/utils/filter-props.mjs
var shouldForward = (key2) => !isValidMotionProp(key2);
function loadExternalIsValidProp(isValidProp) {
  !isValidProp || (shouldForward = (key2) => key2.startsWith("on") ? !isValidMotionProp(key2) : isValidProp(key2));
}
try {
  loadExternalIsValidProp((init_is_prop_valid_esm(), __toCommonJS(is_prop_valid_esm_exports)).default);
} catch {
}
function filterProps(props, isDom, forwardMotionProps) {
  let filteredProps = {};
  for (let key2 in props)
    key2 === "values" && typeof props.values == "object" || (shouldForward(key2) || forwardMotionProps === !0 && isValidMotionProp(key2) || !isDom && !isValidMotionProp(key2) || props.draggable && key2.startsWith("onDrag")) && (filteredProps[key2] = props[key2]);
  return filteredProps;
}

// node_modules/framer-motion/dist/es/render/svg/use-props.mjs
var import_react30 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/render/svg/utils/transform-origin.mjs
function calcOrigin(origin, offset, size) {
  return typeof origin == "string" ? origin : px.transform(offset + size * origin);
}
function calcSVGTransformOrigin(dimensions, originX, originY) {
  let pxOriginX = calcOrigin(originX, dimensions.x, dimensions.width), pxOriginY = calcOrigin(originY, dimensions.y, dimensions.height);
  return `${pxOriginX} ${pxOriginY}`;
}

// node_modules/framer-motion/dist/es/render/svg/utils/path.mjs
var dashKeys = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
}, camelKeys = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = !0) {
  attrs.pathLength = 1;
  let keys2 = useDashCase ? dashKeys : camelKeys;
  attrs[keys2.offset] = px.transform(-offset);
  let pathLength = px.transform(length), pathSpacing = px.transform(spacing);
  attrs[keys2.array] = `${pathLength} ${pathSpacing}`;
}

// node_modules/framer-motion/dist/es/render/svg/utils/build-attrs.mjs
function buildSVGAttrs(state, {
  attrX,
  attrY,
  originX,
  originY,
  pathLength,
  pathSpacing = 1,
  pathOffset = 0,
  ...latest
}, options2, isSVGTag2, transformTemplate) {
  if (buildHTMLStyles(state, latest, options2, transformTemplate), isSVGTag2) {
    state.style.viewBox && (state.attrs.viewBox = state.style.viewBox);
    return;
  }
  state.attrs = state.style, state.style = {};
  let { attrs, style, dimensions } = state;
  attrs.transform && (dimensions && (style.transform = attrs.transform), delete attrs.transform), dimensions && (originX !== void 0 || originY !== void 0 || style.transform) && (style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== void 0 ? originX : 0.5, originY !== void 0 ? originY : 0.5)), attrX !== void 0 && (attrs.x = attrX), attrY !== void 0 && (attrs.y = attrY), pathLength !== void 0 && buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, !1);
}

// node_modules/framer-motion/dist/es/render/svg/utils/create-render-state.mjs
var createSvgRenderState = () => ({
  ...createHtmlRenderState(),
  attrs: {}
});

// node_modules/framer-motion/dist/es/render/svg/utils/is-svg-tag.mjs
var isSVGTag = (tag) => typeof tag == "string" && tag.toLowerCase() === "svg";

// node_modules/framer-motion/dist/es/render/svg/use-props.mjs
function useSVGProps(props, visualState, _isStatic, Component3) {
  let visualProps = (0, import_react30.useMemo)(() => {
    let state = createSvgRenderState();
    return buildSVGAttrs(state, visualState, { enableHardwareAcceleration: !1 }, isSVGTag(Component3), props.transformTemplate), {
      ...state.attrs,
      style: { ...state.style }
    };
  }, [visualState]);
  if (props.style) {
    let rawStyles = {};
    copyRawValuesOnly(rawStyles, props.style, props), visualProps.style = { ...rawStyles, ...visualProps.style };
  }
  return visualProps;
}

// node_modules/framer-motion/dist/es/render/dom/use-render.mjs
function createUseRender(forwardMotionProps = !1) {
  return (Component3, props, projectionId, ref, { latestValues }, isStatic) => {
    let visualProps = (isSVGComponent(Component3) ? useSVGProps : useHTMLProps)(props, latestValues, isStatic, Component3), elementProps = {
      ...filterProps(props, typeof Component3 == "string", forwardMotionProps),
      ...visualProps,
      ref
    }, { children } = props, renderedChildren = (0, import_react31.useMemo)(() => isMotionValue(children) ? children.get() : children, [children]);
    return projectionId && (elementProps["data-projection-id"] = projectionId), (0, import_react31.createElement)(Component3, {
      ...elementProps,
      children: renderedChildren
    });
  };
}

// node_modules/framer-motion/dist/es/render/dom/utils/camel-to-dash.mjs
var camelToDash = (str2) => str2.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();

// node_modules/framer-motion/dist/es/render/html/utils/render.mjs
function renderHTML(element, { style, vars }, styleProp, projection) {
  Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));
  for (let key2 in vars)
    element.style.setProperty(key2, vars[key2]);
}

// node_modules/framer-motion/dist/es/render/svg/utils/camel-case-attrs.mjs
var camelCaseAttributes = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);

// node_modules/framer-motion/dist/es/render/svg/utils/render.mjs
function renderSVG(element, renderState, _styleProp, projection) {
  renderHTML(element, renderState, void 0, projection);
  for (let key2 in renderState.attrs)
    element.setAttribute(camelCaseAttributes.has(key2) ? key2 : camelToDash(key2), renderState.attrs[key2]);
}

// node_modules/framer-motion/dist/es/render/html/utils/scrape-motion-values.mjs
function scrapeMotionValuesFromProps(props, prevProps) {
  let { style } = props, newValues = {};
  for (let key2 in style)
    (isMotionValue(style[key2]) || prevProps.style && isMotionValue(prevProps.style[key2]) || isForcedMotionValue(key2, props)) && (newValues[key2] = style[key2]);
  return newValues;
}

// node_modules/framer-motion/dist/es/render/svg/utils/scrape-motion-values.mjs
function scrapeMotionValuesFromProps2(props, prevProps) {
  let newValues = scrapeMotionValuesFromProps(props, prevProps);
  for (let key2 in props)
    if (isMotionValue(props[key2]) || isMotionValue(prevProps[key2])) {
      let targetKey = key2 === "x" || key2 === "y" ? "attr" + key2.toUpperCase() : key2;
      newValues[targetKey] = props[key2];
    }
  return newValues;
}

// node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs
var import_react32 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/render/utils/resolve-variants.mjs
function resolveVariantFromProps(props, definition, custom, currentValues = {}, currentVelocity = {}) {
  return typeof definition == "function" && (definition = definition(custom !== void 0 ? custom : props.custom, currentValues, currentVelocity)), typeof definition == "string" && (definition = props.variants && props.variants[definition]), typeof definition == "function" && (definition = definition(custom !== void 0 ? custom : props.custom, currentValues, currentVelocity)), definition;
}

// node_modules/framer-motion/dist/es/animation/utils/is-keyframes-target.mjs
var isKeyframesTarget = (v2) => Array.isArray(v2);

// node_modules/framer-motion/dist/es/utils/resolve-value.mjs
var isCustomValue = (v2) => Boolean(v2 && typeof v2 == "object" && v2.mix && v2.toValue), resolveFinalValueInKeyframes = (v2) => isKeyframesTarget(v2) ? v2[v2.length - 1] || 0 : v2;

// node_modules/framer-motion/dist/es/value/utils/resolve-motion-value.mjs
function resolveMotionValue(value2) {
  let unwrappedValue = isMotionValue(value2) ? value2.get() : value2;
  return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;
}

// node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs
function makeState({ scrapeMotionValuesFromProps: scrapeMotionValuesFromProps3, createRenderState, onMount }, props, context, presenceContext) {
  let state = {
    latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps3),
    renderState: createRenderState()
  };
  return onMount && (state.mount = (instance2) => onMount(props, instance2, state)), state;
}
var makeUseVisualState = (config2) => (props, isStatic) => {
  let context = (0, import_react32.useContext)(MotionContext), presenceContext = (0, import_react32.useContext)(PresenceContext), make = () => makeState(config2, props, context, presenceContext);
  return isStatic ? make() : useConstant(make);
};
function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {
  let values = {}, motionValues = scrapeMotionValues(props, {});
  for (let key2 in motionValues)
    values[key2] = resolveMotionValue(motionValues[key2]);
  let { initial, animate } = props, isControllingVariants$1 = isControllingVariants(props), isVariantNode$1 = isVariantNode(props);
  context && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== !1 && (initial === void 0 && (initial = context.initial), animate === void 0 && (animate = context.animate));
  let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === !1 : !1;
  isInitialAnimationBlocked = isInitialAnimationBlocked || initial === !1;
  let variantToSet = isInitialAnimationBlocked ? animate : initial;
  return variantToSet && typeof variantToSet != "boolean" && !isAnimationControls(variantToSet) && (Array.isArray(variantToSet) ? variantToSet : [variantToSet]).forEach((definition) => {
    let resolved = resolveVariantFromProps(props, definition);
    if (!resolved)
      return;
    let { transitionEnd: transitionEnd2, transition, ...target } = resolved;
    for (let key2 in target) {
      let valueTarget = target[key2];
      if (Array.isArray(valueTarget)) {
        let index2 = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;
        valueTarget = valueTarget[index2];
      }
      valueTarget !== null && (values[key2] = valueTarget);
    }
    for (let key2 in transitionEnd2)
      values[key2] = transitionEnd2[key2];
  }), values;
}

// node_modules/framer-motion/dist/es/render/svg/config-motion.mjs
var svgMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2,
    createRenderState: createSvgRenderState,
    onMount: (props, instance2, { renderState, latestValues }) => {
      try {
        renderState.dimensions = typeof instance2.getBBox == "function" ? instance2.getBBox() : instance2.getBoundingClientRect();
      } catch {
        renderState.dimensions = {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        };
      }
      buildSVGAttrs(renderState, latestValues, { enableHardwareAcceleration: !1 }, isSVGTag(instance2.tagName), props.transformTemplate), renderSVG(instance2, renderState);
    }
  })
};

// node_modules/framer-motion/dist/es/render/html/config-motion.mjs
var htmlMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps,
    createRenderState: createHtmlRenderState
  })
};

// node_modules/framer-motion/dist/es/render/dom/utils/create-config.mjs
function createDomMotionConfig(Component3, { forwardMotionProps = !1 }, preloadedFeatures2, createVisualElement) {
  return {
    ...isSVGComponent(Component3) ? svgMotionConfig : htmlMotionConfig,
    preloadedFeatures: preloadedFeatures2,
    useRender: createUseRender(forwardMotionProps),
    createVisualElement,
    Component: Component3
  };
}

// node_modules/framer-motion/dist/es/events/add-dom-event.mjs
function addDomEvent(target, eventName, handler, options2 = { passive: !0 }) {
  return target.addEventListener(eventName, handler, options2), () => target.removeEventListener(eventName, handler);
}

// node_modules/framer-motion/dist/es/events/utils/is-primary-pointer.mjs
var isPrimaryPointer = (event2) => event2.pointerType === "mouse" ? typeof event2.button != "number" || event2.button <= 0 : event2.isPrimary !== !1;

// node_modules/framer-motion/dist/es/events/event-info.mjs
function extractEventInfo(event2, pointType = "page") {
  return {
    point: {
      x: event2[pointType + "X"],
      y: event2[pointType + "Y"]
    }
  };
}
var addPointerInfo = (handler) => (event2) => isPrimaryPointer(event2) && handler(event2, extractEventInfo(event2));

// node_modules/framer-motion/dist/es/events/add-pointer-event.mjs
function addPointerEvent(target, eventName, handler, options2) {
  return addDomEvent(target, eventName, addPointerInfo(handler), options2);
}

// node_modules/framer-motion/dist/es/utils/pipe.mjs
var combineFunctions = (a3, b2) => (v2) => b2(a3(v2)), pipe = (...transformers) => transformers.reduce(combineFunctions);

// node_modules/framer-motion/dist/es/gestures/drag/utils/lock.mjs
function createLock(name) {
  let lock = null;
  return () => {
    let openLock = () => {
      lock = null;
    };
    return lock === null ? (lock = name, openLock) : !1;
  };
}
var globalHorizontalLock = createLock("dragHorizontal"), globalVerticalLock = createLock("dragVertical");
function getGlobalLock(drag2) {
  let lock = !1;
  if (drag2 === "y")
    lock = globalVerticalLock();
  else if (drag2 === "x")
    lock = globalHorizontalLock();
  else {
    let openHorizontal = globalHorizontalLock(), openVertical = globalVerticalLock();
    openHorizontal && openVertical ? lock = () => {
      openHorizontal(), openVertical();
    } : (openHorizontal && openHorizontal(), openVertical && openVertical());
  }
  return lock;
}
function isDragActive() {
  let openGestureLock = getGlobalLock(!0);
  return openGestureLock ? (openGestureLock(), !1) : !0;
}

// node_modules/framer-motion/dist/es/motion/features/Feature.mjs
var Feature = class {
  constructor(node) {
    this.isMounted = !1, this.node = node;
  }
  update() {
  }
};

// node_modules/framer-motion/dist/es/frameloop/create-render-step.mjs
function createRenderStep(runNextFrame2) {
  let toRun = [], toRunNextFrame = [], numToRun = 0, isProcessing = !1, flushNextFrame = !1, toKeepAlive = /* @__PURE__ */ new WeakSet(), step = {
    schedule: (callback, keepAlive = !1, immediate = !1) => {
      let addToCurrentFrame = immediate && isProcessing, buffer2 = addToCurrentFrame ? toRun : toRunNextFrame;
      return keepAlive && toKeepAlive.add(callback), buffer2.indexOf(callback) === -1 && (buffer2.push(callback), addToCurrentFrame && isProcessing && (numToRun = toRun.length)), callback;
    },
    cancel: (callback) => {
      let index2 = toRunNextFrame.indexOf(callback);
      index2 !== -1 && toRunNextFrame.splice(index2, 1), toKeepAlive.delete(callback);
    },
    process: (frameData2) => {
      if (isProcessing) {
        flushNextFrame = !0;
        return;
      }
      if (isProcessing = !0, [toRun, toRunNextFrame] = [toRunNextFrame, toRun], toRunNextFrame.length = 0, numToRun = toRun.length, numToRun)
        for (let i3 = 0; i3 < numToRun; i3++) {
          let callback = toRun[i3];
          callback(frameData2), toKeepAlive.has(callback) && (step.schedule(callback), runNextFrame2());
        }
      isProcessing = !1, flushNextFrame && (flushNextFrame = !1, step.process(frameData2));
    }
  };
  return step;
}

// node_modules/framer-motion/dist/es/frameloop/data.mjs
var frameData = {
  delta: 0,
  timestamp: 0,
  isProcessing: !1
};

// node_modules/framer-motion/dist/es/frameloop/index.mjs
var maxElapsed = 40, useDefaultElapsed = !0, runNextFrame = !1, stepsOrder = [
  "read",
  "update",
  "preRender",
  "render",
  "postRender"
], steps = stepsOrder.reduce((acc, key2) => (acc[key2] = createRenderStep(() => runNextFrame = !0), acc), {}), sync = stepsOrder.reduce((acc, key2) => {
  let step = steps[key2];
  return acc[key2] = (process2, keepAlive = !1, immediate = !1) => (runNextFrame || startLoop(), step.schedule(process2, keepAlive, immediate)), acc;
}, {}), cancelSync = stepsOrder.reduce((acc, key2) => (acc[key2] = steps[key2].cancel, acc), {}), flushSync = stepsOrder.reduce((acc, key2) => (acc[key2] = () => steps[key2].process(frameData), acc), {}), processStep = (stepId) => steps[stepId].process(frameData), processFrame = (timestamp2) => {
  runNextFrame = !1, frameData.delta = useDefaultElapsed ? 1e3 / 60 : Math.max(Math.min(timestamp2 - frameData.timestamp, maxElapsed), 1), frameData.timestamp = timestamp2, frameData.isProcessing = !0, stepsOrder.forEach(processStep), frameData.isProcessing = !1, runNextFrame && (useDefaultElapsed = !1, requestAnimationFrame(processFrame));
}, startLoop = () => {
  runNextFrame = !0, useDefaultElapsed = !0, frameData.isProcessing || requestAnimationFrame(processFrame);
};

// node_modules/framer-motion/dist/es/gestures/hover.mjs
function addHoverEvent(node, isActive) {
  let eventName = "pointer" + (isActive ? "enter" : "leave"), callbackName = "onHover" + (isActive ? "Start" : "End"), handleEvent = (event2, info) => {
    if (event2.type === "touch" || isDragActive())
      return;
    let props = node.getProps();
    node.animationState && props.whileHover && node.animationState.setActive("whileHover", isActive), props[callbackName] && sync.update(() => props[callbackName](event2, info));
  };
  return addPointerEvent(node.current, eventName, handleEvent, {
    passive: !node.getProps()[callbackName]
  });
}
var HoverGesture = class extends Feature {
  mount() {
    this.unmount = pipe(addHoverEvent(this.node, !0), addHoverEvent(this.node, !1));
  }
  unmount() {
  }
};

// node_modules/framer-motion/dist/es/gestures/focus.mjs
var FocusGesture = class extends Feature {
  constructor() {
    super(...arguments), this.isActive = !1;
  }
  onFocus() {
    let isFocusVisible = !1;
    try {
      isFocusVisible = this.node.current.matches(":focus-visible");
    } catch {
      isFocusVisible = !0;
    }
    !isFocusVisible || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0);
  }
  onBlur() {
    !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1);
  }
  mount() {
    this.unmount = pipe(addDomEvent(this.node.current, "focus", () => this.onFocus()), addDomEvent(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
};

// node_modules/framer-motion/dist/es/gestures/utils/is-node-or-child.mjs
var isNodeOrChild = (parent, child) => child ? parent === child ? !0 : isNodeOrChild(parent, child.parentElement) : !1;

// node_modules/framer-motion/dist/es/utils/noop.mjs
var noop3 = (any) => any;

// node_modules/framer-motion/dist/es/gestures/press.mjs
function fireSyntheticPointerEvent(name, handler) {
  if (!handler)
    return;
  let syntheticPointerEvent = new PointerEvent("pointer" + name);
  handler(syntheticPointerEvent, extractEventInfo(syntheticPointerEvent));
}
var PressGesture = class extends Feature {
  constructor() {
    super(...arguments), this.removeStartListeners = noop3, this.removeEndListeners = noop3, this.removeAccessibleListeners = noop3, this.startPointerPress = (startEvent, startInfo) => {
      if (this.removeEndListeners(), this.isPressing)
        return;
      let props = this.node.getProps(), removePointerUpListener = addPointerEvent(window, "pointerup", (endEvent, endInfo) => {
        if (!this.checkPressEnd())
          return;
        let { onTap, onTapCancel } = this.node.getProps();
        sync.update(() => {
          isNodeOrChild(this.node.current, endEvent.target) ? onTap && onTap(endEvent, endInfo) : onTapCancel && onTapCancel(endEvent, endInfo);
        });
      }, { passive: !(props.onTap || props.onPointerUp) }), removePointerCancelListener = addPointerEvent(window, "pointercancel", (cancelEvent, cancelInfo) => this.cancelPress(cancelEvent, cancelInfo), { passive: !(props.onTapCancel || props.onPointerCancel) });
      this.removeEndListeners = pipe(removePointerUpListener, removePointerCancelListener), this.startPress(startEvent, startInfo);
    }, this.startAccessiblePress = () => {
      let handleKeydown = (keydownEvent) => {
        if (keydownEvent.key !== "Enter" || this.isPressing)
          return;
        let handleKeyup = (keyupEvent) => {
          keyupEvent.key !== "Enter" || !this.checkPressEnd() || fireSyntheticPointerEvent("up", (event2, info) => {
            let { onTap } = this.node.getProps();
            onTap && sync.update(() => onTap(event2, info));
          });
        };
        this.removeEndListeners(), this.removeEndListeners = addDomEvent(this.node.current, "keyup", handleKeyup), fireSyntheticPointerEvent("down", (event2, info) => {
          this.startPress(event2, info);
        });
      }, removeKeydownListener = addDomEvent(this.node.current, "keydown", handleKeydown), handleBlur = () => {
        !this.isPressing || fireSyntheticPointerEvent("cancel", (cancelEvent, cancelInfo) => this.cancelPress(cancelEvent, cancelInfo));
      }, removeBlurListener = addDomEvent(this.node.current, "blur", handleBlur);
      this.removeAccessibleListeners = pipe(removeKeydownListener, removeBlurListener);
    };
  }
  startPress(event2, info) {
    this.isPressing = !0;
    let { onTapStart, whileTap } = this.node.getProps();
    whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !0), onTapStart && sync.update(() => onTapStart(event2, info));
  }
  checkPressEnd() {
    return this.removeEndListeners(), this.isPressing = !1, this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1), !isDragActive();
  }
  cancelPress(event2, info) {
    if (!this.checkPressEnd())
      return;
    let { onTapCancel } = this.node.getProps();
    onTapCancel && sync.update(() => onTapCancel(event2, info));
  }
  mount() {
    let props = this.node.getProps(), removePointerListener = addPointerEvent(this.node.current, "pointerdown", this.startPointerPress, { passive: !(props.onTapStart || props.onPointerStart) }), removeFocusListener = addDomEvent(this.node.current, "focus", this.startAccessiblePress);
    this.removeStartListeners = pipe(removePointerListener, removeFocusListener);
  }
  unmount() {
    this.removeStartListeners(), this.removeEndListeners(), this.removeAccessibleListeners();
  }
};

// node_modules/framer-motion/dist/es/motion/features/viewport/observers.mjs
var observerCallbacks = /* @__PURE__ */ new WeakMap(), observers = /* @__PURE__ */ new WeakMap(), fireObserverCallback = (entry2) => {
  let callback = observerCallbacks.get(entry2.target);
  callback && callback(entry2);
}, fireAllObserverCallbacks = (entries) => {
  entries.forEach(fireObserverCallback);
};
function initIntersectionObserver({ root: root2, ...options2 }) {
  let lookupRoot = root2 || document;
  observers.has(lookupRoot) || observers.set(lookupRoot, {});
  let rootObservers = observers.get(lookupRoot), key2 = JSON.stringify(options2);
  return rootObservers[key2] || (rootObservers[key2] = new IntersectionObserver(fireAllObserverCallbacks, { root: root2, ...options2 })), rootObservers[key2];
}
function observeIntersection(element, options2, callback) {
  let rootInteresectionObserver = initIntersectionObserver(options2);
  return observerCallbacks.set(element, callback), rootInteresectionObserver.observe(element), () => {
    observerCallbacks.delete(element), rootInteresectionObserver.unobserve(element);
  };
}

// node_modules/framer-motion/dist/es/motion/features/viewport/index.mjs
var thresholdNames = {
  some: 0,
  all: 1
}, InViewFeature = class extends Feature {
  constructor() {
    super(...arguments), this.hasEnteredView = !1, this.isInView = !1;
  }
  startObserver() {
    this.unmount();
    let { viewport = {} } = this.node.getProps(), { root: root2, margin: rootMargin, amount = "some", once: once3 } = viewport, options2 = {
      root: root2 ? root2.current : void 0,
      rootMargin,
      threshold: typeof amount == "number" ? amount : thresholdNames[amount]
    }, onIntersectionUpdate = (entry2) => {
      let { isIntersecting } = entry2;
      if (this.isInView === isIntersecting || (this.isInView = isIntersecting, once3 && !isIntersecting && this.hasEnteredView))
        return;
      isIntersecting && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", isIntersecting);
      let { onViewportEnter, onViewportLeave } = this.node.getProps(), callback = isIntersecting ? onViewportEnter : onViewportLeave;
      callback && callback(entry2);
    };
    return observeIntersection(this.node.current, options2, onIntersectionUpdate);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u")
      return;
    let { props, prevProps } = this.node;
    ["amount", "margin", "root"].some(hasViewportOptionChanged(props, prevProps)) && this.startObserver();
  }
  unmount() {
  }
};
function hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {
  return (name) => viewport[name] !== prevViewport[name];
}

// node_modules/framer-motion/dist/es/motion/features/gestures.mjs
var gestureAnimations = {
  inView: {
    Feature: InViewFeature
  },
  tap: {
    Feature: PressGesture
  },
  focus: {
    Feature: FocusGesture
  },
  hover: {
    Feature: HoverGesture
  }
};

// node_modules/framer-motion/dist/es/utils/shallow-compare.mjs
function shallowCompare(next, prev) {
  if (!Array.isArray(prev))
    return !1;
  let prevLength = prev.length;
  if (prevLength !== next.length)
    return !1;
  for (let i3 = 0; i3 < prevLength; i3++)
    if (prev[i3] !== next[i3])
      return !1;
  return !0;
}

// node_modules/framer-motion/dist/es/render/utils/resolve-dynamic-variants.mjs
function getCurrent(visualElement) {
  let current = {};
  return visualElement.values.forEach((value2, key2) => current[key2] = value2.get()), current;
}
function getVelocity(visualElement) {
  let velocity = {};
  return visualElement.values.forEach((value2, key2) => velocity[key2] = value2.getVelocity()), velocity;
}
function resolveVariant(visualElement, definition, custom) {
  let props = visualElement.getProps();
  return resolveVariantFromProps(props, definition, custom !== void 0 ? custom : props.custom, getCurrent(visualElement), getVelocity(visualElement));
}

// node_modules/framer-motion/dist/es/animation/optimized-appear/data-id.mjs
var optimizedAppearDataId = "framerAppearId", optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId);

// node_modules/framer-motion/dist/es/utils/errors.mjs
var warning2 = noop3, invariant4 = noop3;
warning2 = (check, message) => {
  !check && typeof console < "u" && console.warn(message);
}, invariant4 = (check, message) => {
  if (!check)
    throw new Error(message);
};

// node_modules/framer-motion/dist/es/utils/time-conversion.mjs
var secondsToMilliseconds = (seconds) => seconds * 1e3, millisecondsToSeconds = (milliseconds) => milliseconds / 1e3;

// node_modules/framer-motion/dist/es/utils/use-instant-transition-state.mjs
var instantAnimationState = {
  current: !1
};

// node_modules/framer-motion/dist/es/easing/utils/is-bezier-definition.mjs
var isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] == "number";

// node_modules/framer-motion/dist/es/animation/animators/waapi/easing.mjs
function isWaapiSupportedEasing(easing) {
  return Boolean(!easing || typeof easing == "string" && supportedWaapiEasing[easing] || isBezierDefinition(easing) || Array.isArray(easing) && easing.every(isWaapiSupportedEasing));
}
var cubicBezierAsString = ([a3, b2, c4, d2]) => `cubic-bezier(${a3}, ${b2}, ${c4}, ${d2})`, supportedWaapiEasing = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: cubicBezierAsString([0, 0.65, 0.55, 1]),
  circOut: cubicBezierAsString([0.55, 0, 1, 0.45]),
  backIn: cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),
  backOut: cubicBezierAsString([0.33, 1.53, 0.69, 0.99])
};
function mapEasingToNativeEasing(easing) {
  if (!!easing)
    return isBezierDefinition(easing) ? cubicBezierAsString(easing) : Array.isArray(easing) ? easing.map(mapEasingToNativeEasing) : supportedWaapiEasing[easing];
}

// node_modules/framer-motion/dist/es/animation/animators/waapi/index.mjs
function animateStyle(element, valueName, keyframes2, { delay: delay2 = 0, duration, repeat: repeat2 = 0, repeatType = "loop", ease: ease2, times } = {}) {
  let keyframeOptions = { [valueName]: keyframes2 };
  times && (keyframeOptions.offset = times);
  let easing = mapEasingToNativeEasing(ease2);
  return Array.isArray(easing) && (keyframeOptions.easing = easing), element.animate(keyframeOptions, {
    delay: delay2,
    duration,
    easing: Array.isArray(easing) ? "linear" : easing,
    fill: "both",
    iterations: repeat2 + 1,
    direction: repeatType === "reverse" ? "alternate" : "normal"
  });
}

// node_modules/framer-motion/dist/es/animation/animators/waapi/supports.mjs
var featureTests = {
  waapi: () => Object.hasOwnProperty.call(Element.prototype, "animate")
}, results = {}, supports = {};
for (let key2 in featureTests)
  supports[key2] = () => (results[key2] === void 0 && (results[key2] = featureTests[key2]()), results[key2]);

// node_modules/framer-motion/dist/es/animation/animators/waapi/utils/get-final-keyframe.mjs
function getFinalKeyframe(keyframes2, { repeat: repeat2, repeatType = "loop" }) {
  let index2 = repeat2 && repeatType !== "loop" && repeat2 % 2 === 1 ? 0 : keyframes2.length - 1;
  return keyframes2[index2];
}

// node_modules/framer-motion/dist/es/easing/cubic-bezier.mjs
var calcBezier = (t4, a1, a22) => (((1 - 3 * a22 + 3 * a1) * t4 + (3 * a22 - 6 * a1)) * t4 + 3 * a1) * t4, subdivisionPrecision = 1e-7, subdivisionMaxIterations = 12;
function binarySubdivide(x2, lowerBound, upperBound, mX1, mX2) {
  let currentX, currentT, i3 = 0;
  do
    currentT = lowerBound + (upperBound - lowerBound) / 2, currentX = calcBezier(currentT, mX1, mX2) - x2, currentX > 0 ? upperBound = currentT : lowerBound = currentT;
  while (Math.abs(currentX) > subdivisionPrecision && ++i3 < subdivisionMaxIterations);
  return currentT;
}
function cubicBezier(mX1, mY1, mX2, mY2) {
  if (mX1 === mY1 && mX2 === mY2)
    return noop3;
  let getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);
  return (t4) => t4 === 0 || t4 === 1 ? t4 : calcBezier(getTForX(t4), mY1, mY2);
}

// node_modules/framer-motion/dist/es/easing/ease.mjs
var easeIn = cubicBezier(0.42, 0, 1, 1), easeOut = cubicBezier(0, 0, 0.58, 1), easeInOut = cubicBezier(0.42, 0, 0.58, 1);

// node_modules/framer-motion/dist/es/easing/utils/is-easing-array.mjs
var isEasingArray = (ease2) => Array.isArray(ease2) && typeof ease2[0] != "number";

// node_modules/framer-motion/dist/es/easing/modifiers/mirror.mjs
var mirrorEasing = (easing) => (p) => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;

// node_modules/framer-motion/dist/es/easing/modifiers/reverse.mjs
var reverseEasing = (easing) => (p) => 1 - easing(1 - p);

// node_modules/framer-motion/dist/es/easing/circ.mjs
var circIn = (p) => 1 - Math.sin(Math.acos(p)), circOut = reverseEasing(circIn), circInOut = mirrorEasing(circOut);

// node_modules/framer-motion/dist/es/easing/back.mjs
var backOut = cubicBezier(0.33, 1.53, 0.69, 0.99), backIn = reverseEasing(backOut), backInOut = mirrorEasing(backIn);

// node_modules/framer-motion/dist/es/easing/anticipate.mjs
var anticipate = (p) => (p *= 2) < 1 ? 0.5 * backIn(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));

// node_modules/framer-motion/dist/es/easing/utils/map.mjs
var easingLookup = {
  linear: noop3,
  easeIn,
  easeInOut,
  easeOut,
  circIn,
  circInOut,
  circOut,
  backIn,
  backInOut,
  backOut,
  anticipate
}, easingDefinitionToFunction = (definition) => {
  if (Array.isArray(definition)) {
    invariant4(definition.length === 4, "Cubic bezier arrays must contain four numerical values.");
    let [x1, y1, x2, y2] = definition;
    return cubicBezier(x1, y1, x2, y2);
  } else if (typeof definition == "string")
    return invariant4(easingLookup[definition] !== void 0, `Invalid easing type '${definition}'`), easingLookup[definition];
  return definition;
};

// node_modules/framer-motion/dist/es/value/types/color/utils.mjs
var isColorString = (type2, testProp) => (v2) => Boolean(isString2(v2) && singleColorRegex.test(v2) && v2.startsWith(type2) || testProp && Object.prototype.hasOwnProperty.call(v2, testProp)), splitColor = (aName, bName, cName) => (v2) => {
  if (!isString2(v2))
    return v2;
  let [a3, b2, c4, alpha2] = v2.match(floatRegex);
  return {
    [aName]: parseFloat(a3),
    [bName]: parseFloat(b2),
    [cName]: parseFloat(c4),
    alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1
  };
};

// node_modules/framer-motion/dist/es/value/types/color/rgba.mjs
var clampRgbUnit = (v2) => clamp(0, 255, v2), rgbUnit = {
  ...number3,
  transform: (v2) => Math.round(clampRgbUnit(v2))
}, rgba = {
  test: isColorString("rgb", "red"),
  parse: splitColor("red", "green", "blue"),
  transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => "rgba(" + rgbUnit.transform(red) + ", " + rgbUnit.transform(green) + ", " + rgbUnit.transform(blue) + ", " + sanitize(alpha.transform(alpha$1)) + ")"
};

// node_modules/framer-motion/dist/es/value/types/color/hex.mjs
function parseHex(v2) {
  let r3 = "", g2 = "", b2 = "", a3 = "";
  return v2.length > 5 ? (r3 = v2.substring(1, 3), g2 = v2.substring(3, 5), b2 = v2.substring(5, 7), a3 = v2.substring(7, 9)) : (r3 = v2.substring(1, 2), g2 = v2.substring(2, 3), b2 = v2.substring(3, 4), a3 = v2.substring(4, 5), r3 += r3, g2 += g2, b2 += b2, a3 += a3), {
    red: parseInt(r3, 16),
    green: parseInt(g2, 16),
    blue: parseInt(b2, 16),
    alpha: a3 ? parseInt(a3, 16) / 255 : 1
  };
}
var hex2 = {
  test: isColorString("#"),
  parse: parseHex,
  transform: rgba.transform
};

// node_modules/framer-motion/dist/es/value/types/color/hsla.mjs
var hsla = {
  test: isColorString("hsl", "hue"),
  parse: splitColor("hue", "saturation", "lightness"),
  transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$1)) + ")"
};

// node_modules/framer-motion/dist/es/value/types/color/index.mjs
var color = {
  test: (v2) => rgba.test(v2) || hex2.test(v2) || hsla.test(v2),
  parse: (v2) => rgba.test(v2) ? rgba.parse(v2) : hsla.test(v2) ? hsla.parse(v2) : hex2.parse(v2),
  transform: (v2) => isString2(v2) ? v2 : v2.hasOwnProperty("red") ? rgba.transform(v2) : hsla.transform(v2)
};

// node_modules/framer-motion/dist/es/utils/mix.mjs
var mix = (from2, to, progress2) => -progress2 * from2 + progress2 * to + from2;

// node_modules/framer-motion/dist/es/utils/hsla-to-rgba.mjs
function hueToRgb(p, q2, t4) {
  return t4 < 0 && (t4 += 1), t4 > 1 && (t4 -= 1), t4 < 1 / 6 ? p + (q2 - p) * 6 * t4 : t4 < 1 / 2 ? q2 : t4 < 2 / 3 ? p + (q2 - p) * (2 / 3 - t4) * 6 : p;
}
function hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {
  hue /= 360, saturation /= 100, lightness /= 100;
  let red = 0, green = 0, blue = 0;
  if (!saturation)
    red = green = blue = lightness;
  else {
    let q2 = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation, p = 2 * lightness - q2;
    red = hueToRgb(p, q2, hue + 1 / 3), green = hueToRgb(p, q2, hue), blue = hueToRgb(p, q2, hue - 1 / 3);
  }
  return {
    red: Math.round(red * 255),
    green: Math.round(green * 255),
    blue: Math.round(blue * 255),
    alpha: alpha2
  };
}

// node_modules/framer-motion/dist/es/utils/mix-color.mjs
var mixLinearColor = (from2, to, v2) => {
  let fromExpo = from2 * from2;
  return Math.sqrt(Math.max(0, v2 * (to * to - fromExpo) + fromExpo));
}, colorTypes = [hex2, rgba, hsla], getColorType = (v2) => colorTypes.find((type2) => type2.test(v2));
function asRGBA(color2) {
  let type2 = getColorType(color2);
  invariant4(Boolean(type2), `'${color2}' is not an animatable color. Use the equivalent color code instead.`);
  let model = type2.parse(color2);
  return type2 === hsla && (model = hslaToRgba(model)), model;
}
var mixColor = (from2, to) => {
  let fromRGBA = asRGBA(from2), toRGBA = asRGBA(to), blended = { ...fromRGBA };
  return (v2) => (blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v2), blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v2), blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v2), blended.alpha = mix(fromRGBA.alpha, toRGBA.alpha, v2), rgba.transform(blended));
};

// node_modules/framer-motion/dist/es/value/types/complex/index.mjs
var colorToken = "${c}", numberToken = "${n}";
function test(v2) {
  var _a, _b;
  return isNaN(v2) && isString2(v2) && (((_a = v2.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) || 0) + (((_b = v2.match(colorRegex)) === null || _b === void 0 ? void 0 : _b.length) || 0) > 0;
}
function analyseComplexValue(v2) {
  typeof v2 == "number" && (v2 = `${v2}`);
  let values = [], numColors = 0, numNumbers = 0, colors = v2.match(colorRegex);
  colors && (numColors = colors.length, v2 = v2.replace(colorRegex, colorToken), values.push(...colors.map(color.parse)));
  let numbers = v2.match(floatRegex);
  return numbers && (numNumbers = numbers.length, v2 = v2.replace(floatRegex, numberToken), values.push(...numbers.map(number3.parse))), { values, numColors, numNumbers, tokenised: v2 };
}
function parse4(v2) {
  return analyseComplexValue(v2).values;
}
function createTransformer(source2) {
  let { values, numColors, tokenised } = analyseComplexValue(source2), numValues = values.length;
  return (v2) => {
    let output2 = tokenised;
    for (let i3 = 0; i3 < numValues; i3++)
      output2 = output2.replace(i3 < numColors ? colorToken : numberToken, i3 < numColors ? color.transform(v2[i3]) : sanitize(v2[i3]));
    return output2;
  };
}
var convertNumbersToZero = (v2) => typeof v2 == "number" ? 0 : v2;
function getAnimatableNone(v2) {
  let parsed = parse4(v2);
  return createTransformer(v2)(parsed.map(convertNumbersToZero));
}
var complex = { test, parse: parse4, createTransformer, getAnimatableNone };

// node_modules/framer-motion/dist/es/utils/mix-complex.mjs
function getMixer(origin, target) {
  return typeof origin == "number" ? (v2) => mix(origin, target, v2) : color.test(origin) ? mixColor(origin, target) : mixComplex(origin, target);
}
var mixArray = (from2, to) => {
  let output2 = [...from2], numValues = output2.length, blendValue = from2.map((fromThis, i3) => getMixer(fromThis, to[i3]));
  return (v2) => {
    for (let i3 = 0; i3 < numValues; i3++)
      output2[i3] = blendValue[i3](v2);
    return output2;
  };
}, mixObject = (origin, target) => {
  let output2 = { ...origin, ...target }, blendValue = {};
  for (let key2 in output2)
    origin[key2] !== void 0 && target[key2] !== void 0 && (blendValue[key2] = getMixer(origin[key2], target[key2]));
  return (v2) => {
    for (let key2 in blendValue)
      output2[key2] = blendValue[key2](v2);
    return output2;
  };
}, mixComplex = (origin, target) => {
  let template = complex.createTransformer(target), originStats = analyseComplexValue(origin), targetStats = analyseComplexValue(target);
  return originStats.numColors === targetStats.numColors && originStats.numNumbers >= targetStats.numNumbers ? pipe(mixArray(originStats.values, targetStats.values), template) : (warning2(!0, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`), (p) => `${p > 0 ? target : origin}`);
};

// node_modules/framer-motion/dist/es/utils/progress.mjs
var progress = (from2, to, value2) => {
  let toFromDifference = to - from2;
  return toFromDifference === 0 ? 1 : (value2 - from2) / toFromDifference;
};

// node_modules/framer-motion/dist/es/utils/interpolate.mjs
var mixNumber = (from2, to) => (p) => mix(from2, to, p);
function detectMixerFactory(v2) {
  return typeof v2 == "number" ? mixNumber : typeof v2 == "string" ? color.test(v2) ? mixColor : mixComplex : Array.isArray(v2) ? mixArray : typeof v2 == "object" ? mixObject : mixNumber;
}
function createMixers(output2, ease2, customMixer) {
  let mixers = [], mixerFactory = customMixer || detectMixerFactory(output2[0]), numMixers = output2.length - 1;
  for (let i3 = 0; i3 < numMixers; i3++) {
    let mixer = mixerFactory(output2[i3], output2[i3 + 1]);
    if (ease2) {
      let easingFunction = Array.isArray(ease2) ? ease2[i3] || noop3 : ease2;
      mixer = pipe(easingFunction, mixer);
    }
    mixers.push(mixer);
  }
  return mixers;
}
function interpolate(input, output2, { clamp: isClamp = !0, ease: ease2, mixer } = {}) {
  let inputLength = input.length;
  if (invariant4(inputLength === output2.length, "Both input and output ranges must be the same length"), inputLength === 1)
    return () => output2[0];
  input[0] > input[inputLength - 1] && (input = [...input].reverse(), output2 = [...output2].reverse());
  let mixers = createMixers(output2, ease2, mixer), numMixers = mixers.length, interpolator = (v2) => {
    let i3 = 0;
    if (numMixers > 1)
      for (; i3 < input.length - 2 && !(v2 < input[i3 + 1]); i3++)
        ;
    let progressInRange = progress(input[i3], input[i3 + 1], v2);
    return mixers[i3](progressInRange);
  };
  return isClamp ? (v2) => interpolator(clamp(input[0], input[inputLength - 1], v2)) : interpolator;
}

// node_modules/framer-motion/dist/es/utils/offsets/fill.mjs
function fillOffset(offset, remaining) {
  let min = offset[offset.length - 1];
  for (let i3 = 1; i3 <= remaining; i3++) {
    let offsetProgress = progress(0, remaining, i3);
    offset.push(mix(min, 1, offsetProgress));
  }
}

// node_modules/framer-motion/dist/es/utils/offsets/default.mjs
function defaultOffset(arr2) {
  let offset = [0];
  return fillOffset(offset, arr2.length - 1), offset;
}

// node_modules/framer-motion/dist/es/utils/offsets/time.mjs
function convertOffsetToTimes(offset, duration) {
  return offset.map((o2) => o2 * duration);
}

// node_modules/framer-motion/dist/es/animation/generators/keyframes.mjs
function defaultEasing(values, easing) {
  return values.map(() => easing || easeInOut).splice(0, values.length - 1);
}
function keyframes({ duration = 300, keyframes: keyframeValues, times, ease: ease2 = "easeInOut" }) {
  let easingFunctions = isEasingArray(ease2) ? ease2.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease2), state = {
    done: !1,
    value: keyframeValues[0]
  }, absoluteTimes = convertOffsetToTimes(
    times && times.length === keyframeValues.length ? times : defaultOffset(keyframeValues),
    duration
  ), mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {
    ease: Array.isArray(easingFunctions) ? easingFunctions : defaultEasing(keyframeValues, easingFunctions)
  });
  return {
    calculatedDuration: duration,
    next: (t4) => (state.value = mapTimeToKeyframe(t4), state.done = t4 >= duration, state)
  };
}

// node_modules/framer-motion/dist/es/utils/velocity-per-second.mjs
function velocityPerSecond(velocity, frameDuration) {
  return frameDuration ? velocity * (1e3 / frameDuration) : 0;
}

// node_modules/framer-motion/dist/es/animation/generators/utils/velocity.mjs
var velocitySampleDuration = 5;
function calcGeneratorVelocity(resolveValue, t4, current) {
  let prevT = Math.max(t4 - velocitySampleDuration, 0);
  return velocityPerSecond(current - resolveValue(prevT), t4 - prevT);
}

// node_modules/framer-motion/dist/es/animation/generators/spring/find.mjs
var safeMin = 1e-3, minDuration = 0.01, maxDuration = 10, minDamping = 0.05, maxDamping = 1;
function findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1 }) {
  let envelope, derivative;
  warning2(duration <= secondsToMilliseconds(maxDuration), "Spring duration must be 10 seconds or less");
  let dampingRatio = 1 - bounce;
  dampingRatio = clamp(minDamping, maxDamping, dampingRatio), duration = clamp(minDuration, maxDuration, millisecondsToSeconds(duration)), dampingRatio < 1 ? (envelope = (undampedFreq2) => {
    let exponentialDecay = undampedFreq2 * dampingRatio, delta = exponentialDecay * duration, a3 = exponentialDecay - velocity, b2 = calcAngularFreq(undampedFreq2, dampingRatio), c4 = Math.exp(-delta);
    return safeMin - a3 / b2 * c4;
  }, derivative = (undampedFreq2) => {
    let delta = undampedFreq2 * dampingRatio * duration, d2 = delta * velocity + velocity, e3 = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration, f2 = Math.exp(-delta), g2 = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
    return (-envelope(undampedFreq2) + safeMin > 0 ? -1 : 1) * ((d2 - e3) * f2) / g2;
  }) : (envelope = (undampedFreq2) => {
    let a3 = Math.exp(-undampedFreq2 * duration), b2 = (undampedFreq2 - velocity) * duration + 1;
    return -safeMin + a3 * b2;
  }, derivative = (undampedFreq2) => {
    let a3 = Math.exp(-undampedFreq2 * duration), b2 = (velocity - undampedFreq2) * (duration * duration);
    return a3 * b2;
  });
  let initialGuess = 5 / duration, undampedFreq = approximateRoot(envelope, derivative, initialGuess);
  if (duration = secondsToMilliseconds(duration), isNaN(undampedFreq))
    return {
      stiffness: 100,
      damping: 10,
      duration
    };
  {
    let stiffness = Math.pow(undampedFreq, 2) * mass;
    return {
      stiffness,
      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
      duration
    };
  }
}
var rootIterations = 12;
function approximateRoot(envelope, derivative, initialGuess) {
  let result2 = initialGuess;
  for (let i3 = 1; i3 < rootIterations; i3++)
    result2 = result2 - envelope(result2) / derivative(result2);
  return result2;
}
function calcAngularFreq(undampedFreq, dampingRatio) {
  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
}

// node_modules/framer-motion/dist/es/animation/generators/spring/index.mjs
var durationKeys = ["duration", "bounce"], physicsKeys = ["stiffness", "damping", "mass"];
function isSpringType(options2, keys2) {
  return keys2.some((key2) => options2[key2] !== void 0);
}
function getSpringOptions(options2) {
  let springOptions = {
    velocity: 0,
    stiffness: 100,
    damping: 10,
    mass: 1,
    isResolvedFromDuration: !1,
    ...options2
  };
  if (!isSpringType(options2, physicsKeys) && isSpringType(options2, durationKeys)) {
    let derived = findSpring(options2);
    springOptions = {
      ...springOptions,
      ...derived,
      velocity: 0,
      mass: 1
    }, springOptions.isResolvedFromDuration = !0;
  }
  return springOptions;
}
function spring({ keyframes: keyframes2, restDelta, restSpeed, ...options2 }) {
  let origin = keyframes2[0], target = keyframes2[keyframes2.length - 1], state = { done: !1, value: origin }, { stiffness, damping, mass, velocity, duration, isResolvedFromDuration } = getSpringOptions(options2), initialVelocity = velocity ? -millisecondsToSeconds(velocity) : 0, dampingRatio = damping / (2 * Math.sqrt(stiffness * mass)), initialDelta = target - origin, undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass)), isGranularScale = Math.abs(initialDelta) < 5;
  restSpeed || (restSpeed = isGranularScale ? 0.01 : 2), restDelta || (restDelta = isGranularScale ? 5e-3 : 0.5);
  let resolveSpring;
  if (dampingRatio < 1) {
    let angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
    resolveSpring = (t4) => {
      let envelope = Math.exp(-dampingRatio * undampedAngularFreq * t4);
      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t4) + initialDelta * Math.cos(angularFreq * t4));
    };
  } else if (dampingRatio === 1)
    resolveSpring = (t4) => target - Math.exp(-undampedAngularFreq * t4) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t4);
  else {
    let dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
    resolveSpring = (t4) => {
      let envelope = Math.exp(-dampingRatio * undampedAngularFreq * t4), freqForT = Math.min(dampedAngularFreq * t4, 300);
      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
    };
  }
  return {
    calculatedDuration: isResolvedFromDuration && duration || null,
    next: (t4) => {
      let current = resolveSpring(t4);
      if (isResolvedFromDuration)
        state.done = t4 >= duration;
      else {
        let currentVelocity = initialVelocity;
        t4 !== 0 && (dampingRatio < 1 ? currentVelocity = calcGeneratorVelocity(resolveSpring, t4, current) : currentVelocity = 0);
        let isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed, isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;
        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
      }
      return state.value = state.done ? target : current, state;
    }
  };
}

// node_modules/framer-motion/dist/es/animation/generators/inertia.mjs
function inertia({ keyframes: keyframes2, velocity = 0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min, max, restDelta = 0.5, restSpeed }) {
  let origin = keyframes2[0], state = {
    done: !1,
    value: origin
  }, isOutOfBounds = (v2) => min !== void 0 && v2 < min || max !== void 0 && v2 > max, nearestBoundary = (v2) => min === void 0 ? max : max === void 0 || Math.abs(min - v2) < Math.abs(max - v2) ? min : max, amplitude = power * velocity, ideal = origin + amplitude, target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
  target !== ideal && (amplitude = target - origin);
  let calcDelta = (t4) => -amplitude * Math.exp(-t4 / timeConstant), calcLatest = (t4) => target + calcDelta(t4), applyFriction = (t4) => {
    let delta = calcDelta(t4), latest = calcLatest(t4);
    state.done = Math.abs(delta) <= restDelta, state.value = state.done ? target : latest;
  }, timeReachedBoundary, spring$1, checkCatchBoundary = (t4) => {
    !isOutOfBounds(state.value) || (timeReachedBoundary = t4, spring$1 = spring({
      keyframes: [state.value, nearestBoundary(state.value)],
      velocity: calcGeneratorVelocity(calcLatest, t4, state.value),
      damping: bounceDamping,
      stiffness: bounceStiffness,
      restDelta,
      restSpeed
    }));
  };
  return checkCatchBoundary(0), {
    calculatedDuration: null,
    next: (t4) => {
      let hasUpdatedFrame = !1;
      return !spring$1 && timeReachedBoundary === void 0 && (hasUpdatedFrame = !0, applyFriction(t4), checkCatchBoundary(t4)), timeReachedBoundary !== void 0 && t4 > timeReachedBoundary ? spring$1.next(t4 - timeReachedBoundary) : (!hasUpdatedFrame && applyFriction(t4), state);
    }
  };
}

// node_modules/framer-motion/dist/es/animation/animators/js/driver-frameloop.mjs
var frameloopDriver = (update) => {
  let passTimestamp = ({ timestamp: timestamp2 }) => update(timestamp2);
  return {
    start: () => sync.update(passTimestamp, !0),
    stop: () => cancelSync.update(passTimestamp),
    now: () => frameData.isProcessing ? frameData.timestamp : performance.now()
  };
};

// node_modules/framer-motion/dist/es/animation/generators/utils/calc-duration.mjs
function calcGeneratorDuration(generator) {
  let duration = 0, timeStep = 50, state = generator.next(duration);
  for (; !state.done && duration < 2e4; )
    duration += timeStep, state = generator.next(duration);
  return duration >= 2e4 ? 1 / 0 : duration;
}

// node_modules/framer-motion/dist/es/animation/animators/js/index.mjs
var types2 = {
  decay: inertia,
  inertia,
  tween: keyframes,
  keyframes,
  spring
};
function animateValue({ autoplay = !0, delay: delay2 = 0, driver = frameloopDriver, keyframes: keyframes$1, type: type2 = "keyframes", repeat: repeat2 = 0, repeatDelay = 0, repeatType = "loop", onPlay, onStop, onComplete, onUpdate, ...options2 }) {
  let speed = 1, hasStopped = !1, resolveFinishedPromise, currentFinishedPromise, updateFinishedPromise = () => {
    resolveFinishedPromise && resolveFinishedPromise(), currentFinishedPromise = new Promise((resolve2) => {
      resolveFinishedPromise = resolve2;
    });
  };
  updateFinishedPromise();
  let animationDriver, generatorFactory = types2[type2] || keyframes, mapNumbersToKeyframes;
  generatorFactory !== keyframes && typeof keyframes$1[0] != "number" && (mapNumbersToKeyframes = interpolate([0, 100], keyframes$1, {
    clamp: !1
  }), keyframes$1 = [0, 100]);
  let generator = generatorFactory({ ...options2, keyframes: keyframes$1 }), mirroredGenerator;
  repeatType === "mirror" && (mirroredGenerator = generatorFactory({
    ...options2,
    keyframes: [...keyframes$1].reverse(),
    velocity: -(options2.velocity || 0)
  }));
  let playState = "idle", holdTime = null, startTime2 = null, cancelTime = null;
  generator.calculatedDuration === null && repeat2 && (generator.calculatedDuration = calcGeneratorDuration(generator));
  let { calculatedDuration } = generator, resolvedDuration = 1 / 0, totalDuration = 1 / 0;
  calculatedDuration !== null && (resolvedDuration = calculatedDuration + repeatDelay, totalDuration = resolvedDuration * (repeat2 + 1) - repeatDelay);
  let currentTime = 0, tick = (timestamp2) => {
    if (startTime2 === null)
      return;
    speed > 0 && (startTime2 = Math.min(startTime2, timestamp2)), holdTime !== null ? currentTime = holdTime : currentTime = (timestamp2 - startTime2) * speed;
    let timeWithoutDelay = currentTime - delay2, isInDelayPhase = timeWithoutDelay < 0;
    currentTime = Math.max(timeWithoutDelay, 0), playState === "finished" && holdTime === null && (currentTime = totalDuration);
    let elapsed = currentTime, frameGenerator = generator;
    if (repeat2) {
      let progress2 = currentTime / resolvedDuration, currentIteration = Math.floor(progress2), iterationProgress = progress2 % 1;
      !iterationProgress && progress2 >= 1 && (iterationProgress = 1), iterationProgress === 1 && currentIteration--, currentIteration = Math.min(currentIteration, repeat2 + 1);
      let iterationIsOdd = Boolean(currentIteration % 2);
      iterationIsOdd && (repeatType === "reverse" ? (iterationProgress = 1 - iterationProgress, repeatDelay && (iterationProgress -= repeatDelay / resolvedDuration)) : repeatType === "mirror" && (frameGenerator = mirroredGenerator));
      let p = clamp(0, 1, iterationProgress);
      currentTime > totalDuration && (p = repeatType === "reverse" && iterationIsOdd ? 1 : 0), elapsed = p * resolvedDuration;
    }
    let state = isInDelayPhase ? { done: !1, value: keyframes$1[0] } : frameGenerator.next(elapsed);
    mapNumbersToKeyframes && (state.value = mapNumbersToKeyframes(state.value));
    let { done: done2 } = state;
    !isInDelayPhase && calculatedDuration !== null && (done2 = currentTime >= totalDuration);
    let isAnimationFinished = holdTime === null && (playState === "finished" || playState === "running" && done2 || speed < 0 && currentTime <= 0);
    return onUpdate && onUpdate(state.value), isAnimationFinished && finish(), state;
  }, stopAnimationDriver = () => {
    animationDriver && animationDriver.stop(), animationDriver = void 0;
  }, cancel = () => {
    playState = "idle", stopAnimationDriver(), updateFinishedPromise(), startTime2 = cancelTime = null;
  }, finish = () => {
    playState = "finished", onComplete && onComplete(), stopAnimationDriver(), updateFinishedPromise();
  }, play = () => {
    if (hasStopped)
      return;
    animationDriver || (animationDriver = driver(tick));
    let now2 = animationDriver.now();
    onPlay && onPlay(), playState = "running", holdTime !== null ? startTime2 = now2 - holdTime : startTime2 || (startTime2 = now2), cancelTime = startTime2, holdTime = null, animationDriver.start();
  };
  autoplay && play();
  let controls = {
    then(resolve2, reject) {
      return currentFinishedPromise.then(resolve2, reject);
    },
    get time() {
      return millisecondsToSeconds(currentTime);
    },
    set time(newTime) {
      newTime = secondsToMilliseconds(newTime), currentTime = newTime, holdTime !== null || !animationDriver || speed === 0 ? holdTime = newTime : startTime2 = animationDriver.now() - newTime / speed;
    },
    get duration() {
      let duration = generator.calculatedDuration === null ? calcGeneratorDuration(generator) : generator.calculatedDuration;
      return millisecondsToSeconds(duration);
    },
    get speed() {
      return speed;
    },
    set speed(newSpeed) {
      newSpeed === speed || !animationDriver || (speed = newSpeed, controls.time = millisecondsToSeconds(currentTime));
    },
    get state() {
      return playState;
    },
    play,
    pause: () => {
      playState = "paused", holdTime = currentTime;
    },
    stop: () => {
      hasStopped = !0, playState !== "idle" && (playState = "idle", onStop && onStop(), cancel());
    },
    cancel: () => {
      cancelTime !== null && tick(cancelTime), cancel();
    },
    complete: () => {
      playState = "finished";
    },
    sample: (elapsed) => (startTime2 = 0, tick(elapsed))
  };
  return controls;
}

// node_modules/framer-motion/dist/es/animation/animators/waapi/create-accelerated-animation.mjs
var acceleratedValues = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform",
  "backgroundColor"
]), sampleDelta = 10, maxDuration2 = 2e4, requiresPregeneratedKeyframes = (valueName, options2) => options2.type === "spring" || valueName === "backgroundColor" || !isWaapiSupportedEasing(options2.ease);
function createAcceleratedAnimation(value2, valueName, { onUpdate, onComplete, ...options2 }) {
  if (!(supports.waapi() && acceleratedValues.has(valueName) && !options2.repeatDelay && options2.repeatType !== "mirror" && options2.damping !== 0 && options2.type !== "inertia"))
    return !1;
  let hasStopped = !1, resolveFinishedPromise, currentFinishedPromise, updateFinishedPromise = () => {
    currentFinishedPromise = new Promise((resolve2) => {
      resolveFinishedPromise = resolve2;
    });
  };
  updateFinishedPromise();
  let { keyframes: keyframes2, duration = 300, ease: ease2, times } = options2;
  if (requiresPregeneratedKeyframes(valueName, options2)) {
    let sampleAnimation = animateValue({
      ...options2,
      repeat: 0,
      delay: 0
    }), state = { done: !1, value: keyframes2[0] }, pregeneratedKeyframes = [], t4 = 0;
    for (; !state.done && t4 < maxDuration2; )
      state = sampleAnimation.sample(t4), pregeneratedKeyframes.push(state.value), t4 += sampleDelta;
    times = void 0, keyframes2 = pregeneratedKeyframes, duration = t4 - sampleDelta, ease2 = "linear";
  }
  let animation = animateStyle(value2.owner.current, valueName, keyframes2, {
    ...options2,
    duration,
    ease: ease2,
    times
  }), safeCancel = () => {
    sync.update(() => animation.cancel()), resolveFinishedPromise(), updateFinishedPromise();
  };
  return animation.onfinish = () => {
    value2.set(getFinalKeyframe(keyframes2, options2)), onComplete && onComplete(), safeCancel();
  }, {
    then(resolve2, reject) {
      return currentFinishedPromise.then(resolve2, reject);
    },
    get time() {
      return millisecondsToSeconds(animation.currentTime || 0);
    },
    set time(newTime) {
      animation.currentTime = secondsToMilliseconds(newTime);
    },
    get speed() {
      return animation.playbackRate;
    },
    set speed(newSpeed) {
      animation.playbackRate = newSpeed;
    },
    get duration() {
      return millisecondsToSeconds(duration);
    },
    play: () => {
      hasStopped || animation.play();
    },
    pause: () => animation.pause(),
    stop: () => {
      if (hasStopped = !0, animation.playState === "idle")
        return;
      let { currentTime } = animation;
      if (currentTime) {
        let sampleAnimation = animateValue({
          ...options2,
          autoplay: !1
        });
        value2.setWithVelocity(sampleAnimation.sample(currentTime - sampleDelta).value, sampleAnimation.sample(currentTime).value, sampleDelta);
      }
      safeCancel();
    },
    complete: () => animation.finish(),
    cancel: safeCancel
  };
}

// node_modules/framer-motion/dist/es/animation/animators/instant.mjs
function createInstantAnimation({ keyframes: keyframes2, delay: delay2, onUpdate, onComplete }) {
  let setValue = () => (onUpdate && onUpdate(keyframes2[keyframes2.length - 1]), onComplete && onComplete(), {
    time: 0,
    speed: 1,
    duration: 0,
    play: noop3,
    pause: noop3,
    stop: noop3,
    then: (resolve2) => (resolve2(), Promise.resolve()),
    cancel: noop3,
    complete: noop3
  });
  return delay2 ? animateValue({
    keyframes: [0, 1],
    duration: 0,
    delay: delay2,
    onComplete: setValue
  }) : setValue();
}

// node_modules/framer-motion/dist/es/animation/utils/default-transitions.mjs
var underDampedSpring = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
}, criticallyDampedSpring = (target) => ({
  type: "spring",
  stiffness: 550,
  damping: target === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
}), keyframesTransition = {
  type: "keyframes",
  duration: 0.8
}, ease = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
}, getDefaultTransition = (valueKey, { keyframes: keyframes2 }) => keyframes2.length > 2 ? keyframesTransition : transformProps.has(valueKey) ? valueKey.startsWith("scale") ? criticallyDampedSpring(keyframes2[1]) : underDampedSpring : ease;

// node_modules/framer-motion/dist/es/animation/utils/is-animatable.mjs
var isAnimatable = (key2, value2) => key2 === "zIndex" ? !1 : !!(typeof value2 == "number" || Array.isArray(value2) || typeof value2 == "string" && complex.test(value2) && !value2.startsWith("url("));

// node_modules/framer-motion/dist/es/value/types/complex/filter.mjs
var maxDefaults = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function applyDefaultFilter(v2) {
  let [name, value2] = v2.slice(0, -1).split("(");
  if (name === "drop-shadow")
    return v2;
  let [number4] = value2.match(floatRegex) || [];
  if (!number4)
    return v2;
  let unit = value2.replace(number4, ""), defaultValue = maxDefaults.has(name) ? 1 : 0;
  return number4 !== value2 && (defaultValue *= 100), name + "(" + defaultValue + unit + ")";
}
var functionRegex = /([a-z-]*)\(.*?\)/g, filter2 = {
  ...complex,
  getAnimatableNone: (v2) => {
    let functions = v2.match(functionRegex);
    return functions ? functions.map(applyDefaultFilter).join(" ") : v2;
  }
};

// node_modules/framer-motion/dist/es/render/dom/value-types/defaults.mjs
var defaultValueTypes = {
  ...numberValueTypes,
  color,
  backgroundColor: color,
  outlineColor: color,
  fill: color,
  stroke: color,
  borderColor: color,
  borderTopColor: color,
  borderRightColor: color,
  borderBottomColor: color,
  borderLeftColor: color,
  filter: filter2,
  WebkitFilter: filter2
}, getDefaultValueType = (key2) => defaultValueTypes[key2];

// node_modules/framer-motion/dist/es/render/dom/value-types/animatable-none.mjs
function getAnimatableNone2(key2, value2) {
  let defaultValueType = getDefaultValueType(key2);
  return defaultValueType !== filter2 && (defaultValueType = complex), defaultValueType.getAnimatableNone ? defaultValueType.getAnimatableNone(value2) : void 0;
}

// node_modules/framer-motion/dist/es/animation/utils/transitions.mjs
function isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat: repeat2, repeatType, repeatDelay, from: from2, elapsed, ...transition }) {
  return !!Object.keys(transition).length;
}
function isZero(value2) {
  return value2 === 0 || typeof value2 == "string" && parseFloat(value2) === 0 && value2.indexOf(" ") === -1;
}
function getZeroUnit(potentialUnitType) {
  return typeof potentialUnitType == "number" ? 0 : getAnimatableNone2("", potentialUnitType);
}
function getValueTransition(transition, key2) {
  return transition[key2] || transition.default || transition;
}

// node_modules/framer-motion/dist/es/animation/utils/wildcards.mjs
function fillWildcardKeyframes(origin, [...keyframes2]) {
  for (let i3 = 0; i3 < keyframes2.length; i3++)
    keyframes2[i3] === null && (keyframes2[i3] = i3 === 0 ? origin : keyframes2[i3 - 1]);
  return keyframes2;
}

// node_modules/framer-motion/dist/es/animation/utils/keyframes.mjs
function getKeyframes(value2, valueName, target, transition) {
  let isTargetAnimatable = isAnimatable(valueName, target), origin = transition.from !== void 0 ? transition.from : value2.get();
  return origin === "none" && isTargetAnimatable && typeof target == "string" ? origin = getAnimatableNone2(valueName, target) : isZero(origin) && typeof target == "string" ? origin = getZeroUnit(target) : !Array.isArray(target) && isZero(target) && typeof origin == "string" && (target = getZeroUnit(origin)), Array.isArray(target) ? fillWildcardKeyframes(origin, target) : [origin, target];
}

// node_modules/framer-motion/dist/es/animation/interfaces/motion-value.mjs
var animateMotionValue = (valueName, value2, target, transition = {}) => (onComplete) => {
  let valueTransition = getValueTransition(transition, valueName) || {}, delay2 = valueTransition.delay || transition.delay || 0, { elapsed = 0 } = transition;
  elapsed = elapsed - secondsToMilliseconds(delay2);
  let keyframes2 = getKeyframes(value2, valueName, target, valueTransition), originKeyframe = keyframes2[0], targetKeyframe = keyframes2[keyframes2.length - 1], isOriginAnimatable = isAnimatable(valueName, originKeyframe), isTargetAnimatable = isAnimatable(valueName, targetKeyframe);
  warning2(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${valueName} from "${originKeyframe}" to "${targetKeyframe}". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${targetKeyframe} via the \`style\` property.`);
  let options2 = {
    keyframes: keyframes2,
    velocity: value2.getVelocity(),
    ease: "easeOut",
    ...valueTransition,
    delay: -elapsed,
    onUpdate: (v2) => {
      value2.set(v2), valueTransition.onUpdate && valueTransition.onUpdate(v2);
    },
    onComplete: () => {
      onComplete(), valueTransition.onComplete && valueTransition.onComplete();
    }
  };
  if (isTransitionDefined(valueTransition) || (options2 = {
    ...options2,
    ...getDefaultTransition(valueName, options2)
  }), options2.duration && (options2.duration = secondsToMilliseconds(options2.duration)), options2.repeatDelay && (options2.repeatDelay = secondsToMilliseconds(options2.repeatDelay)), !isOriginAnimatable || !isTargetAnimatable || instantAnimationState.current || valueTransition.type === !1)
    return createInstantAnimation(options2);
  if (value2.owner && value2.owner.current instanceof HTMLElement && !value2.owner.getProps().onUpdate) {
    let acceleratedAnimation = createAcceleratedAnimation(value2, valueName, options2);
    if (acceleratedAnimation)
      return acceleratedAnimation;
  }
  return animateValue(options2);
};

// node_modules/framer-motion/dist/es/value/use-will-change/is.mjs
function isWillChangeMotionValue(value2) {
  return Boolean(isMotionValue(value2) && value2.add);
}

// node_modules/framer-motion/dist/es/utils/is-numerical-string.mjs
var isNumericalString = (v2) => /^\-?\d*\.?\d+$/.test(v2);

// node_modules/framer-motion/dist/es/utils/is-zero-value-string.mjs
var isZeroValueString = (v2) => /^0[^.\s]+$/.test(v2);

// node_modules/framer-motion/dist/es/utils/array.mjs
function addUniqueItem(arr2, item) {
  arr2.indexOf(item) === -1 && arr2.push(item);
}
function removeItem(arr2, item) {
  let index2 = arr2.indexOf(item);
  index2 > -1 && arr2.splice(index2, 1);
}

// node_modules/framer-motion/dist/es/utils/subscription-manager.mjs
var SubscriptionManager = class {
  constructor() {
    this.subscriptions = [];
  }
  add(handler) {
    return addUniqueItem(this.subscriptions, handler), () => removeItem(this.subscriptions, handler);
  }
  notify(a3, b2, c4) {
    let numSubscriptions = this.subscriptions.length;
    if (!!numSubscriptions)
      if (numSubscriptions === 1)
        this.subscriptions[0](a3, b2, c4);
      else
        for (let i3 = 0; i3 < numSubscriptions; i3++) {
          let handler = this.subscriptions[i3];
          handler && handler(a3, b2, c4);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
};

// node_modules/framer-motion/dist/es/utils/warn-once.mjs
var warned = /* @__PURE__ */ new Set();
function warnOnce3(condition, message, element) {
  condition || warned.has(message) || (console.warn(message), element && console.warn(element), warned.add(message));
}

// node_modules/framer-motion/dist/es/value/index.mjs
var isFloat2 = (value2) => !isNaN(parseFloat(value2)), MotionValue = class {
  constructor(init4, options2 = {}) {
    this.version = "10.11.2", this.timeDelta = 0, this.lastUpdated = 0, this.canTrackVelocity = !1, this.events = {}, this.updateAndNotify = (v2, render = !0) => {
      this.prev = this.current, this.current = v2;
      let { delta, timestamp: timestamp2 } = frameData;
      this.lastUpdated !== timestamp2 && (this.timeDelta = delta, this.lastUpdated = timestamp2, sync.postRender(this.scheduleVelocityCheck)), this.prev !== this.current && this.events.change && this.events.change.notify(this.current), this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()), render && this.events.renderRequest && this.events.renderRequest.notify(this.current);
    }, this.scheduleVelocityCheck = () => sync.postRender(this.velocityCheck), this.velocityCheck = ({ timestamp: timestamp2 }) => {
      timestamp2 !== this.lastUpdated && (this.prev = this.current, this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()));
    }, this.hasAnimated = !1, this.prev = this.current = init4, this.canTrackVelocity = isFloat2(this.current), this.owner = options2.owner;
  }
  onChange(subscription) {
    return warnOnce3(!1, 'value.onChange(callback) is deprecated. Switch to value.on("change", callback).'), this.on("change", subscription);
  }
  on(eventName, callback) {
    this.events[eventName] || (this.events[eventName] = new SubscriptionManager());
    let unsubscribe = this.events[eventName].add(callback);
    return eventName === "change" ? () => {
      unsubscribe(), sync.read(() => {
        this.events.change.getSize() || this.stop();
      });
    } : unsubscribe;
  }
  clearListeners() {
    for (let eventManagers in this.events)
      this.events[eventManagers].clear();
  }
  attach(passiveEffect, stopPassiveEffect) {
    this.passiveEffect = passiveEffect, this.stopPassiveEffect = stopPassiveEffect;
  }
  set(v2, render = !0) {
    !render || !this.passiveEffect ? this.updateAndNotify(v2, render) : this.passiveEffect(v2, this.updateAndNotify);
  }
  setWithVelocity(prev, current, delta) {
    this.set(current), this.prev = prev, this.timeDelta = delta;
  }
  jump(v2) {
    this.updateAndNotify(v2), this.prev = v2, this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
  get() {
    return this.current;
  }
  getPrevious() {
    return this.prev;
  }
  getVelocity() {
    return this.canTrackVelocity ? velocityPerSecond(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta) : 0;
  }
  start(startAnimation) {
    return this.stop(), new Promise((resolve2) => {
      this.hasAnimated = !0, this.animation = startAnimation(resolve2), this.events.animationStart && this.events.animationStart.notify();
    }).then(() => {
      this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();
    });
  }
  stop() {
    this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();
  }
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  destroy() {
    this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
};
function motionValue(init4, options2) {
  return new MotionValue(init4, options2);
}

// node_modules/framer-motion/dist/es/render/dom/value-types/test.mjs
var testValueType = (v2) => (type2) => type2.test(v2);

// node_modules/framer-motion/dist/es/render/dom/value-types/type-auto.mjs
var auto = {
  test: (v2) => v2 === "auto",
  parse: (v2) => v2
};

// node_modules/framer-motion/dist/es/render/dom/value-types/dimensions.mjs
var dimensionValueTypes = [number3, px, percent, degrees, vw, vh, auto], findDimensionValueType = (v2) => dimensionValueTypes.find(testValueType(v2));

// node_modules/framer-motion/dist/es/render/dom/value-types/find.mjs
var valueTypes = [...dimensionValueTypes, color, complex], findValueType = (v2) => valueTypes.find(testValueType(v2));

// node_modules/framer-motion/dist/es/render/utils/setters.mjs
function setMotionValue(visualElement, key2, value2) {
  visualElement.hasValue(key2) ? visualElement.getValue(key2).set(value2) : visualElement.addValue(key2, motionValue(value2));
}
function setTarget(visualElement, definition) {
  let resolved = resolveVariant(visualElement, definition), { transitionEnd: transitionEnd2 = {}, transition = {}, ...target } = resolved ? visualElement.makeTargetAnimatable(resolved, !1) : {};
  target = { ...target, ...transitionEnd2 };
  for (let key2 in target) {
    let value2 = resolveFinalValueInKeyframes(target[key2]);
    setMotionValue(visualElement, key2, value2);
  }
}
function checkTargetForNewValues(visualElement, target, origin) {
  var _a, _b;
  let newValueKeys = Object.keys(target).filter((key2) => !visualElement.hasValue(key2)), numNewValues = newValueKeys.length;
  if (!!numNewValues)
    for (let i3 = 0; i3 < numNewValues; i3++) {
      let key2 = newValueKeys[i3], targetValue = target[key2], value2 = null;
      Array.isArray(targetValue) && (value2 = targetValue[0]), value2 === null && (value2 = (_b = (_a = origin[key2]) !== null && _a !== void 0 ? _a : visualElement.readValue(key2)) !== null && _b !== void 0 ? _b : target[key2]), value2 != null && (typeof value2 == "string" && (isNumericalString(value2) || isZeroValueString(value2)) ? value2 = parseFloat(value2) : !findValueType(value2) && complex.test(targetValue) && (value2 = getAnimatableNone2(key2, targetValue)), visualElement.addValue(key2, motionValue(value2, { owner: visualElement })), origin[key2] === void 0 && (origin[key2] = value2), value2 !== null && visualElement.setBaseTarget(key2, value2));
    }
}
function getOriginFromTransition(key2, transition) {
  return transition ? (transition[key2] || transition.default || transition).from : void 0;
}
function getOrigin(target, transition, visualElement) {
  let origin = {};
  for (let key2 in target) {
    let transitionOrigin = getOriginFromTransition(key2, transition);
    if (transitionOrigin !== void 0)
      origin[key2] = transitionOrigin;
    else {
      let value2 = visualElement.getValue(key2);
      value2 && (origin[key2] = value2.get());
    }
  }
  return origin;
}

// node_modules/framer-motion/dist/es/animation/interfaces/visual-element-target.mjs
function shouldBlockAnimation({ protectedKeys, needsAnimating }, key2) {
  let shouldBlock = protectedKeys.hasOwnProperty(key2) && needsAnimating[key2] !== !0;
  return needsAnimating[key2] = !1, shouldBlock;
}
function animateTarget(visualElement, definition, { delay: delay2 = 0, transitionOverride, type: type2 } = {}) {
  let { transition = visualElement.getDefaultTransition(), transitionEnd: transitionEnd2, ...target } = visualElement.makeTargetAnimatable(definition), willChange = visualElement.getValue("willChange");
  transitionOverride && (transition = transitionOverride);
  let animations2 = [], animationTypeState = type2 && visualElement.animationState && visualElement.animationState.getState()[type2];
  for (let key2 in target) {
    let value2 = visualElement.getValue(key2), valueTarget = target[key2];
    if (!value2 || valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key2))
      continue;
    let valueTransition = { delay: delay2, elapsed: 0, ...transition };
    if (window.HandoffAppearAnimations && !value2.hasAnimated) {
      let appearId = visualElement.getProps()[optimizedAppearDataAttribute];
      appearId && (valueTransition.elapsed = window.HandoffAppearAnimations(appearId, key2, value2, sync));
    }
    value2.start(animateMotionValue(key2, value2, valueTarget, visualElement.shouldReduceMotion && transformProps.has(key2) ? { type: !1 } : valueTransition));
    let animation = value2.animation;
    isWillChangeMotionValue(willChange) && (willChange.add(key2), animation.then(() => willChange.remove(key2))), animations2.push(animation);
  }
  return transitionEnd2 && Promise.all(animations2).then(() => {
    transitionEnd2 && setTarget(visualElement, transitionEnd2);
  }), animations2;
}

// node_modules/framer-motion/dist/es/animation/interfaces/visual-element-variant.mjs
function animateVariant(visualElement, variant, options2 = {}) {
  let resolved = resolveVariant(visualElement, variant, options2.custom), { transition = visualElement.getDefaultTransition() || {} } = resolved || {};
  options2.transitionOverride && (transition = options2.transitionOverride);
  let getAnimation = resolved ? () => Promise.all(animateTarget(visualElement, resolved, options2)) : () => Promise.resolve(), getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size ? (forwardDelay = 0) => {
    let { delayChildren = 0, staggerChildren, staggerDirection } = transition;
    return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options2);
  } : () => Promise.resolve(), { when } = transition;
  if (when) {
    let [first, last] = when === "beforeChildren" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation];
    return first().then(() => last());
  } else
    return Promise.all([getAnimation(), getChildAnimations(options2.delay)]);
}
function animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options2) {
  let animations2 = [], maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren, generateStaggerDuration = staggerDirection === 1 ? (i3 = 0) => i3 * staggerChildren : (i3 = 0) => maxStaggerDuration - i3 * staggerChildren;
  return Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach((child, i3) => {
    child.notify("AnimationStart", variant), animations2.push(animateVariant(child, variant, {
      ...options2,
      delay: delayChildren + generateStaggerDuration(i3)
    }).then(() => child.notify("AnimationComplete", variant)));
  }), Promise.all(animations2);
}
function sortByTreeOrder(a3, b2) {
  return a3.sortNodePosition(b2);
}

// node_modules/framer-motion/dist/es/animation/interfaces/visual-element.mjs
function animateVisualElement(visualElement, definition, options2 = {}) {
  visualElement.notify("AnimationStart", definition);
  let animation;
  if (Array.isArray(definition)) {
    let animations2 = definition.map((variant) => animateVariant(visualElement, variant, options2));
    animation = Promise.all(animations2);
  } else if (typeof definition == "string")
    animation = animateVariant(visualElement, definition, options2);
  else {
    let resolvedDefinition = typeof definition == "function" ? resolveVariant(visualElement, definition, options2.custom) : definition;
    animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options2));
  }
  return animation.then(() => visualElement.notify("AnimationComplete", definition));
}

// node_modules/framer-motion/dist/es/render/utils/animation-state.mjs
var reversePriorityOrder = [...variantPriorityOrder].reverse(), numAnimationTypes = variantPriorityOrder.length;
function animateList(visualElement) {
  return (animations2) => Promise.all(animations2.map(({ animation, options: options2 }) => animateVisualElement(visualElement, animation, options2)));
}
function createAnimationState(visualElement) {
  let animate = animateList(visualElement), state = createState(), isInitialRender = !0, buildResolvedTypeValues = (acc, definition) => {
    let resolved = resolveVariant(visualElement, definition);
    if (resolved) {
      let { transition, transitionEnd: transitionEnd2, ...target } = resolved;
      acc = { ...acc, ...target, ...transitionEnd2 };
    }
    return acc;
  };
  function setAnimateFunction(makeAnimator) {
    animate = makeAnimator(visualElement);
  }
  function animateChanges(options2, changedActiveType) {
    let props = visualElement.getProps(), context = visualElement.getVariantContext(!0) || {}, animations2 = [], removedKeys = /* @__PURE__ */ new Set(), encounteredKeys = {}, removedVariantIndex = 1 / 0;
    for (let i3 = 0; i3 < numAnimationTypes; i3++) {
      let type2 = reversePriorityOrder[i3], typeState = state[type2], prop = props[type2] !== void 0 ? props[type2] : context[type2], propIsVariant = isVariantLabel(prop), activeDelta = type2 === changedActiveType ? typeState.isActive : null;
      activeDelta === !1 && (removedVariantIndex = i3);
      let isInherited = prop === context[type2] && prop !== props[type2] && propIsVariant;
      if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount && (isInherited = !1), typeState.protectedKeys = { ...encounteredKeys }, !typeState.isActive && activeDelta === null || !prop && !typeState.prevProp || isAnimationControls(prop) || typeof prop == "boolean")
        continue;
      let variantDidChange = checkVariantsDidChange(typeState.prevProp, prop), shouldAnimateType = variantDidChange || type2 === changedActiveType && typeState.isActive && !isInherited && propIsVariant || i3 > removedVariantIndex && propIsVariant, definitionList = Array.isArray(prop) ? prop : [prop], resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});
      activeDelta === !1 && (resolvedValues = {});
      let { prevResolvedValues = {} } = typeState, allKeys = {
        ...prevResolvedValues,
        ...resolvedValues
      }, markToAnimate = (key2) => {
        shouldAnimateType = !0, removedKeys.delete(key2), typeState.needsAnimating[key2] = !0;
      };
      for (let key2 in allKeys) {
        let next = resolvedValues[key2], prev = prevResolvedValues[key2];
        encounteredKeys.hasOwnProperty(key2) || (next !== prev ? isKeyframesTarget(next) && isKeyframesTarget(prev) ? !shallowCompare(next, prev) || variantDidChange ? markToAnimate(key2) : typeState.protectedKeys[key2] = !0 : next !== void 0 ? markToAnimate(key2) : removedKeys.add(key2) : next !== void 0 && removedKeys.has(key2) ? markToAnimate(key2) : typeState.protectedKeys[key2] = !0);
      }
      typeState.prevProp = prop, typeState.prevResolvedValues = resolvedValues, typeState.isActive && (encounteredKeys = { ...encounteredKeys, ...resolvedValues }), isInitialRender && visualElement.blockInitialAnimation && (shouldAnimateType = !1), shouldAnimateType && !isInherited && animations2.push(...definitionList.map((animation) => ({
        animation,
        options: { type: type2, ...options2 }
      })));
    }
    if (removedKeys.size) {
      let fallbackAnimation = {};
      removedKeys.forEach((key2) => {
        let fallbackTarget = visualElement.getBaseTarget(key2);
        fallbackTarget !== void 0 && (fallbackAnimation[key2] = fallbackTarget);
      }), animations2.push({ animation: fallbackAnimation });
    }
    let shouldAnimate = Boolean(animations2.length);
    return isInitialRender && props.initial === !1 && !visualElement.manuallyAnimateOnMount && (shouldAnimate = !1), isInitialRender = !1, shouldAnimate ? animate(animations2) : Promise.resolve();
  }
  function setActive(type2, isActive, options2) {
    var _a;
    if (state[type2].isActive === isActive)
      return Promise.resolve();
    (_a = visualElement.variantChildren) === null || _a === void 0 || _a.forEach((child) => {
      var _a2;
      return (_a2 = child.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(type2, isActive);
    }), state[type2].isActive = isActive;
    let animations2 = animateChanges(options2, type2);
    for (let key2 in state)
      state[key2].protectedKeys = {};
    return animations2;
  }
  return {
    animateChanges,
    setActive,
    setAnimateFunction,
    getState: () => state
  };
}
function checkVariantsDidChange(prev, next) {
  return typeof next == "string" ? next !== prev : Array.isArray(next) ? !shallowCompare(next, prev) : !1;
}
function createTypeState(isActive = !1) {
  return {
    isActive,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function createState() {
  return {
    animate: createTypeState(!0),
    whileInView: createTypeState(),
    whileHover: createTypeState(),
    whileTap: createTypeState(),
    whileDrag: createTypeState(),
    whileFocus: createTypeState(),
    exit: createTypeState()
  };
}

// node_modules/framer-motion/dist/es/motion/features/animation/index.mjs
var AnimationFeature = class extends Feature {
  constructor(node) {
    super(node), node.animationState || (node.animationState = createAnimationState(node));
  }
  updateAnimationControlsSubscription() {
    let { animate } = this.node.getProps();
    this.unmount(), isAnimationControls(animate) && (this.unmount = animate.subscribe(this.node));
  }
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    let { animate } = this.node.getProps(), { animate: prevAnimate } = this.node.prevProps || {};
    animate !== prevAnimate && this.updateAnimationControlsSubscription();
  }
  unmount() {
  }
};

// node_modules/framer-motion/dist/es/motion/features/animation/exit.mjs
var id2 = 0, ExitAnimationFeature = class extends Feature {
  constructor() {
    super(...arguments), this.id = id2++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    let { isPresent, onExitComplete, custom } = this.node.presenceContext, { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || isPresent === prevIsPresent)
      return;
    let exitAnimation = this.node.animationState.setActive("exit", !isPresent, { custom: custom ?? this.node.getProps().custom });
    onExitComplete && !isPresent && exitAnimation.then(() => onExitComplete(this.id));
  }
  mount() {
    let { register } = this.node.presenceContext || {};
    register && (this.unmount = register(this.id));
  }
  unmount() {
  }
};

// node_modules/framer-motion/dist/es/motion/features/animations.mjs
var animations = {
  animation: {
    Feature: AnimationFeature
  },
  exit: {
    Feature: ExitAnimationFeature
  }
};

// node_modules/framer-motion/dist/es/utils/distance.mjs
var distance = (a3, b2) => Math.abs(a3 - b2);
function distance2D(a3, b2) {
  let xDelta = distance(a3.x, b2.x), yDelta = distance(a3.y, b2.y);
  return Math.sqrt(xDelta ** 2 + yDelta ** 2);
}

// node_modules/framer-motion/dist/es/gestures/pan/PanSession.mjs
var PanSession = class {
  constructor(event2, handlers, { transformPagePoint } = {}) {
    if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      let info2 = getPanInfo(this.lastMoveEventInfo, this.history), isPanStarted = this.startEvent !== null, isDistancePastThreshold = distance2D(info2.offset, { x: 0, y: 0 }) >= 3;
      if (!isPanStarted && !isDistancePastThreshold)
        return;
      let { point: point2 } = info2, { timestamp: timestamp3 } = frameData;
      this.history.push({ ...point2, timestamp: timestamp3 });
      let { onStart, onMove } = this.handlers;
      isPanStarted || (onStart && onStart(this.lastMoveEvent, info2), this.startEvent = this.lastMoveEvent), onMove && onMove(this.lastMoveEvent, info2);
    }, this.handlePointerMove = (event3, info2) => {
      this.lastMoveEvent = event3, this.lastMoveEventInfo = transformPoint(info2, this.transformPagePoint), sync.update(this.updatePoint, !0);
    }, this.handlePointerUp = (event3, info2) => {
      if (this.end(), !(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      let { onEnd, onSessionEnd } = this.handlers, panInfo = getPanInfo(event3.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(info2, this.transformPagePoint), this.history);
      this.startEvent && onEnd && onEnd(event3, panInfo), onSessionEnd && onSessionEnd(event3, panInfo);
    }, !isPrimaryPointer(event2))
      return;
    this.handlers = handlers, this.transformPagePoint = transformPagePoint;
    let info = extractEventInfo(event2), initialInfo = transformPoint(info, this.transformPagePoint), { point } = initialInfo, { timestamp: timestamp2 } = frameData;
    this.history = [{ ...point, timestamp: timestamp2 }];
    let { onSessionStart } = handlers;
    onSessionStart && onSessionStart(event2, getPanInfo(initialInfo, this.history)), this.removeListeners = pipe(addPointerEvent(window, "pointermove", this.handlePointerMove), addPointerEvent(window, "pointerup", this.handlePointerUp), addPointerEvent(window, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(handlers) {
    this.handlers = handlers;
  }
  end() {
    this.removeListeners && this.removeListeners(), cancelSync.update(this.updatePoint);
  }
};
function transformPoint(info, transformPagePoint) {
  return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
}
function subtractPoint(a3, b2) {
  return { x: a3.x - b2.x, y: a3.y - b2.y };
}
function getPanInfo({ point }, history) {
  return {
    point,
    delta: subtractPoint(point, lastDevicePoint(history)),
    offset: subtractPoint(point, startDevicePoint(history)),
    velocity: getVelocity2(history, 0.1)
  };
}
function startDevicePoint(history) {
  return history[0];
}
function lastDevicePoint(history) {
  return history[history.length - 1];
}
function getVelocity2(history, timeDelta) {
  if (history.length < 2)
    return { x: 0, y: 0 };
  let i3 = history.length - 1, timestampedPoint = null, lastPoint = lastDevicePoint(history);
  for (; i3 >= 0 && (timestampedPoint = history[i3], !(lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta))); )
    i3--;
  if (!timestampedPoint)
    return { x: 0, y: 0 };
  let time3 = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);
  if (time3 === 0)
    return { x: 0, y: 0 };
  let currentVelocity = {
    x: (lastPoint.x - timestampedPoint.x) / time3,
    y: (lastPoint.y - timestampedPoint.y) / time3
  };
  return currentVelocity.x === 1 / 0 && (currentVelocity.x = 0), currentVelocity.y === 1 / 0 && (currentVelocity.y = 0), currentVelocity;
}

// node_modules/framer-motion/dist/es/projection/geometry/delta-calc.mjs
function calcLength(axis) {
  return axis.max - axis.min;
}
function isNear(value2, target = 0, maxDistance = 0.01) {
  return Math.abs(value2 - target) <= maxDistance;
}
function calcAxisDelta(delta, source2, target, origin = 0.5) {
  delta.origin = origin, delta.originPoint = mix(source2.min, source2.max, delta.origin), delta.scale = calcLength(target) / calcLength(source2), (isNear(delta.scale, 1, 1e-4) || isNaN(delta.scale)) && (delta.scale = 1), delta.translate = mix(target.min, target.max, delta.origin) - delta.originPoint, (isNear(delta.translate) || isNaN(delta.translate)) && (delta.translate = 0);
}
function calcBoxDelta(delta, source2, target, origin) {
  calcAxisDelta(delta.x, source2.x, target.x, origin ? origin.originX : void 0), calcAxisDelta(delta.y, source2.y, target.y, origin ? origin.originY : void 0);
}
function calcRelativeAxis(target, relative2, parent) {
  target.min = parent.min + relative2.min, target.max = target.min + calcLength(relative2);
}
function calcRelativeBox(target, relative2, parent) {
  calcRelativeAxis(target.x, relative2.x, parent.x), calcRelativeAxis(target.y, relative2.y, parent.y);
}
function calcRelativeAxisPosition(target, layout2, parent) {
  target.min = layout2.min - parent.min, target.max = target.min + calcLength(layout2);
}
function calcRelativePosition(target, layout2, parent) {
  calcRelativeAxisPosition(target.x, layout2.x, parent.x), calcRelativeAxisPosition(target.y, layout2.y, parent.y);
}

// node_modules/framer-motion/dist/es/gestures/drag/utils/constraints.mjs
function applyConstraints(point, { min, max }, elastic) {
  return min !== void 0 && point < min ? point = elastic ? mix(min, point, elastic.min) : Math.max(point, min) : max !== void 0 && point > max && (point = elastic ? mix(max, point, elastic.max) : Math.min(point, max)), point;
}
function calcRelativeAxisConstraints(axis, min, max) {
  return {
    min: min !== void 0 ? axis.min + min : void 0,
    max: max !== void 0 ? axis.max + max - (axis.max - axis.min) : void 0
  };
}
function calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {
  return {
    x: calcRelativeAxisConstraints(layoutBox.x, left, right),
    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)
  };
}
function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
  let min = constraintsAxis.min - layoutAxis.min, max = constraintsAxis.max - layoutAxis.max;
  return constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min && ([min, max] = [max, min]), { min, max };
}
function calcViewportConstraints(layoutBox, constraintsBox) {
  return {
    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
  };
}
function calcOrigin2(source2, target) {
  let origin = 0.5, sourceLength = calcLength(source2), targetLength = calcLength(target);
  return targetLength > sourceLength ? origin = progress(target.min, target.max - sourceLength, source2.min) : sourceLength > targetLength && (origin = progress(source2.min, source2.max - targetLength, target.min)), clamp(0, 1, origin);
}
function rebaseAxisConstraints(layout2, constraints) {
  let relativeConstraints = {};
  return constraints.min !== void 0 && (relativeConstraints.min = constraints.min - layout2.min), constraints.max !== void 0 && (relativeConstraints.max = constraints.max - layout2.min), relativeConstraints;
}
var defaultElastic = 0.35;
function resolveDragElastic(dragElastic = defaultElastic) {
  return dragElastic === !1 ? dragElastic = 0 : dragElastic === !0 && (dragElastic = defaultElastic), {
    x: resolveAxisElastic(dragElastic, "left", "right"),
    y: resolveAxisElastic(dragElastic, "top", "bottom")
  };
}
function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
  return {
    min: resolvePointElastic(dragElastic, minLabel),
    max: resolvePointElastic(dragElastic, maxLabel)
  };
}
function resolvePointElastic(dragElastic, label) {
  return typeof dragElastic == "number" ? dragElastic : dragElastic[label] || 0;
}

// node_modules/framer-motion/dist/es/projection/geometry/models.mjs
var createAxisDelta = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
}), createDelta = () => ({
  x: createAxisDelta(),
  y: createAxisDelta()
}), createAxis = () => ({ min: 0, max: 0 }), createBox = () => ({
  x: createAxis(),
  y: createAxis()
});

// node_modules/framer-motion/dist/es/projection/utils/each-axis.mjs
function eachAxis(callback) {
  return [callback("x"), callback("y")];
}

// node_modules/framer-motion/dist/es/projection/geometry/conversion.mjs
function convertBoundingBoxToBox({ top, left, right, bottom }) {
  return {
    x: { min: left, max: right },
    y: { min: top, max: bottom }
  };
}
function convertBoxToBoundingBox({ x: x2, y: y2 }) {
  return { top: y2.min, right: x2.max, bottom: y2.max, left: x2.min };
}
function transformBoxPoints(point, transformPoint2) {
  if (!transformPoint2)
    return point;
  let topLeft = transformPoint2({ x: point.left, y: point.top }), bottomRight = transformPoint2({ x: point.right, y: point.bottom });
  return {
    top: topLeft.y,
    left: topLeft.x,
    bottom: bottomRight.y,
    right: bottomRight.x
  };
}

// node_modules/framer-motion/dist/es/projection/utils/has-transform.mjs
function isIdentityScale(scale2) {
  return scale2 === void 0 || scale2 === 1;
}
function hasScale({ scale: scale2, scaleX, scaleY }) {
  return !isIdentityScale(scale2) || !isIdentityScale(scaleX) || !isIdentityScale(scaleY);
}
function hasTransform(values) {
  return hasScale(values) || has2DTranslate(values) || values.z || values.rotate || values.rotateX || values.rotateY;
}
function has2DTranslate(values) {
  return is2DTranslate(values.x) || is2DTranslate(values.y);
}
function is2DTranslate(value2) {
  return value2 && value2 !== "0%";
}

// node_modules/framer-motion/dist/es/projection/geometry/delta-apply.mjs
function scalePoint(point, scale2, originPoint) {
  let distanceFromOrigin = point - originPoint, scaled = scale2 * distanceFromOrigin;
  return originPoint + scaled;
}
function applyPointDelta(point, translate, scale2, originPoint, boxScale) {
  return boxScale !== void 0 && (point = scalePoint(point, boxScale, originPoint)), scalePoint(point, scale2, originPoint) + translate;
}
function applyAxisDelta(axis, translate = 0, scale2 = 1, originPoint, boxScale) {
  axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale), axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function applyBoxDelta(box, { x: x2, y: y2 }) {
  applyAxisDelta(box.x, x2.translate, x2.scale, x2.originPoint), applyAxisDelta(box.y, y2.translate, y2.scale, y2.originPoint);
}
function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = !1) {
  let treeLength = treePath.length;
  if (!treeLength)
    return;
  treeScale.x = treeScale.y = 1;
  let node, delta;
  for (let i3 = 0; i3 < treeLength; i3++) {
    node = treePath[i3], delta = node.projectionDelta;
    let instance2 = node.instance;
    instance2 && instance2.style && instance2.style.display === "contents" || (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root && transformBox(box, {
      x: -node.scroll.offset.x,
      y: -node.scroll.offset.y
    }), delta && (treeScale.x *= delta.x.scale, treeScale.y *= delta.y.scale, applyBoxDelta(box, delta)), isSharedTransition && hasTransform(node.latestValues) && transformBox(box, node.latestValues));
  }
  treeScale.x = snapToDefault(treeScale.x), treeScale.y = snapToDefault(treeScale.y);
}
function snapToDefault(scale2) {
  return Number.isInteger(scale2) || scale2 > 1.0000000000001 || scale2 < 0.999999999999 ? scale2 : 1;
}
function translateAxis(axis, distance2) {
  axis.min = axis.min + distance2, axis.max = axis.max + distance2;
}
function transformAxis(axis, transforms, [key2, scaleKey, originKey]) {
  let axisOrigin = transforms[originKey] !== void 0 ? transforms[originKey] : 0.5, originPoint = mix(axis.min, axis.max, axisOrigin);
  applyAxisDelta(axis, transforms[key2], transforms[scaleKey], originPoint, transforms.scale);
}
var xKeys = ["x", "scaleX", "originX"], yKeys = ["y", "scaleY", "originY"];
function transformBox(box, transform) {
  transformAxis(box.x, transform, xKeys), transformAxis(box.y, transform, yKeys);
}

// node_modules/framer-motion/dist/es/projection/utils/measure.mjs
function measureViewportBox(instance2, transformPoint2) {
  return convertBoundingBoxToBox(transformBoxPoints(instance2.getBoundingClientRect(), transformPoint2));
}
function measurePageBox(element, rootProjectionNode2, transformPagePoint) {
  let viewportBox = measureViewportBox(element, transformPagePoint), { scroll } = rootProjectionNode2;
  return scroll && (translateAxis(viewportBox.x, scroll.offset.x), translateAxis(viewportBox.y, scroll.offset.y)), viewportBox;
}

// node_modules/framer-motion/dist/es/gestures/drag/VisualElementDragControls.mjs
var elementDragControls = /* @__PURE__ */ new WeakMap(), VisualElementDragControls = class {
  constructor(visualElement) {
    this.openGlobalLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = createBox(), this.visualElement = visualElement;
  }
  start(originEvent, { snapToCursor = !1 } = {}) {
    let { presenceContext } = this.visualElement;
    if (presenceContext && presenceContext.isPresent === !1)
      return;
    let onSessionStart = (event2) => {
      this.stopAnimation(), snapToCursor && this.snapToCursor(extractEventInfo(event2, "page").point);
    }, onStart = (event2, info) => {
      let { drag: drag2, dragPropagation, onDragStart } = this.getProps();
      if (drag2 && !dragPropagation && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = getGlobalLock(drag2), !this.openGlobalLock))
        return;
      this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), eachAxis((axis) => {
        let current = this.getAxisMotionValue(axis).get() || 0;
        if (percent.test(current)) {
          let { projection } = this.visualElement;
          if (projection && projection.layout) {
            let measuredAxis = projection.layout.layoutBox[axis];
            measuredAxis && (current = calcLength(measuredAxis) * (parseFloat(current) / 100));
          }
        }
        this.originPoint[axis] = current;
      }), onDragStart && sync.update(() => onDragStart(event2, info));
      let { animationState } = this.visualElement;
      animationState && animationState.setActive("whileDrag", !0);
    }, onMove = (event2, info) => {
      let { dragPropagation, dragDirectionLock, onDirectionLock, onDrag } = this.getProps();
      if (!dragPropagation && !this.openGlobalLock)
        return;
      let { offset } = info;
      if (dragDirectionLock && this.currentDirection === null) {
        this.currentDirection = getCurrentDirection(offset), this.currentDirection !== null && onDirectionLock && onDirectionLock(this.currentDirection);
        return;
      }
      this.updateAxis("x", info.point, offset), this.updateAxis("y", info.point, offset), this.visualElement.render(), onDrag && onDrag(event2, info);
    }, onSessionEnd = (event2, info) => this.stop(event2, info);
    this.panSession = new PanSession(originEvent, {
      onSessionStart,
      onStart,
      onMove,
      onSessionEnd
    }, { transformPagePoint: this.visualElement.getTransformPagePoint() });
  }
  stop(event2, info) {
    let isDragging = this.isDragging;
    if (this.cancel(), !isDragging)
      return;
    let { velocity } = info;
    this.startAnimation(velocity);
    let { onDragEnd } = this.getProps();
    onDragEnd && sync.update(() => onDragEnd(event2, info));
  }
  cancel() {
    this.isDragging = !1;
    let { projection, animationState } = this.visualElement;
    projection && (projection.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0;
    let { dragPropagation } = this.getProps();
    !dragPropagation && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), animationState && animationState.setActive("whileDrag", !1);
  }
  updateAxis(axis, _point, offset) {
    let { drag: drag2 } = this.getProps();
    if (!offset || !shouldDrag(axis, drag2, this.currentDirection))
      return;
    let axisValue = this.getAxisMotionValue(axis), next = this.originPoint[axis] + offset[axis];
    this.constraints && this.constraints[axis] && (next = applyConstraints(next, this.constraints[axis], this.elastic[axis])), axisValue.set(next);
  }
  resolveConstraints() {
    let { dragConstraints, dragElastic } = this.getProps(), { layout: layout2 } = this.visualElement.projection || {}, prevConstraints = this.constraints;
    dragConstraints && isRefObject(dragConstraints) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : dragConstraints && layout2 ? this.constraints = calcRelativeConstraints(layout2.layoutBox, dragConstraints) : this.constraints = !1, this.elastic = resolveDragElastic(dragElastic), prevConstraints !== this.constraints && layout2 && this.constraints && !this.hasMutatedConstraints && eachAxis((axis) => {
      this.getAxisMotionValue(axis) && (this.constraints[axis] = rebaseAxisConstraints(layout2.layoutBox[axis], this.constraints[axis]));
    });
  }
  resolveRefConstraints() {
    let { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();
    if (!constraints || !isRefObject(constraints))
      return !1;
    let constraintsElement = constraints.current;
    invariant4(constraintsElement !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
    let { projection } = this.visualElement;
    if (!projection || !projection.layout)
      return !1;
    let constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint()), measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);
    if (onMeasureDragConstraints) {
      let userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));
      this.hasMutatedConstraints = !!userConstraints, userConstraints && (measuredConstraints = convertBoundingBoxToBox(userConstraints));
    }
    return measuredConstraints;
  }
  startAnimation(velocity) {
    let { drag: drag2, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd } = this.getProps(), constraints = this.constraints || {}, momentumAnimations = eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, this.currentDirection))
        return;
      let transition = constraints && constraints[axis] || {};
      dragSnapToOrigin && (transition = { min: 0, max: 0 });
      let bounceStiffness = dragElastic ? 200 : 1e6, bounceDamping = dragElastic ? 40 : 1e7, inertia2 = {
        type: "inertia",
        velocity: dragMomentum ? velocity[axis] : 0,
        bounceStiffness,
        bounceDamping,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...dragTransition,
        ...transition
      };
      return this.startAxisValueAnimation(axis, inertia2);
    });
    return Promise.all(momentumAnimations).then(onDragTransitionEnd);
  }
  startAxisValueAnimation(axis, transition) {
    let axisValue = this.getAxisMotionValue(axis);
    return axisValue.start(animateMotionValue(axis, axisValue, 0, transition));
  }
  stopAnimation() {
    eachAxis((axis) => this.getAxisMotionValue(axis).stop());
  }
  getAxisMotionValue(axis) {
    let dragKey = "_drag" + axis.toUpperCase(), props = this.visualElement.getProps(), externalMotionValue = props[dragKey];
    return externalMotionValue || this.visualElement.getValue(axis, (props.initial ? props.initial[axis] : void 0) || 0);
  }
  snapToCursor(point) {
    eachAxis((axis) => {
      let { drag: drag2 } = this.getProps();
      if (!shouldDrag(axis, drag2, this.currentDirection))
        return;
      let { projection } = this.visualElement, axisValue = this.getAxisMotionValue(axis);
      if (projection && projection.layout) {
        let { min, max } = projection.layout.layoutBox[axis];
        axisValue.set(point[axis] - mix(min, max, 0.5));
      }
    });
  }
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    let { drag: drag2, dragConstraints } = this.getProps(), { projection } = this.visualElement;
    if (!isRefObject(dragConstraints) || !projection || !this.constraints)
      return;
    this.stopAnimation();
    let boxProgress = { x: 0, y: 0 };
    eachAxis((axis) => {
      let axisValue = this.getAxisMotionValue(axis);
      if (axisValue) {
        let latest = axisValue.get();
        boxProgress[axis] = calcOrigin2({ min: latest, max: latest }, this.constraints[axis]);
      }
    });
    let { transformTemplate } = this.visualElement.getProps();
    this.visualElement.current.style.transform = transformTemplate ? transformTemplate({}, "") : "none", projection.root && projection.root.updateScroll(), projection.updateLayout(), this.resolveConstraints(), eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, null))
        return;
      let axisValue = this.getAxisMotionValue(axis), { min, max } = this.constraints[axis];
      axisValue.set(mix(min, max, boxProgress[axis]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    elementDragControls.set(this.visualElement, this);
    let element = this.visualElement.current, stopPointerListener = addPointerEvent(element, "pointerdown", (event2) => {
      let { drag: drag2, dragListener = !0 } = this.getProps();
      drag2 && dragListener && this.start(event2);
    }), measureDragConstraints = () => {
      let { dragConstraints } = this.getProps();
      isRefObject(dragConstraints) && (this.constraints = this.resolveRefConstraints());
    }, { projection } = this.visualElement, stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
    projection && !projection.layout && (projection.root && projection.root.updateScroll(), projection.updateLayout()), measureDragConstraints();
    let stopResizeListener = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints()), stopLayoutUpdateListener = projection.addEventListener("didUpdate", ({ delta, hasLayoutChanged }) => {
      this.isDragging && hasLayoutChanged && (eachAxis((axis) => {
        let motionValue2 = this.getAxisMotionValue(axis);
        !motionValue2 || (this.originPoint[axis] += delta[axis].translate, motionValue2.set(motionValue2.get() + delta[axis].translate));
      }), this.visualElement.render());
    });
    return () => {
      stopResizeListener(), stopPointerListener(), stopMeasureLayoutListener(), stopLayoutUpdateListener && stopLayoutUpdateListener();
    };
  }
  getProps() {
    let props = this.visualElement.getProps(), { drag: drag2 = !1, dragDirectionLock = !1, dragPropagation = !1, dragConstraints = !1, dragElastic = defaultElastic, dragMomentum = !0 } = props;
    return {
      ...props,
      drag: drag2,
      dragDirectionLock,
      dragPropagation,
      dragConstraints,
      dragElastic,
      dragMomentum
    };
  }
};
function shouldDrag(direction, drag2, currentDirection) {
  return (drag2 === !0 || drag2 === direction) && (currentDirection === null || currentDirection === direction);
}
function getCurrentDirection(offset, lockThreshold = 10) {
  let direction = null;
  return Math.abs(offset.y) > lockThreshold ? direction = "y" : Math.abs(offset.x) > lockThreshold && (direction = "x"), direction;
}

// node_modules/framer-motion/dist/es/gestures/drag/index.mjs
var DragGesture = class extends Feature {
  constructor(node) {
    super(node), this.removeGroupControls = noop3, this.removeListeners = noop3, this.controls = new VisualElementDragControls(node);
  }
  mount() {
    let { dragControls } = this.node.getProps();
    dragControls && (this.removeGroupControls = dragControls.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || noop3;
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners();
  }
};

// node_modules/framer-motion/dist/es/gestures/pan/index.mjs
var asyncHandler = (handler) => (event2, info) => {
  handler && sync.update(() => handler(event2, info));
}, PanGesture = class extends Feature {
  constructor() {
    super(...arguments), this.removePointerDownListener = noop3;
  }
  onPointerDown(pointerDownEvent) {
    this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), { transformPagePoint: this.node.getTransformPagePoint() });
  }
  createPanHandlers() {
    let { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();
    return {
      onSessionStart: asyncHandler(onPanSessionStart),
      onStart: asyncHandler(onPanStart),
      onMove: onPan,
      onEnd: (event2, info) => {
        delete this.session, onPanEnd && sync.update(() => onPanEnd(event2, info));
      }
    };
  }
  mount() {
    this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", (event2) => this.onPointerDown(event2));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end();
  }
};

// node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs
var import_react34 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/components/AnimatePresence/use-presence.mjs
var import_react33 = __toESM(require_react(), 1);
function usePresence() {
  let context = (0, import_react33.useContext)(PresenceContext);
  if (context === null)
    return [!0, null];
  let { isPresent, onExitComplete, register } = context, id4 = (0, import_react33.useId)();
  return (0, import_react33.useEffect)(() => register(id4), []), !isPresent && onExitComplete ? [!1, () => onExitComplete && onExitComplete(id4)] : [!0];
}

// node_modules/framer-motion/dist/es/projection/styles/scale-border-radius.mjs
function pixelsToPercent(pixels, axis) {
  return axis.max === axis.min ? 0 : pixels / (axis.max - axis.min) * 100;
}
var correctBorderRadius = {
  correct: (latest, node) => {
    if (!node.target)
      return latest;
    if (typeof latest == "string")
      if (px.test(latest))
        latest = parseFloat(latest);
      else
        return latest;
    let x2 = pixelsToPercent(latest, node.target.x), y2 = pixelsToPercent(latest, node.target.y);
    return `${x2}% ${y2}%`;
  }
};

// node_modules/framer-motion/dist/es/render/dom/utils/css-variables-conversion.mjs
var cssVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
function parseCSSVariable(current) {
  let match = cssVariableRegex.exec(current);
  if (!match)
    return [,];
  let [, token2, fallback] = match;
  return [token2, fallback];
}
var maxDepth = 4;
function getVariableValue(current, element, depth = 1) {
  invariant4(depth <= maxDepth, `Max CSS variable fallback depth detected in property "${current}". This may indicate a circular fallback dependency.`);
  let [token2, fallback] = parseCSSVariable(current);
  if (!token2)
    return;
  let resolved = window.getComputedStyle(element).getPropertyValue(token2);
  return resolved ? resolved.trim() : isCSSVariableToken(fallback) ? getVariableValue(fallback, element, depth + 1) : fallback;
}
function resolveCSSVariables(visualElement, { ...target }, transitionEnd2) {
  let element = visualElement.current;
  if (!(element instanceof Element))
    return { target, transitionEnd: transitionEnd2 };
  transitionEnd2 && (transitionEnd2 = { ...transitionEnd2 }), visualElement.values.forEach((value2) => {
    let current = value2.get();
    if (!isCSSVariableToken(current))
      return;
    let resolved = getVariableValue(current, element);
    resolved && value2.set(resolved);
  });
  for (let key2 in target) {
    let current = target[key2];
    if (!isCSSVariableToken(current))
      continue;
    let resolved = getVariableValue(current, element);
    !resolved || (target[key2] = resolved, transitionEnd2 || (transitionEnd2 = {}), transitionEnd2[key2] === void 0 && (transitionEnd2[key2] = current));
  }
  return { target, transitionEnd: transitionEnd2 };
}

// node_modules/framer-motion/dist/es/projection/styles/scale-box-shadow.mjs
var varToken = "_$css", correctBoxShadow = {
  correct: (latest, { treeScale, projectionDelta }) => {
    let original = latest, containsCSSVariables = latest.includes("var("), cssVariables = [];
    containsCSSVariables && (latest = latest.replace(cssVariableRegex, (match) => (cssVariables.push(match), varToken)));
    let shadow = complex.parse(latest);
    if (shadow.length > 5)
      return original;
    let template = complex.createTransformer(latest), offset = typeof shadow[0] != "number" ? 1 : 0, xScale = projectionDelta.x.scale * treeScale.x, yScale = projectionDelta.y.scale * treeScale.y;
    shadow[0 + offset] /= xScale, shadow[1 + offset] /= yScale;
    let averageScale = mix(xScale, yScale, 0.5);
    typeof shadow[2 + offset] == "number" && (shadow[2 + offset] /= averageScale), typeof shadow[3 + offset] == "number" && (shadow[3 + offset] /= averageScale);
    let output2 = template(shadow);
    if (containsCSSVariables) {
      let i3 = 0;
      output2 = output2.replace(varToken, () => {
        let cssVariable = cssVariables[i3];
        return i3++, cssVariable;
      });
    }
    return output2;
  }
};

// node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs
var MeasureLayoutWithContext = class extends import_react34.default.Component {
  componentDidMount() {
    let { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props, { projection } = visualElement;
    addScaleCorrector(defaultScaleCorrectors), projection && (layoutGroup.group && layoutGroup.group.add(projection), switchLayoutGroup && switchLayoutGroup.register && layoutId && switchLayoutGroup.register(projection), projection.root.didUpdate(), projection.addEventListener("animationComplete", () => {
      this.safeToRemove();
    }), projection.setOptions({
      ...projection.options,
      onExitComplete: () => this.safeToRemove()
    })), globalProjectionState.hasEverUpdated = !0;
  }
  getSnapshotBeforeUpdate(prevProps) {
    let { layoutDependency, visualElement, drag: drag2, isPresent } = this.props, projection = visualElement.projection;
    return projection && (projection.isPresent = isPresent, drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0 ? projection.willUpdate() : this.safeToRemove(), prevProps.isPresent !== isPresent && (isPresent ? projection.promote() : projection.relegate() || sync.postRender(() => {
      let stack2 = projection.getStack();
      (!stack2 || !stack2.members.length) && this.safeToRemove();
    }))), null;
  }
  componentDidUpdate() {
    let { projection } = this.props.visualElement;
    projection && (projection.root.didUpdate(), !projection.currentAnimation && projection.isLead() && this.safeToRemove());
  }
  componentWillUnmount() {
    let { visualElement, layoutGroup, switchLayoutGroup: promoteContext } = this.props, { projection } = visualElement;
    projection && (projection.scheduleCheckAfterUnmount(), layoutGroup && layoutGroup.group && layoutGroup.group.remove(projection), promoteContext && promoteContext.deregister && promoteContext.deregister(projection));
  }
  safeToRemove() {
    let { safeToRemove } = this.props;
    safeToRemove && safeToRemove();
  }
  render() {
    return null;
  }
};
function MeasureLayout(props) {
  let [isPresent, safeToRemove] = usePresence(), layoutGroup = (0, import_react34.useContext)(LayoutGroupContext);
  return import_react34.default.createElement(MeasureLayoutWithContext, { ...props, layoutGroup, switchLayoutGroup: (0, import_react34.useContext)(SwitchLayoutGroupContext), isPresent, safeToRemove });
}
var defaultScaleCorrectors = {
  borderRadius: {
    ...correctBorderRadius,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: correctBorderRadius,
  borderTopRightRadius: correctBorderRadius,
  borderBottomLeftRadius: correctBorderRadius,
  borderBottomRightRadius: correctBorderRadius,
  boxShadow: correctBoxShadow
};

// node_modules/framer-motion/dist/es/projection/animation/mix-values.mjs
var borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], numBorders = borders.length, asNumber = (value2) => typeof value2 == "string" ? parseFloat(value2) : value2, isPx = (value2) => typeof value2 == "number" || px.test(value2);
function mixValues(target, follow, lead, progress2, shouldCrossfadeOpacity, isOnlyMember) {
  shouldCrossfadeOpacity ? (target.opacity = mix(
    0,
    lead.opacity !== void 0 ? lead.opacity : 1,
    easeCrossfadeIn(progress2)
  ), target.opacityExit = mix(follow.opacity !== void 0 ? follow.opacity : 1, 0, easeCrossfadeOut(progress2))) : isOnlyMember && (target.opacity = mix(follow.opacity !== void 0 ? follow.opacity : 1, lead.opacity !== void 0 ? lead.opacity : 1, progress2));
  for (let i3 = 0; i3 < numBorders; i3++) {
    let borderLabel = `border${borders[i3]}Radius`, followRadius = getRadius(follow, borderLabel), leadRadius = getRadius(lead, borderLabel);
    if (followRadius === void 0 && leadRadius === void 0)
      continue;
    followRadius || (followRadius = 0), leadRadius || (leadRadius = 0), followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius) ? (target[borderLabel] = Math.max(mix(asNumber(followRadius), asNumber(leadRadius), progress2), 0), (percent.test(leadRadius) || percent.test(followRadius)) && (target[borderLabel] += "%")) : target[borderLabel] = leadRadius;
  }
  (follow.rotate || lead.rotate) && (target.rotate = mix(follow.rotate || 0, lead.rotate || 0, progress2));
}
function getRadius(values, radiusName) {
  return values[radiusName] !== void 0 ? values[radiusName] : values.borderRadius;
}
var easeCrossfadeIn = compress(0, 0.5, circOut), easeCrossfadeOut = compress(0.5, 0.95, noop3);
function compress(min, max, easing) {
  return (p) => p < min ? 0 : p > max ? 1 : easing(progress(min, max, p));
}

// node_modules/framer-motion/dist/es/projection/geometry/copy.mjs
function copyAxisInto(axis, originAxis) {
  axis.min = originAxis.min, axis.max = originAxis.max;
}
function copyBoxInto(box, originBox) {
  copyAxisInto(box.x, originBox.x), copyAxisInto(box.y, originBox.y);
}

// node_modules/framer-motion/dist/es/projection/geometry/delta-remove.mjs
function removePointDelta(point, translate, scale2, originPoint, boxScale) {
  return point -= translate, point = scalePoint(point, 1 / scale2, originPoint), boxScale !== void 0 && (point = scalePoint(point, 1 / boxScale, originPoint)), point;
}
function removeAxisDelta(axis, translate = 0, scale2 = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {
  if (percent.test(translate) && (translate = parseFloat(translate), translate = mix(sourceAxis.min, sourceAxis.max, translate / 100) - sourceAxis.min), typeof translate != "number")
    return;
  let originPoint = mix(originAxis.min, originAxis.max, origin);
  axis === originAxis && (originPoint -= translate), axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale), axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function removeAxisTransforms(axis, transforms, [key2, scaleKey, originKey], origin, sourceAxis) {
  removeAxisDelta(axis, transforms[key2], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);
}
var xKeys2 = ["x", "scaleX", "originX"], yKeys2 = ["y", "scaleY", "originY"];
function removeBoxTransforms(box, transforms, originBox, sourceBox) {
  removeAxisTransforms(box.x, transforms, xKeys2, originBox ? originBox.x : void 0, sourceBox ? sourceBox.x : void 0), removeAxisTransforms(box.y, transforms, yKeys2, originBox ? originBox.y : void 0, sourceBox ? sourceBox.y : void 0);
}

// node_modules/framer-motion/dist/es/projection/geometry/utils.mjs
function isAxisDeltaZero(delta) {
  return delta.translate === 0 && delta.scale === 1;
}
function isDeltaZero(delta) {
  return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
}
function boxEquals(a3, b2) {
  return a3.x.min === b2.x.min && a3.x.max === b2.x.max && a3.y.min === b2.y.min && a3.y.max === b2.y.max;
}
function aspectRatio(box) {
  return calcLength(box.x) / calcLength(box.y);
}

// node_modules/framer-motion/dist/es/projection/shared/stack.mjs
var NodeStack = class {
  constructor() {
    this.members = [];
  }
  add(node) {
    addUniqueItem(this.members, node), node.scheduleRender();
  }
  remove(node) {
    if (removeItem(this.members, node), node === this.prevLead && (this.prevLead = void 0), node === this.lead) {
      let prevLead = this.members[this.members.length - 1];
      prevLead && this.promote(prevLead);
    }
  }
  relegate(node) {
    let indexOfNode = this.members.findIndex((member) => node === member);
    if (indexOfNode === 0)
      return !1;
    let prevLead;
    for (let i3 = indexOfNode; i3 >= 0; i3--) {
      let member = this.members[i3];
      if (member.isPresent !== !1) {
        prevLead = member;
        break;
      }
    }
    return prevLead ? (this.promote(prevLead), !0) : !1;
  }
  promote(node, preserveFollowOpacity) {
    let prevLead = this.lead;
    if (node !== prevLead && (this.prevLead = prevLead, this.lead = node, node.show(), prevLead)) {
      prevLead.instance && prevLead.scheduleRender(), node.scheduleRender(), node.resumeFrom = prevLead, preserveFollowOpacity && (node.resumeFrom.preserveOpacity = !0), prevLead.snapshot && (node.snapshot = prevLead.snapshot, node.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues), node.root && node.root.isUpdating && (node.isLayoutDirty = !0);
      let { crossfade } = node.options;
      crossfade === !1 && prevLead.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((node) => {
      let { options: options2, resumingFrom } = node;
      options2.onExitComplete && options2.onExitComplete(), resumingFrom && resumingFrom.options.onExitComplete && resumingFrom.options.onExitComplete();
    });
  }
  scheduleRender() {
    this.members.forEach((node) => {
      node.instance && node.scheduleRender(!1);
    });
  }
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
};

// node_modules/framer-motion/dist/es/projection/styles/transform.mjs
function buildProjectionTransform(delta, treeScale, latestTransform) {
  let transform = "", xTranslate = delta.x.translate / treeScale.x, yTranslate = delta.y.translate / treeScale.y;
  if ((xTranslate || yTranslate) && (transform = `translate3d(${xTranslate}px, ${yTranslate}px, 0) `), (treeScale.x !== 1 || treeScale.y !== 1) && (transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `), latestTransform) {
    let { rotate, rotateX, rotateY } = latestTransform;
    rotate && (transform += `rotate(${rotate}deg) `), rotateX && (transform += `rotateX(${rotateX}deg) `), rotateY && (transform += `rotateY(${rotateY}deg) `);
  }
  let elementScaleX = delta.x.scale * treeScale.x, elementScaleY = delta.y.scale * treeScale.y;
  return (elementScaleX !== 1 || elementScaleY !== 1) && (transform += `scale(${elementScaleX}, ${elementScaleY})`), transform || "none";
}

// node_modules/framer-motion/dist/es/render/utils/compare-by-depth.mjs
var compareByDepth = (a3, b2) => a3.depth - b2.depth;

// node_modules/framer-motion/dist/es/render/utils/flat-tree.mjs
var FlatTree = class {
  constructor() {
    this.children = [], this.isDirty = !1;
  }
  add(child) {
    addUniqueItem(this.children, child), this.isDirty = !0;
  }
  remove(child) {
    removeItem(this.children, child), this.isDirty = !0;
  }
  forEach(callback) {
    this.isDirty && this.children.sort(compareByDepth), this.isDirty = !1, this.children.forEach(callback);
  }
};

// node_modules/framer-motion/dist/es/utils/delay.mjs
function delay(callback, timeout2) {
  let start3 = performance.now(), checkElapsed = ({ timestamp: timestamp2 }) => {
    let elapsed = timestamp2 - start3;
    elapsed >= timeout2 && (cancelSync.read(checkElapsed), callback(elapsed - timeout2));
  };
  return sync.read(checkElapsed, !0), () => cancelSync.read(checkElapsed);
}

// node_modules/framer-motion/dist/es/debug/record.mjs
function record(data2) {
  window.MotionDebug && window.MotionDebug.record(data2);
}

// node_modules/framer-motion/dist/es/render/dom/utils/is-svg-element.mjs
function isSVGElement(element) {
  return element instanceof SVGElement && element.tagName !== "svg";
}

// node_modules/framer-motion/dist/es/animation/interfaces/single-value.mjs
function animateSingleValue(value2, keyframes2, options2) {
  let motionValue$1 = isMotionValue(value2) ? value2 : motionValue(value2);
  return motionValue$1.start(animateMotionValue("", motionValue$1, keyframes2, options2)), motionValue$1.animation;
}

// node_modules/framer-motion/dist/es/projection/node/create-projection-node.mjs
var transformAxes = ["", "X", "Y", "Z"], animationTarget = 1e3, id3 = 0, projectionFrameData = {
  type: "projectionFrame",
  totalNodes: 0,
  resolvedTargetDeltas: 0,
  recalculatedProjection: 0
};
function createProjectionNode({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform }) {
  return class {
    constructor(elementId, latestValues = {}, parent = defaultParent == null ? void 0 : defaultParent()) {
      this.id = id3++, this.animationId = 0, this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = /* @__PURE__ */ new Map(), this.potentialNodes = /* @__PURE__ */ new Map(), this.checkUpdateFailed = () => {
        this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots());
      }, this.updateProjection = () => {
        projectionFrameData.totalNodes = projectionFrameData.resolvedTargetDeltas = projectionFrameData.recalculatedProjection = 0, this.nodes.forEach(propagateDirtyNodes), this.nodes.forEach(resolveTargetDelta), this.nodes.forEach(calcProjection), this.nodes.forEach(cleanDirtyNodes), record(projectionFrameData);
      }, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.elementId = elementId, this.latestValues = latestValues, this.root = parent ? parent.root || parent : this, this.path = parent ? [...parent.path, parent] : [], this.parent = parent, this.depth = parent ? parent.depth + 1 : 0, elementId && this.root.registerPotentialNode(elementId, this);
      for (let i3 = 0; i3 < this.path.length; i3++)
        this.path[i3].shouldResetTransform = !0;
      this.root === this && (this.nodes = new FlatTree());
    }
    addEventListener(name, handler) {
      return this.eventHandlers.has(name) || this.eventHandlers.set(name, new SubscriptionManager()), this.eventHandlers.get(name).add(handler);
    }
    notifyListeners(name, ...args) {
      let subscriptionManager = this.eventHandlers.get(name);
      subscriptionManager && subscriptionManager.notify(...args);
    }
    hasListeners(name) {
      return this.eventHandlers.has(name);
    }
    registerPotentialNode(elementId, node) {
      this.potentialNodes.set(elementId, node);
    }
    mount(instance2, isLayoutDirty = !1) {
      if (this.instance)
        return;
      this.isSVG = isSVGElement(instance2), this.instance = instance2;
      let { layoutId, layout: layout2, visualElement } = this.options;
      if (visualElement && !visualElement.current && visualElement.mount(instance2), this.root.nodes.add(this), this.parent && this.parent.children.add(this), this.elementId && this.root.potentialNodes.delete(this.elementId), isLayoutDirty && (layout2 || layoutId) && (this.isLayoutDirty = !0), attachResizeListener) {
        let cancelDelay, resizeUnblockUpdate = () => this.root.updateBlockedByResize = !1;
        attachResizeListener(instance2, () => {
          this.root.updateBlockedByResize = !0, cancelDelay && cancelDelay(), cancelDelay = delay(resizeUnblockUpdate, 250), globalProjectionState.hasAnimatedSinceResize && (globalProjectionState.hasAnimatedSinceResize = !1, this.nodes.forEach(finishAnimation));
        });
      }
      layoutId && this.root.registerSharedNode(layoutId, this), this.options.animate !== !1 && visualElement && (layoutId || layout2) && this.addEventListener("didUpdate", ({ delta, hasLayoutChanged, hasRelativeTargetChanged, layout: newLayout }) => {
        if (this.isTreeAnimationBlocked()) {
          this.target = void 0, this.relativeTarget = void 0;
          return;
        }
        let layoutTransition = this.options.transition || visualElement.getDefaultTransition() || defaultLayoutTransition, { onLayoutAnimationStart, onLayoutAnimationComplete } = visualElement.getProps(), targetChanged = !this.targetLayout || !boxEquals(this.targetLayout, newLayout) || hasRelativeTargetChanged, hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;
        if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || hasOnlyRelativeTargetChanged || hasLayoutChanged && (targetChanged || !this.currentAnimation)) {
          this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
          let animationOptions = {
            ...getValueTransition(layoutTransition, "layout"),
            onPlay: onLayoutAnimationStart,
            onComplete: onLayoutAnimationComplete
          };
          (visualElement.shouldReduceMotion || this.options.layoutRoot) && (animationOptions.delay = 0, animationOptions.type = !1), this.startAnimation(animationOptions);
        } else
          !hasLayoutChanged && this.animationProgress === 0 && finishAnimation(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
        this.targetLayout = newLayout;
      });
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
      let stack2 = this.getStack();
      stack2 && stack2.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, cancelSync.preRender(this.updateProjection);
    }
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1;
    }
    startUpdate() {
      this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(resetRotation), this.animationId++);
    }
    getTransformTemplate() {
      let { visualElement } = this.options;
      return visualElement && visualElement.getProps().transformTemplate;
    }
    willUpdate(shouldNotifyListeners = !0) {
      if (this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (!this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
        return;
      this.isLayoutDirty = !0;
      for (let i3 = 0; i3 < this.path.length; i3++) {
        let node = this.path[i3];
        node.shouldResetTransform = !0, node.updateScroll("snapshot"), node.options.layoutRoot && node.willUpdate(!1);
      }
      let { layoutId, layout: layout2 } = this.options;
      if (layoutId === void 0 && !layout2)
        return;
      let transformTemplate = this.getTransformTemplate();
      this.prevTransformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0, this.updateSnapshot(), shouldNotifyListeners && this.notifyListeners("willUpdate");
    }
    didUpdate() {
      if (this.isUpdateBlocked()) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(clearMeasurements);
        return;
      }
      !this.isUpdating || (this.isUpdating = !1, this.potentialNodes.size && (this.potentialNodes.forEach(mountNodeEarly), this.potentialNodes.clear()), this.nodes.forEach(resetTransformStyle), this.nodes.forEach(updateLayout), this.nodes.forEach(notifyLayoutUpdate), this.clearAllSnapshots(), flushSync.update(), flushSync.preRender(), flushSync.render());
    }
    clearAllSnapshots() {
      this.nodes.forEach(clearSnapshot), this.sharedNodes.forEach(removeLeadSnapshots);
    }
    scheduleUpdateProjection() {
      sync.preRender(this.updateProjection, !1, !0);
    }
    scheduleCheckAfterUnmount() {
      sync.postRender(() => {
        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();
      });
    }
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure());
    }
    updateLayout() {
      if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let i3 = 0; i3 < this.path.length; i3++)
          this.path[i3].updateScroll();
      let prevLayout = this.layout;
      this.layout = this.measure(!1), this.layoutCorrected = createBox(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
      let { visualElement } = this.options;
      visualElement && visualElement.notify("LayoutMeasure", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : void 0);
    }
    updateScroll(phase = "measure") {
      let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);
      this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === phase && (needsMeasurement = !1), needsMeasurement && (this.scroll = {
        animationId: this.root.animationId,
        phase,
        isRoot: checkIsScrollRoot(this.instance),
        offset: measureScroll(this.instance)
      });
    }
    resetTransform() {
      if (!resetTransform)
        return;
      let isResetRequested = this.isLayoutDirty || this.shouldResetTransform, hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta), transformTemplate = this.getTransformTemplate(), transformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0, transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
      isResetRequested && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged) && (resetTransform(this.instance, transformTemplateValue), this.shouldResetTransform = !1, this.scheduleRender());
    }
    measure(removeTransform = !0) {
      let pageBox = this.measurePageBox(), layoutBox = this.removeElementScroll(pageBox);
      return removeTransform && (layoutBox = this.removeTransform(layoutBox)), roundBox(layoutBox), {
        animationId: this.root.animationId,
        measuredBox: pageBox,
        layoutBox,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      let { visualElement } = this.options;
      if (!visualElement)
        return createBox();
      let box = visualElement.measureViewportBox(), { scroll } = this.root;
      return scroll && (translateAxis(box.x, scroll.offset.x), translateAxis(box.y, scroll.offset.y)), box;
    }
    removeElementScroll(box) {
      let boxWithoutScroll = createBox();
      copyBoxInto(boxWithoutScroll, box);
      for (let i3 = 0; i3 < this.path.length; i3++) {
        let node = this.path[i3], { scroll, options: options2 } = node;
        if (node !== this.root && scroll && options2.layoutScroll) {
          if (scroll.isRoot) {
            copyBoxInto(boxWithoutScroll, box);
            let { scroll: rootScroll } = this.root;
            rootScroll && (translateAxis(boxWithoutScroll.x, -rootScroll.offset.x), translateAxis(boxWithoutScroll.y, -rootScroll.offset.y));
          }
          translateAxis(boxWithoutScroll.x, scroll.offset.x), translateAxis(boxWithoutScroll.y, scroll.offset.y);
        }
      }
      return boxWithoutScroll;
    }
    applyTransform(box, transformOnly = !1) {
      let withTransforms = createBox();
      copyBoxInto(withTransforms, box);
      for (let i3 = 0; i3 < this.path.length; i3++) {
        let node = this.path[i3];
        !transformOnly && node.options.layoutScroll && node.scroll && node !== node.root && transformBox(withTransforms, {
          x: -node.scroll.offset.x,
          y: -node.scroll.offset.y
        }), hasTransform(node.latestValues) && transformBox(withTransforms, node.latestValues);
      }
      return hasTransform(this.latestValues) && transformBox(withTransforms, this.latestValues), withTransforms;
    }
    removeTransform(box) {
      let boxWithoutTransform = createBox();
      copyBoxInto(boxWithoutTransform, box);
      for (let i3 = 0; i3 < this.path.length; i3++) {
        let node = this.path[i3];
        if (!node.instance || !hasTransform(node.latestValues))
          continue;
        hasScale(node.latestValues) && node.updateSnapshot();
        let sourceBox = createBox(), nodeBox = node.measurePageBox();
        copyBoxInto(sourceBox, nodeBox), removeBoxTransforms(boxWithoutTransform, node.latestValues, node.snapshot ? node.snapshot.layoutBox : void 0, sourceBox);
      }
      return hasTransform(this.latestValues) && removeBoxTransforms(boxWithoutTransform, this.latestValues), boxWithoutTransform;
    }
    setTargetDelta(delta) {
      this.targetDelta = delta, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0;
    }
    setOptions(options2) {
      this.options = {
        ...this.options,
        ...options2,
        crossfade: options2.crossfade !== void 0 ? options2.crossfade : !0
      };
    }
    clearMeasurements() {
      this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1;
    }
    resolveTargetDelta(forceRecalculation = !1) {
      var _a;
      let lead = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);
      let isShared = Boolean(this.resumingFrom) || this !== lead;
      if (!(forceRecalculation || isShared && this.isSharedProjectionDirty || this.isProjectionDirty || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isProjectionDirty) || this.attemptToResolveRelativeTarget))
        return;
      let { layout: layout2, layoutId } = this.options;
      if (!(!this.layout || !(layout2 || layoutId))) {
        if (this.resolvedRelativeTargetAt = frameData.timestamp, !this.targetDelta && !this.relativeTarget) {
          let relativeParent = this.getClosestProjectingParent();
          relativeParent && relativeParent.layout ? (this.relativeParent = relativeParent, this.relativeTarget = createBox(), this.relativeTargetOrigin = createBox(), calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox), copyBoxInto(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
        }
        if (!(!this.relativeTarget && !this.targetDelta)) {
          if (this.target || (this.target = createBox(), this.targetWithTransforms = createBox()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp && this.relativeParent.resolveTargetDelta(!0), calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (Boolean(this.resumingFrom) ? this.target = this.applyTransform(this.layout.layoutBox) : copyBoxInto(this.target, this.layout.layoutBox), applyBoxDelta(this.target, this.targetDelta)) : copyBoxInto(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) {
            this.attemptToResolveRelativeTarget = !1;
            let relativeParent = this.getClosestProjectingParent();
            relativeParent && Boolean(relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !relativeParent.options.layoutScroll && relativeParent.target ? (this.relativeParent = relativeParent, this.relativeTarget = createBox(), this.relativeTargetOrigin = createBox(), calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target), copyBoxInto(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
          }
          projectionFrameData.resolvedTargetDeltas++;
        }
      }
    }
    getClosestProjectingParent() {
      if (!(!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues)))
        return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return Boolean((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    calcProjection() {
      var _a;
      let lead = this.getLead(), isShared = Boolean(this.resumingFrom) || this !== lead, canSkip = !0;
      if ((this.isProjectionDirty || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isProjectionDirty)) && (canSkip = !1), isShared && (this.isSharedProjectionDirty || this.isTransformDirty) && (canSkip = !1), this.resolvedRelativeTargetAt === frameData.timestamp && (canSkip = !1), canSkip)
        return;
      let { layout: layout2, layoutId } = this.options;
      if (this.isTreeAnimating = Boolean(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(layout2 || layoutId))
        return;
      copyBoxInto(this.layoutCorrected, this.layout.layoutBox), applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);
      let { target } = lead;
      if (!target)
        return;
      this.projectionDelta || (this.projectionDelta = createDelta(), this.projectionDeltaWithTransform = createDelta());
      let prevTreeScaleX = this.treeScale.x, prevTreeScaleY = this.treeScale.y, prevProjectionTransform = this.projectionTransform;
      calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues), this.projectionTransform = buildProjectionTransform(this.projectionDelta, this.treeScale), (this.projectionTransform !== prevProjectionTransform || this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", target)), projectionFrameData.recalculatedProjection++;
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(notifyAll = !0) {
      if (this.options.scheduleRender && this.options.scheduleRender(), notifyAll) {
        let stack2 = this.getStack();
        stack2 && stack2.scheduleRender();
      }
      this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
    }
    setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = !1) {
      let snapshot = this.snapshot, snapshotLatestValues = snapshot ? snapshot.latestValues : {}, mixedValues = { ...this.latestValues }, targetDelta = createDelta();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
      let relativeLayout = createBox(), snapshotSource = snapshot ? snapshot.source : void 0, layoutSource = this.layout ? this.layout.source : void 0, isSharedLayoutAnimation = snapshotSource !== layoutSource, stack2 = this.getStack(), isOnlyMember = !stack2 || stack2.members.length <= 1, shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === !0 && !this.path.some(hasOpacityCrossfade));
      this.animationProgress = 0;
      let prevRelativeTarget;
      this.mixTargetDelta = (latest) => {
        let progress2 = latest / 1e3;
        mixAxisDelta(targetDelta.x, delta.x, progress2), mixAxisDelta(targetDelta.y, delta.y, progress2), this.setTargetDelta(targetDelta), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox), mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress2), prevRelativeTarget && boxEquals(this.relativeTarget, prevRelativeTarget) && (this.isProjectionDirty = !1), prevRelativeTarget || (prevRelativeTarget = createBox()), copyBoxInto(prevRelativeTarget, this.relativeTarget)), isSharedLayoutAnimation && (this.animationValues = mixedValues, mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress2, shouldCrossfadeOpacity, isOnlyMember)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = progress2;
      }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(options2) {
      this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (cancelSync.update(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = sync.update(() => {
        globalProjectionState.hasAnimatedSinceResize = !0, this.currentAnimation = animateSingleValue(0, animationTarget, {
          ...options2,
          onUpdate: (latest) => {
            this.mixTargetDelta(latest), options2.onUpdate && options2.onUpdate(latest);
          },
          onComplete: () => {
            options2.onComplete && options2.onComplete(), this.completeAnimation();
          }
        }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
      let stack2 = this.getStack();
      stack2 && stack2.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(animationTarget), this.currentAnimation.stop()), this.completeAnimation();
    }
    applyTransformsToTarget() {
      let lead = this.getLead(), { targetWithTransforms, target, layout: layout2, latestValues } = lead;
      if (!(!targetWithTransforms || !target || !layout2)) {
        if (this !== lead && this.layout && layout2 && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout2.layoutBox)) {
          target = this.target || createBox();
          let xLength = calcLength(this.layout.layoutBox.x);
          target.x.min = lead.target.x.min, target.x.max = target.x.min + xLength;
          let yLength = calcLength(this.layout.layoutBox.y);
          target.y.min = lead.target.y.min, target.y.max = target.y.min + yLength;
        }
        copyBoxInto(targetWithTransforms, target), transformBox(targetWithTransforms, latestValues), calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
      }
    }
    registerSharedNode(layoutId, node) {
      this.sharedNodes.has(layoutId) || this.sharedNodes.set(layoutId, new NodeStack()), this.sharedNodes.get(layoutId).add(node);
      let config2 = node.options.initialPromotionConfig;
      node.promote({
        transition: config2 ? config2.transition : void 0,
        preserveFollowOpacity: config2 && config2.shouldPreserveFollowOpacity ? config2.shouldPreserveFollowOpacity(node) : void 0
      });
    }
    isLead() {
      let stack2 = this.getStack();
      return stack2 ? stack2.lead === this : !0;
    }
    getLead() {
      var _a;
      let { layoutId } = this.options;
      return layoutId ? ((_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.lead) || this : this;
    }
    getPrevLead() {
      var _a;
      let { layoutId } = this.options;
      return layoutId ? (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.prevLead : void 0;
    }
    getStack() {
      let { layoutId } = this.options;
      if (layoutId)
        return this.root.sharedNodes.get(layoutId);
    }
    promote({ needsReset, transition, preserveFollowOpacity } = {}) {
      let stack2 = this.getStack();
      stack2 && stack2.promote(this, preserveFollowOpacity), needsReset && (this.projectionDelta = void 0, this.needsReset = !0), transition && this.setOptions({ transition });
    }
    relegate() {
      let stack2 = this.getStack();
      return stack2 ? stack2.relegate(this) : !1;
    }
    resetRotation() {
      let { visualElement } = this.options;
      if (!visualElement)
        return;
      let hasRotate = !1, { latestValues } = visualElement;
      if ((latestValues.rotate || latestValues.rotateX || latestValues.rotateY || latestValues.rotateZ) && (hasRotate = !0), !hasRotate)
        return;
      let resetValues = {};
      for (let i3 = 0; i3 < transformAxes.length; i3++) {
        let key2 = "rotate" + transformAxes[i3];
        latestValues[key2] && (resetValues[key2] = latestValues[key2], visualElement.setStaticValue(key2, 0));
      }
      visualElement.render();
      for (let key2 in resetValues)
        visualElement.setStaticValue(key2, resetValues[key2]);
      visualElement.scheduleRender();
    }
    getProjectionStyles(styleProp = {}) {
      var _a, _b;
      let styles = {};
      if (!this.instance || this.isSVG)
        return styles;
      if (this.isVisible)
        styles.visibility = "";
      else
        return { visibility: "hidden" };
      let transformTemplate = this.getTransformTemplate();
      if (this.needsReset)
        return this.needsReset = !1, styles.opacity = "", styles.pointerEvents = resolveMotionValue(styleProp.pointerEvents) || "", styles.transform = transformTemplate ? transformTemplate(this.latestValues, "") : "none", styles;
      let lead = this.getLead();
      if (!this.projectionDelta || !this.layout || !lead.target) {
        let emptyStyles = {};
        return this.options.layoutId && (emptyStyles.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, emptyStyles.pointerEvents = resolveMotionValue(styleProp.pointerEvents) || ""), this.hasProjected && !hasTransform(this.latestValues) && (emptyStyles.transform = transformTemplate ? transformTemplate({}, "") : "none", this.hasProjected = !1), emptyStyles;
      }
      let valuesToRender = lead.animationValues || lead.latestValues;
      this.applyTransformsToTarget(), styles.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender), transformTemplate && (styles.transform = transformTemplate(valuesToRender, styles.transform));
      let { x: x2, y: y2 } = this.projectionDelta;
      styles.transformOrigin = `${x2.origin * 100}% ${y2.origin * 100}% 0`, lead.animationValues ? styles.opacity = lead === this ? (_b = (_a = valuesToRender.opacity) !== null && _a !== void 0 ? _a : this.latestValues.opacity) !== null && _b !== void 0 ? _b : 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit : styles.opacity = lead === this ? valuesToRender.opacity !== void 0 ? valuesToRender.opacity : "" : valuesToRender.opacityExit !== void 0 ? valuesToRender.opacityExit : 0;
      for (let key2 in scaleCorrectors) {
        if (valuesToRender[key2] === void 0)
          continue;
        let { correct, applyTo } = scaleCorrectors[key2], corrected = styles.transform === "none" ? valuesToRender[key2] : correct(valuesToRender[key2], lead);
        if (applyTo) {
          let num = applyTo.length;
          for (let i3 = 0; i3 < num; i3++)
            styles[applyTo[i3]] = corrected;
        } else
          styles[key2] = corrected;
      }
      return this.options.layoutId && (styles.pointerEvents = lead === this ? resolveMotionValue(styleProp.pointerEvents) || "" : "none"), styles;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    resetTree() {
      this.root.nodes.forEach((node) => {
        var _a;
        return (_a = node.currentAnimation) === null || _a === void 0 ? void 0 : _a.stop();
      }), this.root.nodes.forEach(clearMeasurements), this.root.sharedNodes.clear();
    }
  };
}
function updateLayout(node) {
  node.updateLayout();
}
function notifyLayoutUpdate(node) {
  var _a;
  let snapshot = ((_a = node.resumeFrom) === null || _a === void 0 ? void 0 : _a.snapshot) || node.snapshot;
  if (node.isLead() && node.layout && snapshot && node.hasListeners("didUpdate")) {
    let { layoutBox: layout2, measuredBox: measuredLayout } = node.layout, { animationType } = node.options, isShared = snapshot.source !== node.layout.source;
    animationType === "size" ? eachAxis((axis) => {
      let axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis], length = calcLength(axisSnapshot);
      axisSnapshot.min = layout2[axis].min, axisSnapshot.max = axisSnapshot.min + length;
    }) : shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout2) && eachAxis((axis) => {
      let axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis], length = calcLength(layout2[axis]);
      axisSnapshot.max = axisSnapshot.min + length, node.relativeTarget && !node.currentAnimation && (node.isProjectionDirty = !0, node.relativeTarget[axis].max = node.relativeTarget[axis].min + length);
    });
    let layoutDelta = createDelta();
    calcBoxDelta(layoutDelta, layout2, snapshot.layoutBox);
    let visualDelta = createDelta();
    isShared ? calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, !0), snapshot.measuredBox) : calcBoxDelta(visualDelta, layout2, snapshot.layoutBox);
    let hasLayoutChanged = !isDeltaZero(layoutDelta), hasRelativeTargetChanged = !1;
    if (!node.resumeFrom) {
      let relativeParent = node.getClosestProjectingParent();
      if (relativeParent && !relativeParent.resumeFrom) {
        let { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;
        if (parentSnapshot && parentLayout) {
          let relativeSnapshot = createBox();
          calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);
          let relativeLayout = createBox();
          calcRelativePosition(relativeLayout, layout2, parentLayout.layoutBox), boxEquals(relativeSnapshot, relativeLayout) || (hasRelativeTargetChanged = !0), relativeParent.options.layoutRoot && (node.relativeTarget = relativeLayout, node.relativeTargetOrigin = relativeSnapshot, node.relativeParent = relativeParent);
        }
      }
    }
    node.notifyListeners("didUpdate", {
      layout: layout2,
      snapshot,
      delta: visualDelta,
      layoutDelta,
      hasLayoutChanged,
      hasRelativeTargetChanged
    });
  } else if (node.isLead()) {
    let { onExitComplete } = node.options;
    onExitComplete && onExitComplete();
  }
  node.options.transition = void 0;
}
function propagateDirtyNodes(node) {
  projectionFrameData.totalNodes++, node.parent && (node.isProjecting() || (node.isProjectionDirty = node.parent.isProjectionDirty), node.isSharedProjectionDirty || (node.isSharedProjectionDirty = Boolean(node.isProjectionDirty || node.parent.isProjectionDirty || node.parent.isSharedProjectionDirty)), node.isTransformDirty || (node.isTransformDirty = node.parent.isTransformDirty));
}
function cleanDirtyNodes(node) {
  node.isProjectionDirty = node.isSharedProjectionDirty = node.isTransformDirty = !1;
}
function clearSnapshot(node) {
  node.clearSnapshot();
}
function clearMeasurements(node) {
  node.clearMeasurements();
}
function resetTransformStyle(node) {
  let { visualElement } = node.options;
  visualElement && visualElement.getProps().onBeforeLayoutMeasure && visualElement.notify("BeforeLayoutMeasure"), node.resetTransform();
}
function finishAnimation(node) {
  node.finishAnimation(), node.targetDelta = node.relativeTarget = node.target = void 0;
}
function resolveTargetDelta(node) {
  node.resolveTargetDelta();
}
function calcProjection(node) {
  node.calcProjection();
}
function resetRotation(node) {
  node.resetRotation();
}
function removeLeadSnapshots(stack2) {
  stack2.removeLeadSnapshot();
}
function mixAxisDelta(output2, delta, p) {
  output2.translate = mix(delta.translate, 0, p), output2.scale = mix(delta.scale, 1, p), output2.origin = delta.origin, output2.originPoint = delta.originPoint;
}
function mixAxis(output2, from2, to, p) {
  output2.min = mix(from2.min, to.min, p), output2.max = mix(from2.max, to.max, p);
}
function mixBox(output2, from2, to, p) {
  mixAxis(output2.x, from2.x, to.x, p), mixAxis(output2.y, from2.y, to.y, p);
}
function hasOpacityCrossfade(node) {
  return node.animationValues && node.animationValues.opacityExit !== void 0;
}
var defaultLayoutTransition = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
};
function mountNodeEarly(node, elementId) {
  let searchNode = node.root;
  for (let i3 = node.path.length - 1; i3 >= 0; i3--)
    if (Boolean(node.path[i3].instance)) {
      searchNode = node.path[i3];
      break;
    }
  let element = (searchNode && searchNode !== node.root ? searchNode.instance : document).querySelector(`[data-projection-id="${elementId}"]`);
  element && node.mount(element, !0);
}
function roundAxis(axis) {
  axis.min = Math.round(axis.min), axis.max = Math.round(axis.max);
}
function roundBox(box) {
  roundAxis(box.x), roundAxis(box.y);
}
function shouldAnimatePositionOnly(animationType, snapshot, layout2) {
  return animationType === "position" || animationType === "preserve-aspect" && !isNear(aspectRatio(snapshot), aspectRatio(layout2), 0.2);
}

// node_modules/framer-motion/dist/es/projection/node/DocumentProjectionNode.mjs
var DocumentProjectionNode = createProjectionNode({
  attachResizeListener: (ref, notify) => addDomEvent(ref, "resize", notify),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => !0
});

// node_modules/framer-motion/dist/es/projection/node/HTMLProjectionNode.mjs
var rootProjectionNode = {
  current: void 0
}, HTMLProjectionNode = createProjectionNode({
  measureScroll: (instance2) => ({
    x: instance2.scrollLeft,
    y: instance2.scrollTop
  }),
  defaultParent: () => {
    if (!rootProjectionNode.current) {
      let documentNode = new DocumentProjectionNode(0, {});
      documentNode.mount(window), documentNode.setOptions({ layoutScroll: !0 }), rootProjectionNode.current = documentNode;
    }
    return rootProjectionNode.current;
  },
  resetTransform: (instance2, value2) => {
    instance2.style.transform = value2 !== void 0 ? value2 : "none";
  },
  checkIsScrollRoot: (instance2) => Boolean(window.getComputedStyle(instance2).position === "fixed")
});

// node_modules/framer-motion/dist/es/motion/features/drag.mjs
var drag = {
  pan: {
    Feature: PanGesture
  },
  drag: {
    Feature: DragGesture,
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout
  }
};

// node_modules/framer-motion/dist/es/render/dom/utils/unit-conversion.mjs
var positionalKeys = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  "x",
  "y"
]), isPositionalKey = (key2) => positionalKeys.has(key2), hasPositionalKey = (target) => Object.keys(target).some(isPositionalKey), isNumOrPxType = (v2) => v2 === number3 || v2 === px, getPosFromMatrix = (matrix, pos2) => parseFloat(matrix.split(", ")[pos2]), getTranslateFromMatrix = (pos2, pos3) => (_bbox, { transform }) => {
  if (transform === "none" || !transform)
    return 0;
  let matrix3d = transform.match(/^matrix3d\((.+)\)$/);
  if (matrix3d)
    return getPosFromMatrix(matrix3d[1], pos3);
  {
    let matrix = transform.match(/^matrix\((.+)\)$/);
    return matrix ? getPosFromMatrix(matrix[1], pos2) : 0;
  }
}, transformKeys = /* @__PURE__ */ new Set(["x", "y", "z"]), nonTranslationalTransformKeys = transformPropOrder.filter((key2) => !transformKeys.has(key2));
function removeNonTranslationalTransform(visualElement) {
  let removedTransforms = [];
  return nonTranslationalTransformKeys.forEach((key2) => {
    let value2 = visualElement.getValue(key2);
    value2 !== void 0 && (removedTransforms.push([key2, value2.get()]), value2.set(key2.startsWith("scale") ? 1 : 0));
  }), removedTransforms.length && visualElement.render(), removedTransforms;
}
var positionalValues = {
  width: ({ x: x2 }, { paddingLeft = "0", paddingRight = "0" }) => x2.max - x2.min - parseFloat(paddingLeft) - parseFloat(paddingRight),
  height: ({ y: y2 }, { paddingTop = "0", paddingBottom = "0" }) => y2.max - y2.min - parseFloat(paddingTop) - parseFloat(paddingBottom),
  top: (_bbox, { top }) => parseFloat(top),
  left: (_bbox, { left }) => parseFloat(left),
  bottom: ({ y: y2 }, { top }) => parseFloat(top) + (y2.max - y2.min),
  right: ({ x: x2 }, { left }) => parseFloat(left) + (x2.max - x2.min),
  x: getTranslateFromMatrix(4, 13),
  y: getTranslateFromMatrix(5, 14)
}, convertChangedValueTypes = (target, visualElement, changedKeys) => {
  let originBbox = visualElement.measureViewportBox(), element = visualElement.current, elementComputedStyle = getComputedStyle(element), { display } = elementComputedStyle, origin = {};
  display === "none" && visualElement.setStaticValue("display", target.display || "block"), changedKeys.forEach((key2) => {
    origin[key2] = positionalValues[key2](originBbox, elementComputedStyle);
  }), visualElement.render();
  let targetBbox = visualElement.measureViewportBox();
  return changedKeys.forEach((key2) => {
    let value2 = visualElement.getValue(key2);
    value2 && value2.jump(origin[key2]), target[key2] = positionalValues[key2](targetBbox, elementComputedStyle);
  }), target;
}, checkAndConvertChangedValueTypes = (visualElement, target, origin = {}, transitionEnd2 = {}) => {
  target = { ...target }, transitionEnd2 = { ...transitionEnd2 };
  let targetPositionalKeys = Object.keys(target).filter(isPositionalKey), removedTransformValues = [], hasAttemptedToRemoveTransformValues = !1, changedValueTypeKeys = [];
  if (targetPositionalKeys.forEach((key2) => {
    let value2 = visualElement.getValue(key2);
    if (!visualElement.hasValue(key2))
      return;
    let from2 = origin[key2], fromType = findDimensionValueType(from2), to = target[key2], toType;
    if (isKeyframesTarget(to)) {
      let numKeyframes = to.length, fromIndex = to[0] === null ? 1 : 0;
      from2 = to[fromIndex], fromType = findDimensionValueType(from2);
      for (let i3 = fromIndex; i3 < numKeyframes && to[i3] !== null; i3++)
        toType ? invariant4(findDimensionValueType(to[i3]) === toType, "All keyframes must be of the same type") : (toType = findDimensionValueType(to[i3]), invariant4(toType === fromType || isNumOrPxType(fromType) && isNumOrPxType(toType), "Keyframes must be of the same dimension as the current value"));
    } else
      toType = findDimensionValueType(to);
    if (fromType !== toType)
      if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {
        let current = value2.get();
        typeof current == "string" && value2.set(parseFloat(current)), typeof to == "string" ? target[key2] = parseFloat(to) : Array.isArray(to) && toType === px && (target[key2] = to.map(parseFloat));
      } else
        (fromType == null ? void 0 : fromType.transform) && (toType == null ? void 0 : toType.transform) && (from2 === 0 || to === 0) ? from2 === 0 ? value2.set(toType.transform(from2)) : target[key2] = fromType.transform(to) : (hasAttemptedToRemoveTransformValues || (removedTransformValues = removeNonTranslationalTransform(visualElement), hasAttemptedToRemoveTransformValues = !0), changedValueTypeKeys.push(key2), transitionEnd2[key2] = transitionEnd2[key2] !== void 0 ? transitionEnd2[key2] : target[key2], value2.jump(to));
  }), changedValueTypeKeys.length) {
    let scrollY = changedValueTypeKeys.indexOf("height") >= 0 ? window.pageYOffset : null, convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys);
    return removedTransformValues.length && removedTransformValues.forEach(([key2, value2]) => {
      visualElement.getValue(key2).set(value2);
    }), visualElement.render(), isBrowser3 && scrollY !== null && window.scrollTo({ top: scrollY }), { target: convertedTarget, transitionEnd: transitionEnd2 };
  } else
    return { target, transitionEnd: transitionEnd2 };
};
function unitConversion(visualElement, target, origin, transitionEnd2) {
  return hasPositionalKey(target) ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd2) : { target, transitionEnd: transitionEnd2 };
}

// node_modules/framer-motion/dist/es/render/dom/utils/parse-dom-variant.mjs
var parseDomVariant = (visualElement, target, origin, transitionEnd2) => {
  let resolved = resolveCSSVariables(visualElement, target, transitionEnd2);
  return target = resolved.target, transitionEnd2 = resolved.transitionEnd, unitConversion(visualElement, target, origin, transitionEnd2);
};

// node_modules/framer-motion/dist/es/utils/reduced-motion/state.mjs
var prefersReducedMotion = { current: null }, hasReducedMotionListener = { current: !1 };

// node_modules/framer-motion/dist/es/utils/reduced-motion/index.mjs
function initPrefersReducedMotion() {
  if (hasReducedMotionListener.current = !0, !!isBrowser3)
    if (window.matchMedia) {
      let motionMediaQuery = window.matchMedia("(prefers-reduced-motion)"), setReducedMotionPreferences = () => prefersReducedMotion.current = motionMediaQuery.matches;
      motionMediaQuery.addListener(setReducedMotionPreferences), setReducedMotionPreferences();
    } else
      prefersReducedMotion.current = !1;
}

// node_modules/framer-motion/dist/es/render/utils/motion-values.mjs
function updateMotionValuesFromProps(element, next, prev) {
  let { willChange } = next;
  for (let key2 in next) {
    let nextValue = next[key2], prevValue = prev[key2];
    if (isMotionValue(nextValue))
      element.addValue(key2, nextValue), isWillChangeMotionValue(willChange) && willChange.add(key2), warnOnce3(nextValue.version === "10.11.2", `Attempting to mix Framer Motion versions ${nextValue.version} with 10.11.2 may not work as expected.`);
    else if (isMotionValue(prevValue))
      element.addValue(key2, motionValue(nextValue, { owner: element })), isWillChangeMotionValue(willChange) && willChange.remove(key2);
    else if (prevValue !== nextValue)
      if (element.hasValue(key2)) {
        let existingValue = element.getValue(key2);
        !existingValue.hasAnimated && existingValue.set(nextValue);
      } else {
        let latestValue = element.getStaticValue(key2);
        element.addValue(key2, motionValue(latestValue !== void 0 ? latestValue : nextValue, { owner: element }));
      }
  }
  for (let key2 in prev)
    next[key2] === void 0 && element.removeValue(key2);
  return next;
}

// node_modules/framer-motion/dist/es/render/store.mjs
var visualElementStore = /* @__PURE__ */ new WeakMap();

// node_modules/framer-motion/dist/es/render/VisualElement.mjs
var featureNames = Object.keys(featureDefinitions), numFeatures = featureNames.length, propEventHandlers = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
], numVariantProps = variantProps.length, VisualElement = class {
  constructor({ parent, props, presenceContext, reducedMotionConfig, visualState }, options2 = {}) {
    this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = /* @__PURE__ */ new Map(), this.features = {}, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
      !this.current || (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
    }, this.scheduleRender = () => sync.render(this.render, !1, !0);
    let { latestValues, renderState } = visualState;
    this.latestValues = latestValues, this.baseTarget = { ...latestValues }, this.initialValues = props.initial ? { ...latestValues } : {}, this.renderState = renderState, this.parent = parent, this.props = props, this.presenceContext = presenceContext, this.depth = parent ? parent.depth + 1 : 0, this.reducedMotionConfig = reducedMotionConfig, this.options = options2, this.isControllingVariants = isControllingVariants(props), this.isVariantNode = isVariantNode(props), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = Boolean(parent && parent.current);
    let { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {});
    for (let key2 in initialMotionValues) {
      let value2 = initialMotionValues[key2];
      latestValues[key2] !== void 0 && isMotionValue(value2) && (value2.set(latestValues[key2], !1), isWillChangeMotionValue(willChange) && willChange.add(key2));
    }
  }
  scrapeMotionValuesFromProps(_props, _prevProps) {
    return {};
  }
  mount(instance2) {
    this.current = instance2, visualElementStore.set(instance2, this), this.projection && this.projection.mount(instance2), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((value2, key2) => this.bindToMotionValue(key2, value2)), hasReducedMotionListener.current || initPrefersReducedMotion(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : prefersReducedMotion.current, warnOnce3(this.shouldReduceMotion !== !0, "You have Reduced Motion enabled on your device. Animations may not appear as expected."), this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext);
  }
  unmount() {
    visualElementStore.delete(this.current), this.projection && this.projection.unmount(), cancelSync.update(this.notifyUpdate), cancelSync.render(this.render), this.valueSubscriptions.forEach((remove) => remove()), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this);
    for (let key2 in this.events)
      this.events[key2].clear();
    for (let key2 in this.features)
      this.features[key2].unmount();
    this.current = null;
  }
  bindToMotionValue(key2, value2) {
    let valueIsTransform = transformProps.has(key2), removeOnChange = value2.on("change", (latestValue) => {
      this.latestValues[key2] = latestValue, this.props.onUpdate && sync.update(this.notifyUpdate, !1, !0), valueIsTransform && this.projection && (this.projection.isTransformDirty = !0);
    }), removeOnRenderRequest = value2.on("renderRequest", this.scheduleRender);
    this.valueSubscriptions.set(key2, () => {
      removeOnChange(), removeOnRenderRequest();
    });
  }
  sortNodePosition(other) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== other.type ? 0 : this.sortInstanceNodePosition(this.current, other.current);
  }
  loadFeatures({ children, ...renderedProps }, isStrict, preloadedFeatures2, projectionId, initialLayoutGroupConfig) {
    let ProjectionNodeConstructor, MeasureLayout2;
    if (preloadedFeatures2 && isStrict) {
      let strictMessage = "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.";
      renderedProps.ignoreStrict ? warning2(!1, strictMessage) : invariant4(!1, strictMessage);
    }
    for (let i3 = 0; i3 < numFeatures; i3++) {
      let name = featureNames[i3], { isEnabled, Feature: FeatureConstructor, ProjectionNode, MeasureLayout: MeasureLayoutComponent } = featureDefinitions[name];
      ProjectionNode && (ProjectionNodeConstructor = ProjectionNode), isEnabled(renderedProps) && (!this.features[name] && FeatureConstructor && (this.features[name] = new FeatureConstructor(this)), MeasureLayoutComponent && (MeasureLayout2 = MeasureLayoutComponent));
    }
    if (!this.projection && ProjectionNodeConstructor) {
      this.projection = new ProjectionNodeConstructor(projectionId, this.latestValues, this.parent && this.parent.projection);
      let { layoutId, layout: layout2, drag: drag2, dragConstraints, layoutScroll, layoutRoot } = renderedProps;
      this.projection.setOptions({
        layoutId,
        layout: layout2,
        alwaysMeasureLayout: Boolean(drag2) || dragConstraints && isRefObject(dragConstraints),
        visualElement: this,
        scheduleRender: () => this.scheduleRender(),
        animationType: typeof layout2 == "string" ? layout2 : "both",
        initialPromotionConfig: initialLayoutGroupConfig,
        layoutScroll,
        layoutRoot
      });
    }
    return MeasureLayout2;
  }
  updateFeatures() {
    for (let key2 in this.features) {
      let feature = this.features[key2];
      feature.isMounted ? feature.update(this.props, this.prevProps) : (feature.mount(), feature.isMounted = !0);
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.options, this.props);
  }
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();
  }
  getStaticValue(key2) {
    return this.latestValues[key2];
  }
  setStaticValue(key2, value2) {
    this.latestValues[key2] = value2;
  }
  makeTargetAnimatable(target, canMutate = !0) {
    return this.makeTargetAnimatableFromInstance(target, this.props, canMutate);
  }
  update(props, presenceContext) {
    (props.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = props, this.prevPresenceContext = this.presenceContext, this.presenceContext = presenceContext;
    for (let i3 = 0; i3 < propEventHandlers.length; i3++) {
      let key2 = propEventHandlers[i3];
      this.propEventSubscriptions[key2] && (this.propEventSubscriptions[key2](), delete this.propEventSubscriptions[key2]);
      let listener = props["on" + key2];
      listener && (this.propEventSubscriptions[key2] = this.on(key2, listener));
    }
    this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue();
  }
  getProps() {
    return this.props;
  }
  getVariant(name) {
    return this.props.variants ? this.props.variants[name] : void 0;
  }
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  getVariantContext(startAtParent = !1) {
    if (startAtParent)
      return this.parent ? this.parent.getVariantContext() : void 0;
    if (!this.isControllingVariants) {
      let context2 = this.parent ? this.parent.getVariantContext() || {} : {};
      return this.props.initial !== void 0 && (context2.initial = this.props.initial), context2;
    }
    let context = {};
    for (let i3 = 0; i3 < numVariantProps; i3++) {
      let name = variantProps[i3], prop = this.props[name];
      (isVariantLabel(prop) || prop === !1) && (context[name] = prop);
    }
    return context;
  }
  addVariantChild(child) {
    let closestVariantNode = this.getClosestVariantNode();
    if (closestVariantNode)
      return closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child), () => closestVariantNode.variantChildren.delete(child);
  }
  addValue(key2, value2) {
    value2 !== this.values.get(key2) && (this.removeValue(key2), this.bindToMotionValue(key2, value2)), this.values.set(key2, value2), this.latestValues[key2] = value2.get();
  }
  removeValue(key2) {
    this.values.delete(key2);
    let unsubscribe = this.valueSubscriptions.get(key2);
    unsubscribe && (unsubscribe(), this.valueSubscriptions.delete(key2)), delete this.latestValues[key2], this.removeValueFromRenderState(key2, this.renderState);
  }
  hasValue(key2) {
    return this.values.has(key2);
  }
  getValue(key2, defaultValue) {
    if (this.props.values && this.props.values[key2])
      return this.props.values[key2];
    let value2 = this.values.get(key2);
    return value2 === void 0 && defaultValue !== void 0 && (value2 = motionValue(defaultValue, { owner: this }), this.addValue(key2, value2)), value2;
  }
  readValue(key2) {
    return this.latestValues[key2] !== void 0 || !this.current ? this.latestValues[key2] : this.readValueFromInstance(this.current, key2, this.options);
  }
  setBaseTarget(key2, value2) {
    this.baseTarget[key2] = value2;
  }
  getBaseTarget(key2) {
    var _a;
    let { initial } = this.props, valueFromInitial = typeof initial == "string" || typeof initial == "object" ? (_a = resolveVariantFromProps(this.props, initial)) === null || _a === void 0 ? void 0 : _a[key2] : void 0;
    if (initial && valueFromInitial !== void 0)
      return valueFromInitial;
    let target = this.getBaseTargetFromProps(this.props, key2);
    return target !== void 0 && !isMotionValue(target) ? target : this.initialValues[key2] !== void 0 && valueFromInitial === void 0 ? void 0 : this.baseTarget[key2];
  }
  on(eventName, callback) {
    return this.events[eventName] || (this.events[eventName] = new SubscriptionManager()), this.events[eventName].add(callback);
  }
  notify(eventName, ...args) {
    this.events[eventName] && this.events[eventName].notify(...args);
  }
};

// node_modules/framer-motion/dist/es/render/dom/DOMVisualElement.mjs
var DOMVisualElement = class extends VisualElement {
  sortInstanceNodePosition(a3, b2) {
    return a3.compareDocumentPosition(b2) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(props, key2) {
    return props.style ? props.style[key2] : void 0;
  }
  removeValueFromRenderState(key2, { vars, style }) {
    delete vars[key2], delete style[key2];
  }
  makeTargetAnimatableFromInstance({ transition, transitionEnd: transitionEnd2, ...target }, { transformValues }, isMounted) {
    let origin = getOrigin(target, transition || {}, this);
    if (transformValues && (transitionEnd2 && (transitionEnd2 = transformValues(transitionEnd2)), target && (target = transformValues(target)), origin && (origin = transformValues(origin))), isMounted) {
      checkTargetForNewValues(this, target, origin);
      let parsed = parseDomVariant(this, target, origin, transitionEnd2);
      transitionEnd2 = parsed.transitionEnd, target = parsed.target;
    }
    return {
      transition,
      transitionEnd: transitionEnd2,
      ...target
    };
  }
};

// node_modules/framer-motion/dist/es/render/html/HTMLVisualElement.mjs
function getComputedStyle2(element) {
  return window.getComputedStyle(element);
}
var HTMLVisualElement = class extends DOMVisualElement {
  readValueFromInstance(instance2, key2) {
    if (transformProps.has(key2)) {
      let defaultType = getDefaultValueType(key2);
      return defaultType && defaultType.default || 0;
    } else {
      let computedStyle = getComputedStyle2(instance2), value2 = (isCSSVariableName(key2) ? computedStyle.getPropertyValue(key2) : computedStyle[key2]) || 0;
      return typeof value2 == "string" ? value2.trim() : value2;
    }
  }
  measureInstanceViewportBox(instance2, { transformPagePoint }) {
    return measureViewportBox(instance2, transformPagePoint);
  }
  build(renderState, latestValues, options2, props) {
    buildHTMLStyles(renderState, latestValues, options2, props.transformTemplate);
  }
  scrapeMotionValuesFromProps(props, prevProps) {
    return scrapeMotionValuesFromProps(props, prevProps);
  }
  handleChildMotionValue() {
    this.childSubscription && (this.childSubscription(), delete this.childSubscription);
    let { children } = this.props;
    isMotionValue(children) && (this.childSubscription = children.on("change", (latest) => {
      this.current && (this.current.textContent = `${latest}`);
    }));
  }
  renderInstance(instance2, renderState, styleProp, projection) {
    renderHTML(instance2, renderState, styleProp, projection);
  }
};

// node_modules/framer-motion/dist/es/render/svg/SVGVisualElement.mjs
var SVGVisualElement = class extends DOMVisualElement {
  constructor() {
    super(...arguments), this.isSVGTag = !1;
  }
  getBaseTargetFromProps(props, key2) {
    return props[key2];
  }
  readValueFromInstance(instance2, key2) {
    if (transformProps.has(key2)) {
      let defaultType = getDefaultValueType(key2);
      return defaultType && defaultType.default || 0;
    }
    return key2 = camelCaseAttributes.has(key2) ? key2 : camelToDash(key2), instance2.getAttribute(key2);
  }
  measureInstanceViewportBox() {
    return createBox();
  }
  scrapeMotionValuesFromProps(props, prevProps) {
    return scrapeMotionValuesFromProps2(props, prevProps);
  }
  build(renderState, latestValues, options2, props) {
    buildSVGAttrs(renderState, latestValues, options2, this.isSVGTag, props.transformTemplate);
  }
  renderInstance(instance2, renderState, styleProp, projection) {
    renderSVG(instance2, renderState, styleProp, projection);
  }
  mount(instance2) {
    this.isSVGTag = isSVGTag(instance2.tagName), super.mount(instance2);
  }
};

// node_modules/framer-motion/dist/es/render/dom/create-visual-element.mjs
var createDomVisualElement = (Component3, options2) => isSVGComponent(Component3) ? new SVGVisualElement(options2, { enableHardwareAcceleration: !1 }) : new HTMLVisualElement(options2, { enableHardwareAcceleration: !0 });

// node_modules/framer-motion/dist/es/motion/features/layout.mjs
var layout = {
  layout: {
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout
  }
};

// node_modules/framer-motion/dist/es/render/dom/motion.mjs
var preloadedFeatures = {
  ...animations,
  ...gestureAnimations,
  ...drag,
  ...layout
}, motion = /* @__PURE__ */ createMotionProxy((Component3, config2) => createDomMotionConfig(Component3, config2, preloadedFeatures, createDomVisualElement));

// node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs
var React11 = __toESM(require_react(), 1), import_react40 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/utils/use-force-update.mjs
var import_react36 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/utils/use-is-mounted.mjs
var import_react35 = __toESM(require_react(), 1);
function useIsMounted() {
  let isMounted = (0, import_react35.useRef)(!1);
  return useIsomorphicLayoutEffect(() => (isMounted.current = !0, () => {
    isMounted.current = !1;
  }), []), isMounted;
}

// node_modules/framer-motion/dist/es/utils/use-force-update.mjs
function useForceUpdate() {
  let isMounted = useIsMounted(), [forcedRenderCount, setForcedRenderCount] = (0, import_react36.useState)(0), forceRender = (0, import_react36.useCallback)(() => {
    isMounted.current && setForcedRenderCount(forcedRenderCount + 1);
  }, [forcedRenderCount]);
  return [(0, import_react36.useCallback)(() => sync.postRender(forceRender), [forceRender]), forcedRenderCount];
}

// node_modules/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs
var React10 = __toESM(require_react(), 1), import_react38 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/components/AnimatePresence/PopChild.mjs
var React9 = __toESM(require_react(), 1), import_react37 = __toESM(require_react(), 1), PopChildMeasure = class extends React9.Component {
  getSnapshotBeforeUpdate(prevProps) {
    let element = this.props.childRef.current;
    if (element && prevProps.isPresent && !this.props.isPresent) {
      let size = this.props.sizeRef.current;
      size.height = element.offsetHeight || 0, size.width = element.offsetWidth || 0, size.top = element.offsetTop, size.left = element.offsetLeft;
    }
    return null;
  }
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
};
function PopChild({ children, isPresent }) {
  let id4 = (0, import_react37.useId)(), ref = (0, import_react37.useRef)(null), size = (0, import_react37.useRef)({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  });
  return (0, import_react37.useInsertionEffect)(() => {
    let { width, height, top, left } = size.current;
    if (isPresent || !ref.current || !width || !height)
      return;
    ref.current.dataset.motionPopId = id4;
    let style = document.createElement("style");
    return document.head.appendChild(style), style.sheet && style.sheet.insertRule(`
          [data-motion-pop-id="${id4}"] {
            position: absolute !important;
            width: ${width}px !important;
            height: ${height}px !important;
            top: ${top}px !important;
            left: ${left}px !important;
          }
        `), () => {
      document.head.removeChild(style);
    };
  }, [isPresent]), React9.createElement(PopChildMeasure, { isPresent, childRef: ref, sizeRef: size }, React9.cloneElement(children, { ref }));
}

// node_modules/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs
var PresenceChild = ({ children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode }) => {
  let presenceChildren = useConstant(newChildrenMap), id4 = (0, import_react38.useId)(), context = (0, import_react38.useMemo)(
    () => ({
      id: id4,
      initial,
      isPresent,
      custom,
      onExitComplete: (childId) => {
        presenceChildren.set(childId, !0);
        for (let isComplete of presenceChildren.values())
          if (!isComplete)
            return;
        onExitComplete && onExitComplete();
      },
      register: (childId) => (presenceChildren.set(childId, !1), () => presenceChildren.delete(childId))
    }),
    presenceAffectsLayout ? void 0 : [isPresent]
  );
  return (0, import_react38.useMemo)(() => {
    presenceChildren.forEach((_24, key2) => presenceChildren.set(key2, !1));
  }, [isPresent]), React10.useEffect(() => {
    !isPresent && !presenceChildren.size && onExitComplete && onExitComplete();
  }, [isPresent]), mode === "popLayout" && (children = React10.createElement(PopChild, { isPresent }, children)), React10.createElement(PresenceContext.Provider, { value: context }, children);
};
function newChildrenMap() {
  return /* @__PURE__ */ new Map();
}

// node_modules/framer-motion/dist/es/utils/use-unmount-effect.mjs
var import_react39 = __toESM(require_react(), 1);
function useUnmountEffect(callback) {
  return (0, import_react39.useEffect)(() => () => callback(), []);
}

// node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs
var getChildKey = (child) => child.key || "";
function updateChildLookup(children, allChildren) {
  children.forEach((child) => {
    let key2 = getChildKey(child);
    allChildren.set(key2, child);
  });
}
function onlyElements(children) {
  let filtered = [];
  return import_react40.Children.forEach(children, (child) => {
    (0, import_react40.isValidElement)(child) && filtered.push(child);
  }), filtered;
}
var AnimatePresence = ({ children, custom, initial = !0, onExitComplete, exitBeforeEnter, presenceAffectsLayout = !0, mode = "sync" }) => {
  invariant4(!exitBeforeEnter, "Replace exitBeforeEnter with mode='wait'");
  let [forceRender] = useForceUpdate(), forceRenderLayoutGroup = (0, import_react40.useContext)(LayoutGroupContext).forceRender;
  forceRenderLayoutGroup && (forceRender = forceRenderLayoutGroup);
  let isMounted = useIsMounted(), filteredChildren = onlyElements(children), childrenToRender = filteredChildren, exiting = /* @__PURE__ */ new Set(), presentChildren = (0, import_react40.useRef)(childrenToRender), allChildren = (0, import_react40.useRef)(/* @__PURE__ */ new Map()).current, isInitialRender = (0, import_react40.useRef)(!0);
  if (useIsomorphicLayoutEffect(() => {
    isInitialRender.current = !1, updateChildLookup(filteredChildren, allChildren), presentChildren.current = childrenToRender;
  }), useUnmountEffect(() => {
    isInitialRender.current = !0, allChildren.clear(), exiting.clear();
  }), isInitialRender.current)
    return React11.createElement(React11.Fragment, null, childrenToRender.map((child) => React11.createElement(PresenceChild, { key: getChildKey(child), isPresent: !0, initial: initial ? void 0 : !1, presenceAffectsLayout, mode }, child)));
  childrenToRender = [...childrenToRender];
  let presentKeys = presentChildren.current.map(getChildKey), targetKeys = filteredChildren.map(getChildKey), numPresent = presentKeys.length;
  for (let i3 = 0; i3 < numPresent; i3++) {
    let key2 = presentKeys[i3];
    targetKeys.indexOf(key2) === -1 && exiting.add(key2);
  }
  return mode === "wait" && exiting.size && (childrenToRender = []), exiting.forEach((key2) => {
    if (targetKeys.indexOf(key2) !== -1)
      return;
    let child = allChildren.get(key2);
    if (!child)
      return;
    let insertionIndex = presentKeys.indexOf(key2), onExit = () => {
      allChildren.delete(key2), exiting.delete(key2);
      let removeIndex = presentChildren.current.findIndex((presentChild) => presentChild.key === key2);
      if (presentChildren.current.splice(removeIndex, 1), !exiting.size) {
        if (presentChildren.current = filteredChildren, isMounted.current === !1)
          return;
        forceRender(), onExitComplete && onExitComplete();
      }
    };
    childrenToRender.splice(insertionIndex, 0, React11.createElement(PresenceChild, { key: getChildKey(child), isPresent: !1, onExitComplete: onExit, custom, presenceAffectsLayout, mode }, child));
  }), childrenToRender = childrenToRender.map((child) => {
    let key2 = child.key;
    return exiting.has(key2) ? child : React11.createElement(PresenceChild, { key: getChildKey(child), isPresent: !0, presenceAffectsLayout, mode }, child);
  }), mode === "wait" && childrenToRender.length > 1 && console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.`), React11.createElement(React11.Fragment, null, exiting.size ? childrenToRender : childrenToRender.map((child) => (0, import_react40.cloneElement)(child)));
};

// app/components/common/Modal/index.tsx
var import_jsx_dev_runtime27 = __toESM(require_jsx_dev_runtime()), Background = styled_components_esm_default.div.withConfig({
  displayName: "Modal__Background",
  componentId: "sc-1xdlpbc-0"
})([""]), ModalContainer = styled_components_esm_default.div.withConfig({
  displayName: "Modal__ModalContainer",
  componentId: "sc-1xdlpbc-1"
})(["z-index:999;"]), ModalCloseButton = styled_components_esm_default.button.withConfig({
  displayName: "Modal__ModalCloseButton",
  componentId: "sc-1xdlpbc-2"
})(["position:absolute;top:16px;right:16px;padding:10px;"]), ModalInner = styled_components_esm_default(motion.div).withConfig({
  displayName: "Modal__ModalInner",
  componentId: "sc-1xdlpbc-3"
})(["position:absolute;z-index:999;padding:64px 16px 32px;background-color:", ";width:95vw;max-width:590px;border-radius:16px;display:flex;flex-direction:column;justify-content:center;align-items:center;@media (min-width:768px){padding:68px 46px 40px;}@media (min-width:1280px){padding:76px 102px 48px;}"], ({
  theme
}) => theme.modal.backgroundColor), Modal = ({
  visibility,
  setVisibility,
  children
}) => {
  let {
    theme
  } = useApp();
  return /* @__PURE__ */ (0, import_jsx_dev_runtime27.jsxDEV)(AnimatePresence, { children: visibility && /* @__PURE__ */ (0, import_jsx_dev_runtime27.jsxDEV)(import_jsx_dev_runtime27.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime27.jsxDEV)(Background, { className: "fixed inset-0 z-30", children: /* @__PURE__ */ (0, import_jsx_dev_runtime27.jsxDEV)(motion.div, { initial: {
      opacity: 0
    }, animate: {
      opacity: 0.75
    }, exit: {
      opacity: 0
    }, transition: {
      duration: 0.15
    }, className: "absolute inset-0 bg-zinc-700 z-998" }, void 0, !1, {
      fileName: "app/components/common/Modal/index.tsx",
      lineNumber: 39,
      columnNumber: 13
    }, this) }, void 0, !1, {
      fileName: "app/components/common/Modal/index.tsx",
      lineNumber: 38,
      columnNumber: 11
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime27.jsxDEV)(ModalContainer, { className: "px-5 fixed h-full w-full flex items-center justify-center top-0 left-0", children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime27.jsxDEV)(ModalInner, { initial: {
        y: 50,
        opacity: 0
      }, animate: {
        y: 0,
        opacity: 1
      }, exit: {
        y: -50,
        opacity: 0
      }, transition: {
        type: "spring",
        bounce: 0,
        duration: 0.4
      }, children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime27.jsxDEV)(ModalCloseButton, { onClick: () => setVisibility(!visibility), children: /* @__PURE__ */ (0, import_jsx_dev_runtime27.jsxDEV)(Close_default, { color: theme.modal.svgColor }, void 0, !1, {
          fileName: "app/components/common/Modal/index.tsx",
          lineNumber: 65,
          columnNumber: 17
        }, this) }, void 0, !1, {
          fileName: "app/components/common/Modal/index.tsx",
          lineNumber: 64,
          columnNumber: 15
        }, this),
        children
      ] }, void 0, !0, {
        fileName: "app/components/common/Modal/index.tsx",
        lineNumber: 50,
        columnNumber: 13
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime27.jsxDEV)(motion.div, { initial: {
        opacity: 0
      }, animate: {
        opacity: 1
      }, exit: {
        opacity: 0
      }, transition: {
        type: "spring",
        bounce: 0,
        duration: 0.2
      }, onClick: () => setVisibility(!visibility), className: "bg-transparent px-5 fixed h-full w-full flex items-center justify-center top-0 left-0", style: {
        zIndex: -1
      } }, void 0, !1, {
        fileName: "app/components/common/Modal/index.tsx",
        lineNumber: 69,
        columnNumber: 13
      }, this)
    ] }, void 0, !0, {
      fileName: "app/components/common/Modal/index.tsx",
      lineNumber: 49,
      columnNumber: 11
    }, this)
  ] }, void 0, !0, {
    fileName: "app/components/common/Modal/index.tsx",
    lineNumber: 37,
    columnNumber: 22
  }, this) }, void 0, !1, {
    fileName: "app/components/common/Modal/index.tsx",
    lineNumber: 36,
    columnNumber: 10
  }, this);
};

// app/components/pages/Auth/Login/styles.ts
var BoxContainer = styled_components_esm_default.div`
  display: flex;
  flex-direction: column;
  width: 100%;
  align-items: center;
  justify-content: center;
  gap: 24px;
  width: 100%;
  max-width: 100%;
  @media (min-width: 768px) {
    max-width: 388px;
  }
  @media (min-width: 1024px) {
    gap: 32px;
  }
`, BoxForm = styled_components_esm_default.div`
  display: flex;
  flex-direction: column;
  width: 100%;
  align-items: center;
  gap: 24px;
  margin-bottom: -8px;
  @media (min-width: 1024px) {
    margin-bottom: -16px;
  }
`, BoxSocial = styled_components_esm_default.div`
  display: flex;
  flex-direction: column;
  width: 100%;
  align-items: center;
  gap: 24px;
  margin-top: -8px;
  @media (min-width: 1024px) {
    margin-top: -16px;
  }
`, BoxHelp = styled_components_esm_default.div`
  cursor: pointer;
  display: flex;
  flex-direction: row;
  align-items: center;
  gap: 24px;
  justify-content: center;
  margin-top: -8px;
  @media (min-width: 1024px) {
    margin-top: -16px;
  }
`, PoliciesText = styled_components_esm_default.div`
  margin-top: -8px;
  text-align: center;
`, HelpButton = styled_components_esm_default.div`
  &:hover,
  &:focus {
    span {
      color: ${({ theme }) => theme.auth.helpButtonHoverColor};
    }
  }
  &:active {
    transform: scale(0.95);
    span {
      color: ${({ theme }) => theme.auth.helpButtonActiveColor};
    }
  }
`;

// app/components/pages/Auth/Login/index.tsx
var import_jsx_dev_runtime28 = __toESM(require_jsx_dev_runtime());
function Login({
  visibility,
  setVisibility
}) {
  let {
    t: t4,
    theme
  } = useApp(), login = useFetcher2(), ref = (0, import_react41.useRef)();
  return (0, import_react41.useEffect)(() => {
    var _a;
    login.type === "done" && login.data.ok && ((_a = ref.current) == null || _a.reset());
  }, [login]), /* @__PURE__ */ (0, import_jsx_dev_runtime28.jsxDEV)(Modal, { visibility, setVisibility, children: /* @__PURE__ */ (0, import_jsx_dev_runtime28.jsxDEV)(BoxContainer, { children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime28.jsxDEV)(Text, { variant: TextVariantEnum.textHeading3, style: {
      textAlign: "center"
    }, children: t4("auth:create_new_account_or_sign_in") }, void 0, !1, {
      fileName: "app/components/pages/Auth/Login/index.tsx",
      lineNumber: 34,
      columnNumber: 9
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime28.jsxDEV)(login.Form, { method: "POST", action: "/auth/login", style: {
      width: "100%"
    }, children: /* @__PURE__ */ (0, import_jsx_dev_runtime28.jsxDEV)(BoxForm, { children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime28.jsxDEV)(Input, { placeholder: t4("auth:enter_email"), id: "i_email", name: "email" }, void 0, !1, {
        fileName: "app/components/pages/Auth/Login/index.tsx",
        lineNumber: 43,
        columnNumber: 13
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime28.jsxDEV)(Input, { placeholder: t4("auth:enter_password"), id: "i_password", name: "password" }, void 0, !1, {
        fileName: "app/components/pages/Auth/Login/index.tsx",
        lineNumber: 44,
        columnNumber: 13
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime28.jsxDEV)(Button_default, { priority: "primary", fullwidth: !0, children: /* @__PURE__ */ (0, import_jsx_dev_runtime28.jsxDEV)(Text, { variant: TextVariantEnum.textBody2, children: t4("auth:sign_in_with_email") }, void 0, !1, {
        fileName: "app/components/pages/Auth/Login/index.tsx",
        lineNumber: 46,
        columnNumber: 15
      }, this) }, void 0, !1, {
        fileName: "app/components/pages/Auth/Login/index.tsx",
        lineNumber: 45,
        columnNumber: 13
      }, this)
    ] }, void 0, !0, {
      fileName: "app/components/pages/Auth/Login/index.tsx",
      lineNumber: 42,
      columnNumber: 11
    }, this) }, void 0, !1, {
      fileName: "app/components/pages/Auth/Login/index.tsx",
      lineNumber: 39,
      columnNumber: 9
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime28.jsxDEV)(Text, { variant: TextVariantEnum.textBody2medium, children: t4("auth:or_register_with_social_accounts") }, void 0, !1, {
      fileName: "app/components/pages/Auth/Login/index.tsx",
      lineNumber: 50,
      columnNumber: 9
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime28.jsxDEV)(BoxSocial, { children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime28.jsxDEV)(Button_default, { priority: "small", fullwidth: !0, iconName: IconEnum.google, children: /* @__PURE__ */ (0, import_jsx_dev_runtime28.jsxDEV)(Text, { variant: TextVariantEnum.textBody2, children: t4("auth:sign_with_google") }, void 0, !1, {
        fileName: "app/components/pages/Auth/Login/index.tsx",
        lineNumber: 55,
        columnNumber: 13
      }, this) }, void 0, !1, {
        fileName: "app/components/pages/Auth/Login/index.tsx",
        lineNumber: 54,
        columnNumber: 11
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime28.jsxDEV)(Button_default, { priority: "small", fullwidth: !0, iconName: IconEnum.fb, children: /* @__PURE__ */ (0, import_jsx_dev_runtime28.jsxDEV)(Text, { variant: TextVariantEnum.textBody2, children: t4("auth:sign_with_facebook") }, void 0, !1, {
        fileName: "app/components/pages/Auth/Login/index.tsx",
        lineNumber: 58,
        columnNumber: 13
      }, this) }, void 0, !1, {
        fileName: "app/components/pages/Auth/Login/index.tsx",
        lineNumber: 57,
        columnNumber: 11
      }, this)
    ] }, void 0, !0, {
      fileName: "app/components/pages/Auth/Login/index.tsx",
      lineNumber: 53,
      columnNumber: 9
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime28.jsxDEV)(BoxHelp, { children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime28.jsxDEV)(HelpButton, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime28.jsxDEV)(Text, { variant: TextVariantEnum.textBody2medium, color: theme.auth.helpButtonColor, children: t4("auth:forgot_password") }, void 0, !1, {
        fileName: "app/components/pages/Auth/Login/index.tsx",
        lineNumber: 63,
        columnNumber: 13
      }, this) }, void 0, !1, {
        fileName: "app/components/pages/Auth/Login/index.tsx",
        lineNumber: 62,
        columnNumber: 11
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime28.jsxDEV)(HelpButton, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime28.jsxDEV)(Link2, { to: "/register", children: /* @__PURE__ */ (0, import_jsx_dev_runtime28.jsxDEV)(Text, { variant: TextVariantEnum.textBody2medium, color: theme.auth.helpButtonColor, children: t4("auth:registration") }, void 0, !1, {
        fileName: "app/components/pages/Auth/Login/index.tsx",
        lineNumber: 69,
        columnNumber: 15
      }, this) }, void 0, !1, {
        fileName: "app/components/pages/Auth/Login/index.tsx",
        lineNumber: 68,
        columnNumber: 13
      }, this) }, void 0, !1, {
        fileName: "app/components/pages/Auth/Login/index.tsx",
        lineNumber: 67,
        columnNumber: 11
      }, this)
    ] }, void 0, !0, {
      fileName: "app/components/pages/Auth/Login/index.tsx",
      lineNumber: 61,
      columnNumber: 9
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime28.jsxDEV)(PoliciesText, { children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime28.jsxDEV)(Text, { variant: TextVariantEnum.textBody2, children: `${t4("auth:by_continuing_i_agree_to_the")} ` }, void 0, !1, {
        fileName: "app/components/pages/Auth/Login/index.tsx",
        lineNumber: 76,
        columnNumber: 11
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime28.jsxDEV)(Link2, { to: "/", children: /* @__PURE__ */ (0, import_jsx_dev_runtime28.jsxDEV)(Text, { variant: TextVariantEnum.textBody2, style: {
        textDecoration: "underline",
        cursor: "pointer"
      }, children: t4("auth:terms_of_use") }, void 0, !1, {
        fileName: "app/components/pages/Auth/Login/index.tsx",
        lineNumber: 80,
        columnNumber: 13
      }, this) }, void 0, !1, {
        fileName: "app/components/pages/Auth/Login/index.tsx",
        lineNumber: 79,
        columnNumber: 11
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime28.jsxDEV)(Text, { variant: TextVariantEnum.textBody2, children: ` ${t4("auth:and")} ` }, void 0, !1, {
        fileName: "app/components/pages/Auth/Login/index.tsx",
        lineNumber: 87,
        columnNumber: 11
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime28.jsxDEV)(Link2, { to: "/", children: /* @__PURE__ */ (0, import_jsx_dev_runtime28.jsxDEV)(Text, { variant: TextVariantEnum.textBody2, style: {
        textDecoration: "underline",
        cursor: "pointer"
      }, children: [
        t4("auth:privacy_policy"),
        "."
      ] }, void 0, !0, {
        fileName: "app/components/pages/Auth/Login/index.tsx",
        lineNumber: 89,
        columnNumber: 13
      }, this) }, void 0, !1, {
        fileName: "app/components/pages/Auth/Login/index.tsx",
        lineNumber: 88,
        columnNumber: 11
      }, this)
    ] }, void 0, !0, {
      fileName: "app/components/pages/Auth/Login/index.tsx",
      lineNumber: 75,
      columnNumber: 9
    }, this)
  ] }, void 0, !0, {
    fileName: "app/components/pages/Auth/Login/index.tsx",
    lineNumber: 33,
    columnNumber: 7
  }, this) }, void 0, !1, {
    fileName: "app/components/pages/Auth/Login/index.tsx",
    lineNumber: 32,
    columnNumber: 10
  }, this);
}

// app/components/lib/Navbar/index.tsx
var import_jsx_dev_runtime29 = __toESM(require_jsx_dev_runtime()), ModalOverlay = styled_components_esm_default.div.withConfig({
  displayName: "Navbar__ModalOverlay",
  componentId: "sc-12z5iw6-0"
})(["position:fixed;top:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,0.5);display:flex;justify-content:center;align-items:center;"]), ModalWindow = styled_components_esm_default.div.withConfig({
  displayName: "Navbar__ModalWindow",
  componentId: "sc-12z5iw6-1"
})(["background-color:#fff;padding:20px;border-radius:4px;box-shadow:0 0 10px rgba(0,0,0,0.5);max-width:90%;max-height:90%;overflow:auto;"]), Navbar = (0, import_react44.memo)(function() {
  let [visibilityLogin, setVisibilityLogin] = (0, import_react44.useState)(!1), {
    userContext,
    setUserContext,
    theme,
    t: t4,
    i18n
  } = useApp();
  function setLang(language) {
    setUserContext((prevContext) => ({
      ...prevContext,
      language
    }));
  }
  let changeLanguage2 = () => {
    (userContext == null ? void 0 : userContext.language) === LanguageEnum.TH ? setUserContext((prevContext) => ({
      ...prevContext,
      language: LanguageEnum.EN
    })) : setUserContext((prevContext) => ({
      ...prevContext,
      language: LanguageEnum.TH
    }));
  };
  return (0, import_react44.useEffect)(() => {
    i18n.changeLanguage(userContext == null ? void 0 : userContext.language);
  }, [i18n, userContext == null ? void 0 : userContext.language]), /* @__PURE__ */ (0, import_jsx_dev_runtime29.jsxDEV)(WrapperHeader, { children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime29.jsxDEV)(ContainerHeader, { children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime29.jsxDEV)(LeftContainer, { children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime29.jsxDEV)(Link2, { to: "/", children: /* @__PURE__ */ (0, import_jsx_dev_runtime29.jsxDEV)(LogoWrapper, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime29.jsxDEV)(Logo_default, { color: theme.navbar.logoColor }, void 0, !1, {
          fileName: "app/components/lib/Navbar/index.tsx",
          lineNumber: 57,
          columnNumber: 15
        }, this) }, void 0, !1, {
          fileName: "app/components/lib/Navbar/index.tsx",
          lineNumber: 56,
          columnNumber: 13
        }, this) }, void 0, !1, {
          fileName: "app/components/lib/Navbar/index.tsx",
          lineNumber: 55,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime29.jsxDEV)(TranslateBox, { children: [
          /* @__PURE__ */ (0, import_jsx_dev_runtime29.jsxDEV)(BoxText, { style: {
            cursor: "pointer"
          }, lang: LanguageEnum.TH, selectedLang: (userContext == null ? void 0 : userContext.language) ?? "", onClick: () => setLang(LanguageEnum.TH), children: /* @__PURE__ */ (0, import_jsx_dev_runtime29.jsxDEV)(Text, { color: (userContext == null ? void 0 : userContext.language) === LanguageEnum.TH ? theme.navbar.textActiveLangColor : theme.navbar.textNoActiveLangColor, children: "\u0E20\u0E32\u0E29\u0E32\u0E44\u0E17\u0E22" }, void 0, !1, {
            fileName: "app/components/lib/Navbar/index.tsx",
            lineNumber: 64,
            columnNumber: 15
          }, this) }, void 0, !1, {
            fileName: "app/components/lib/Navbar/index.tsx",
            lineNumber: 61,
            columnNumber: 13
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime29.jsxDEV)(Switcher, { onChange: changeLanguage2, checked: (userContext == null ? void 0 : userContext.language) === LanguageEnum.EN, htmlLabel: "lang" }, void 0, !1, {
            fileName: "app/components/lib/Navbar/index.tsx",
            lineNumber: 68,
            columnNumber: 13
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime29.jsxDEV)(BoxText, { style: {
            cursor: "pointer"
          }, lang: LanguageEnum.EN, selectedLang: (userContext == null ? void 0 : userContext.language) ?? "", onClick: () => setLang(LanguageEnum.EN), children: /* @__PURE__ */ (0, import_jsx_dev_runtime29.jsxDEV)(Text, { color: (userContext == null ? void 0 : userContext.language) === LanguageEnum.EN ? theme.navbar.textActiveLangColor : theme.navbar.textNoActiveLangColor, children: "English" }, void 0, !1, {
            fileName: "app/components/lib/Navbar/index.tsx",
            lineNumber: 72,
            columnNumber: 15
          }, this) }, void 0, !1, {
            fileName: "app/components/lib/Navbar/index.tsx",
            lineNumber: 69,
            columnNumber: 13
          }, this)
        ] }, void 0, !0, {
          fileName: "app/components/lib/Navbar/index.tsx",
          lineNumber: 60,
          columnNumber: 11
        }, this)
      ] }, void 0, !0, {
        fileName: "app/components/lib/Navbar/index.tsx",
        lineNumber: 54,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime29.jsxDEV)(MenuContainer, { children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime29.jsxDEV)(IconButtons, { children: [
          /* @__PURE__ */ (0, import_jsx_dev_runtime29.jsxDEV)(IconButton, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime29.jsxDEV)(Bell_default, { color: theme.navbar.svgColor }, void 0, !1, {
            fileName: "app/components/lib/Navbar/index.tsx",
            lineNumber: 81,
            columnNumber: 26
          }, this) }, void 0, !1, {
            fileName: "app/components/lib/Navbar/index.tsx",
            lineNumber: 81,
            columnNumber: 13
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime29.jsxDEV)(IconButton, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime29.jsxDEV)(Email_default, { color: theme.navbar.svgColor }, void 0, !1, {
            fileName: "app/components/lib/Navbar/index.tsx",
            lineNumber: 82,
            columnNumber: 26
          }, this) }, void 0, !1, {
            fileName: "app/components/lib/Navbar/index.tsx",
            lineNumber: 82,
            columnNumber: 13
          }, this)
        ] }, void 0, !0, {
          fileName: "app/components/lib/Navbar/index.tsx",
          lineNumber: 80,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime29.jsxDEV)(Button, { onClick: () => setVisibilityLogin(!visibilityLogin), priority: "small", children: /* @__PURE__ */ (0, import_jsx_dev_runtime29.jsxDEV)(Text, { children: t4("signIn") }, void 0, !1, {
          fileName: "app/components/lib/Navbar/index.tsx",
          lineNumber: 85,
          columnNumber: 13
        }, this) }, void 0, !1, {
          fileName: "app/components/lib/Navbar/index.tsx",
          lineNumber: 84,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime29.jsxDEV)(Outlet, {}, void 0, !1, {
          fileName: "app/components/lib/Navbar/index.tsx",
          lineNumber: 87,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime29.jsxDEV)(IconButton, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime29.jsxDEV)(Menu_default, { color: theme.navbar.svgColor }, void 0, !1, {
          fileName: "app/components/lib/Navbar/index.tsx",
          lineNumber: 88,
          columnNumber: 24
        }, this) }, void 0, !1, {
          fileName: "app/components/lib/Navbar/index.tsx",
          lineNumber: 88,
          columnNumber: 11
        }, this)
      ] }, void 0, !0, {
        fileName: "app/components/lib/Navbar/index.tsx",
        lineNumber: 79,
        columnNumber: 9
      }, this)
    ] }, void 0, !0, {
      fileName: "app/components/lib/Navbar/index.tsx",
      lineNumber: 53,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime29.jsxDEV)(Login, { visibility: visibilityLogin, setVisibility: setVisibilityLogin }, void 0, !1, {
      fileName: "app/components/lib/Navbar/index.tsx",
      lineNumber: 91,
      columnNumber: 7
    }, this)
  ] }, void 0, !0, {
    fileName: "app/components/lib/Navbar/index.tsx",
    lineNumber: 52,
    columnNumber: 10
  }, this);
});

// app/components/layouts/CommonLayout.tsx
var import_jsx_dev_runtime30 = __toESM(require_jsx_dev_runtime()), Container = styled_components_esm_default(Box).withConfig({
  displayName: "CommonLayout__Container",
  componentId: "sc-1kqrea7-0"
})(["background-color:", ";"], ({
  theme
}) => theme.backgroundColor), CommonLayout = ({
  children
}) => /* @__PURE__ */ (0, import_jsx_dev_runtime30.jsxDEV)(Container, { flexDirection: "column", minHeight: "100vh", children: [
  /* @__PURE__ */ (0, import_jsx_dev_runtime30.jsxDEV)(Navbar, {}, void 0, !1, {
    fileName: "app/components/layouts/CommonLayout.tsx",
    lineNumber: 19,
    columnNumber: 7
  }, this),
  /* @__PURE__ */ (0, import_jsx_dev_runtime30.jsxDEV)(
    Box,
    {
      width: "100%",
      flexDirection: "column",
      children
    },
    void 0,
    !1,
    {
      fileName: "app/components/layouts/CommonLayout.tsx",
      lineNumber: 21,
      columnNumber: 7
    },
    this
  ),
  /* @__PURE__ */ (0, import_jsx_dev_runtime30.jsxDEV)(Footer, {}, void 0, !1, {
    fileName: "app/components/layouts/CommonLayout.tsx",
    lineNumber: 27,
    columnNumber: 7
  }, this)
] }, void 0, !0, {
  fileName: "app/components/layouts/CommonLayout.tsx",
  lineNumber: 18,
  columnNumber: 10
}, this);

// app/components/pages/Auth/Register/index.tsx
var import_jsx_dev_runtime31 = __toESM(require_jsx_dev_runtime()), Wrapper2 = styled_components_esm_default.div.withConfig({
  displayName: "Register__Wrapper",
  componentId: "sc-19cnfja-0"
})(["padding:16px;background-color:", ";width:100%;display:flex;justify-content:center;align-items:center;@media (min-width:768px){gap:24px;}"], ({
  theme
}) => theme.auth.backgroundRegisterPage), BoxForm2 = styled_components_esm_default.div.withConfig({
  displayName: "Register__BoxForm",
  componentId: "sc-19cnfja-1"
})(["display:flex;flex-direction:column;width:100%;background-color:", ";border-radius:8px;align-items:center;gap:24px;padding:16px;@media (min-width:768px){gap:32px;max-width:476px;padding:40px;}@media (min-width:1280px){padding:48px 102px;max-width:792px;}"], ({
  theme
}) => theme.auth.backgroundRegisterContainerColor), BoxRadios = styled_components_esm_default.div.withConfig({
  displayName: "Register__BoxRadios",
  componentId: "sc-19cnfja-2"
})(["width:100%;display:flex;flex-direction:column;gap:16px;@media (min-width:1280px){flex-direction:row;justify-content:center;}"]), RadioBtnWrapper = styled_components_esm_default.label.withConfig({
  displayName: "Register__RadioBtnWrapper",
  componentId: "sc-19cnfja-3"
})(["display:flex;flex-direction:row;align-items:center;gap:8px;"]), RadioBtn = styled_components_esm_default.input.withConfig({
  displayName: "Register__RadioBtn",
  componentId: "sc-19cnfja-4"
})(["accent-color:", ";width:20px;height:20px;"], ({
  theme
}) => theme.auth.radioButtonColor), RegisterPage = (0, import_react46.memo)(function() {
  let {
    t: t4
  } = useApp();
  return /* @__PURE__ */ (0, import_jsx_dev_runtime31.jsxDEV)(CommonLayout, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime31.jsxDEV)(Wrapper2, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime31.jsxDEV)(Form, { method: "post", action: "/", style: {
    width: "100%",
    display: "flex",
    justifyContent: "center"
  }, children: /* @__PURE__ */ (0, import_jsx_dev_runtime31.jsxDEV)(BoxForm2, { children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime31.jsxDEV)(Text, { variant: TextVariantEnum.textHeading3, style: {
      textAlign: "center"
    }, children: t4("auth:sign_up") }, void 0, !1, {
      fileName: "app/components/pages/Auth/Register/index.tsx",
      lineNumber: 49,
      columnNumber: 13
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime31.jsxDEV)(Input, { placeholder: t4("auth:enter_first_name"), id: "i_enter_first_name", name: "enter_first_name" }, void 0, !1, {
      fileName: "app/components/pages/Auth/Register/index.tsx",
      lineNumber: 54,
      columnNumber: 13
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime31.jsxDEV)(Input, { placeholder: t4("auth:enter_last_name"), id: "i_last_name", name: "last_name" }, void 0, !1, {
      fileName: "app/components/pages/Auth/Register/index.tsx",
      lineNumber: 55,
      columnNumber: 13
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime31.jsxDEV)(Input, { placeholder: t4("auth:enter_email"), id: "i_email", name: "email" }, void 0, !1, {
      fileName: "app/components/pages/Auth/Register/index.tsx",
      lineNumber: 56,
      columnNumber: 13
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime31.jsxDEV)(Input, { placeholder: t4("auth:enter_password"), id: "i_password", name: "password" }, void 0, !1, {
      fileName: "app/components/pages/Auth/Register/index.tsx",
      lineNumber: 57,
      columnNumber: 13
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime31.jsxDEV)(Input, { placeholder: t4("auth:password_confirmation"), id: "i_password_confirmation", name: "password_confirmation" }, void 0, !1, {
      fileName: "app/components/pages/Auth/Register/index.tsx",
      lineNumber: 58,
      columnNumber: 13
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime31.jsxDEV)(BoxRadios, { children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime31.jsxDEV)(RadioBtnWrapper, { children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime31.jsxDEV)(RadioBtn, { type: "radio", id: "i_newsletter", name: "newsletter" }, void 0, !1, {
          fileName: "app/components/pages/Auth/Register/index.tsx",
          lineNumber: 61,
          columnNumber: 17
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime31.jsxDEV)(Text, { variant: TextVariantEnum.textBody1medium, children: t4("auth:subscribe_to_newsletter") }, void 0, !1, {
          fileName: "app/components/pages/Auth/Register/index.tsx",
          lineNumber: 62,
          columnNumber: 17
        }, this)
      ] }, void 0, !0, {
        fileName: "app/components/pages/Auth/Register/index.tsx",
        lineNumber: 60,
        columnNumber: 15
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime31.jsxDEV)(RadioBtnWrapper, { children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime31.jsxDEV)(RadioBtn, { type: "radio", id: "i_policy", name: "policy" }, void 0, !1, {
          fileName: "app/components/pages/Auth/Register/index.tsx",
          lineNumber: 67,
          columnNumber: 17
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime31.jsxDEV)(Text, { variant: TextVariantEnum.textBody1medium, children: t4("auth:i_accept_terms_of_use") }, void 0, !1, {
          fileName: "app/components/pages/Auth/Register/index.tsx",
          lineNumber: 68,
          columnNumber: 17
        }, this)
      ] }, void 0, !0, {
        fileName: "app/components/pages/Auth/Register/index.tsx",
        lineNumber: 66,
        columnNumber: 15
      }, this)
    ] }, void 0, !0, {
      fileName: "app/components/pages/Auth/Register/index.tsx",
      lineNumber: 59,
      columnNumber: 13
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime31.jsxDEV)(Button_default, { priority: "primary", fullwidth: !0, children: /* @__PURE__ */ (0, import_jsx_dev_runtime31.jsxDEV)(Text, { variant: TextVariantEnum.textBody2, children: t4("auth:sign_up") }, void 0, !1, {
      fileName: "app/components/pages/Auth/Register/index.tsx",
      lineNumber: 74,
      columnNumber: 15
    }, this) }, void 0, !1, {
      fileName: "app/components/pages/Auth/Register/index.tsx",
      lineNumber: 73,
      columnNumber: 13
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime31.jsxDEV)(PoliciesText, { children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime31.jsxDEV)(Text, { variant: TextVariantEnum.textBody2, children: `${t4("auth:by_continuing_i_agree_to_the")} ` }, void 0, !1, {
        fileName: "app/components/pages/Auth/Register/index.tsx",
        lineNumber: 77,
        columnNumber: 15
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime31.jsxDEV)(Link2, { to: "/", children: /* @__PURE__ */ (0, import_jsx_dev_runtime31.jsxDEV)(Text, { variant: TextVariantEnum.textBody2, style: {
        textDecoration: "underline",
        cursor: "pointer"
      }, children: t4("auth:terms_of_use") }, void 0, !1, {
        fileName: "app/components/pages/Auth/Register/index.tsx",
        lineNumber: 81,
        columnNumber: 17
      }, this) }, void 0, !1, {
        fileName: "app/components/pages/Auth/Register/index.tsx",
        lineNumber: 80,
        columnNumber: 15
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime31.jsxDEV)(Text, { variant: TextVariantEnum.textBody2, children: ` ${t4("auth:and")} ` }, void 0, !1, {
        fileName: "app/components/pages/Auth/Register/index.tsx",
        lineNumber: 88,
        columnNumber: 15
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime31.jsxDEV)(Link2, { to: "/", children: /* @__PURE__ */ (0, import_jsx_dev_runtime31.jsxDEV)(Text, { variant: TextVariantEnum.textBody2, style: {
        textDecoration: "underline",
        cursor: "pointer"
      }, children: [
        t4("auth:privacy_policy"),
        "."
      ] }, void 0, !0, {
        fileName: "app/components/pages/Auth/Register/index.tsx",
        lineNumber: 90,
        columnNumber: 17
      }, this) }, void 0, !1, {
        fileName: "app/components/pages/Auth/Register/index.tsx",
        lineNumber: 89,
        columnNumber: 15
      }, this)
    ] }, void 0, !0, {
      fileName: "app/components/pages/Auth/Register/index.tsx",
      lineNumber: 76,
      columnNumber: 13
    }, this)
  ] }, void 0, !0, {
    fileName: "app/components/pages/Auth/Register/index.tsx",
    lineNumber: 48,
    columnNumber: 11
  }, this) }, void 0, !1, {
    fileName: "app/components/pages/Auth/Register/index.tsx",
    lineNumber: 43,
    columnNumber: 9
  }, this) }, void 0, !1, {
    fileName: "app/components/pages/Auth/Register/index.tsx",
    lineNumber: 42,
    columnNumber: 7
  }, this) }, void 0, !1, {
    fileName: "app/components/pages/Auth/Register/index.tsx",
    lineNumber: 41,
    columnNumber: 10
  }, this);
});

// app/routes/register.tsx
var import_jsx_dev_runtime32 = __toESM(require_jsx_dev_runtime());
function Register() {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime32.jsxDEV)(RegisterPage, {}, void 0, !1, {
    fileName: "app/routes/register.tsx",
    lineNumber: 3,
    columnNumber: 10
  }, this);
}

// app/routes/ui/index.tsx
var ui_exports = {};
__export(ui_exports, {
  default: () => Index2
});

// app/components/common/Card/styles.tsx
var CardWrapper = styled_components_esm_default.a.withConfig({
  displayName: "styles__CardWrapper",
  componentId: "sc-sqtgwc-0"
})(["cursor:pointer;display:flex;flex-direction:column;align-items:flex-start;width:100%;min-height:176px;transition:all 0.15s ease-in;position:relative;margin:14px 0;@media (min-width:768px){min-width:", ";}@media (min-width:1024px){min-width:100%;margin:", ";}@media (min-width:1280px){max-width:", ";}&:hover{z-index:1;transform:translateZ(0) ", ";}"], ({
  variant
}) => variant === "companies" ? "152px" : "256px", ({
  variant
}) => variant === "companies" ? "14px 0" : "0", ({
  variant
}) => variant === "companies" ? "200px" : "100%", ({
  variant
}) => variant === "companies" ? "scale(1.1)" : "scale(1.05)"), Image = styled_components_esm_default.div.withConfig({
  displayName: "styles__Image",
  componentId: "sc-sqtgwc-1"
})(["padding:", ";background:", ";min-width:", ";display:flex;flex-direction:column;align-items:center;border-radius:", ";height:100%;flex-grow:1;img{max-width:100%;height:auto;border-radius:", ";}@media (min-width:768px){padding:", ";height:", ";img{min-width:", ";height:", ";}}@media (min-width:1024px){height:", ";padding:", ";width:100%;}@media (min-width:1280px){width:", ";}"], ({
  variant
}) => variant === "companies" ? "15px 25px" : "0", ({
  theme
}) => theme.\u0441ards.imageBackground, ({
  variant
}) => variant === "companies" ? "100%" : "138px", ({
  variant
}) => variant === "companies" ? " 16px 16px 0px 0px" : "8px 8px 0px 0px", ({
  variant
}) => variant === "companies" ? "0" : "8px 8px 0px 0px", ({
  variant
}) => variant === "companies" ? "18px 20px" : "0", ({
  variant
}) => variant === "companies" ? "118px" : "200px", ({
  variant
}) => variant === "companies" ? "110px" : "256px", ({
  variant
}) => variant === "companies" ? "80px" : "auto", ({
  variant
}) => variant === "companies" ? "130px" : "auto", ({
  variant
}) => variant === "companies" ? "25px 45px" : "0", ({
  variant
}) => variant === "companies" ? "200px" : "100%"), CardContent = styled_components_esm_default.div.withConfig({
  displayName: "styles__CardContent",
  componentId: "sc-sqtgwc-2"
})(["width:100%;min-height:", ";height:100%;display:flex;flex-direction:column;align-items:flex-start;text-align:start;background:", ";border-radius:", ";gap:6px;padding:", ";justify-content:space-between;@media (min-width:768px){gap:", ";.cardTitle{font-size:", ";}}@media (min-width:1024px){padding:", ";width:100%;height:100%;.cardTitle{font-size:", ";}}@media (min-width:1280px){width:", ";}"], ({
  variant
}) => variant === "articles" ? "110px" : "102px", ({
  theme
}) => theme.\u0441ards.cardContentBackground, ({
  variant
}) => variant === "companies" ? "0px 0px 16px 16px" : "0px 0px 8px 8px", ({
  variant
}) => variant === "companies" ? "8px" : "10px", ({
  variant
}) => variant === "companies" ? "24px" : "8px", FONT_SIZES_TAB[TextVariantEnum.textBody1], ({
  variant
}) => variant === "companies" ? "20px" : "16px 18px", FONT_SIZES_DESC[TextVariantEnum.textBody1], ({
  variant
}) => variant === "companies" ? "200px" : "100%");

// app/components/common/Card/index.tsx
var import_jsx_dev_runtime33 = __toESM(require_jsx_dev_runtime());
var Card = ({
  className,
  style,
  variant,
  title: title2,
  date: date3,
  vacancies,
  image
}) => {
  let {
    theme
  } = useApp();
  return /* @__PURE__ */ (0, import_jsx_dev_runtime33.jsxDEV)(CardWrapper, { variant, className, style, children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime33.jsxDEV)(Image, { variant, children: /* @__PURE__ */ (0, import_jsx_dev_runtime33.jsxDEV)("img", { src: image, alt: title2 }, void 0, !1, {
      fileName: "app/components/common/Card/index.tsx",
      lineNumber: 36,
      columnNumber: 9
    }, this) }, void 0, !1, {
      fileName: "app/components/common/Card/index.tsx",
      lineNumber: 35,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime33.jsxDEV)(CardContent, { variant, children: [
      variant === "articles" && /* @__PURE__ */ (0, import_jsx_dev_runtime33.jsxDEV)(Text, { variant: TextVariantEnum.textSmall, color: theme.\u0441ards.articlesTextColor, children: date3 }, void 0, !1, {
        fileName: "app/components/common/Card/index.tsx",
        lineNumber: 39,
        columnNumber: 36
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime33.jsxDEV)(Text, { className: "cardTitle", variant: TextVariantEnum.textBody2, children: title2 }, void 0, !1, {
        fileName: "app/components/common/Card/index.tsx",
        lineNumber: 42,
        columnNumber: 9
      }, this),
      variant === "companies" && /* @__PURE__ */ (0, import_jsx_dev_runtime33.jsxDEV)(Text, { variant: TextVariantEnum.textSmall, color: vacancies ? theme.\u0441ards.vacanciesTextColor : theme.\u0441ards.noVacanciesTextColor, children: vacancies ? `${vacancies} vacancies` : "no vacancies" }, void 0, !1, {
        fileName: "app/components/common/Card/index.tsx",
        lineNumber: 45,
        columnNumber: 37
      }, this)
    ] }, void 0, !0, {
      fileName: "app/components/common/Card/index.tsx",
      lineNumber: 38,
      columnNumber: 7
    }, this)
  ] }, void 0, !0, {
    fileName: "app/components/common/Card/index.tsx",
    lineNumber: 34,
    columnNumber: 10
  }, this);
}, Card_default = Card;

// app/components/common/Tabs/index.tsx
var import_react49 = __toESM(require_react());

// app/components/common/Tabs/styles.ts
var TabContainer = styled_components_esm_default.div`
  display: flex;
  align-items: center;
  background-color: ${({ theme }) => theme.tabs.tabContainer.backgroundColor};
  border-radius: 16px 16px 0 0;
  width: 100%;
`, TabButton = styled_components_esm_default.button`
  cursor: pointer;
  width: 100%;
  min-width: fit-content;
  background-color: ${({ isActive, theme }) => isActive ? theme.tabs.tabButton.activeBackgroundColor : theme.tabs.tabButton.backgroundColor};
  padding: 12px 17px;
  border-radius: 16px 16px 0 0;
  transition: all 0.15s ease-in;
  &:hover,
  &:focus {
    background-color: ${({ isActive, theme }) => isActive ? theme.tabs.tabButton.focusBackgroundColor : theme.tabs.tabButton.focusActiveBackgroundColor};
    span {
      color: ${({ isActive, theme }) => isActive ? theme.tabs.tabButton.focusSpanActiveBackgroundColor : theme.tabs.tabButton.focusSpanBackgroundColor};
      font-weight: 400;
    }
  }
  &:active {
    span {
      font-weight: ${({ isActive }) => isActive ? 400 : 500};
    }
  }

  @media (min-width: 768px) {
    padding: 18px 40px;
    &:hover,
    &:focus {
      background-color: ${({ isActive, theme }) => isActive ? theme.tabs.tabButton.focusBackgroundColor : theme.tabs.tabButton.focusActiveBackgroundColor};
      span {
        color: ${({ isActive, theme }) => isActive ? theme.tabs.tabButton.focusSpanActiveBackgroundColor : theme.tabs.tabButton.focusSpanBackgroundColor};
        font-weight: 400;
      }
    }
    &:active {
      background-color: ${({ isActive, theme }) => isActive ? theme.tabs.tabButton.focusBackgroundColor : theme.tabs.tabButton.focusActiveBackgroundColor};
      span {
        color: ${({ isActive, theme }) => isActive ? theme.tabs.tabButton.focusSpanActiveBackgroundColor : theme.tabs.tabButton.focusSpanBackgroundColor};
        font-weight: ${({ isActive }) => isActive ? 400 : 600};
      }
    }
  }

  @media (min-width: 940px) {
    max-width: fit-content;
    padding: 24px 43px 24px;
  }

  @media (min-width: 1280px) {
    max-width: fit-content;
    padding: 24px 43px 24px;
  }

  @media (max-width: 768px) {
    span {
      font-size: 14px;
      line-height: 20px;
    }
  }
`, MiddleBorder = styled_components_esm_default.div`
  min-width: 1px;
  height: 26px;
  transition: all 0.15s ease-in;
  background-color: ${({ theme }) => theme.tabs.middleBorder.backgroundColor};
  visibility: ${({ index: index2, activeTab, tabs }) => {
  var _a, _b;
  return index2 !== tabs.length - 1 && activeTab.id !== ((_a = tabs[index2]) == null ? void 0 : _a.id) && activeTab.id !== ((_b = tabs[index2 + 1]) == null ? void 0 : _b.id) ? "visible" : "hidden";
}};
  @media (min-width: 940px) {
    height: 44px;
  }
`, TabContent = styled_components_esm_default.div`
  padding: 16px;
  border: 2px solid lightblue;
  margin-top: 16px;
`;

// app/components/lib/Search/index.tsx
init_esm2();
var import_react48 = __toESM(require_react());
init_es();

// app/components/lib/Search/styles.ts
var SearchContainer = styled_components_esm_default.div`
  width: 100%;
  background-color: ${({ theme }) => theme.search.backgroundWrapper};
  display: flex;
  flex-direction: column;
  border-radius: 0 0 8px 8px;

  @media (min-width: 940px) {
    flex-direction: row;
    border-radius: 0 0 16px 16px;
  }
`, MainInputSearch = styled_components_esm_default.input`
  background-color: ${({ theme }) => theme.search.backgroundWrapper};
  padding: 20px 26px 18px 65px;
  display: flex;
  flex-direction: row;
  width: 100%;
  font-size: ${FONT_SIZES_MOB[TextVariantEnum.textBody1]};

  &:nth-child(1) {
    border-bottom: 1px solid ${({ theme }) => theme.search.borderColor};
  }

  @media (min-width: 940px) {
    border-radius: 0 0 0 16px;
    padding: 26px 13px 24px 76px;
    min-width: 480px;
    font-size: ${FONT_SIZES_DESC[TextVariantEnum.textBody1]};
    &:nth-child(1) {
      border-bottom: none;
    }
  }
`, PlaceInputSearch = styled_components_esm_default.input`
  background-color: ${({ theme }) => theme.search.backgroundWrapper};
  padding: 18px 26px 18px 65px;
  display: flex;
  flex-direction: row;
  width: 100%;
  border-radius: 0px 0px 8px 8px;
  font-size: ${FONT_SIZES_MOB[TextVariantEnum.textBody1]};

  @media (min-width: 940px) {
    padding: 26px 14px 24px 54px;
    border-radius: 0px 0px 16px 0px;
    font-size: ${FONT_SIZES_DESC[TextVariantEnum.textBody1]};
  }
`, WrapperInput2 = styled_components_esm_default.div`
  width: 100%;
  position: relative;
  border-radius: 0px 0px 8px 8px;
`, SvgWrapper = styled_components_esm_default.div`
  display: flex;
  position: absolute;
  top: 18px;
  left: 26px;
  @media (min-width: 940px) {
    top: 24px;
    left: ${({ search }) => search ? "40px" : "14px"};
  }
`, MiddleBorder2 = styled_components_esm_default.div`
  display: none;
  min-width: 1px;
  height: 40px;
  background-color: ${({ theme }) => theme.search.middleBorderColor};
  padding: 16px 0px;
  margin-top: 16px;
  @media (min-width: 940px) {
    display: flex;
  }
`;

// app/components/lib/Search/index.tsx
var import_jsx_dev_runtime34 = __toESM(require_jsx_dev_runtime()), Search = (0, import_react48.memo)(function({
  theme
}) {
  let {
    t: t4
  } = useTranslation();
  return /* @__PURE__ */ (0, import_jsx_dev_runtime34.jsxDEV)(Form, { method: "GET", className: "search-form", style: {
    width: "100%"
  }, children: /* @__PURE__ */ (0, import_jsx_dev_runtime34.jsxDEV)(SearchContainer, { children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime34.jsxDEV)(WrapperInput2, { children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime34.jsxDEV)(MainInputSearch, { placeholder: t4("home:job_title_keywords_or_company"), type: "text" }, void 0, !1, {
        fileName: "app/components/lib/Search/index.tsx",
        lineNumber: 89,
        columnNumber: 11
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime34.jsxDEV)(SvgWrapper, { search: !0, children: /* @__PURE__ */ (0, import_jsx_dev_runtime34.jsxDEV)(Search_default, { color: theme.search.svgColor }, void 0, !1, {
        fileName: "app/components/lib/Search/index.tsx",
        lineNumber: 91,
        columnNumber: 13
      }, this) }, void 0, !1, {
        fileName: "app/components/lib/Search/index.tsx",
        lineNumber: 90,
        columnNumber: 11
      }, this)
    ] }, void 0, !0, {
      fileName: "app/components/lib/Search/index.tsx",
      lineNumber: 88,
      columnNumber: 9
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime34.jsxDEV)(MiddleBorder2, {}, void 0, !1, {
      fileName: "app/components/lib/Search/index.tsx",
      lineNumber: 94,
      columnNumber: 9
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime34.jsxDEV)(WrapperInput2, { children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime34.jsxDEV)(PlaceInputSearch, { placeholder: "place" }, void 0, !1, {
        fileName: "app/components/lib/Search/index.tsx",
        lineNumber: 97,
        columnNumber: 11
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime34.jsxDEV)(SvgWrapper, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime34.jsxDEV)(Map_default, { color: theme.search.svgColor }, void 0, !1, {
        fileName: "app/components/lib/Search/index.tsx",
        lineNumber: 99,
        columnNumber: 13
      }, this) }, void 0, !1, {
        fileName: "app/components/lib/Search/index.tsx",
        lineNumber: 98,
        columnNumber: 11
      }, this)
    ] }, void 0, !0, {
      fileName: "app/components/lib/Search/index.tsx",
      lineNumber: 96,
      columnNumber: 9
    }, this)
  ] }, void 0, !0, {
    fileName: "app/components/lib/Search/index.tsx",
    lineNumber: 87,
    columnNumber: 7
  }, this) }, void 0, !1, {
    fileName: "app/components/lib/Search/index.tsx",
    lineNumber: 84,
    columnNumber: 10
  }, this);
});

// app/components/common/Tabs/index.tsx
var import_jsx_dev_runtime35 = __toESM(require_jsx_dev_runtime()), TabSwitcher = () => {
  let {
    theme,
    t: t4
  } = useApp(), tabs = [{
    id: "1",
    label: `${t4("home:find_job")}`,
    content: `${t4("home:find_job")}`
  }, {
    id: "2",
    label: `${t4("home:find_employer")}`,
    content: `${t4("home:find_employer")}`
  }, {
    id: "3",
    label: `${t4("home:companies")}`,
    content: `${t4("home:companies")}`
  }], [activeTab, setActiveTab] = (0, import_react49.useState)(tabs[0]), handleTabClick = (tab) => {
    setActiveTab(tab);
  };
  return /* @__PURE__ */ (0, import_jsx_dev_runtime35.jsxDEV)(import_jsx_dev_runtime35.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime35.jsxDEV)(TabContainer, { children: tabs.map((tab, index2) => /* @__PURE__ */ (0, import_jsx_dev_runtime35.jsxDEV)(import_react49.default.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime35.jsxDEV)(TabButton, { isActive: activeTab.id === tab.id, onClick: () => handleTabClick(tab), children: /* @__PURE__ */ (0, import_jsx_dev_runtime35.jsxDEV)(Text, { variant: TextVariantEnum.textBody1, color: activeTab.id === tab.id ? theme.tabs.activeTabColor : theme.tabs.disabledTabColor, children: [
        tab.label,
        activeTab.id === tab.id
      ] }, void 0, !0, {
        fileName: "app/components/common/Tabs/index.tsx",
        lineNumber: 39,
        columnNumber: 15
      }, this) }, void 0, !1, {
        fileName: "app/components/common/Tabs/index.tsx",
        lineNumber: 38,
        columnNumber: 13
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime35.jsxDEV)(MiddleBorder, { index: index2, tabs, activeTab }, void 0, !1, {
        fileName: "app/components/common/Tabs/index.tsx",
        lineNumber: 44,
        columnNumber: 13
      }, this)
    ] }, tab.id, !0, {
      fileName: "app/components/common/Tabs/index.tsx",
      lineNumber: 37,
      columnNumber: 35
    }, this)) }, void 0, !1, {
      fileName: "app/components/common/Tabs/index.tsx",
      lineNumber: 36,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime35.jsxDEV)(Search, { theme }, void 0, !1, {
      fileName: "app/components/common/Tabs/index.tsx",
      lineNumber: 47,
      columnNumber: 7
    }, this)
  ] }, void 0, !0, {
    fileName: "app/components/common/Tabs/index.tsx",
    lineNumber: 35,
    columnNumber: 10
  }, this);
}, Tabs_default = TabSwitcher;

// app/routes/ui/index.tsx
var import_jsx_dev_runtime36 = __toESM(require_jsx_dev_runtime());
function Index2() {
  let {
    userContext,
    setUserContext,
    t: t4
  } = useApp(), LogoLink = styled_components_esm_default.a.withConfig({
    displayName: "ui__LogoLink",
    componentId: "sc-1ouqhn2-0"
  })(["transition:all 0.15s ease-in;cursor:pointer;svg{transition:all 0.15s ease-in;color:", ";width:92px;}&:hover{svg{color:", ";}}@media (min-width:1024px){svg{width:118px;}}"], ({
    theme
  }) => theme.ui.logoLinkColor, ({
    theme
  }) => theme.ui.logoLinkHoverColor), companies = [{
    id: "1",
    title: "Apple company-1",
    vacancies: 100,
    image: "images/homePage/apple.png"
  }, {
    id: "2",
    title: "Apple company-1",
    vacancies: 23,
    image: "images/homePage/apple.png"
  }, {
    id: "3",
    title: "Apple company-2",
    vacancies: 0,
    image: "images/homePage/apple.png"
  }, {
    id: "4",
    title: "Apple company-1",
    vacancies: 100,
    image: "images/homePage/apple.png"
  }, {
    id: "5",
    title: "Apple company-1",
    vacancies: 23,
    image: "images/homePage/apple.png"
  }, {
    id: "6",
    title: "Apple company-2",
    vacancies: 0,
    image: "images/homePage/apple.png"
  }], news = [{
    id: "1",
    title: " 1 - The first Episode of NBT \u201CMee Kam Tob\u201D Features MOL\u2019s Liveasdas",
    date: "17.02.2023",
    image: "images/homePage/new.png"
  }, {
    id: "2",
    title: "2 - The first Episode of NBT \u201CMee Kam Tob\u201D Features MOL\u2019s Liveasdas",
    date: "17.02.2023",
    image: "images/homePage/new.png"
  }, {
    id: "3",
    title: "3 - The first Episode of NBT \u201CMee Kam Tob\u201D Features MOL\u2019s Liveasdas",
    date: "17.02.2023",
    image: "images/homePage/new.png"
  }, {
    id: "4",
    title: "4 - The first Episode of NBT \u201CMee Kam Tob\u201D Features MOL\u2019s Liveasdas",
    date: "17.02.2023",
    image: "images/homePage/new.png"
  }, {
    id: "5",
    title: "5 - The first Episode of NBT \u201CMee Kam Tob\u201D Features MOL\u2019s Liveasdas",
    date: "17.02.2023",
    image: "images/homePage/new.png"
  }, {
    id: "6",
    title: "6 - Apple company-2",
    vacancies: 0,
    image: "images/homePage/new.png"
  }], WrapperCardsCompanies = styled_components_esm_default.div.withConfig({
    displayName: "ui__WrapperCardsCompanies",
    componentId: "sc-1ouqhn2-1"
  })(["align-items:'stretch';display:grid;grid-template-columns:repeat(3,1fr);column-gap:10px;row-gap:16px;@media (min-width:768px){display:flex;position:relative;flex-flow:row;flex-direction:row;gap:14px;overflow:auto;overflow-y:hidden;}"]), WrapperCardsNews = styled_components_esm_default.div.withConfig({
    displayName: "ui__WrapperCardsNews",
    componentId: "sc-1ouqhn2-2"
  })(["display:flex;position:relative;flex-flow:row;flex-direction:row;gap:14px;overflow:auto;overflow-y:hidden;@media (min-width:768px){gap:24px;}@media (min-width:1024px){gap:40px;}"]);
  function setTheme(event2) {
    switch (event2.target.value) {
      case ThemeEnum.Light:
        setUserContext((prevContext) => ({
          ...prevContext,
          theme: ThemeEnum.Light
        }));
        break;
      case ThemeEnum.Dark:
        setUserContext((prevContext) => ({
          ...prevContext,
          theme: ThemeEnum.Dark
        }));
        break;
      case ThemeEnum.Dora:
        setUserContext((prevContext) => ({
          ...prevContext,
          theme: ThemeEnum.Dora
        }));
        break;
    }
  }
  function setLang(language) {
    setUserContext((prevContext) => ({
      ...prevContext,
      language
    }));
  }
  let changeLanguage2 = () => {
    (userContext == null ? void 0 : userContext.language) === LanguageEnum.TH ? setUserContext((prevContext) => ({
      ...prevContext,
      language: LanguageEnum.EN
    })) : setUserContext((prevContext) => ({
      ...prevContext,
      language: LanguageEnum.TH
    }));
  };
  function themeIsCheckedRadiobutton(value2) {
    switch (value2) {
      case ThemeEnum.Light:
        return (userContext == null ? void 0 : userContext.theme) === ThemeEnum.Light;
      case ThemeEnum.Dark:
        return (userContext == null ? void 0 : userContext.theme) === ThemeEnum.Dark;
      case ThemeEnum.Dora:
        return (userContext == null ? void 0 : userContext.theme) === ThemeEnum.Dora;
    }
  }
  return /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(CommonLayout, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(Box, { flexDirection: "column", padding: "16px", gap: "20px", children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(Box, { flexDirection: "row", gap: "10px", children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(Box, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(Box, { flexDirection: "column", onChange: setTheme, border: "1px solid", borderRadius: "5px", gap: "10px", className: "p-5", children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(Text, { children: "Theme test" }, void 0, !1, {
          fileName: "app/routes/ui/index.tsx",
          lineNumber: 151,
          columnNumber: 15
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(Box, { children: [
          /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)("input", { type: "radio", value: "light", id: "light", name: "theme", checked: themeIsCheckedRadiobutton("light") }, void 0, !1, {
            fileName: "app/routes/ui/index.tsx",
            lineNumber: 153,
            columnNumber: 17
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)("label", { htmlFor: "light", className: "pl-1", children: "Light" }, void 0, !1, {
            fileName: "app/routes/ui/index.tsx",
            lineNumber: 154,
            columnNumber: 17
          }, this)
        ] }, void 0, !0, {
          fileName: "app/routes/ui/index.tsx",
          lineNumber: 152,
          columnNumber: 15
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(Box, { children: [
          /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)("input", { type: "radio", value: "dark", id: "dark", name: "theme", checked: themeIsCheckedRadiobutton("dark") }, void 0, !1, {
            fileName: "app/routes/ui/index.tsx",
            lineNumber: 159,
            columnNumber: 17
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)("label", { htmlFor: "dark", className: "pl-1", children: "Dark" }, void 0, !1, {
            fileName: "app/routes/ui/index.tsx",
            lineNumber: 160,
            columnNumber: 17
          }, this)
        ] }, void 0, !0, {
          fileName: "app/routes/ui/index.tsx",
          lineNumber: 158,
          columnNumber: 15
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(Box, { children: [
          /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)("input", { type: "radio", value: "dora", id: "dora", name: "theme", checked: themeIsCheckedRadiobutton("dora") }, void 0, !1, {
            fileName: "app/routes/ui/index.tsx",
            lineNumber: 165,
            columnNumber: 17
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)("label", { htmlFor: "dora", className: "pl-1", children: "Dora" }, void 0, !1, {
            fileName: "app/routes/ui/index.tsx",
            lineNumber: 166,
            columnNumber: 17
          }, this)
        ] }, void 0, !0, {
          fileName: "app/routes/ui/index.tsx",
          lineNumber: 164,
          columnNumber: 15
        }, this)
      ] }, void 0, !0, {
        fileName: "app/routes/ui/index.tsx",
        lineNumber: 150,
        columnNumber: 13
      }, this) }, void 0, !1, {
        fileName: "app/routes/ui/index.tsx",
        lineNumber: 149,
        columnNumber: 11
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(Box, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(Box, { flexDirection: "column", border: "1px solid", borderRadius: "5px", gap: "10px", className: "p-5", children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(Text, { children: [
          "Language test: ",
          t4("language")
        ] }, void 0, !0, {
          fileName: "app/routes/ui/index.tsx",
          lineNumber: 175,
          columnNumber: 15
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(TranslateBox, { children: [
          /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(BoxText, { style: {
            cursor: "pointer"
          }, lang: LanguageEnum.TH, selectedLang: (userContext == null ? void 0 : userContext.language) ?? "", onClick: () => setLang(LanguageEnum.TH), children: /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(Text, { children: "\u0E20\u0E32\u0E29\u0E32\u0E44\u0E17\u0E22" }, void 0, !1, {
            fileName: "app/routes/ui/index.tsx",
            lineNumber: 180,
            columnNumber: 19
          }, this) }, void 0, !1, {
            fileName: "app/routes/ui/index.tsx",
            lineNumber: 177,
            columnNumber: 17
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(Switcher, { onChange: changeLanguage2, checked: (userContext == null ? void 0 : userContext.language) === LanguageEnum.EN, htmlLabel: "lang" }, void 0, !1, {
            fileName: "app/routes/ui/index.tsx",
            lineNumber: 182,
            columnNumber: 17
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(BoxText, { style: {
            cursor: "pointer"
          }, lang: LanguageEnum.EN, selectedLang: (userContext == null ? void 0 : userContext.language) ?? "", onClick: () => setLang(LanguageEnum.EN), children: /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(Text, { children: "English" }, void 0, !1, {
            fileName: "app/routes/ui/index.tsx",
            lineNumber: 186,
            columnNumber: 19
          }, this) }, void 0, !1, {
            fileName: "app/routes/ui/index.tsx",
            lineNumber: 183,
            columnNumber: 17
          }, this)
        ] }, void 0, !0, {
          fileName: "app/routes/ui/index.tsx",
          lineNumber: 176,
          columnNumber: 15
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)("p", { children: [
          "Greeting from Common: ",
          t4("greeting")
        ] }, void 0, !0, {
          fileName: "app/routes/ui/index.tsx",
          lineNumber: 189,
          columnNumber: 15
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)("p", { children: [
          "Title from Home: ",
          t4("home:title")
        ] }, void 0, !0, {
          fileName: "app/routes/ui/index.tsx",
          lineNumber: 190,
          columnNumber: 15
        }, this)
      ] }, void 0, !0, {
        fileName: "app/routes/ui/index.tsx",
        lineNumber: 174,
        columnNumber: 13
      }, this) }, void 0, !1, {
        fileName: "app/routes/ui/index.tsx",
        lineNumber: 173,
        columnNumber: 11
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(Box, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(Box, { flexDirection: "column", border: "1px solid", borderRadius: "5px", gap: "10px", className: "p-5", children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(Text, { children: "User context test" }, void 0, !1, {
          fileName: "app/routes/ui/index.tsx",
          lineNumber: 196,
          columnNumber: 15
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(Text, { children: JSON.stringify(userContext) }, void 0, !1, {
          fileName: "app/routes/ui/index.tsx",
          lineNumber: 197,
          columnNumber: 15
        }, this)
      ] }, void 0, !0, {
        fileName: "app/routes/ui/index.tsx",
        lineNumber: 195,
        columnNumber: 13
      }, this) }, void 0, !1, {
        fileName: "app/routes/ui/index.tsx",
        lineNumber: 194,
        columnNumber: 11
      }, this)
    ] }, void 0, !0, {
      fileName: "app/routes/ui/index.tsx",
      lineNumber: 148,
      columnNumber: 9
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(Box, { flexDirection: "column", gap: "10px", children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(Input, { background: "#D9DBDE", placeholder: "Cammmon", id: "i_firstname" }, void 0, !1, {
        fileName: "app/routes/ui/index.tsx",
        lineNumber: 203,
        columnNumber: 11
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(Button_default, { priority: "primary", children: /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(Text, { children: "Primary S" }, void 0, !1, {
        fileName: "app/routes/ui/index.tsx",
        lineNumber: 206,
        columnNumber: 13
      }, this) }, void 0, !1, {
        fileName: "app/routes/ui/index.tsx",
        lineNumber: 205,
        columnNumber: 11
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(Button_default, { priority: "secondary", children: /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(Text, { children: "Secondary S" }, void 0, !1, {
        fileName: "app/routes/ui/index.tsx",
        lineNumber: 210,
        columnNumber: 13
      }, this) }, void 0, !1, {
        fileName: "app/routes/ui/index.tsx",
        lineNumber: 209,
        columnNumber: 11
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(Button_default, { priority: "small", children: /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(Text, { children: "Small S" }, void 0, !1, {
        fileName: "app/routes/ui/index.tsx",
        lineNumber: 214,
        columnNumber: 13
      }, this) }, void 0, !1, {
        fileName: "app/routes/ui/index.tsx",
        lineNumber: 213,
        columnNumber: 11
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(Button_default, { priority: "primary", size: "M", children: /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(Text, { children: "Primary M" }, void 0, !1, {
        fileName: "app/routes/ui/index.tsx",
        lineNumber: 218,
        columnNumber: 13
      }, this) }, void 0, !1, {
        fileName: "app/routes/ui/index.tsx",
        lineNumber: 217,
        columnNumber: 11
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(Button_default, { priority: "secondary", size: "M", children: /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(Text, { children: "Secondary M" }, void 0, !1, {
        fileName: "app/routes/ui/index.tsx",
        lineNumber: 222,
        columnNumber: 13
      }, this) }, void 0, !1, {
        fileName: "app/routes/ui/index.tsx",
        lineNumber: 221,
        columnNumber: 11
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(Button_default, { priority: "chips", size: "M", children: /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(Text, { children: "Chips M" }, void 0, !1, {
        fileName: "app/routes/ui/index.tsx",
        lineNumber: 226,
        columnNumber: 13
      }, this) }, void 0, !1, {
        fileName: "app/routes/ui/index.tsx",
        lineNumber: 225,
        columnNumber: 11
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(Button_default, { priority: "chips", children: /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(Text, { children: "Chips S" }, void 0, !1, {
        fileName: "app/routes/ui/index.tsx",
        lineNumber: 230,
        columnNumber: 13
      }, this) }, void 0, !1, {
        fileName: "app/routes/ui/index.tsx",
        lineNumber: 229,
        columnNumber: 11
      }, this)
    ] }, void 0, !0, {
      fileName: "app/routes/ui/index.tsx",
      lineNumber: 202,
      columnNumber: 9
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(LogoLink, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(Logo_default, {}, void 0, !1, {
      fileName: "app/routes/ui/index.tsx",
      lineNumber: 234,
      columnNumber: 11
    }, this) }, void 0, !1, {
      fileName: "app/routes/ui/index.tsx",
      lineNumber: 233,
      columnNumber: 9
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(Tabs_default, {}, void 0, !1, {
      fileName: "app/routes/ui/index.tsx",
      lineNumber: 237,
      columnNumber: 9
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(WrapperCardsCompanies, { children: companies.map((item) => /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(Card_default, { image: item.image, title: item.title, vacancies: item.vacancies, variant: "companies" }, item.id, !1, {
      fileName: "app/routes/ui/index.tsx",
      lineNumber: 240,
      columnNumber: 34
    }, this)) }, void 0, !1, {
      fileName: "app/routes/ui/index.tsx",
      lineNumber: 239,
      columnNumber: 9
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(Box, { margin: "40px 0", children: /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(WrapperCardsNews, { children: news.map((item) => /* @__PURE__ */ (0, import_jsx_dev_runtime36.jsxDEV)(Card_default, { image: item.image, title: item.title, date: item.date, variant: "articles" }, item.id, !1, {
      fileName: "app/routes/ui/index.tsx",
      lineNumber: 245,
      columnNumber: 31
    }, this)) }, void 0, !1, {
      fileName: "app/routes/ui/index.tsx",
      lineNumber: 244,
      columnNumber: 11
    }, this) }, void 0, !1, {
      fileName: "app/routes/ui/index.tsx",
      lineNumber: 243,
      columnNumber: 9
    }, this)
  ] }, void 0, !0, {
    fileName: "app/routes/ui/index.tsx",
    lineNumber: 147,
    columnNumber: 7
  }, this) }, void 0, !1, {
    fileName: "app/routes/ui/index.tsx",
    lineNumber: 146,
    columnNumber: 10
  }, this);
}

// app/routes/index.tsx
var routes_exports = {};
__export(routes_exports, {
  default: () => Index3,
  loader: () => loader4
});
var import_cloudflare7 = __toESM(require_dist()), import_components6 = __toESM(require_components());

// shared/client.ts
var HttpClient = class {
  constructor(apiConfig = {}) {
    this.baseUrl = "http://upjob.com/api/v1";
    this.securityData = null;
    this.abortControllers = /* @__PURE__ */ new Map();
    this.customFetch = (...fetchParams) => fetch(...fetchParams);
    this.baseApiParams = {
      credentials: "same-origin",
      headers: {},
      redirect: "follow",
      referrerPolicy: "no-referrer"
    };
    this.setSecurityData = (data2) => {
      this.securityData = data2;
    };
    this.contentFormatters = {
      ["application/json" /* Json */]: (input) => input !== null && (typeof input == "object" || typeof input == "string") ? JSON.stringify(input) : input,
      ["text/plain" /* Text */]: (input) => input !== null && typeof input != "string" ? JSON.stringify(input) : input,
      ["multipart/form-data" /* FormData */]: (input) => Object.keys(input || {}).reduce((formData, key2) => {
        let property = input[key2];
        return formData.append(
          key2,
          property instanceof Blob ? property : typeof property == "object" && property !== null ? JSON.stringify(property) : `${property}`
        ), formData;
      }, new FormData()),
      ["application/x-www-form-urlencoded" /* UrlEncoded */]: (input) => this.toQueryString(input)
    };
    this.createAbortSignal = (cancelToken) => {
      if (this.abortControllers.has(cancelToken)) {
        let abortController2 = this.abortControllers.get(cancelToken);
        return abortController2 ? abortController2.signal : void 0;
      }
      let abortController = new AbortController();
      return this.abortControllers.set(cancelToken, abortController), abortController.signal;
    };
    this.abortRequest = (cancelToken) => {
      let abortController = this.abortControllers.get(cancelToken);
      abortController && (abortController.abort(), this.abortControllers.delete(cancelToken));
    };
    this.request = async ({
      body,
      secure,
      path: path2,
      type: type2,
      query,
      format: format2,
      baseUrl,
      cancelToken,
      ...params
    }) => {
      let secureParams = (typeof secure == "boolean" ? secure : this.baseApiParams.secure) && this.securityWorker && await this.securityWorker(this.securityData) || {}, requestParams = this.mergeRequestParams(params, secureParams), queryString = query && this.toQueryString(query), payloadFormatter = this.contentFormatters[type2 || "application/json" /* Json */], responseFormat = format2 || requestParams.format;
      return this.customFetch(
        `${baseUrl || this.baseUrl || ""}${path2}${queryString ? `?${queryString}` : ""}`,
        {
          ...requestParams,
          headers: {
            ...requestParams.headers || {},
            ...type2 && type2 !== "multipart/form-data" /* FormData */ ? { "Content-Type": type2 } : {}
          },
          signal: cancelToken ? this.createAbortSignal(cancelToken) : requestParams.signal,
          body: typeof body > "u" || body === null ? null : payloadFormatter(body)
        }
      ).then(async (response) => {
        let r3 = response;
        r3.data = null, r3.error = null;
        let data2 = responseFormat ? await response[responseFormat]().then((data3) => (r3.ok ? r3.data = data3 : r3.error = data3, r3)).catch((e3) => (r3.error = e3, r3)) : r3;
        if (cancelToken && this.abortControllers.delete(cancelToken), !response.ok)
          throw data2;
        return data2;
      });
    };
    Object.assign(this, apiConfig);
  }
  encodeQueryParam(key2, value2) {
    return `${encodeURIComponent(key2)}=${encodeURIComponent(typeof value2 == "number" ? value2 : `${value2}`)}`;
  }
  addQueryParam(query, key2) {
    return this.encodeQueryParam(key2, query[key2]);
  }
  addArrayQueryParam(query, key2) {
    return query[key2].map((v2) => this.encodeQueryParam(key2, v2)).join("&");
  }
  toQueryString(rawQuery) {
    let query = rawQuery || {};
    return Object.keys(query).filter((key2) => typeof query[key2] < "u").map(
      (key2) => Array.isArray(query[key2]) ? this.addArrayQueryParam(query, key2) : this.addQueryParam(query, key2)
    ).join("&");
  }
  addQueryParams(rawQuery) {
    let queryString = this.toQueryString(rawQuery);
    return queryString ? `?${queryString}` : "";
  }
  mergeRequestParams(params1, params2) {
    return {
      ...this.baseApiParams,
      ...params1,
      ...params2 || {},
      headers: {
        ...this.baseApiParams.headers || {},
        ...params1.headers || {},
        ...params2 && params2.headers || {}
      }
    };
  }
}, Api = class extends HttpClient {
  constructor() {
    super(...arguments);
    this.citizenship = {
      citizenshipList: (query, params = {}) => this.request({
        path: "/citizenship",
        method: "GET",
        query,
        format: "json",
        ...params
      })
    };
    this.companies = {
      companiesList: (query, params = {}) => this.request({
        path: "/companies",
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      companiesCreate: (request, params = {}) => this.request({
        path: "/companies",
        method: "POST",
        body: request,
        type: "application/json" /* Json */,
        format: "json",
        ...params
      }),
      companiesDetail: (id4, params = {}) => this.request({
        path: `/companies/${id4}`,
        method: "GET",
        format: "json",
        ...params
      }),
      companiesDelete: (id4, params = {}) => this.request({
        path: `/companies/${id4}`,
        method: "DELETE",
        format: "json",
        ...params
      })
    };
    this.complianceOfRequirements = {
      complianceOfRequirementsList: (params = {}) => this.request({
        path: "/compliance-of-requirements",
        method: "GET",
        format: "json",
        ...params
      })
    };
    this.countries = {
      countriesList: (params = {}) => this.request({
        path: "/countries",
        method: "GET",
        format: "json",
        ...params
      }),
      regionsDetail: (countryId, params = {}) => this.request({
        path: `/countries/${countryId}/regions`,
        method: "GET",
        format: "json",
        ...params
      }),
      regionsLocationDetail: (countryId, regionId, params = {}) => this.request({
        path: `/countries/${countryId}/regions/${regionId}/location`,
        method: "GET",
        format: "json",
        ...params
      })
    };
    this.currency = {
      currencyList: (params = {}) => this.request({
        path: "/currency",
        method: "GET",
        format: "json",
        ...params
      })
    };
    this.drivingLicenses = {
      drivingLicensesList: (params = {}) => this.request({
        path: "/driving-licenses",
        method: "GET",
        format: "json",
        ...params
      })
    };
    this.educationLevel = {
      educationLevelList: (params = {}) => this.request({
        path: "/education-level",
        method: "GET",
        format: "json",
        ...params
      })
    };
    this.emailNotificationsSettings = {
      emailNotificationsSettingsList: (params = {}) => this.request({
        path: "/email-notifications-settings",
        method: "GET",
        format: "json",
        ...params
      })
    };
    this.employee = {
      numbersList: (params = {}) => this.request({
        path: "/employee/numbers",
        method: "GET",
        format: "json",
        ...params
      })
    };
    this.employments = {
      employmentsList: (params = {}) => this.request({
        path: "/employments",
        method: "GET",
        format: "json",
        ...params
      })
    };
    this.faq = {
      getFaq: (query, params = {}) => this.request({
        path: "/faq",
        method: "GET",
        query,
        format: "json",
        ...params
      })
    };
    this.feedback = {
      feedbackCreate: (request, params = {}) => this.request({
        path: "/feedback",
        method: "POST",
        body: request,
        type: "application/json" /* Json */,
        format: "json",
        ...params
      })
    };
    this.file = {
      uploadCreate: (data2, params = {}) => this.request({
        path: "/file/upload",
        method: "POST",
        body: data2,
        type: "multipart/form-data" /* FormData */,
        format: "json",
        ...params
      })
    };
    this.genders = {
      gendersList: (params = {}) => this.request({
        path: "/genders",
        method: "GET",
        format: "json",
        ...params
      })
    };
    this.init = {
      indexList: (params = {}) => this.request({
        path: "/init/index",
        method: "GET",
        format: "json",
        ...params
      })
    };
    this.jobTypes = {
      jobTypesList: (params = {}) => this.request({
        path: "/job-types",
        method: "GET",
        format: "json",
        ...params
      })
    };
    this.languageLevel = {
      languageLevelList: (params = {}) => this.request({
        path: "/language-level",
        method: "GET",
        format: "json",
        ...params
      })
    };
    this.languages = {
      languagesList: (params = {}) => this.request({
        path: "/languages",
        method: "GET",
        format: "json",
        ...params
      })
    };
    this.location = {
      locationList: (query, params = {}) => this.request({
        path: "/location",
        method: "GET",
        query,
        format: "json",
        ...params
      })
    };
    this.maritalStatuses = {
      maritalStatusesList: (params = {}) => this.request({
        path: "/marital-statuses",
        method: "GET",
        format: "json",
        ...params
      })
    };
    this.materials = {
      articlesList: (query, params = {}) => this.request({
        path: "/materials/articles",
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      articlesDetail: (id4, params = {}) => this.request({
        path: `/materials/articles/${id4}`,
        method: "GET",
        format: "json",
        ...params
      }),
      newsList: (query, params = {}) => this.request({
        path: "/materials/news",
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      newsDetail: (id4, params = {}) => this.request({
        path: `/materials/news/${id4}`,
        method: "GET",
        format: "json",
        ...params
      })
    };
    this.payoutPeriods = {
      payoutPeriodsList: (params = {}) => this.request({
        path: "/payout-periods",
        method: "GET",
        format: "json",
        ...params
      })
    };
    this.religions = {
      religionsList: (params = {}) => this.request({
        path: "/religions",
        method: "GET",
        format: "json",
        ...params
      })
    };
    this.relocations = {
      relocationsList: (params = {}) => this.request({
        path: "/relocations",
        method: "GET",
        format: "json",
        ...params
      })
    };
    this.requirementsLevel = {
      requirementsLevelList: (params = {}) => this.request({
        path: "/requirements-level",
        method: "GET",
        format: "json",
        ...params
      })
    };
    this.responseCanBeDoneBy = {
      responseCanBeDoneByList: (params = {}) => this.request({
        path: "/response-can-be-done-by",
        method: "GET",
        format: "json",
        ...params
      })
    };
    this.resume = {
      resumeCreate: (request, params = {}) => this.request({
        path: "/resume",
        method: "POST",
        body: request,
        type: "application/json" /* Json */,
        format: "json",
        ...params
      })
    };
    this.resumes = {
      resumesList: (query, params = {}) => this.request({
        path: "/resumes",
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      requestPersonalDataDetail: (id4, query, params = {}) => this.request({
        path: `/resumes/request-personal-data/${id4}`,
        method: "GET",
        query,
        type: "application/json" /* Json */,
        format: "json",
        ...params
      }),
      resumesDetail: (id4, params = {}) => this.request({
        path: `/resumes/${id4}`,
        method: "GET",
        format: "json",
        ...params
      }),
      resumesDelete: (id4, params = {}) => this.request({
        path: `/resumes/${id4}`,
        method: "DELETE",
        format: "json",
        ...params
      }),
      copyCreate: (id4, params = {}) => this.request({
        path: `/resumes/${id4}/copy`,
        method: "POST",
        type: "application/json" /* Json */,
        format: "json",
        ...params
      }),
      provideDetail: (id4, query, params = {}) => this.request({
        path: `/resumes/${id4}/provide`,
        method: "GET",
        query,
        type: "application/json" /* Json */,
        format: "json",
        ...params
      }),
      publishCreate: (id4, params = {}) => this.request({
        path: `/resumes/${id4}/publish`,
        method: "POST",
        format: "json",
        ...params
      }),
      unpublishCreate: (id4, params = {}) => this.request({
        path: `/resumes/${id4}/unpublish`,
        method: "POST",
        format: "json",
        ...params
      })
    };
    this.showEmail = {
      showEmailList: (params = {}) => this.request({
        path: "/show-email",
        method: "GET",
        format: "json",
        ...params
      })
    };
    this.showPhoneNumber = {
      showPhoneNumberList: (params = {}) => this.request({
        path: "/show-phone-number",
        method: "GET",
        format: "json",
        ...params
      })
    };
    this.skills = {
      skillsList: (query, params = {}) => this.request({
        path: "/skills",
        method: "GET",
        query,
        format: "json",
        ...params
      })
    };
    this.sourceOfInformation = {
      sourceOfInformationList: (params = {}) => this.request({
        path: "/source_of_information",
        method: "GET",
        format: "json",
        ...params
      })
    };
    this.specializations = {
      specializationsList: (query, params = {}) => this.request({
        path: "/specializations",
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      jobPositionsDetail: (specializationId, query, params = {}) => this.request({
        path: `/specializations/${specializationId}/job-positions`,
        method: "GET",
        query,
        format: "json",
        ...params
      })
    };
    this.staticPages = {
      staticPagesDetail: (urn, params = {}) => this.request({
        path: `/static-pages/${urn}`,
        method: "GET",
        format: "json",
        ...params
      })
    };
    this.userService = {
      forgotPasswordCreate: (request, params = {}) => this.request({
        path: "/user-service/forgot-password",
        method: "POST",
        body: request,
        type: "application/json" /* Json */,
        ...params
      }),
      forgotPasswordVerifyDetail: (secret, params = {}) => this.request({
        path: `/user-service/forgot-password-verify/${secret}`,
        method: "GET",
        ...params
      }),
      infoList: (params = {}) => this.request({
        path: "/user-service/info",
        method: "GET",
        format: "json",
        ...params
      }),
      infoUpdate: (request, params = {}) => this.request({
        path: "/user-service/info",
        method: "PUT",
        body: request,
        type: "application/json" /* Json */,
        format: "json",
        ...params
      }),
      infoDetail: (id4, params = {}) => this.request({
        path: `/user-service/info/${id4}`,
        method: "GET",
        format: "json",
        ...params
      }),
      loginCreate: (request, params = {}) => this.request({
        path: "/user-service/login",
        method: "POST",
        body: request,
        type: "application/json" /* Json */,
        format: "json",
        ...params
      }),
      loginFacebookList: (params = {}) => this.request({
        path: "/user-service/login/facebook",
        method: "GET",
        ...params
      }),
      loginGoogleList: (params = {}) => this.request({
        path: "/user-service/login/google",
        method: "GET",
        ...params
      }),
      logoutCreate: (params = {}) => this.request({
        path: "/user-service/logout",
        method: "POST",
        ...params
      }),
      getUserService: (params = {}) => this.request({
        path: "/user-service/me",
        method: "GET",
        format: "json",
        ...params
      }),
      registrationCreate: (request, params = {}) => this.request({
        path: "/user-service/registration",
        method: "POST",
        body: request,
        type: "application/json" /* Json */,
        format: "json",
        ...params
      }),
      registrationConfirmDetail: (hash, params = {}) => this.request({
        path: `/user-service/registration/confirm/${hash}`,
        method: "GET",
        ...params
      }),
      registrationFacebookCallbackList: (query, params = {}) => this.request({
        path: "/user-service/registration/facebook/callback",
        method: "GET",
        query,
        ...params
      }),
      registrationGoogleCallbackList: (query, params = {}) => this.request({
        path: "/user-service/registration/google/callback",
        method: "GET",
        query,
        ...params
      }),
      resetPasswordCreate: (request, params = {}) => this.request({
        path: "/user-service/reset-password",
        method: "POST",
        body: request,
        type: "application/json" /* Json */,
        ...params
      })
    };
    this.vacancies = {
      vacanciesList: (query, params = {}) => this.request({
        path: "/vacancies",
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      requestPersonalDataDetail: (id4, query, params = {}) => this.request({
        path: `/vacancies/request-personal-data/${id4}`,
        method: "GET",
        query,
        type: "application/json" /* Json */,
        format: "json",
        ...params
      }),
      vacanciesDetail: (id4, params = {}) => this.request({
        path: `/vacancies/${id4}`,
        method: "GET",
        format: "json",
        ...params
      }),
      vacanciesDelete: (id4, params = {}) => this.request({
        path: `/vacancies/${id4}`,
        method: "DELETE",
        format: "json",
        ...params
      }),
      archiveCreate: (id4, params = {}) => this.request({
        path: `/vacancies/${id4}/archive`,
        method: "POST",
        format: "json",
        ...params
      }),
      provideDetail: (id4, query, params = {}) => this.request({
        path: `/vacancies/${id4}/provide`,
        method: "GET",
        query,
        type: "application/json" /* Json */,
        format: "json",
        ...params
      }),
      publishCreate: (id4, params = {}) => this.request({
        path: `/vacancies/${id4}/publish`,
        method: "POST",
        format: "json",
        ...params
      }),
      unarchiveCreate: (id4, params = {}) => this.request({
        path: `/vacancies/${id4}/unarchive`,
        method: "POST",
        format: "json",
        ...params
      }),
      unpublishCreate: (id4, params = {}) => this.request({
        path: `/vacancies/${id4}/unpublish`,
        method: "POST",
        format: "json",
        ...params
      })
    };
    this.vacancy = {
      vacancyCreate: (request, params = {}) => this.request({
        path: "/vacancy",
        method: "POST",
        body: request,
        type: "application/json" /* Json */,
        format: "json",
        ...params
      })
    };
    this.workFeatures = {
      workFeaturesList: (params = {}) => this.request({
        path: "/work-features",
        method: "GET",
        format: "json",
        ...params
      })
    };
    this.yearsOfExperience = {
      yearsOfExperienceList: (params = {}) => this.request({
        path: "/years-of-experience",
        method: "GET",
        format: "json",
        ...params
      })
    };
  }
};

// app/components/pages/HomePage/index.tsx
var import_react64 = __toESM(require_react());

// app/components/pages/HomePage/SectionTop/index.tsx
var import_react50 = __toESM(require_react());

// app/components/pages/HomePage/SectionTop/styles.ts
var WrapperSection = styled_components_esm_default.div`
  display: flex;
  width: 100%;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  background: url('images/homePage/backgroundSectionTop.jpg') no-repeat;
  background-size: cover;
  background-repeat: round;
  padding: 32px 16px 40px 16px;
  gap: 16px;
  @media (min-width: 768px) {
    background: url('images/homePage/backgroundSectionTopTablet.jpg');
    background-size: cover;
    background-repeat: round;
    padding: 94px 44px 130px;
    gap: 32px;
  }

  @media (min-width: 940px) {
    padding: 120px 62px 130px;
  }

  @media (min-width: 1280px) {
    background: url('images/homePage/backgroundSectionTopDestop.jpg');
    background-size: cover;
    background-repeat: round;
  }
`, ButtonContainer = styled_components_esm_default.div`
  max-width: 816px;
  display: flex;
  width: 100%;
  flex-direction: row;
  gap: 18px;
  button {
    width: 100%;
  }
  @media (min-width: 768px) {
    justify-content: space-between;
    button {
      width: auto;
    }
  }
`;

// app/components/pages/HomePage/SectionTop/index.tsx
var import_jsx_dev_runtime37 = __toESM(require_jsx_dev_runtime()), SectionTop = (0, import_react50.memo)(function() {
  let {
    theme,
    t: t4
  } = useApp();
  return /* @__PURE__ */ (0, import_jsx_dev_runtime37.jsxDEV)(WrapperSection, { children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime37.jsxDEV)(Text, { variant: TextVariantEnum.textHeading1, color: theme.mainPage.headingColor, children: t4("home:title") }, void 0, !1, {
      fileName: "app/components/pages/HomePage/SectionTop/index.tsx",
      lineNumber: 15,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime37.jsxDEV)(Box, { width: "100%", maxWidth: "816px", flexDirection: "column", children: /* @__PURE__ */ (0, import_jsx_dev_runtime37.jsxDEV)(Tabs_default, {}, void 0, !1, {
      fileName: "app/components/pages/HomePage/SectionTop/index.tsx",
      lineNumber: 19,
      columnNumber: 9
    }, this) }, void 0, !1, {
      fileName: "app/components/pages/HomePage/SectionTop/index.tsx",
      lineNumber: 18,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime37.jsxDEV)(ButtonContainer, { children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime37.jsxDEV)(Button_default, { priority: "secondary", size: "S", children: /* @__PURE__ */ (0, import_jsx_dev_runtime37.jsxDEV)(Text, { children: [
        " ",
        t4("home:create_resume")
      ] }, void 0, !0, {
        fileName: "app/components/pages/HomePage/SectionTop/index.tsx",
        lineNumber: 23,
        columnNumber: 11
      }, this) }, void 0, !1, {
        fileName: "app/components/pages/HomePage/SectionTop/index.tsx",
        lineNumber: 22,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime37.jsxDEV)(Button_default, { priority: "primary", size: "S", children: /* @__PURE__ */ (0, import_jsx_dev_runtime37.jsxDEV)(Text, { children: [
        " ",
        t4("home:search")
      ] }, void 0, !0, {
        fileName: "app/components/pages/HomePage/SectionTop/index.tsx",
        lineNumber: 26,
        columnNumber: 11
      }, this) }, void 0, !1, {
        fileName: "app/components/pages/HomePage/SectionTop/index.tsx",
        lineNumber: 25,
        columnNumber: 9
      }, this)
    ] }, void 0, !0, {
      fileName: "app/components/pages/HomePage/SectionTop/index.tsx",
      lineNumber: 21,
      columnNumber: 7
    }, this)
  ] }, void 0, !0, {
    fileName: "app/components/pages/HomePage/SectionTop/index.tsx",
    lineNumber: 14,
    columnNumber: 10
  }, this);
});

// app/components/pages/HomePage/SectionTrending/index.tsx
var import_react59 = __toESM(require_react());

// app/components/lib/Slider/index.tsx
var import_react57 = __toESM(require_react());

// node_modules/ssr-window/ssr-window.esm.js
function isObject3(obj) {
  return obj !== null && typeof obj == "object" && "constructor" in obj && obj.constructor === Object;
}
function extend3(target = {}, src = {}) {
  Object.keys(src).forEach((key2) => {
    typeof target[key2] > "u" ? target[key2] = src[key2] : isObject3(src[key2]) && isObject3(target[key2]) && Object.keys(src[key2]).length > 0 && extend3(target[key2], src[key2]);
  });
}
var ssrDocument = {
  body: {},
  addEventListener() {
  },
  removeEventListener() {
  },
  activeElement: {
    blur() {
    },
    nodeName: ""
  },
  querySelector() {
    return null;
  },
  querySelectorAll() {
    return [];
  },
  getElementById() {
    return null;
  },
  createEvent() {
    return {
      initEvent() {
      }
    };
  },
  createElement() {
    return {
      children: [],
      childNodes: [],
      style: {},
      setAttribute() {
      },
      getElementsByTagName() {
        return [];
      }
    };
  },
  createElementNS() {
    return {};
  },
  importNode() {
    return null;
  },
  location: {
    hash: "",
    host: "",
    hostname: "",
    href: "",
    origin: "",
    pathname: "",
    protocol: "",
    search: ""
  }
};
function getDocument() {
  let doc = typeof document < "u" ? document : {};
  return extend3(doc, ssrDocument), doc;
}
var ssrWindow = {
  document: ssrDocument,
  navigator: {
    userAgent: ""
  },
  location: {
    hash: "",
    host: "",
    hostname: "",
    href: "",
    origin: "",
    pathname: "",
    protocol: "",
    search: ""
  },
  history: {
    replaceState() {
    },
    pushState() {
    },
    go() {
    },
    back() {
    }
  },
  CustomEvent: function() {
    return this;
  },
  addEventListener() {
  },
  removeEventListener() {
  },
  getComputedStyle() {
    return {
      getPropertyValue() {
        return "";
      }
    };
  },
  Image() {
  },
  Date() {
  },
  screen: {},
  setTimeout() {
  },
  clearTimeout() {
  },
  matchMedia() {
    return {};
  },
  requestAnimationFrame(callback) {
    return typeof setTimeout > "u" ? (callback(), null) : setTimeout(callback, 0);
  },
  cancelAnimationFrame(id4) {
    typeof setTimeout > "u" || clearTimeout(id4);
  }
};
function getWindow() {
  let win = typeof window < "u" ? window : {};
  return extend3(win, ssrWindow), win;
}

// node_modules/swiper/shared/utils.js
function deleteProps(obj) {
  let object = obj;
  Object.keys(object).forEach((key2) => {
    try {
      object[key2] = null;
    } catch {
    }
    try {
      delete object[key2];
    } catch {
    }
  });
}
function nextTick2(callback, delay2 = 0) {
  return setTimeout(callback, delay2);
}
function now() {
  return Date.now();
}
function getComputedStyle3(el) {
  let window2 = getWindow(), style;
  return window2.getComputedStyle && (style = window2.getComputedStyle(el, null)), !style && el.currentStyle && (style = el.currentStyle), style || (style = el.style), style;
}
function getTranslate(el, axis = "x") {
  let window2 = getWindow(), matrix, curTransform, transformMatrix, curStyle = getComputedStyle3(el, null);
  return window2.WebKitCSSMatrix ? (curTransform = curStyle.transform || curStyle.webkitTransform, curTransform.split(",").length > 6 && (curTransform = curTransform.split(", ").map((a3) => a3.replace(",", ".")).join(", ")), transformMatrix = new window2.WebKitCSSMatrix(curTransform === "none" ? "" : curTransform)) : (transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), matrix = transformMatrix.toString().split(",")), axis === "x" && (window2.WebKitCSSMatrix ? curTransform = transformMatrix.m41 : matrix.length === 16 ? curTransform = parseFloat(matrix[12]) : curTransform = parseFloat(matrix[4])), axis === "y" && (window2.WebKitCSSMatrix ? curTransform = transformMatrix.m42 : matrix.length === 16 ? curTransform = parseFloat(matrix[13]) : curTransform = parseFloat(matrix[5])), curTransform || 0;
}
function isObject4(o2) {
  return typeof o2 == "object" && o2 !== null && o2.constructor && Object.prototype.toString.call(o2).slice(8, -1) === "Object";
}
function isNode(node) {
  return typeof window < "u" && typeof window.HTMLElement < "u" ? node instanceof HTMLElement : node && (node.nodeType === 1 || node.nodeType === 11);
}
function extend4(...args) {
  let to = Object(args[0]), noExtend = ["__proto__", "constructor", "prototype"];
  for (let i3 = 1; i3 < args.length; i3 += 1) {
    let nextSource = args[i3];
    if (nextSource != null && !isNode(nextSource)) {
      let keysArray = Object.keys(Object(nextSource)).filter((key2) => noExtend.indexOf(key2) < 0);
      for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
        let nextKey = keysArray[nextIndex], desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
        desc !== void 0 && desc.enumerable && (isObject4(to[nextKey]) && isObject4(nextSource[nextKey]) ? nextSource[nextKey].__swiper__ ? to[nextKey] = nextSource[nextKey] : extend4(to[nextKey], nextSource[nextKey]) : !isObject4(to[nextKey]) && isObject4(nextSource[nextKey]) ? (to[nextKey] = {}, nextSource[nextKey].__swiper__ ? to[nextKey] = nextSource[nextKey] : extend4(to[nextKey], nextSource[nextKey])) : to[nextKey] = nextSource[nextKey]);
      }
    }
  }
  return to;
}
function setCSSProperty(el, varName, varValue) {
  el.style.setProperty(varName, varValue);
}
function animateCSSModeScroll({
  swiper,
  targetPosition,
  side
}) {
  let window2 = getWindow(), startPosition = -swiper.translate, startTime2 = null, time3, duration = swiper.params.speed;
  swiper.wrapperEl.style.scrollSnapType = "none", window2.cancelAnimationFrame(swiper.cssModeFrameID);
  let dir = targetPosition > startPosition ? "next" : "prev", isOutOfBound = (current, target) => dir === "next" && current >= target || dir === "prev" && current <= target, animate = () => {
    time3 = new Date().getTime(), startTime2 === null && (startTime2 = time3);
    let progress2 = Math.max(Math.min((time3 - startTime2) / duration, 1), 0), easeProgress = 0.5 - Math.cos(progress2 * Math.PI) / 2, currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
    if (isOutOfBound(currentPosition, targetPosition) && (currentPosition = targetPosition), swiper.wrapperEl.scrollTo({
      [side]: currentPosition
    }), isOutOfBound(currentPosition, targetPosition)) {
      swiper.wrapperEl.style.overflow = "hidden", swiper.wrapperEl.style.scrollSnapType = "", setTimeout(() => {
        swiper.wrapperEl.style.overflow = "", swiper.wrapperEl.scrollTo({
          [side]: currentPosition
        });
      }), window2.cancelAnimationFrame(swiper.cssModeFrameID);
      return;
    }
    swiper.cssModeFrameID = window2.requestAnimationFrame(animate);
  };
  animate();
}
function elementChildren(element, selector = "") {
  return [...element.children].filter((el) => el.matches(selector));
}
function createElement17(tag, classes = []) {
  let el = document.createElement(tag);
  return el.classList.add(...Array.isArray(classes) ? classes : [classes]), el;
}
function elementPrevAll(el, selector) {
  let prevEls = [];
  for (; el.previousElementSibling; ) {
    let prev = el.previousElementSibling;
    selector ? prev.matches(selector) && prevEls.push(prev) : prevEls.push(prev), el = prev;
  }
  return prevEls;
}
function elementNextAll(el, selector) {
  let nextEls = [];
  for (; el.nextElementSibling; ) {
    let next = el.nextElementSibling;
    selector ? next.matches(selector) && nextEls.push(next) : nextEls.push(next), el = next;
  }
  return nextEls;
}
function elementStyle(el, prop) {
  return getWindow().getComputedStyle(el, null).getPropertyValue(prop);
}
function elementIndex(el) {
  let child = el, i3;
  if (child) {
    for (i3 = 0; (child = child.previousSibling) !== null; )
      child.nodeType === 1 && (i3 += 1);
    return i3;
  }
}
function elementParents(el, selector) {
  let parents = [], parent = el.parentElement;
  for (; parent; )
    selector ? parent.matches(selector) && parents.push(parent) : parents.push(parent), parent = parent.parentElement;
  return parents;
}
function elementOuterSize(el, size, includeMargins) {
  let window2 = getWindow();
  return includeMargins ? el[size === "width" ? "offsetWidth" : "offsetHeight"] + parseFloat(window2.getComputedStyle(el, null).getPropertyValue(size === "width" ? "margin-right" : "margin-top")) + parseFloat(window2.getComputedStyle(el, null).getPropertyValue(size === "width" ? "margin-left" : "margin-bottom")) : el.offsetWidth;
}

// node_modules/swiper/shared/get-support.js
var support;
function calcSupport() {
  let window2 = getWindow(), document2 = getDocument();
  return {
    smoothScroll: document2.documentElement && "scrollBehavior" in document2.documentElement.style,
    touch: !!("ontouchstart" in window2 || window2.DocumentTouch && document2 instanceof window2.DocumentTouch)
  };
}
function getSupport() {
  return support || (support = calcSupport()), support;
}

// node_modules/swiper/shared/get-device.js
var deviceCached;
function calcDevice({
  userAgent
} = {}) {
  let support2 = getSupport(), window2 = getWindow(), platform2 = window2.navigator.platform, ua = userAgent || window2.navigator.userAgent, device = {
    ios: !1,
    android: !1
  }, screenWidth = window2.screen.width, screenHeight = window2.screen.height, android = ua.match(/(Android);?[\s\/]+([\d.]+)?/), ipad = ua.match(/(iPad).*OS\s([\d_]+)/), ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/), iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/), windows = platform2 === "Win32", macos = platform2 === "MacIntel", iPadScreens = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"];
  return !ipad && macos && support2.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0 && (ipad = ua.match(/(Version)\/([\d.]+)/), ipad || (ipad = [0, 1, "13_0_0"]), macos = !1), android && !windows && (device.os = "android", device.android = !0), (ipad || iphone || ipod) && (device.os = "ios", device.ios = !0), device;
}
function getDevice(overrides = {}) {
  return deviceCached || (deviceCached = calcDevice(overrides)), deviceCached;
}

// node_modules/swiper/shared/get-browser.js
var browser2;
function calcBrowser() {
  let window2 = getWindow(), needPerspectiveFix = !1;
  function isSafari() {
    let ua = window2.navigator.userAgent.toLowerCase();
    return ua.indexOf("safari") >= 0 && ua.indexOf("chrome") < 0 && ua.indexOf("android") < 0;
  }
  if (isSafari()) {
    let ua = String(window2.navigator.userAgent);
    if (ua.includes("Version/")) {
      let [major, minor] = ua.split("Version/")[1].split(" ")[0].split(".").map((num) => Number(num));
      needPerspectiveFix = major < 16 || major === 16 && minor < 2;
    }
  }
  return {
    isSafari: needPerspectiveFix || isSafari(),
    needPerspectiveFix,
    isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window2.navigator.userAgent)
  };
}
function getBrowser() {
  return browser2 || (browser2 = calcBrowser()), browser2;
}

// node_modules/swiper/core/modules/resize/resize.js
function Resize({
  swiper,
  on: on2,
  emit: emit3
}) {
  let window2 = getWindow(), observer = null, animationFrame = null, resizeHandler = () => {
    !swiper || swiper.destroyed || !swiper.initialized || (emit3("beforeResize"), emit3("resize"));
  }, createObserver = () => {
    !swiper || swiper.destroyed || !swiper.initialized || (observer = new ResizeObserver((entries) => {
      animationFrame = window2.requestAnimationFrame(() => {
        let {
          width,
          height
        } = swiper, newWidth = width, newHeight = height;
        entries.forEach(({
          contentBoxSize,
          contentRect,
          target
        }) => {
          target && target !== swiper.el || (newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize, newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize);
        }), (newWidth !== width || newHeight !== height) && resizeHandler();
      });
    }), observer.observe(swiper.el));
  }, removeObserver = () => {
    animationFrame && window2.cancelAnimationFrame(animationFrame), observer && observer.unobserve && swiper.el && (observer.unobserve(swiper.el), observer = null);
  }, orientationChangeHandler = () => {
    !swiper || swiper.destroyed || !swiper.initialized || emit3("orientationchange");
  };
  on2("init", () => {
    if (swiper.params.resizeObserver && typeof window2.ResizeObserver < "u") {
      createObserver();
      return;
    }
    window2.addEventListener("resize", resizeHandler), window2.addEventListener("orientationchange", orientationChangeHandler);
  }), on2("destroy", () => {
    removeObserver(), window2.removeEventListener("resize", resizeHandler), window2.removeEventListener("orientationchange", orientationChangeHandler);
  });
}

// node_modules/swiper/core/modules/observer/observer.js
function Observer({
  swiper,
  extendParams,
  on: on2,
  emit: emit3
}) {
  let observers2 = [], window2 = getWindow(), attach = (target, options2 = {}) => {
    let ObserverFunc = window2.MutationObserver || window2.WebkitMutationObserver, observer = new ObserverFunc((mutations) => {
      if (swiper.__preventObserver__)
        return;
      if (mutations.length === 1) {
        emit3("observerUpdate", mutations[0]);
        return;
      }
      let observerUpdate = function() {
        emit3("observerUpdate", mutations[0]);
      };
      window2.requestAnimationFrame ? window2.requestAnimationFrame(observerUpdate) : window2.setTimeout(observerUpdate, 0);
    });
    observer.observe(target, {
      attributes: typeof options2.attributes > "u" ? !0 : options2.attributes,
      childList: typeof options2.childList > "u" ? !0 : options2.childList,
      characterData: typeof options2.characterData > "u" ? !0 : options2.characterData
    }), observers2.push(observer);
  }, init4 = () => {
    if (!!swiper.params.observer) {
      if (swiper.params.observeParents) {
        let containerParents = elementParents(swiper.el);
        for (let i3 = 0; i3 < containerParents.length; i3 += 1)
          attach(containerParents[i3]);
      }
      attach(swiper.el, {
        childList: swiper.params.observeSlideChildren
      }), attach(swiper.wrapperEl, {
        attributes: !1
      });
    }
  }, destroy = () => {
    observers2.forEach((observer) => {
      observer.disconnect();
    }), observers2.splice(0, observers2.length);
  };
  extendParams({
    observer: !1,
    observeParents: !1,
    observeSlideChildren: !1
  }), on2("init", init4), on2("destroy", destroy);
}

// node_modules/swiper/core/events-emitter.js
var events_emitter_default = {
  on(events2, handler, priority) {
    let self = this;
    if (!self.eventsListeners || self.destroyed || typeof handler != "function")
      return self;
    let method = priority ? "unshift" : "push";
    return events2.split(" ").forEach((event2) => {
      self.eventsListeners[event2] || (self.eventsListeners[event2] = []), self.eventsListeners[event2][method](handler);
    }), self;
  },
  once(events2, handler, priority) {
    let self = this;
    if (!self.eventsListeners || self.destroyed || typeof handler != "function")
      return self;
    function onceHandler(...args) {
      self.off(events2, onceHandler), onceHandler.__emitterProxy && delete onceHandler.__emitterProxy, handler.apply(self, args);
    }
    return onceHandler.__emitterProxy = handler, self.on(events2, onceHandler, priority);
  },
  onAny(handler, priority) {
    let self = this;
    if (!self.eventsListeners || self.destroyed || typeof handler != "function")
      return self;
    let method = priority ? "unshift" : "push";
    return self.eventsAnyListeners.indexOf(handler) < 0 && self.eventsAnyListeners[method](handler), self;
  },
  offAny(handler) {
    let self = this;
    if (!self.eventsListeners || self.destroyed || !self.eventsAnyListeners)
      return self;
    let index2 = self.eventsAnyListeners.indexOf(handler);
    return index2 >= 0 && self.eventsAnyListeners.splice(index2, 1), self;
  },
  off(events2, handler) {
    let self = this;
    return !self.eventsListeners || self.destroyed || !self.eventsListeners || events2.split(" ").forEach((event2) => {
      typeof handler > "u" ? self.eventsListeners[event2] = [] : self.eventsListeners[event2] && self.eventsListeners[event2].forEach((eventHandler, index2) => {
        (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) && self.eventsListeners[event2].splice(index2, 1);
      });
    }), self;
  },
  emit(...args) {
    let self = this;
    if (!self.eventsListeners || self.destroyed || !self.eventsListeners)
      return self;
    let events2, data2, context;
    return typeof args[0] == "string" || Array.isArray(args[0]) ? (events2 = args[0], data2 = args.slice(1, args.length), context = self) : (events2 = args[0].events, data2 = args[0].data, context = args[0].context || self), data2.unshift(context), (Array.isArray(events2) ? events2 : events2.split(" ")).forEach((event2) => {
      self.eventsAnyListeners && self.eventsAnyListeners.length && self.eventsAnyListeners.forEach((eventHandler) => {
        eventHandler.apply(context, [event2, ...data2]);
      }), self.eventsListeners && self.eventsListeners[event2] && self.eventsListeners[event2].forEach((eventHandler) => {
        eventHandler.apply(context, data2);
      });
    }), self;
  }
};

// node_modules/swiper/core/update/updateSize.js
function updateSize() {
  let swiper = this, width, height, el = swiper.el;
  typeof swiper.params.width < "u" && swiper.params.width !== null ? width = swiper.params.width : width = el.clientWidth, typeof swiper.params.height < "u" && swiper.params.height !== null ? height = swiper.params.height : height = el.clientHeight, !(width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) && (width = width - parseInt(elementStyle(el, "padding-left") || 0, 10) - parseInt(elementStyle(el, "padding-right") || 0, 10), height = height - parseInt(elementStyle(el, "padding-top") || 0, 10) - parseInt(elementStyle(el, "padding-bottom") || 0, 10), Number.isNaN(width) && (width = 0), Number.isNaN(height) && (height = 0), Object.assign(swiper, {
    width,
    height,
    size: swiper.isHorizontal() ? width : height
  }));
}

// node_modules/swiper/core/update/updateSlides.js
function updateSlides() {
  let swiper = this;
  function getDirectionLabel(property) {
    return swiper.isHorizontal() ? property : {
      width: "height",
      "margin-top": "margin-left",
      "margin-bottom ": "margin-right",
      "margin-left": "margin-top",
      "margin-right": "margin-bottom",
      "padding-left": "padding-top",
      "padding-right": "padding-bottom",
      marginRight: "marginBottom"
    }[property];
  }
  function getDirectionPropertyValue(node, label) {
    return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);
  }
  let params = swiper.params, {
    wrapperEl,
    slidesEl,
    size: swiperSize,
    rtlTranslate: rtl,
    wrongRTL
  } = swiper, isVirtual = swiper.virtual && params.virtual.enabled, previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length, slides = elementChildren(slidesEl, `.${swiper.params.slideClass}, swiper-slide`), slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length, snapGrid = [], slidesGrid = [], slidesSizesGrid = [], offsetBefore = params.slidesOffsetBefore;
  typeof offsetBefore == "function" && (offsetBefore = params.slidesOffsetBefore.call(swiper));
  let offsetAfter = params.slidesOffsetAfter;
  typeof offsetAfter == "function" && (offsetAfter = params.slidesOffsetAfter.call(swiper));
  let previousSnapGridLength = swiper.snapGrid.length, previousSlidesGridLength = swiper.slidesGrid.length, spaceBetween = params.spaceBetween, slidePosition = -offsetBefore, prevSlideSize = 0, index2 = 0;
  if (typeof swiperSize > "u")
    return;
  typeof spaceBetween == "string" && spaceBetween.indexOf("%") >= 0 && (spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiperSize), swiper.virtualSize = -spaceBetween, slides.forEach((slideEl) => {
    rtl ? slideEl.style.marginLeft = "" : slideEl.style.marginRight = "", slideEl.style.marginBottom = "", slideEl.style.marginTop = "";
  }), params.centeredSlides && params.cssMode && (setCSSProperty(wrapperEl, "--swiper-centered-offset-before", ""), setCSSProperty(wrapperEl, "--swiper-centered-offset-after", ""));
  let gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;
  gridEnabled && swiper.grid.initSlides(slidesLength);
  let slideSize, shouldResetSlideSize = params.slidesPerView === "auto" && params.breakpoints && Object.keys(params.breakpoints).filter((key2) => typeof params.breakpoints[key2].slidesPerView < "u").length > 0;
  for (let i3 = 0; i3 < slidesLength; i3 += 1) {
    slideSize = 0;
    let slide;
    if (slides[i3] && (slide = slides[i3]), gridEnabled && swiper.grid.updateSlide(i3, slide, slidesLength, getDirectionLabel), !(slides[i3] && elementStyle(slide, "display") === "none")) {
      if (params.slidesPerView === "auto") {
        shouldResetSlideSize && (slides[i3].style[getDirectionLabel("width")] = "");
        let slideStyles = getComputedStyle(slide), currentTransform = slide.style.transform, currentWebKitTransform = slide.style.webkitTransform;
        if (currentTransform && (slide.style.transform = "none"), currentWebKitTransform && (slide.style.webkitTransform = "none"), params.roundLengths)
          slideSize = swiper.isHorizontal() ? elementOuterSize(slide, "width", !0) : elementOuterSize(slide, "height", !0);
        else {
          let width = getDirectionPropertyValue(slideStyles, "width"), paddingLeft = getDirectionPropertyValue(slideStyles, "padding-left"), paddingRight = getDirectionPropertyValue(slideStyles, "padding-right"), marginLeft = getDirectionPropertyValue(slideStyles, "margin-left"), marginRight = getDirectionPropertyValue(slideStyles, "margin-right"), boxSizing = slideStyles.getPropertyValue("box-sizing");
          if (boxSizing && boxSizing === "border-box")
            slideSize = width + marginLeft + marginRight;
          else {
            let {
              clientWidth,
              offsetWidth
            } = slide;
            slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
          }
        }
        currentTransform && (slide.style.transform = currentTransform), currentWebKitTransform && (slide.style.webkitTransform = currentWebKitTransform), params.roundLengths && (slideSize = Math.floor(slideSize));
      } else
        slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView, params.roundLengths && (slideSize = Math.floor(slideSize)), slides[i3] && (slides[i3].style[getDirectionLabel("width")] = `${slideSize}px`);
      slides[i3] && (slides[i3].swiperSlideSize = slideSize), slidesSizesGrid.push(slideSize), params.centeredSlides ? (slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween, prevSlideSize === 0 && i3 !== 0 && (slidePosition = slidePosition - swiperSize / 2 - spaceBetween), i3 === 0 && (slidePosition = slidePosition - swiperSize / 2 - spaceBetween), Math.abs(slidePosition) < 1 / 1e3 && (slidePosition = 0), params.roundLengths && (slidePosition = Math.floor(slidePosition)), index2 % params.slidesPerGroup === 0 && snapGrid.push(slidePosition), slidesGrid.push(slidePosition)) : (params.roundLengths && (slidePosition = Math.floor(slidePosition)), (index2 - Math.min(swiper.params.slidesPerGroupSkip, index2)) % swiper.params.slidesPerGroup === 0 && snapGrid.push(slidePosition), slidesGrid.push(slidePosition), slidePosition = slidePosition + slideSize + spaceBetween), swiper.virtualSize += slideSize + spaceBetween, prevSlideSize = slideSize, index2 += 1;
    }
  }
  if (swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter, rtl && wrongRTL && (params.effect === "slide" || params.effect === "coverflow") && (wrapperEl.style.width = `${swiper.virtualSize + params.spaceBetween}px`), params.setWrapperSize && (wrapperEl.style[getDirectionLabel("width")] = `${swiper.virtualSize + params.spaceBetween}px`), gridEnabled && swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel), !params.centeredSlides) {
    let newSlidesGrid = [];
    for (let i3 = 0; i3 < snapGrid.length; i3 += 1) {
      let slidesGridItem = snapGrid[i3];
      params.roundLengths && (slidesGridItem = Math.floor(slidesGridItem)), snapGrid[i3] <= swiper.virtualSize - swiperSize && newSlidesGrid.push(slidesGridItem);
    }
    snapGrid = newSlidesGrid, Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1 && snapGrid.push(swiper.virtualSize - swiperSize);
  }
  if (isVirtual && params.loop) {
    let size = slidesSizesGrid[0] + spaceBetween;
    if (params.slidesPerGroup > 1) {
      let groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup), groupSize = size * params.slidesPerGroup;
      for (let i3 = 0; i3 < groups; i3 += 1)
        snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);
    }
    for (let i3 = 0; i3 < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i3 += 1)
      params.slidesPerGroup === 1 && snapGrid.push(snapGrid[snapGrid.length - 1] + size), slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size), swiper.virtualSize += size;
  }
  if (snapGrid.length === 0 && (snapGrid = [0]), params.spaceBetween !== 0) {
    let key2 = swiper.isHorizontal() && rtl ? "marginLeft" : getDirectionLabel("marginRight");
    slides.filter((_24, slideIndex) => !params.cssMode || params.loop ? !0 : slideIndex !== slides.length - 1).forEach((slideEl) => {
      slideEl.style[key2] = `${spaceBetween}px`;
    });
  }
  if (params.centeredSlides && params.centeredSlidesBounds) {
    let allSlidesSize = 0;
    slidesSizesGrid.forEach((slideSizeValue) => {
      allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
    }), allSlidesSize -= params.spaceBetween;
    let maxSnap = allSlidesSize - swiperSize;
    snapGrid = snapGrid.map((snap) => snap < 0 ? -offsetBefore : snap > maxSnap ? maxSnap + offsetAfter : snap);
  }
  if (params.centerInsufficientSlides) {
    let allSlidesSize = 0;
    if (slidesSizesGrid.forEach((slideSizeValue) => {
      allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
    }), allSlidesSize -= params.spaceBetween, allSlidesSize < swiperSize) {
      let allSlidesOffset = (swiperSize - allSlidesSize) / 2;
      snapGrid.forEach((snap, snapIndex) => {
        snapGrid[snapIndex] = snap - allSlidesOffset;
      }), slidesGrid.forEach((snap, snapIndex) => {
        slidesGrid[snapIndex] = snap + allSlidesOffset;
      });
    }
  }
  if (Object.assign(swiper, {
    slides,
    snapGrid,
    slidesGrid,
    slidesSizesGrid
  }), params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
    setCSSProperty(wrapperEl, "--swiper-centered-offset-before", `${-snapGrid[0]}px`), setCSSProperty(wrapperEl, "--swiper-centered-offset-after", `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
    let addToSnapGrid = -swiper.snapGrid[0], addToSlidesGrid = -swiper.slidesGrid[0];
    swiper.snapGrid = swiper.snapGrid.map((v2) => v2 + addToSnapGrid), swiper.slidesGrid = swiper.slidesGrid.map((v2) => v2 + addToSlidesGrid);
  }
  if (slidesLength !== previousSlidesLength && swiper.emit("slidesLengthChange"), snapGrid.length !== previousSnapGridLength && (swiper.params.watchOverflow && swiper.checkOverflow(), swiper.emit("snapGridLengthChange")), slidesGrid.length !== previousSlidesGridLength && swiper.emit("slidesGridLengthChange"), params.watchSlidesProgress && swiper.updateSlidesOffset(), !isVirtual && !params.cssMode && (params.effect === "slide" || params.effect === "fade")) {
    let backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`, hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);
    slidesLength <= params.maxBackfaceHiddenSlides ? hasClassBackfaceClassAdded || swiper.el.classList.add(backFaceHiddenClass) : hasClassBackfaceClassAdded && swiper.el.classList.remove(backFaceHiddenClass);
  }
}

// node_modules/swiper/core/update/updateAutoHeight.js
function updateAutoHeight(speed) {
  let swiper = this, activeSlides = [], isVirtual = swiper.virtual && swiper.params.virtual.enabled, newHeight = 0, i3;
  typeof speed == "number" ? swiper.setTransition(speed) : speed === !0 && swiper.setTransition(swiper.params.speed);
  let getSlideByIndex = (index2) => isVirtual ? swiper.getSlideIndexByData(index2) : swiper.slides[index2];
  if (swiper.params.slidesPerView !== "auto" && swiper.params.slidesPerView > 1)
    if (swiper.params.centeredSlides)
      (swiper.visibleSlides || []).forEach((slide) => {
        activeSlides.push(slide);
      });
    else
      for (i3 = 0; i3 < Math.ceil(swiper.params.slidesPerView); i3 += 1) {
        let index2 = swiper.activeIndex + i3;
        if (index2 > swiper.slides.length && !isVirtual)
          break;
        activeSlides.push(getSlideByIndex(index2));
      }
  else
    activeSlides.push(getSlideByIndex(swiper.activeIndex));
  for (i3 = 0; i3 < activeSlides.length; i3 += 1)
    if (typeof activeSlides[i3] < "u") {
      let height = activeSlides[i3].offsetHeight;
      newHeight = height > newHeight ? height : newHeight;
    }
  (newHeight || newHeight === 0) && (swiper.wrapperEl.style.height = `${newHeight}px`);
}

// node_modules/swiper/core/update/updateSlidesOffset.js
function updateSlidesOffset() {
  let swiper = this, slides = swiper.slides, minusOffset = swiper.isElement ? swiper.isHorizontal() ? swiper.wrapperEl.offsetLeft : swiper.wrapperEl.offsetTop : 0;
  for (let i3 = 0; i3 < slides.length; i3 += 1)
    slides[i3].swiperSlideOffset = (swiper.isHorizontal() ? slides[i3].offsetLeft : slides[i3].offsetTop) - minusOffset;
}

// node_modules/swiper/core/update/updateSlidesProgress.js
function updateSlidesProgress(translate = this && this.translate || 0) {
  let swiper = this, params = swiper.params, {
    slides,
    rtlTranslate: rtl,
    snapGrid
  } = swiper;
  if (slides.length === 0)
    return;
  typeof slides[0].swiperSlideOffset > "u" && swiper.updateSlidesOffset();
  let offsetCenter = -translate;
  rtl && (offsetCenter = translate), slides.forEach((slideEl) => {
    slideEl.classList.remove(params.slideVisibleClass);
  }), swiper.visibleSlidesIndexes = [], swiper.visibleSlides = [];
  for (let i3 = 0; i3 < slides.length; i3 += 1) {
    let slide = slides[i3], slideOffset = slide.swiperSlideOffset;
    params.cssMode && params.centeredSlides && (slideOffset -= slides[0].swiperSlideOffset);
    let slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween), originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween), slideBefore = -(offsetCenter - slideOffset), slideAfter = slideBefore + swiper.slidesSizesGrid[i3];
    (slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size) && (swiper.visibleSlides.push(slide), swiper.visibleSlidesIndexes.push(i3), slides[i3].classList.add(params.slideVisibleClass)), slide.progress = rtl ? -slideProgress : slideProgress, slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
  }
}

// node_modules/swiper/core/update/updateProgress.js
function updateProgress(translate) {
  let swiper = this;
  if (typeof translate > "u") {
    let multiplier = swiper.rtlTranslate ? -1 : 1;
    translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
  }
  let params = swiper.params, translatesDiff = swiper.maxTranslate() - swiper.minTranslate(), {
    progress: progress2,
    isBeginning,
    isEnd,
    progressLoop
  } = swiper, wasBeginning = isBeginning, wasEnd = isEnd;
  if (translatesDiff === 0)
    progress2 = 0, isBeginning = !0, isEnd = !0;
  else {
    progress2 = (translate - swiper.minTranslate()) / translatesDiff;
    let isBeginningRounded = Math.abs(translate - swiper.minTranslate()) < 1, isEndRounded = Math.abs(translate - swiper.maxTranslate()) < 1;
    isBeginning = isBeginningRounded || progress2 <= 0, isEnd = isEndRounded || progress2 >= 1, isBeginningRounded && (progress2 = 0), isEndRounded && (progress2 = 1);
  }
  if (params.loop) {
    let firstSlideIndex = swiper.getSlideIndexByData(0), lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1), firstSlideTranslate = swiper.slidesGrid[firstSlideIndex], lastSlideTranslate = swiper.slidesGrid[lastSlideIndex], translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1], translateAbs = Math.abs(translate);
    translateAbs >= firstSlideTranslate ? progressLoop = (translateAbs - firstSlideTranslate) / translateMax : progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax, progressLoop > 1 && (progressLoop -= 1);
  }
  Object.assign(swiper, {
    progress: progress2,
    progressLoop,
    isBeginning,
    isEnd
  }), (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) && swiper.updateSlidesProgress(translate), isBeginning && !wasBeginning && swiper.emit("reachBeginning toEdge"), isEnd && !wasEnd && swiper.emit("reachEnd toEdge"), (wasBeginning && !isBeginning || wasEnd && !isEnd) && swiper.emit("fromEdge"), swiper.emit("progress", progress2);
}

// node_modules/swiper/core/update/updateSlidesClasses.js
function updateSlidesClasses() {
  let swiper = this, {
    slides,
    params,
    slidesEl,
    activeIndex
  } = swiper, isVirtual = swiper.virtual && params.virtual.enabled, getFilteredSlide = (selector) => elementChildren(slidesEl, `.${params.slideClass}${selector}, swiper-slide${selector}`)[0];
  slides.forEach((slideEl) => {
    slideEl.classList.remove(params.slideActiveClass, params.slideNextClass, params.slidePrevClass);
  });
  let activeSlide;
  if (isVirtual)
    if (params.loop) {
      let slideIndex = activeIndex - swiper.virtual.slidesBefore;
      slideIndex < 0 && (slideIndex = swiper.virtual.slides.length + slideIndex), slideIndex >= swiper.virtual.slides.length && (slideIndex -= swiper.virtual.slides.length), activeSlide = getFilteredSlide(`[data-swiper-slide-index="${slideIndex}"]`);
    } else
      activeSlide = getFilteredSlide(`[data-swiper-slide-index="${activeIndex}"]`);
  else
    activeSlide = slides[activeIndex];
  if (activeSlide) {
    activeSlide.classList.add(params.slideActiveClass);
    let nextSlide = elementNextAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
    params.loop && !nextSlide && (nextSlide = slides[0]), nextSlide && nextSlide.classList.add(params.slideNextClass);
    let prevSlide = elementPrevAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
    params.loop && !prevSlide === 0 && (prevSlide = slides[slides.length - 1]), prevSlide && prevSlide.classList.add(params.slidePrevClass);
  }
  swiper.emitSlidesClasses();
}

// node_modules/swiper/shared/process-lazy-preloader.js
var processLazyPreloader = (swiper, imageEl) => {
  if (!swiper || swiper.destroyed || !swiper.params)
    return;
  let slideSelector = () => swiper.isElement ? "swiper-slide" : `.${swiper.params.slideClass}`, slideEl = imageEl.closest(slideSelector());
  if (slideEl) {
    let lazyEl = slideEl.querySelector(`.${swiper.params.lazyPreloaderClass}`);
    lazyEl && lazyEl.remove();
  }
}, unlazy = (swiper, index2) => {
  if (!swiper.slides[index2])
    return;
  let imageEl = swiper.slides[index2].querySelector('[loading="lazy"]');
  imageEl && imageEl.removeAttribute("loading");
}, preload = (swiper) => {
  if (!swiper || swiper.destroyed || !swiper.params)
    return;
  let amount = swiper.params.lazyPreloadPrevNext, len = swiper.slides.length;
  if (!len || !amount || amount < 0)
    return;
  amount = Math.min(amount, len);
  let slidesPerView = swiper.params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : Math.ceil(swiper.params.slidesPerView), activeIndex = swiper.activeIndex, slideIndexLastInView = activeIndex + slidesPerView - 1;
  if (swiper.params.rewind)
    for (let i3 = activeIndex - amount; i3 <= slideIndexLastInView + amount; i3 += 1) {
      let realIndex = (i3 % len + len) % len;
      realIndex !== activeIndex && realIndex > slideIndexLastInView && unlazy(swiper, realIndex);
    }
  else
    for (let i3 = Math.max(slideIndexLastInView - amount, 0); i3 <= Math.min(slideIndexLastInView + amount, len - 1); i3 += 1)
      i3 !== activeIndex && i3 > slideIndexLastInView && unlazy(swiper, i3);
};

// node_modules/swiper/core/update/updateActiveIndex.js
function getActiveIndexByTranslate(swiper) {
  let {
    slidesGrid,
    params
  } = swiper, translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate, activeIndex;
  for (let i3 = 0; i3 < slidesGrid.length; i3 += 1)
    typeof slidesGrid[i3 + 1] < "u" ? translate >= slidesGrid[i3] && translate < slidesGrid[i3 + 1] - (slidesGrid[i3 + 1] - slidesGrid[i3]) / 2 ? activeIndex = i3 : translate >= slidesGrid[i3] && translate < slidesGrid[i3 + 1] && (activeIndex = i3 + 1) : translate >= slidesGrid[i3] && (activeIndex = i3);
  return params.normalizeSlideIndex && (activeIndex < 0 || typeof activeIndex > "u") && (activeIndex = 0), activeIndex;
}
function updateActiveIndex(newActiveIndex) {
  let swiper = this, translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate, {
    snapGrid,
    params,
    activeIndex: previousIndex,
    realIndex: previousRealIndex,
    snapIndex: previousSnapIndex
  } = swiper, activeIndex = newActiveIndex, snapIndex, getVirtualRealIndex = (aIndex) => {
    let realIndex2 = aIndex - swiper.virtual.slidesBefore;
    return realIndex2 < 0 && (realIndex2 = swiper.virtual.slides.length + realIndex2), realIndex2 >= swiper.virtual.slides.length && (realIndex2 -= swiper.virtual.slides.length), realIndex2;
  };
  if (typeof activeIndex > "u" && (activeIndex = getActiveIndexByTranslate(swiper)), snapGrid.indexOf(translate) >= 0)
    snapIndex = snapGrid.indexOf(translate);
  else {
    let skip = Math.min(params.slidesPerGroupSkip, activeIndex);
    snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
  }
  if (snapIndex >= snapGrid.length && (snapIndex = snapGrid.length - 1), activeIndex === previousIndex) {
    snapIndex !== previousSnapIndex && (swiper.snapIndex = snapIndex, swiper.emit("snapIndexChange")), swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled && (swiper.realIndex = getVirtualRealIndex(activeIndex));
    return;
  }
  let realIndex;
  swiper.virtual && params.virtual.enabled && params.loop ? realIndex = getVirtualRealIndex(activeIndex) : swiper.slides[activeIndex] ? realIndex = parseInt(swiper.slides[activeIndex].getAttribute("data-swiper-slide-index") || activeIndex, 10) : realIndex = activeIndex, Object.assign(swiper, {
    snapIndex,
    realIndex,
    previousIndex,
    activeIndex
  }), swiper.initialized && preload(swiper), swiper.emit("activeIndexChange"), swiper.emit("snapIndexChange"), previousRealIndex !== realIndex && swiper.emit("realIndexChange"), (swiper.initialized || swiper.params.runCallbacksOnInit) && swiper.emit("slideChange");
}

// node_modules/swiper/core/update/updateClickedSlide.js
function updateClickedSlide(e3) {
  let swiper = this, params = swiper.params, slide = e3.closest(`.${params.slideClass}, swiper-slide`), slideFound = !1, slideIndex;
  if (slide) {
    for (let i3 = 0; i3 < swiper.slides.length; i3 += 1)
      if (swiper.slides[i3] === slide) {
        slideFound = !0, slideIndex = i3;
        break;
      }
  }
  if (slide && slideFound)
    swiper.clickedSlide = slide, swiper.virtual && swiper.params.virtual.enabled ? swiper.clickedIndex = parseInt(slide.getAttribute("data-swiper-slide-index"), 10) : swiper.clickedIndex = slideIndex;
  else {
    swiper.clickedSlide = void 0, swiper.clickedIndex = void 0;
    return;
  }
  params.slideToClickedSlide && swiper.clickedIndex !== void 0 && swiper.clickedIndex !== swiper.activeIndex && swiper.slideToClickedSlide();
}

// node_modules/swiper/core/update/index.js
var update_default = {
  updateSize,
  updateSlides,
  updateAutoHeight,
  updateSlidesOffset,
  updateSlidesProgress,
  updateProgress,
  updateSlidesClasses,
  updateActiveIndex,
  updateClickedSlide
};

// node_modules/swiper/core/translate/getTranslate.js
function getSwiperTranslate(axis = this.isHorizontal() ? "x" : "y") {
  let swiper = this, {
    params,
    rtlTranslate: rtl,
    translate,
    wrapperEl
  } = swiper;
  if (params.virtualTranslate)
    return rtl ? -translate : translate;
  if (params.cssMode)
    return translate;
  let currentTranslate = getTranslate(wrapperEl, axis);
  return rtl && (currentTranslate = -currentTranslate), currentTranslate || 0;
}

// node_modules/swiper/core/translate/setTranslate.js
function setTranslate(translate, byController) {
  let swiper = this, {
    rtlTranslate: rtl,
    params,
    wrapperEl,
    progress: progress2
  } = swiper, x2 = 0, y2 = 0, z2 = 0;
  swiper.isHorizontal() ? x2 = rtl ? -translate : translate : y2 = translate, params.roundLengths && (x2 = Math.floor(x2), y2 = Math.floor(y2)), params.cssMode ? wrapperEl[swiper.isHorizontal() ? "scrollLeft" : "scrollTop"] = swiper.isHorizontal() ? -x2 : -y2 : params.virtualTranslate || (wrapperEl.style.transform = `translate3d(${x2}px, ${y2}px, ${z2}px)`), swiper.previousTranslate = swiper.translate, swiper.translate = swiper.isHorizontal() ? x2 : y2;
  let newProgress, translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  translatesDiff === 0 ? newProgress = 0 : newProgress = (translate - swiper.minTranslate()) / translatesDiff, newProgress !== progress2 && swiper.updateProgress(translate), swiper.emit("setTranslate", swiper.translate, byController);
}

// node_modules/swiper/core/translate/minTranslate.js
function minTranslate() {
  return -this.snapGrid[0];
}

// node_modules/swiper/core/translate/maxTranslate.js
function maxTranslate() {
  return -this.snapGrid[this.snapGrid.length - 1];
}

// node_modules/swiper/core/translate/translateTo.js
function translateTo(translate = 0, speed = this.params.speed, runCallbacks = !0, translateBounds = !0, internal) {
  let swiper = this, {
    params,
    wrapperEl
  } = swiper;
  if (swiper.animating && params.preventInteractionOnTransition)
    return !1;
  let minTranslate2 = swiper.minTranslate(), maxTranslate2 = swiper.maxTranslate(), newTranslate;
  if (translateBounds && translate > minTranslate2 ? newTranslate = minTranslate2 : translateBounds && translate < maxTranslate2 ? newTranslate = maxTranslate2 : newTranslate = translate, swiper.updateProgress(newTranslate), params.cssMode) {
    let isH = swiper.isHorizontal();
    if (speed === 0)
      wrapperEl[isH ? "scrollLeft" : "scrollTop"] = -newTranslate;
    else {
      if (!swiper.support.smoothScroll)
        return animateCSSModeScroll({
          swiper,
          targetPosition: -newTranslate,
          side: isH ? "left" : "top"
        }), !0;
      wrapperEl.scrollTo({
        [isH ? "left" : "top"]: -newTranslate,
        behavior: "smooth"
      });
    }
    return !0;
  }
  return speed === 0 ? (swiper.setTransition(0), swiper.setTranslate(newTranslate), runCallbacks && (swiper.emit("beforeTransitionStart", speed, internal), swiper.emit("transitionEnd"))) : (swiper.setTransition(speed), swiper.setTranslate(newTranslate), runCallbacks && (swiper.emit("beforeTransitionStart", speed, internal), swiper.emit("transitionStart")), swiper.animating || (swiper.animating = !0, swiper.onTranslateToWrapperTransitionEnd || (swiper.onTranslateToWrapperTransitionEnd = function(e3) {
    !swiper || swiper.destroyed || e3.target === this && (swiper.wrapperEl.removeEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd), swiper.onTranslateToWrapperTransitionEnd = null, delete swiper.onTranslateToWrapperTransitionEnd, runCallbacks && swiper.emit("transitionEnd"));
  }), swiper.wrapperEl.addEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd))), !0;
}

// node_modules/swiper/core/translate/index.js
var translate_default = {
  getTranslate: getSwiperTranslate,
  setTranslate,
  minTranslate,
  maxTranslate,
  translateTo
};

// node_modules/swiper/core/transition/setTransition.js
function setTransition(duration, byController) {
  let swiper = this;
  swiper.params.cssMode || (swiper.wrapperEl.style.transitionDuration = `${duration}ms`), swiper.emit("setTransition", duration, byController);
}

// node_modules/swiper/core/transition/transitionEmit.js
function transitionEmit({
  swiper,
  runCallbacks,
  direction,
  step
}) {
  let {
    activeIndex,
    previousIndex
  } = swiper, dir = direction;
  if (dir || (activeIndex > previousIndex ? dir = "next" : activeIndex < previousIndex ? dir = "prev" : dir = "reset"), swiper.emit(`transition${step}`), runCallbacks && activeIndex !== previousIndex) {
    if (dir === "reset") {
      swiper.emit(`slideResetTransition${step}`);
      return;
    }
    swiper.emit(`slideChangeTransition${step}`), dir === "next" ? swiper.emit(`slideNextTransition${step}`) : swiper.emit(`slidePrevTransition${step}`);
  }
}

// node_modules/swiper/core/transition/transitionStart.js
function transitionStart(runCallbacks = !0, direction) {
  let swiper = this, {
    params
  } = swiper;
  params.cssMode || (params.autoHeight && swiper.updateAutoHeight(), transitionEmit({
    swiper,
    runCallbacks,
    direction,
    step: "Start"
  }));
}

// node_modules/swiper/core/transition/transitionEnd.js
function transitionEnd(runCallbacks = !0, direction) {
  let swiper = this, {
    params
  } = swiper;
  swiper.animating = !1, !params.cssMode && (swiper.setTransition(0), transitionEmit({
    swiper,
    runCallbacks,
    direction,
    step: "End"
  }));
}

// node_modules/swiper/core/transition/index.js
var transition_default = {
  setTransition,
  transitionStart,
  transitionEnd
};

// node_modules/swiper/core/slide/slideTo.js
function slideTo(index2 = 0, speed = this.params.speed, runCallbacks = !0, internal, initial) {
  typeof index2 == "string" && (index2 = parseInt(index2, 10));
  let swiper = this, slideIndex = index2;
  slideIndex < 0 && (slideIndex = 0);
  let {
    params,
    snapGrid,
    slidesGrid,
    previousIndex,
    activeIndex,
    rtlTranslate: rtl,
    wrapperEl,
    enabled
  } = swiper;
  if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial)
    return !1;
  let skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex), snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
  snapIndex >= snapGrid.length && (snapIndex = snapGrid.length - 1);
  let translate = -snapGrid[snapIndex];
  if (params.normalizeSlideIndex)
    for (let i3 = 0; i3 < slidesGrid.length; i3 += 1) {
      let normalizedTranslate = -Math.floor(translate * 100), normalizedGrid = Math.floor(slidesGrid[i3] * 100), normalizedGridNext = Math.floor(slidesGrid[i3 + 1] * 100);
      typeof slidesGrid[i3 + 1] < "u" ? normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2 ? slideIndex = i3 : normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext && (slideIndex = i3 + 1) : normalizedTranslate >= normalizedGrid && (slideIndex = i3);
    }
  if (swiper.initialized && slideIndex !== activeIndex && (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate() || !swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate() && (activeIndex || 0) !== slideIndex))
    return !1;
  slideIndex !== (previousIndex || 0) && runCallbacks && swiper.emit("beforeSlideChangeStart"), swiper.updateProgress(translate);
  let direction;
  if (slideIndex > activeIndex ? direction = "next" : slideIndex < activeIndex ? direction = "prev" : direction = "reset", rtl && -translate === swiper.translate || !rtl && translate === swiper.translate)
    return swiper.updateActiveIndex(slideIndex), params.autoHeight && swiper.updateAutoHeight(), swiper.updateSlidesClasses(), params.effect !== "slide" && swiper.setTranslate(translate), direction !== "reset" && (swiper.transitionStart(runCallbacks, direction), swiper.transitionEnd(runCallbacks, direction)), !1;
  if (params.cssMode) {
    let isH = swiper.isHorizontal(), t4 = rtl ? translate : -translate;
    if (speed === 0) {
      let isVirtual = swiper.virtual && swiper.params.virtual.enabled;
      isVirtual && (swiper.wrapperEl.style.scrollSnapType = "none", swiper._immediateVirtual = !0), isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0 ? (swiper._cssModeVirtualInitialSet = !0, requestAnimationFrame(() => {
        wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t4;
      })) : wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t4, isVirtual && requestAnimationFrame(() => {
        swiper.wrapperEl.style.scrollSnapType = "", swiper._immediateVirtual = !1;
      });
    } else {
      if (!swiper.support.smoothScroll)
        return animateCSSModeScroll({
          swiper,
          targetPosition: t4,
          side: isH ? "left" : "top"
        }), !0;
      wrapperEl.scrollTo({
        [isH ? "left" : "top"]: t4,
        behavior: "smooth"
      });
    }
    return !0;
  }
  return swiper.setTransition(speed), swiper.setTranslate(translate), swiper.updateActiveIndex(slideIndex), swiper.updateSlidesClasses(), swiper.emit("beforeTransitionStart", speed, internal), swiper.transitionStart(runCallbacks, direction), speed === 0 ? swiper.transitionEnd(runCallbacks, direction) : swiper.animating || (swiper.animating = !0, swiper.onSlideToWrapperTransitionEnd || (swiper.onSlideToWrapperTransitionEnd = function(e3) {
    !swiper || swiper.destroyed || e3.target === this && (swiper.wrapperEl.removeEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd), swiper.onSlideToWrapperTransitionEnd = null, delete swiper.onSlideToWrapperTransitionEnd, swiper.transitionEnd(runCallbacks, direction));
  }), swiper.wrapperEl.addEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd)), !0;
}

// node_modules/swiper/core/slide/slideToLoop.js
function slideToLoop(index2 = 0, speed = this.params.speed, runCallbacks = !0, internal) {
  typeof index2 == "string" && (index2 = parseInt(index2, 10));
  let swiper = this, newIndex = index2;
  return swiper.params.loop && (swiper.virtual && swiper.params.virtual.enabled ? newIndex = newIndex + swiper.virtual.slidesBefore : newIndex = swiper.getSlideIndexByData(newIndex)), swiper.slideTo(newIndex, speed, runCallbacks, internal);
}

// node_modules/swiper/core/slide/slideNext.js
function slideNext(speed = this.params.speed, runCallbacks = !0, internal) {
  let swiper = this, {
    enabled,
    params,
    animating
  } = swiper;
  if (!enabled)
    return swiper;
  let perGroup = params.slidesPerGroup;
  params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto && (perGroup = Math.max(swiper.slidesPerViewDynamic("current", !0), 1));
  let increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup, isVirtual = swiper.virtual && params.virtual.enabled;
  if (params.loop) {
    if (animating && !isVirtual && params.loopPreventsSliding)
      return !1;
    swiper.loopFix({
      direction: "next"
    }), swiper._clientLeft = swiper.wrapperEl.clientLeft;
  }
  return params.rewind && swiper.isEnd ? swiper.slideTo(0, speed, runCallbacks, internal) : swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
}

// node_modules/swiper/core/slide/slidePrev.js
function slidePrev(speed = this.params.speed, runCallbacks = !0, internal) {
  let swiper = this, {
    params,
    snapGrid,
    slidesGrid,
    rtlTranslate,
    enabled,
    animating
  } = swiper;
  if (!enabled)
    return swiper;
  let isVirtual = swiper.virtual && params.virtual.enabled;
  if (params.loop) {
    if (animating && !isVirtual && params.loopPreventsSliding)
      return !1;
    swiper.loopFix({
      direction: "prev"
    }), swiper._clientLeft = swiper.wrapperEl.clientLeft;
  }
  let translate = rtlTranslate ? swiper.translate : -swiper.translate;
  function normalize2(val) {
    return val < 0 ? -Math.floor(Math.abs(val)) : Math.floor(val);
  }
  let normalizedTranslate = normalize2(translate), normalizedSnapGrid = snapGrid.map((val) => normalize2(val)), prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
  if (typeof prevSnap > "u" && params.cssMode) {
    let prevSnapIndex;
    snapGrid.forEach((snap, snapIndex) => {
      normalizedTranslate >= snap && (prevSnapIndex = snapIndex);
    }), typeof prevSnapIndex < "u" && (prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex]);
  }
  let prevIndex = 0;
  if (typeof prevSnap < "u" && (prevIndex = slidesGrid.indexOf(prevSnap), prevIndex < 0 && (prevIndex = swiper.activeIndex - 1), params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto && (prevIndex = prevIndex - swiper.slidesPerViewDynamic("previous", !0) + 1, prevIndex = Math.max(prevIndex, 0))), params.rewind && swiper.isBeginning) {
    let lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
    return swiper.slideTo(lastIndex, speed, runCallbacks, internal);
  }
  return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
}

// node_modules/swiper/core/slide/slideReset.js
function slideReset(speed = this.params.speed, runCallbacks = !0, internal) {
  let swiper = this;
  return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
}

// node_modules/swiper/core/slide/slideToClosest.js
function slideToClosest(speed = this.params.speed, runCallbacks = !0, internal, threshold = 0.5) {
  let swiper = this, index2 = swiper.activeIndex, skip = Math.min(swiper.params.slidesPerGroupSkip, index2), snapIndex = skip + Math.floor((index2 - skip) / swiper.params.slidesPerGroup), translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  if (translate >= swiper.snapGrid[snapIndex]) {
    let currentSnap = swiper.snapGrid[snapIndex], nextSnap = swiper.snapGrid[snapIndex + 1];
    translate - currentSnap > (nextSnap - currentSnap) * threshold && (index2 += swiper.params.slidesPerGroup);
  } else {
    let prevSnap = swiper.snapGrid[snapIndex - 1], currentSnap = swiper.snapGrid[snapIndex];
    translate - prevSnap <= (currentSnap - prevSnap) * threshold && (index2 -= swiper.params.slidesPerGroup);
  }
  return index2 = Math.max(index2, 0), index2 = Math.min(index2, swiper.slidesGrid.length - 1), swiper.slideTo(index2, speed, runCallbacks, internal);
}

// node_modules/swiper/core/slide/slideToClickedSlide.js
function slideToClickedSlide() {
  let swiper = this, {
    params,
    slidesEl
  } = swiper, slidesPerView = params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : params.slidesPerView, slideToIndex = swiper.clickedIndex, realIndex, slideSelector = swiper.isElement ? "swiper-slide" : `.${params.slideClass}`;
  if (params.loop) {
    if (swiper.animating)
      return;
    realIndex = parseInt(swiper.clickedSlide.getAttribute("data-swiper-slide-index"), 10), params.centeredSlides ? slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2 ? (swiper.loopFix(), slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]), nextTick2(() => {
      swiper.slideTo(slideToIndex);
    })) : swiper.slideTo(slideToIndex) : slideToIndex > swiper.slides.length - slidesPerView ? (swiper.loopFix(), slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]), nextTick2(() => {
      swiper.slideTo(slideToIndex);
    })) : swiper.slideTo(slideToIndex);
  } else
    swiper.slideTo(slideToIndex);
}

// node_modules/swiper/core/slide/index.js
var slide_default = {
  slideTo,
  slideToLoop,
  slideNext,
  slidePrev,
  slideReset,
  slideToClosest,
  slideToClickedSlide
};

// node_modules/swiper/core/loop/loopCreate.js
function loopCreate(slideRealIndex) {
  let swiper = this, {
    params,
    slidesEl
  } = swiper;
  if (!params.loop || swiper.virtual && swiper.params.virtual.enabled)
    return;
  elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`).forEach((el, index2) => {
    el.setAttribute("data-swiper-slide-index", index2);
  }), swiper.loopFix({
    slideRealIndex,
    direction: params.centeredSlides ? void 0 : "next"
  });
}

// node_modules/swiper/core/loop/loopFix.js
function loopFix({
  slideRealIndex,
  slideTo: slideTo2 = !0,
  direction,
  setTranslate: setTranslate2,
  activeSlideIndex,
  byController,
  byMousewheel
} = {}) {
  let swiper = this;
  if (!swiper.params.loop)
    return;
  swiper.emit("beforeLoopFix");
  let {
    slides,
    allowSlidePrev,
    allowSlideNext,
    slidesEl,
    params
  } = swiper;
  if (swiper.allowSlidePrev = !0, swiper.allowSlideNext = !0, swiper.virtual && params.virtual.enabled) {
    slideTo2 && (!params.centeredSlides && swiper.snapIndex === 0 ? swiper.slideTo(swiper.virtual.slides.length, 0, !1, !0) : params.centeredSlides && swiper.snapIndex < params.slidesPerView ? swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, !1, !0) : swiper.snapIndex === swiper.snapGrid.length - 1 && swiper.slideTo(swiper.virtual.slidesBefore, 0, !1, !0)), swiper.allowSlidePrev = allowSlidePrev, swiper.allowSlideNext = allowSlideNext, swiper.emit("loopFix");
    return;
  }
  let slidesPerView = params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)), loopedSlides = params.loopedSlides || slidesPerView;
  loopedSlides % params.slidesPerGroup !== 0 && (loopedSlides += params.slidesPerGroup - loopedSlides % params.slidesPerGroup), swiper.loopedSlides = loopedSlides;
  let prependSlidesIndexes = [], appendSlidesIndexes = [], activeIndex = swiper.activeIndex;
  typeof activeSlideIndex > "u" ? activeSlideIndex = swiper.getSlideIndex(swiper.slides.filter((el) => el.classList.contains(params.slideActiveClass))[0]) : activeIndex = activeSlideIndex;
  let isNext = direction === "next" || !direction, isPrev = direction === "prev" || !direction, slidesPrepended = 0, slidesAppended = 0;
  if (activeSlideIndex < loopedSlides) {
    slidesPrepended = Math.max(loopedSlides - activeSlideIndex, params.slidesPerGroup);
    for (let i3 = 0; i3 < loopedSlides - activeSlideIndex; i3 += 1) {
      let index2 = i3 - Math.floor(i3 / slides.length) * slides.length;
      prependSlidesIndexes.push(slides.length - index2 - 1);
    }
  } else if (activeSlideIndex > swiper.slides.length - loopedSlides * 2) {
    slidesAppended = Math.max(activeSlideIndex - (swiper.slides.length - loopedSlides * 2), params.slidesPerGroup);
    for (let i3 = 0; i3 < slidesAppended; i3 += 1) {
      let index2 = i3 - Math.floor(i3 / slides.length) * slides.length;
      appendSlidesIndexes.push(index2);
    }
  }
  if (isPrev && prependSlidesIndexes.forEach((index2) => {
    slidesEl.prepend(swiper.slides[index2]);
  }), isNext && appendSlidesIndexes.forEach((index2) => {
    slidesEl.append(swiper.slides[index2]);
  }), swiper.recalcSlides(), params.watchSlidesProgress && swiper.updateSlidesOffset(), slideTo2) {
    if (prependSlidesIndexes.length > 0 && isPrev)
      if (typeof slideRealIndex > "u") {
        let currentSlideTranslate = swiper.slidesGrid[activeIndex], diff = swiper.slidesGrid[activeIndex + slidesPrepended] - currentSlideTranslate;
        byMousewheel ? swiper.setTranslate(swiper.translate - diff) : (swiper.slideTo(activeIndex + slidesPrepended, 0, !1, !0), setTranslate2 && (swiper.touches[swiper.isHorizontal() ? "startX" : "startY"] += diff));
      } else
        setTranslate2 && swiper.slideToLoop(slideRealIndex, 0, !1, !0);
    else if (appendSlidesIndexes.length > 0 && isNext)
      if (typeof slideRealIndex > "u") {
        let currentSlideTranslate = swiper.slidesGrid[activeIndex], diff = swiper.slidesGrid[activeIndex - slidesAppended] - currentSlideTranslate;
        byMousewheel ? swiper.setTranslate(swiper.translate - diff) : (swiper.slideTo(activeIndex - slidesAppended, 0, !1, !0), setTranslate2 && (swiper.touches[swiper.isHorizontal() ? "startX" : "startY"] += diff));
      } else
        swiper.slideToLoop(slideRealIndex, 0, !1, !0);
  }
  if (swiper.allowSlidePrev = allowSlidePrev, swiper.allowSlideNext = allowSlideNext, swiper.controller && swiper.controller.control && !byController) {
    let loopParams = {
      slideRealIndex,
      slideTo: !1,
      direction,
      setTranslate: setTranslate2,
      activeSlideIndex,
      byController: !0
    };
    Array.isArray(swiper.controller.control) ? swiper.controller.control.forEach((c4) => {
      !c4.destroyed && c4.params.loop && c4.loopFix(loopParams);
    }) : swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop && swiper.controller.control.loopFix(loopParams);
  }
  swiper.emit("loopFix");
}

// node_modules/swiper/core/loop/loopDestroy.js
function loopDestroy() {
  let swiper = this, {
    params,
    slidesEl
  } = swiper;
  if (!params.loop || swiper.virtual && swiper.params.virtual.enabled)
    return;
  swiper.recalcSlides();
  let newSlidesOrder = [];
  swiper.slides.forEach((slideEl) => {
    let index2 = typeof slideEl.swiperSlideIndex > "u" ? slideEl.getAttribute("data-swiper-slide-index") * 1 : slideEl.swiperSlideIndex;
    newSlidesOrder[index2] = slideEl;
  }), swiper.slides.forEach((slideEl) => {
    slideEl.removeAttribute("data-swiper-slide-index");
  }), newSlidesOrder.forEach((slideEl) => {
    slidesEl.append(slideEl);
  }), swiper.recalcSlides(), swiper.slideTo(swiper.realIndex, 0);
}

// node_modules/swiper/core/loop/index.js
var loop_default = {
  loopCreate,
  loopFix,
  loopDestroy
};

// node_modules/swiper/core/grab-cursor/setGrabCursor.js
function setGrabCursor(moving) {
  let swiper = this;
  if (!swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode)
    return;
  let el = swiper.params.touchEventsTarget === "container" ? swiper.el : swiper.wrapperEl;
  swiper.isElement && (swiper.__preventObserver__ = !0), el.style.cursor = "move", el.style.cursor = moving ? "grabbing" : "grab", swiper.isElement && requestAnimationFrame(() => {
    swiper.__preventObserver__ = !1;
  });
}

// node_modules/swiper/core/grab-cursor/unsetGrabCursor.js
function unsetGrabCursor() {
  let swiper = this;
  swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode || (swiper.isElement && (swiper.__preventObserver__ = !0), swiper[swiper.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "", swiper.isElement && requestAnimationFrame(() => {
    swiper.__preventObserver__ = !1;
  }));
}

// node_modules/swiper/core/grab-cursor/index.js
var grab_cursor_default = {
  setGrabCursor,
  unsetGrabCursor
};

// node_modules/swiper/core/events/onTouchStart.js
function closestElement(selector, base = this) {
  function __closestFrom(el) {
    if (!el || el === getDocument() || el === getWindow())
      return null;
    el.assignedSlot && (el = el.assignedSlot);
    let found = el.closest(selector);
    return !found && !el.getRootNode ? null : found || __closestFrom(el.getRootNode().host);
  }
  return __closestFrom(base);
}
function onTouchStart(event2) {
  let swiper = this, document2 = getDocument(), window2 = getWindow(), data2 = swiper.touchEventsData;
  data2.evCache.push(event2);
  let {
    params,
    touches,
    enabled
  } = swiper;
  if (!enabled || !params.simulateTouch && event2.pointerType === "mouse" || swiper.animating && params.preventInteractionOnTransition)
    return;
  !swiper.animating && params.cssMode && params.loop && swiper.loopFix();
  let e3 = event2;
  e3.originalEvent && (e3 = e3.originalEvent);
  let targetEl = e3.target;
  if (params.touchEventsTarget === "wrapper" && !swiper.wrapperEl.contains(targetEl) || "which" in e3 && e3.which === 3 || "button" in e3 && e3.button > 0 || data2.isTouched && data2.isMoved)
    return;
  let swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== "", eventPath = event2.composedPath ? event2.composedPath() : event2.path;
  swipingClassHasValue && e3.target && e3.target.shadowRoot && eventPath && (targetEl = eventPath[0]);
  let noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`, isTargetShadow = !!(e3.target && e3.target.shadowRoot);
  if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {
    swiper.allowClick = !0;
    return;
  }
  if (params.swipeHandler && !targetEl.closest(params.swipeHandler))
    return;
  touches.currentX = e3.pageX, touches.currentY = e3.pageY;
  let startX = touches.currentX, startY = touches.currentY, edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection, edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
  if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window2.innerWidth - edgeSwipeThreshold))
    if (edgeSwipeDetection === "prevent")
      event2.preventDefault();
    else
      return;
  Object.assign(data2, {
    isTouched: !0,
    isMoved: !1,
    allowTouchCallbacks: !0,
    isScrolling: void 0,
    startMoving: void 0
  }), touches.startX = startX, touches.startY = startY, data2.touchStartTime = now(), swiper.allowClick = !0, swiper.updateSize(), swiper.swipeDirection = void 0, params.threshold > 0 && (data2.allowThresholdMove = !1);
  let preventDefault = !0;
  targetEl.matches(data2.focusableElements) && (preventDefault = !1, targetEl.nodeName === "SELECT" && (data2.isTouched = !1)), document2.activeElement && document2.activeElement.matches(data2.focusableElements) && document2.activeElement !== targetEl && document2.activeElement.blur();
  let shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
  (params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable && e3.preventDefault(), swiper.params.freeMode && swiper.params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode && swiper.freeMode.onTouchStart(), swiper.emit("touchStart", e3);
}

// node_modules/swiper/core/events/onTouchMove.js
function onTouchMove(event2) {
  let document2 = getDocument(), swiper = this, data2 = swiper.touchEventsData, {
    params,
    touches,
    rtlTranslate: rtl,
    enabled
  } = swiper;
  if (!enabled || !params.simulateTouch && event2.pointerType === "mouse")
    return;
  let e3 = event2;
  if (e3.originalEvent && (e3 = e3.originalEvent), !data2.isTouched) {
    data2.startMoving && data2.isScrolling && swiper.emit("touchMoveOpposite", e3);
    return;
  }
  let pointerIndex = data2.evCache.findIndex((cachedEv) => cachedEv.pointerId === e3.pointerId);
  pointerIndex >= 0 && (data2.evCache[pointerIndex] = e3);
  let targetTouch = data2.evCache.length > 1 ? data2.evCache[0] : e3, pageX = targetTouch.pageX, pageY = targetTouch.pageY;
  if (e3.preventedByNestedSwiper) {
    touches.startX = pageX, touches.startY = pageY;
    return;
  }
  if (!swiper.allowTouchMove) {
    e3.target.matches(data2.focusableElements) || (swiper.allowClick = !1), data2.isTouched && (Object.assign(touches, {
      startX: pageX,
      startY: pageY,
      prevX: swiper.touches.currentX,
      prevY: swiper.touches.currentY,
      currentX: pageX,
      currentY: pageY
    }), data2.touchStartTime = now());
    return;
  }
  if (params.touchReleaseOnEdges && !params.loop) {
    if (swiper.isVertical()) {
      if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
        data2.isTouched = !1, data2.isMoved = !1;
        return;
      }
    } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate())
      return;
  }
  if (document2.activeElement && e3.target === document2.activeElement && e3.target.matches(data2.focusableElements)) {
    data2.isMoved = !0, swiper.allowClick = !1;
    return;
  }
  if (data2.allowTouchCallbacks && swiper.emit("touchMove", e3), e3.targetTouches && e3.targetTouches.length > 1)
    return;
  touches.currentX = pageX, touches.currentY = pageY;
  let diffX = touches.currentX - touches.startX, diffY = touches.currentY - touches.startY;
  if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold)
    return;
  if (typeof data2.isScrolling > "u") {
    let touchAngle;
    swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX ? data2.isScrolling = !1 : diffX * diffX + diffY * diffY >= 25 && (touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI, data2.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle);
  }
  if (data2.isScrolling && swiper.emit("touchMoveOpposite", e3), typeof data2.startMoving > "u" && (touches.currentX !== touches.startX || touches.currentY !== touches.startY) && (data2.startMoving = !0), data2.isScrolling || swiper.zoom && swiper.params.zoom && swiper.params.zoom.enabled && data2.evCache.length > 1) {
    data2.isTouched = !1;
    return;
  }
  if (!data2.startMoving)
    return;
  swiper.allowClick = !1, !params.cssMode && e3.cancelable && e3.preventDefault(), params.touchMoveStopPropagation && !params.nested && e3.stopPropagation();
  let diff = swiper.isHorizontal() ? diffX : diffY, touchesDiff = swiper.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;
  params.oneWayMovement && (diff = Math.abs(diff) * (rtl ? 1 : -1), touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1)), touches.diff = diff, diff *= params.touchRatio, rtl && (diff = -diff, touchesDiff = -touchesDiff);
  let prevTouchesDirection = swiper.touchesDirection;
  swiper.swipeDirection = diff > 0 ? "prev" : "next", swiper.touchesDirection = touchesDiff > 0 ? "prev" : "next";
  let isLoop = swiper.params.loop && !params.cssMode;
  if (!data2.isMoved) {
    if (isLoop && swiper.loopFix({
      direction: swiper.swipeDirection
    }), data2.startTranslate = swiper.getTranslate(), swiper.setTransition(0), swiper.animating) {
      let evt = new window.CustomEvent("transitionend", {
        bubbles: !0,
        cancelable: !0
      });
      swiper.wrapperEl.dispatchEvent(evt);
    }
    data2.allowMomentumBounce = !1, params.grabCursor && (swiper.allowSlideNext === !0 || swiper.allowSlidePrev === !0) && swiper.setGrabCursor(!0), swiper.emit("sliderFirstMove", e3);
  }
  let loopFixed;
  data2.isMoved && prevTouchesDirection !== swiper.touchesDirection && isLoop && Math.abs(diff) >= 1 && (swiper.loopFix({
    direction: swiper.swipeDirection,
    setTranslate: !0
  }), loopFixed = !0), swiper.emit("sliderMove", e3), data2.isMoved = !0, data2.currentTranslate = diff + data2.startTranslate;
  let disableParentSwiper = !0, resistanceRatio = params.resistanceRatio;
  if (params.touchReleaseOnEdges && (resistanceRatio = 0), diff > 0 ? (isLoop && !loopFixed && data2.currentTranslate > (params.centeredSlides ? swiper.minTranslate() - swiper.size / 2 : swiper.minTranslate()) && swiper.loopFix({
    direction: "prev",
    setTranslate: !0,
    activeSlideIndex: 0
  }), data2.currentTranslate > swiper.minTranslate() && (disableParentSwiper = !1, params.resistance && (data2.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data2.startTranslate + diff) ** resistanceRatio))) : diff < 0 && (isLoop && !loopFixed && data2.currentTranslate < (params.centeredSlides ? swiper.maxTranslate() + swiper.size / 2 : swiper.maxTranslate()) && swiper.loopFix({
    direction: "next",
    setTranslate: !0,
    activeSlideIndex: swiper.slides.length - (params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))
  }), data2.currentTranslate < swiper.maxTranslate() && (disableParentSwiper = !1, params.resistance && (data2.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data2.startTranslate - diff) ** resistanceRatio))), disableParentSwiper && (e3.preventedByNestedSwiper = !0), !swiper.allowSlideNext && swiper.swipeDirection === "next" && data2.currentTranslate < data2.startTranslate && (data2.currentTranslate = data2.startTranslate), !swiper.allowSlidePrev && swiper.swipeDirection === "prev" && data2.currentTranslate > data2.startTranslate && (data2.currentTranslate = data2.startTranslate), !swiper.allowSlidePrev && !swiper.allowSlideNext && (data2.currentTranslate = data2.startTranslate), params.threshold > 0)
    if (Math.abs(diff) > params.threshold || data2.allowThresholdMove) {
      if (!data2.allowThresholdMove) {
        data2.allowThresholdMove = !0, touches.startX = touches.currentX, touches.startY = touches.currentY, data2.currentTranslate = data2.startTranslate, touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
        return;
      }
    } else {
      data2.currentTranslate = data2.startTranslate;
      return;
    }
  !params.followFinger || params.cssMode || ((params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) && (swiper.updateActiveIndex(), swiper.updateSlidesClasses()), swiper.params.freeMode && params.freeMode.enabled && swiper.freeMode && swiper.freeMode.onTouchMove(), swiper.updateProgress(data2.currentTranslate), swiper.setTranslate(data2.currentTranslate));
}

// node_modules/swiper/core/events/onTouchEnd.js
function onTouchEnd(event2) {
  let swiper = this, data2 = swiper.touchEventsData, pointerIndex = data2.evCache.findIndex((cachedEv) => cachedEv.pointerId === event2.pointerId);
  if (pointerIndex >= 0 && data2.evCache.splice(pointerIndex, 1), ["pointercancel", "pointerout", "pointerleave"].includes(event2.type) && !(event2.type === "pointercancel" && (swiper.browser.isSafari || swiper.browser.isWebView)))
    return;
  let {
    params,
    touches,
    rtlTranslate: rtl,
    slidesGrid,
    enabled
  } = swiper;
  if (!enabled || !params.simulateTouch && event2.pointerType === "mouse")
    return;
  let e3 = event2;
  if (e3.originalEvent && (e3 = e3.originalEvent), data2.allowTouchCallbacks && swiper.emit("touchEnd", e3), data2.allowTouchCallbacks = !1, !data2.isTouched) {
    data2.isMoved && params.grabCursor && swiper.setGrabCursor(!1), data2.isMoved = !1, data2.startMoving = !1;
    return;
  }
  params.grabCursor && data2.isMoved && data2.isTouched && (swiper.allowSlideNext === !0 || swiper.allowSlidePrev === !0) && swiper.setGrabCursor(!1);
  let touchEndTime = now(), timeDiff = touchEndTime - data2.touchStartTime;
  if (swiper.allowClick) {
    let pathTree = e3.path || e3.composedPath && e3.composedPath();
    swiper.updateClickedSlide(pathTree && pathTree[0] || e3.target), swiper.emit("tap click", e3), timeDiff < 300 && touchEndTime - data2.lastClickTime < 300 && swiper.emit("doubleTap doubleClick", e3);
  }
  if (data2.lastClickTime = now(), nextTick2(() => {
    swiper.destroyed || (swiper.allowClick = !0);
  }), !data2.isTouched || !data2.isMoved || !swiper.swipeDirection || touches.diff === 0 || data2.currentTranslate === data2.startTranslate) {
    data2.isTouched = !1, data2.isMoved = !1, data2.startMoving = !1;
    return;
  }
  data2.isTouched = !1, data2.isMoved = !1, data2.startMoving = !1;
  let currentPos;
  if (params.followFinger ? currentPos = rtl ? swiper.translate : -swiper.translate : currentPos = -data2.currentTranslate, params.cssMode)
    return;
  if (swiper.params.freeMode && params.freeMode.enabled) {
    swiper.freeMode.onTouchEnd({
      currentPos
    });
    return;
  }
  let stopIndex = 0, groupSize = swiper.slidesSizesGrid[0];
  for (let i3 = 0; i3 < slidesGrid.length; i3 += i3 < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
    let increment2 = i3 < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
    typeof slidesGrid[i3 + increment2] < "u" ? currentPos >= slidesGrid[i3] && currentPos < slidesGrid[i3 + increment2] && (stopIndex = i3, groupSize = slidesGrid[i3 + increment2] - slidesGrid[i3]) : currentPos >= slidesGrid[i3] && (stopIndex = i3, groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2]);
  }
  let rewindFirstIndex = null, rewindLastIndex = null;
  params.rewind && (swiper.isBeginning ? rewindLastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1 : swiper.isEnd && (rewindFirstIndex = 0));
  let ratio = (currentPos - slidesGrid[stopIndex]) / groupSize, increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
  if (timeDiff > params.longSwipesMs) {
    if (!params.longSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    swiper.swipeDirection === "next" && (ratio >= params.longSwipesRatio ? swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment) : swiper.slideTo(stopIndex)), swiper.swipeDirection === "prev" && (ratio > 1 - params.longSwipesRatio ? swiper.slideTo(stopIndex + increment) : rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio ? swiper.slideTo(rewindLastIndex) : swiper.slideTo(stopIndex));
  } else {
    if (!params.shortSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    swiper.navigation && (e3.target === swiper.navigation.nextEl || e3.target === swiper.navigation.prevEl) ? e3.target === swiper.navigation.nextEl ? swiper.slideTo(stopIndex + increment) : swiper.slideTo(stopIndex) : (swiper.swipeDirection === "next" && swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment), swiper.swipeDirection === "prev" && swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex));
  }
}

// node_modules/swiper/core/events/onResize.js
var timeout;
function onResize() {
  let swiper = this, {
    params,
    el
  } = swiper;
  if (el && el.offsetWidth === 0)
    return;
  params.breakpoints && swiper.setBreakpoint();
  let {
    allowSlideNext,
    allowSlidePrev,
    snapGrid
  } = swiper, isVirtual = swiper.virtual && swiper.params.virtual.enabled;
  swiper.allowSlideNext = !0, swiper.allowSlidePrev = !0, swiper.updateSize(), swiper.updateSlides(), swiper.updateSlidesClasses();
  let isVirtualLoop = isVirtual && params.loop;
  (params.slidesPerView === "auto" || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides && !isVirtualLoop ? swiper.slideTo(swiper.slides.length - 1, 0, !1, !0) : swiper.params.loop && !isVirtual ? swiper.slideToLoop(swiper.realIndex, 0, !1, !0) : swiper.slideTo(swiper.activeIndex, 0, !1, !0), swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused && (clearTimeout(timeout), timeout = setTimeout(() => {
    swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused && swiper.autoplay.resume();
  }, 500)), swiper.allowSlidePrev = allowSlidePrev, swiper.allowSlideNext = allowSlideNext, swiper.params.watchOverflow && snapGrid !== swiper.snapGrid && swiper.checkOverflow();
}

// node_modules/swiper/core/events/onClick.js
function onClick(e3) {
  let swiper = this;
  !swiper.enabled || swiper.allowClick || (swiper.params.preventClicks && e3.preventDefault(), swiper.params.preventClicksPropagation && swiper.animating && (e3.stopPropagation(), e3.stopImmediatePropagation()));
}

// node_modules/swiper/core/events/onScroll.js
function onScroll() {
  let swiper = this, {
    wrapperEl,
    rtlTranslate,
    enabled
  } = swiper;
  if (!enabled)
    return;
  swiper.previousTranslate = swiper.translate, swiper.isHorizontal() ? swiper.translate = -wrapperEl.scrollLeft : swiper.translate = -wrapperEl.scrollTop, swiper.translate === 0 && (swiper.translate = 0), swiper.updateActiveIndex(), swiper.updateSlidesClasses();
  let newProgress, translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  translatesDiff === 0 ? newProgress = 0 : newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff, newProgress !== swiper.progress && swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate), swiper.emit("setTranslate", swiper.translate, !1);
}

// node_modules/swiper/core/events/onLoad.js
function onLoad(e3) {
  let swiper = this;
  processLazyPreloader(swiper, e3.target), swiper.update();
}

// node_modules/swiper/core/events/index.js
var dummyEventAttached = !1;
function dummyEventListener() {
}
var events = (swiper, method) => {
  let document2 = getDocument(), {
    params,
    el,
    wrapperEl,
    device
  } = swiper, capture = !!params.nested, domMethod = method === "on" ? "addEventListener" : "removeEventListener", swiperMethod = method;
  el[domMethod]("pointerdown", swiper.onTouchStart, {
    passive: !1
  }), document2[domMethod]("pointermove", swiper.onTouchMove, {
    passive: !1,
    capture
  }), document2[domMethod]("pointerup", swiper.onTouchEnd, {
    passive: !0
  }), document2[domMethod]("pointercancel", swiper.onTouchEnd, {
    passive: !0
  }), document2[domMethod]("pointerout", swiper.onTouchEnd, {
    passive: !0
  }), document2[domMethod]("pointerleave", swiper.onTouchEnd, {
    passive: !0
  }), (params.preventClicks || params.preventClicksPropagation) && el[domMethod]("click", swiper.onClick, !0), params.cssMode && wrapperEl[domMethod]("scroll", swiper.onScroll), params.updateOnWindowResize ? swiper[swiperMethod](device.ios || device.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize, !0) : swiper[swiperMethod]("observerUpdate", onResize, !0), el[domMethod]("load", swiper.onLoad, {
    capture: !0
  });
};
function attachEvents() {
  let swiper = this, document2 = getDocument(), {
    params
  } = swiper;
  swiper.onTouchStart = onTouchStart.bind(swiper), swiper.onTouchMove = onTouchMove.bind(swiper), swiper.onTouchEnd = onTouchEnd.bind(swiper), params.cssMode && (swiper.onScroll = onScroll.bind(swiper)), swiper.onClick = onClick.bind(swiper), swiper.onLoad = onLoad.bind(swiper), dummyEventAttached || (document2.addEventListener("touchstart", dummyEventListener), dummyEventAttached = !0), events(swiper, "on");
}
function detachEvents() {
  events(this, "off");
}
var events_default2 = {
  attachEvents,
  detachEvents
};

// node_modules/swiper/core/breakpoints/setBreakpoint.js
var isGridEnabled = (swiper, params) => swiper.grid && params.grid && params.grid.rows > 1;
function setBreakpoint() {
  let swiper = this, {
    realIndex,
    initialized,
    params,
    el
  } = swiper, breakpoints = params.breakpoints;
  if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0)
    return;
  let breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);
  if (!breakpoint || swiper.currentBreakpoint === breakpoint)
    return;
  let breakpointParams = (breakpoint in breakpoints ? breakpoints[breakpoint] : void 0) || swiper.originalParams, wasMultiRow = isGridEnabled(swiper, params), isMultiRow = isGridEnabled(swiper, breakpointParams), wasEnabled = params.enabled;
  wasMultiRow && !isMultiRow ? (el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`), swiper.emitContainerClasses()) : !wasMultiRow && isMultiRow && (el.classList.add(`${params.containerModifierClass}grid`), (breakpointParams.grid.fill && breakpointParams.grid.fill === "column" || !breakpointParams.grid.fill && params.grid.fill === "column") && el.classList.add(`${params.containerModifierClass}grid-column`), swiper.emitContainerClasses()), ["navigation", "pagination", "scrollbar"].forEach((prop) => {
    let wasModuleEnabled = params[prop] && params[prop].enabled, isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;
    wasModuleEnabled && !isModuleEnabled && swiper[prop].disable(), !wasModuleEnabled && isModuleEnabled && swiper[prop].enable();
  });
  let directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction, needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
  directionChanged && initialized && swiper.changeDirection(), extend4(swiper.params, breakpointParams);
  let isEnabled = swiper.params.enabled;
  Object.assign(swiper, {
    allowTouchMove: swiper.params.allowTouchMove,
    allowSlideNext: swiper.params.allowSlideNext,
    allowSlidePrev: swiper.params.allowSlidePrev
  }), wasEnabled && !isEnabled ? swiper.disable() : !wasEnabled && isEnabled && swiper.enable(), swiper.currentBreakpoint = breakpoint, swiper.emit("_beforeBreakpoint", breakpointParams), needsReLoop && initialized && (swiper.loopDestroy(), swiper.loopCreate(realIndex), swiper.updateSlides()), swiper.emit("breakpoint", breakpointParams);
}

// node_modules/swiper/core/breakpoints/getBreakpoint.js
function getBreakpoint(breakpoints, base = "window", containerEl) {
  if (!breakpoints || base === "container" && !containerEl)
    return;
  let breakpoint = !1, window2 = getWindow(), currentHeight = base === "window" ? window2.innerHeight : containerEl.clientHeight, points = Object.keys(breakpoints).map((point) => {
    if (typeof point == "string" && point.indexOf("@") === 0) {
      let minRatio = parseFloat(point.substr(1));
      return {
        value: currentHeight * minRatio,
        point
      };
    }
    return {
      value: point,
      point
    };
  });
  points.sort((a3, b2) => parseInt(a3.value, 10) - parseInt(b2.value, 10));
  for (let i3 = 0; i3 < points.length; i3 += 1) {
    let {
      point,
      value: value2
    } = points[i3];
    base === "window" ? window2.matchMedia(`(min-width: ${value2}px)`).matches && (breakpoint = point) : value2 <= containerEl.clientWidth && (breakpoint = point);
  }
  return breakpoint || "max";
}

// node_modules/swiper/core/breakpoints/index.js
var breakpoints_default = {
  setBreakpoint,
  getBreakpoint
};

// node_modules/swiper/core/classes/addClasses.js
function prepareClasses(entries, prefix) {
  let resultClasses = [];
  return entries.forEach((item) => {
    typeof item == "object" ? Object.keys(item).forEach((classNames) => {
      item[classNames] && resultClasses.push(prefix + classNames);
    }) : typeof item == "string" && resultClasses.push(prefix + item);
  }), resultClasses;
}
function addClasses() {
  let swiper = this, {
    classNames,
    params,
    rtl,
    el,
    device
  } = swiper, suffixes = prepareClasses(["initialized", params.direction, {
    "free-mode": swiper.params.freeMode && params.freeMode.enabled
  }, {
    autoheight: params.autoHeight
  }, {
    rtl
  }, {
    grid: params.grid && params.grid.rows > 1
  }, {
    "grid-column": params.grid && params.grid.rows > 1 && params.grid.fill === "column"
  }, {
    android: device.android
  }, {
    ios: device.ios
  }, {
    "css-mode": params.cssMode
  }, {
    centered: params.cssMode && params.centeredSlides
  }, {
    "watch-progress": params.watchSlidesProgress
  }], params.containerModifierClass);
  classNames.push(...suffixes), el.classList.add(...classNames), swiper.emitContainerClasses();
}

// node_modules/swiper/core/classes/removeClasses.js
function removeClasses() {
  let swiper = this, {
    el,
    classNames
  } = swiper;
  el.classList.remove(...classNames), swiper.emitContainerClasses();
}

// node_modules/swiper/core/classes/index.js
var classes_default = {
  addClasses,
  removeClasses
};

// node_modules/swiper/core/check-overflow/index.js
function checkOverflow() {
  let swiper = this, {
    isLocked: wasLocked,
    params
  } = swiper, {
    slidesOffsetBefore
  } = params;
  if (slidesOffsetBefore) {
    let lastSlideIndex = swiper.slides.length - 1, lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
    swiper.isLocked = swiper.size > lastSlideRightEdge;
  } else
    swiper.isLocked = swiper.snapGrid.length === 1;
  params.allowSlideNext === !0 && (swiper.allowSlideNext = !swiper.isLocked), params.allowSlidePrev === !0 && (swiper.allowSlidePrev = !swiper.isLocked), wasLocked && wasLocked !== swiper.isLocked && (swiper.isEnd = !1), wasLocked !== swiper.isLocked && swiper.emit(swiper.isLocked ? "lock" : "unlock");
}
var check_overflow_default = {
  checkOverflow
};

// node_modules/swiper/core/defaults.js
var defaults_default = {
  init: !0,
  direction: "horizontal",
  oneWayMovement: !1,
  touchEventsTarget: "wrapper",
  initialSlide: 0,
  speed: 300,
  cssMode: !1,
  updateOnWindowResize: !0,
  resizeObserver: !0,
  nested: !1,
  createElements: !1,
  enabled: !0,
  focusableElements: "input, select, option, textarea, button, video, label",
  width: null,
  height: null,
  preventInteractionOnTransition: !1,
  userAgent: null,
  url: null,
  edgeSwipeDetection: !1,
  edgeSwipeThreshold: 20,
  autoHeight: !1,
  setWrapperSize: !1,
  virtualTranslate: !1,
  effect: "slide",
  breakpoints: void 0,
  breakpointsBase: "window",
  spaceBetween: 0,
  slidesPerView: 1,
  slidesPerGroup: 1,
  slidesPerGroupSkip: 0,
  slidesPerGroupAuto: !1,
  centeredSlides: !1,
  centeredSlidesBounds: !1,
  slidesOffsetBefore: 0,
  slidesOffsetAfter: 0,
  normalizeSlideIndex: !0,
  centerInsufficientSlides: !1,
  watchOverflow: !0,
  roundLengths: !1,
  touchRatio: 1,
  touchAngle: 45,
  simulateTouch: !0,
  shortSwipes: !0,
  longSwipes: !0,
  longSwipesRatio: 0.5,
  longSwipesMs: 300,
  followFinger: !0,
  allowTouchMove: !0,
  threshold: 5,
  touchMoveStopPropagation: !1,
  touchStartPreventDefault: !0,
  touchStartForcePreventDefault: !1,
  touchReleaseOnEdges: !1,
  uniqueNavElements: !0,
  resistance: !0,
  resistanceRatio: 0.85,
  watchSlidesProgress: !1,
  grabCursor: !1,
  preventClicks: !0,
  preventClicksPropagation: !0,
  slideToClickedSlide: !1,
  loop: !1,
  loopedSlides: null,
  loopPreventsSliding: !0,
  rewind: !1,
  allowSlidePrev: !0,
  allowSlideNext: !0,
  swipeHandler: null,
  noSwiping: !0,
  noSwipingClass: "swiper-no-swiping",
  noSwipingSelector: null,
  passiveListeners: !0,
  maxBackfaceHiddenSlides: 10,
  containerModifierClass: "swiper-",
  slideClass: "swiper-slide",
  slideActiveClass: "swiper-slide-active",
  slideVisibleClass: "swiper-slide-visible",
  slideNextClass: "swiper-slide-next",
  slidePrevClass: "swiper-slide-prev",
  wrapperClass: "swiper-wrapper",
  lazyPreloaderClass: "swiper-lazy-preloader",
  lazyPreloadPrevNext: 0,
  runCallbacksOnInit: !0,
  _emitClasses: !1
};

// node_modules/swiper/core/moduleExtendParams.js
function moduleExtendParams(params, allModulesParams) {
  return function(obj = {}) {
    let moduleParamName = Object.keys(obj)[0], moduleParams = obj[moduleParamName];
    if (typeof moduleParams != "object" || moduleParams === null) {
      extend4(allModulesParams, obj);
      return;
    }
    if (["navigation", "pagination", "scrollbar"].indexOf(moduleParamName) >= 0 && params[moduleParamName] === !0 && (params[moduleParamName] = {
      auto: !0
    }), !(moduleParamName in params && "enabled" in moduleParams)) {
      extend4(allModulesParams, obj);
      return;
    }
    params[moduleParamName] === !0 && (params[moduleParamName] = {
      enabled: !0
    }), typeof params[moduleParamName] == "object" && !("enabled" in params[moduleParamName]) && (params[moduleParamName].enabled = !0), params[moduleParamName] || (params[moduleParamName] = {
      enabled: !1
    }), extend4(allModulesParams, obj);
  };
}

// node_modules/swiper/core/core.js
var prototypes = {
  eventsEmitter: events_emitter_default,
  update: update_default,
  translate: translate_default,
  transition: transition_default,
  slide: slide_default,
  loop: loop_default,
  grabCursor: grab_cursor_default,
  events: events_default2,
  breakpoints: breakpoints_default,
  checkOverflow: check_overflow_default,
  classes: classes_default
}, extendedDefaults = {}, Swiper = class {
  constructor(...args) {
    let el, params;
    args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === "Object" ? params = args[0] : [el, params] = args, params || (params = {}), params = extend4({}, params), el && !params.el && (params.el = el);
    let document2 = getDocument();
    if (params.el && typeof params.el == "string" && document2.querySelectorAll(params.el).length > 1) {
      let swipers = [];
      return document2.querySelectorAll(params.el).forEach((containerEl) => {
        let newParams = extend4({}, params, {
          el: containerEl
        });
        swipers.push(new Swiper(newParams));
      }), swipers;
    }
    let swiper = this;
    swiper.__swiper__ = !0, swiper.support = getSupport(), swiper.device = getDevice({
      userAgent: params.userAgent
    }), swiper.browser = getBrowser(), swiper.eventsListeners = {}, swiper.eventsAnyListeners = [], swiper.modules = [...swiper.__modules__], params.modules && Array.isArray(params.modules) && swiper.modules.push(...params.modules);
    let allModulesParams = {};
    swiper.modules.forEach((mod) => {
      mod({
        params,
        swiper,
        extendParams: moduleExtendParams(params, allModulesParams),
        on: swiper.on.bind(swiper),
        once: swiper.once.bind(swiper),
        off: swiper.off.bind(swiper),
        emit: swiper.emit.bind(swiper)
      });
    });
    let swiperParams = extend4({}, defaults_default, allModulesParams);
    return swiper.params = extend4({}, swiperParams, extendedDefaults, params), swiper.originalParams = extend4({}, swiper.params), swiper.passedParams = extend4({}, params), swiper.params && swiper.params.on && Object.keys(swiper.params.on).forEach((eventName) => {
      swiper.on(eventName, swiper.params.on[eventName]);
    }), swiper.params && swiper.params.onAny && swiper.onAny(swiper.params.onAny), Object.assign(swiper, {
      enabled: swiper.params.enabled,
      el,
      classNames: [],
      slides: [],
      slidesGrid: [],
      snapGrid: [],
      slidesSizesGrid: [],
      isHorizontal() {
        return swiper.params.direction === "horizontal";
      },
      isVertical() {
        return swiper.params.direction === "vertical";
      },
      activeIndex: 0,
      realIndex: 0,
      isBeginning: !0,
      isEnd: !1,
      translate: 0,
      previousTranslate: 0,
      progress: 0,
      velocity: 0,
      animating: !1,
      allowSlideNext: swiper.params.allowSlideNext,
      allowSlidePrev: swiper.params.allowSlidePrev,
      touchEventsData: {
        isTouched: void 0,
        isMoved: void 0,
        allowTouchCallbacks: void 0,
        touchStartTime: void 0,
        isScrolling: void 0,
        currentTranslate: void 0,
        startTranslate: void 0,
        allowThresholdMove: void 0,
        focusableElements: swiper.params.focusableElements,
        lastClickTime: 0,
        clickTimeout: void 0,
        velocities: [],
        allowMomentumBounce: void 0,
        startMoving: void 0,
        evCache: []
      },
      allowClick: !0,
      allowTouchMove: swiper.params.allowTouchMove,
      touches: {
        startX: 0,
        startY: 0,
        currentX: 0,
        currentY: 0,
        diff: 0
      },
      imagesToLoad: [],
      imagesLoaded: 0
    }), swiper.emit("_swiper"), swiper.params.init && swiper.init(), swiper;
  }
  getSlideIndex(slideEl) {
    let {
      slidesEl,
      params
    } = this, slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`), firstSlideIndex = elementIndex(slides[0]);
    return elementIndex(slideEl) - firstSlideIndex;
  }
  getSlideIndexByData(index2) {
    return this.getSlideIndex(this.slides.filter((slideEl) => slideEl.getAttribute("data-swiper-slide-index") * 1 === index2)[0]);
  }
  recalcSlides() {
    let swiper = this, {
      slidesEl,
      params
    } = swiper;
    swiper.slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
  }
  enable() {
    let swiper = this;
    swiper.enabled || (swiper.enabled = !0, swiper.params.grabCursor && swiper.setGrabCursor(), swiper.emit("enable"));
  }
  disable() {
    let swiper = this;
    !swiper.enabled || (swiper.enabled = !1, swiper.params.grabCursor && swiper.unsetGrabCursor(), swiper.emit("disable"));
  }
  setProgress(progress2, speed) {
    let swiper = this;
    progress2 = Math.min(Math.max(progress2, 0), 1);
    let min = swiper.minTranslate(), current = (swiper.maxTranslate() - min) * progress2 + min;
    swiper.translateTo(current, typeof speed > "u" ? 0 : speed), swiper.updateActiveIndex(), swiper.updateSlidesClasses();
  }
  emitContainerClasses() {
    let swiper = this;
    if (!swiper.params._emitClasses || !swiper.el)
      return;
    let cls = swiper.el.className.split(" ").filter((className) => className.indexOf("swiper") === 0 || className.indexOf(swiper.params.containerModifierClass) === 0);
    swiper.emit("_containerClasses", cls.join(" "));
  }
  getSlideClasses(slideEl) {
    let swiper = this;
    return swiper.destroyed ? "" : slideEl.className.split(" ").filter((className) => className.indexOf("swiper-slide") === 0 || className.indexOf(swiper.params.slideClass) === 0).join(" ");
  }
  emitSlidesClasses() {
    let swiper = this;
    if (!swiper.params._emitClasses || !swiper.el)
      return;
    let updates = [];
    swiper.slides.forEach((slideEl) => {
      let classNames = swiper.getSlideClasses(slideEl);
      updates.push({
        slideEl,
        classNames
      }), swiper.emit("_slideClass", slideEl, classNames);
    }), swiper.emit("_slideClasses", updates);
  }
  slidesPerViewDynamic(view = "current", exact = !1) {
    let swiper = this, {
      params,
      slides,
      slidesGrid,
      slidesSizesGrid,
      size: swiperSize,
      activeIndex
    } = swiper, spv = 1;
    if (params.centeredSlides) {
      let slideSize = slides[activeIndex].swiperSlideSize, breakLoop;
      for (let i3 = activeIndex + 1; i3 < slides.length; i3 += 1)
        slides[i3] && !breakLoop && (slideSize += slides[i3].swiperSlideSize, spv += 1, slideSize > swiperSize && (breakLoop = !0));
      for (let i3 = activeIndex - 1; i3 >= 0; i3 -= 1)
        slides[i3] && !breakLoop && (slideSize += slides[i3].swiperSlideSize, spv += 1, slideSize > swiperSize && (breakLoop = !0));
    } else if (view === "current")
      for (let i3 = activeIndex + 1; i3 < slides.length; i3 += 1)
        (exact ? slidesGrid[i3] + slidesSizesGrid[i3] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i3] - slidesGrid[activeIndex] < swiperSize) && (spv += 1);
    else
      for (let i3 = activeIndex - 1; i3 >= 0; i3 -= 1)
        slidesGrid[activeIndex] - slidesGrid[i3] < swiperSize && (spv += 1);
    return spv;
  }
  update() {
    let swiper = this;
    if (!swiper || swiper.destroyed)
      return;
    let {
      snapGrid,
      params
    } = swiper;
    params.breakpoints && swiper.setBreakpoint(), [...swiper.el.querySelectorAll('[loading="lazy"]')].forEach((imageEl) => {
      imageEl.complete && processLazyPreloader(swiper, imageEl);
    }), swiper.updateSize(), swiper.updateSlides(), swiper.updateProgress(), swiper.updateSlidesClasses();
    function setTranslate2() {
      let translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate, newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
      swiper.setTranslate(newTranslate), swiper.updateActiveIndex(), swiper.updateSlidesClasses();
    }
    let translated;
    swiper.params.freeMode && swiper.params.freeMode.enabled ? (setTranslate2(), swiper.params.autoHeight && swiper.updateAutoHeight()) : ((swiper.params.slidesPerView === "auto" || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides ? translated = swiper.slideTo(swiper.slides.length - 1, 0, !1, !0) : translated = swiper.slideTo(swiper.activeIndex, 0, !1, !0), translated || setTranslate2()), params.watchOverflow && snapGrid !== swiper.snapGrid && swiper.checkOverflow(), swiper.emit("update");
  }
  changeDirection(newDirection, needUpdate = !0) {
    let swiper = this, currentDirection = swiper.params.direction;
    return newDirection || (newDirection = currentDirection === "horizontal" ? "vertical" : "horizontal"), newDirection === currentDirection || newDirection !== "horizontal" && newDirection !== "vertical" || (swiper.el.classList.remove(`${swiper.params.containerModifierClass}${currentDirection}`), swiper.el.classList.add(`${swiper.params.containerModifierClass}${newDirection}`), swiper.emitContainerClasses(), swiper.params.direction = newDirection, swiper.slides.forEach((slideEl) => {
      newDirection === "vertical" ? slideEl.style.width = "" : slideEl.style.height = "";
    }), swiper.emit("changeDirection"), needUpdate && swiper.update()), swiper;
  }
  changeLanguageDirection(direction) {
    let swiper = this;
    swiper.rtl && direction === "rtl" || !swiper.rtl && direction === "ltr" || (swiper.rtl = direction === "rtl", swiper.rtlTranslate = swiper.params.direction === "horizontal" && swiper.rtl, swiper.rtl ? (swiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`), swiper.el.dir = "rtl") : (swiper.el.classList.remove(`${swiper.params.containerModifierClass}rtl`), swiper.el.dir = "ltr"), swiper.update());
  }
  mount(element) {
    let swiper = this;
    if (swiper.mounted)
      return !0;
    let el = element || swiper.params.el;
    if (typeof el == "string" && (el = document.querySelector(el)), !el)
      return !1;
    el.swiper = swiper, el.shadowEl && (swiper.isElement = !0);
    let getWrapperSelector = () => `.${(swiper.params.wrapperClass || "").trim().split(" ").join(".")}`, wrapperEl = (() => el && el.shadowRoot && el.shadowRoot.querySelector ? el.shadowRoot.querySelector(getWrapperSelector()) : elementChildren(el, getWrapperSelector())[0])();
    return !wrapperEl && swiper.params.createElements && (wrapperEl = createElement17("div", swiper.params.wrapperClass), el.append(wrapperEl), elementChildren(el, `.${swiper.params.slideClass}`).forEach((slideEl) => {
      wrapperEl.append(slideEl);
    })), Object.assign(swiper, {
      el,
      wrapperEl,
      slidesEl: swiper.isElement ? el : wrapperEl,
      mounted: !0,
      rtl: el.dir.toLowerCase() === "rtl" || elementStyle(el, "direction") === "rtl",
      rtlTranslate: swiper.params.direction === "horizontal" && (el.dir.toLowerCase() === "rtl" || elementStyle(el, "direction") === "rtl"),
      wrongRTL: elementStyle(wrapperEl, "display") === "-webkit-box"
    }), !0;
  }
  init(el) {
    let swiper = this;
    return swiper.initialized || swiper.mount(el) === !1 || (swiper.emit("beforeInit"), swiper.params.breakpoints && swiper.setBreakpoint(), swiper.addClasses(), swiper.updateSize(), swiper.updateSlides(), swiper.params.watchOverflow && swiper.checkOverflow(), swiper.params.grabCursor && swiper.enabled && swiper.setGrabCursor(), swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled ? swiper.slideTo(swiper.params.initialSlide + swiper.virtual.slidesBefore, 0, swiper.params.runCallbacksOnInit, !1, !0) : swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, !1, !0), swiper.params.loop && swiper.loopCreate(), swiper.attachEvents(), [...swiper.el.querySelectorAll('[loading="lazy"]')].forEach((imageEl) => {
      imageEl.complete ? processLazyPreloader(swiper, imageEl) : imageEl.addEventListener("load", (e3) => {
        processLazyPreloader(swiper, e3.target);
      });
    }), preload(swiper), swiper.initialized = !0, preload(swiper), swiper.emit("init"), swiper.emit("afterInit")), swiper;
  }
  destroy(deleteInstance = !0, cleanStyles = !0) {
    let swiper = this, {
      params,
      el,
      wrapperEl,
      slides
    } = swiper;
    return typeof swiper.params > "u" || swiper.destroyed || (swiper.emit("beforeDestroy"), swiper.initialized = !1, swiper.detachEvents(), params.loop && swiper.loopDestroy(), cleanStyles && (swiper.removeClasses(), el.removeAttribute("style"), wrapperEl.removeAttribute("style"), slides && slides.length && slides.forEach((slideEl) => {
      slideEl.classList.remove(params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass), slideEl.removeAttribute("style"), slideEl.removeAttribute("data-swiper-slide-index");
    })), swiper.emit("destroy"), Object.keys(swiper.eventsListeners).forEach((eventName) => {
      swiper.off(eventName);
    }), deleteInstance !== !1 && (swiper.el.swiper = null, deleteProps(swiper)), swiper.destroyed = !0), null;
  }
  static extendDefaults(newDefaults) {
    extend4(extendedDefaults, newDefaults);
  }
  static get extendedDefaults() {
    return extendedDefaults;
  }
  static get defaults() {
    return defaults_default;
  }
  static installModule(mod) {
    Swiper.prototype.__modules__ || (Swiper.prototype.__modules__ = []);
    let modules = Swiper.prototype.__modules__;
    typeof mod == "function" && modules.indexOf(mod) < 0 && modules.push(mod);
  }
  static use(module2) {
    return Array.isArray(module2) ? (module2.forEach((m2) => Swiper.installModule(m2)), Swiper) : (Swiper.installModule(module2), Swiper);
  }
};
Object.keys(prototypes).forEach((prototypeGroup) => {
  Object.keys(prototypes[prototypeGroup]).forEach((protoMethod) => {
    Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
  });
});
Swiper.use([Resize, Observer]);
var core_default = Swiper;

// node_modules/swiper/shared/create-element-if-not-defined.js
function createElementIfNotDefined(swiper, originalParams, params, checkProps) {
  return swiper.params.createElements && Object.keys(checkProps).forEach((key2) => {
    if (!params[key2] && params.auto === !0) {
      let element = elementChildren(swiper.el, `.${checkProps[key2]}`)[0];
      element || (element = createElement17("div", checkProps[key2]), element.className = checkProps[key2], swiper.el.append(element)), params[key2] = element, originalParams[key2] = element;
    }
  }), params;
}

// node_modules/swiper/shared/classes-to-selector.js
function classesToSelector(classes = "") {
  return `.${classes.trim().replace(/([\.:!+\/])/g, "\\$1").replace(/ /g, ".")}`;
}

// node_modules/swiper/modules/pagination/pagination.js
function Pagination({
  swiper,
  extendParams,
  on: on2,
  emit: emit3
}) {
  let pfx = "swiper-pagination";
  extendParams({
    pagination: {
      el: null,
      bulletElement: "span",
      clickable: !1,
      hideOnClick: !1,
      renderBullet: null,
      renderProgressbar: null,
      renderFraction: null,
      renderCustom: null,
      progressbarOpposite: !1,
      type: "bullets",
      dynamicBullets: !1,
      dynamicMainBullets: 1,
      formatFractionCurrent: (number4) => number4,
      formatFractionTotal: (number4) => number4,
      bulletClass: `${pfx}-bullet`,
      bulletActiveClass: `${pfx}-bullet-active`,
      modifierClass: `${pfx}-`,
      currentClass: `${pfx}-current`,
      totalClass: `${pfx}-total`,
      hiddenClass: `${pfx}-hidden`,
      progressbarFillClass: `${pfx}-progressbar-fill`,
      progressbarOppositeClass: `${pfx}-progressbar-opposite`,
      clickableClass: `${pfx}-clickable`,
      lockClass: `${pfx}-lock`,
      horizontalClass: `${pfx}-horizontal`,
      verticalClass: `${pfx}-vertical`,
      paginationDisabledClass: `${pfx}-disabled`
    }
  }), swiper.pagination = {
    el: null,
    bullets: []
  };
  let bulletSize, dynamicBulletIndex = 0, makeElementsArray = (el) => (Array.isArray(el) || (el = [el].filter((e3) => !!e3)), el);
  function isPaginationDisabled() {
    return !swiper.params.pagination.el || !swiper.pagination.el || Array.isArray(swiper.pagination.el) && swiper.pagination.el.length === 0;
  }
  function setSideBullets(bulletEl, position) {
    let {
      bulletActiveClass
    } = swiper.params.pagination;
    !bulletEl || (bulletEl = bulletEl[`${position === "prev" ? "previous" : "next"}ElementSibling`], bulletEl && (bulletEl.classList.add(`${bulletActiveClass}-${position}`), bulletEl = bulletEl[`${position === "prev" ? "previous" : "next"}ElementSibling`], bulletEl && bulletEl.classList.add(`${bulletActiveClass}-${position}-${position}`)));
  }
  function onBulletClick(e3) {
    let bulletEl = e3.target.closest(classesToSelector(swiper.params.pagination.bulletClass));
    if (!bulletEl)
      return;
    e3.preventDefault();
    let index2 = elementIndex(bulletEl) * swiper.params.slidesPerGroup;
    if (swiper.params.loop) {
      if (swiper.realIndex === index2)
        return;
      (index2 < swiper.loopedSlides || index2 > swiper.slides.length - swiper.loopedSlides) && swiper.loopFix({
        direction: index2 < swiper.loopedSlides ? "prev" : "next",
        activeSlideIndex: index2,
        slideTo: !1
      }), swiper.slideToLoop(index2);
    } else
      swiper.slideTo(index2);
  }
  function update() {
    let rtl = swiper.rtl, params = swiper.params.pagination;
    if (isPaginationDisabled())
      return;
    let el = swiper.pagination.el;
    el = makeElementsArray(el);
    let current, slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length, total = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
    if (swiper.params.loop ? current = swiper.params.slidesPerGroup > 1 ? Math.floor(swiper.realIndex / swiper.params.slidesPerGroup) : swiper.realIndex : typeof swiper.snapIndex < "u" ? current = swiper.snapIndex : current = swiper.activeIndex || 0, params.type === "bullets" && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
      let bullets = swiper.pagination.bullets, firstIndex, lastIndex, midIndex;
      if (params.dynamicBullets && (bulletSize = elementOuterSize(bullets[0], swiper.isHorizontal() ? "width" : "height", !0), el.forEach((subEl) => {
        subEl.style[swiper.isHorizontal() ? "width" : "height"] = `${bulletSize * (params.dynamicMainBullets + 4)}px`;
      }), params.dynamicMainBullets > 1 && swiper.previousIndex !== void 0 && (dynamicBulletIndex += current - (swiper.previousIndex || 0), dynamicBulletIndex > params.dynamicMainBullets - 1 ? dynamicBulletIndex = params.dynamicMainBullets - 1 : dynamicBulletIndex < 0 && (dynamicBulletIndex = 0)), firstIndex = Math.max(current - dynamicBulletIndex, 0), lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1), midIndex = (lastIndex + firstIndex) / 2), bullets.forEach((bulletEl) => {
        let classesToRemove = [...["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map((suffix) => `${params.bulletActiveClass}${suffix}`)].map((s3) => typeof s3 == "string" && s3.includes(" ") ? s3.split(" ") : s3).flat();
        bulletEl.classList.remove(...classesToRemove);
      }), el.length > 1)
        bullets.forEach((bullet) => {
          let bulletIndex = elementIndex(bullet);
          bulletIndex === current && bullet.classList.add(...params.bulletActiveClass.split(" ")), params.dynamicBullets && (bulletIndex >= firstIndex && bulletIndex <= lastIndex && bullet.classList.add(...`${params.bulletActiveClass}-main`.split(" ")), bulletIndex === firstIndex && setSideBullets(bullet, "prev"), bulletIndex === lastIndex && setSideBullets(bullet, "next"));
        });
      else {
        let bullet = bullets[current];
        if (bullet && bullet.classList.add(...params.bulletActiveClass.split(" ")), params.dynamicBullets) {
          let firstDisplayedBullet = bullets[firstIndex], lastDisplayedBullet = bullets[lastIndex];
          for (let i3 = firstIndex; i3 <= lastIndex; i3 += 1)
            bullets[i3] && bullets[i3].classList.add(...`${params.bulletActiveClass}-main`.split(" "));
          setSideBullets(firstDisplayedBullet, "prev"), setSideBullets(lastDisplayedBullet, "next");
        }
      }
      if (params.dynamicBullets) {
        let dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4), bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize, offsetProp = rtl ? "right" : "left";
        bullets.forEach((bullet) => {
          bullet.style[swiper.isHorizontal() ? offsetProp : "top"] = `${bulletsOffset}px`;
        });
      }
    }
    el.forEach((subEl, subElIndex) => {
      if (params.type === "fraction" && (subEl.querySelectorAll(classesToSelector(params.currentClass)).forEach((fractionEl) => {
        fractionEl.textContent = params.formatFractionCurrent(current + 1);
      }), subEl.querySelectorAll(classesToSelector(params.totalClass)).forEach((totalEl) => {
        totalEl.textContent = params.formatFractionTotal(total);
      })), params.type === "progressbar") {
        let progressbarDirection;
        params.progressbarOpposite ? progressbarDirection = swiper.isHorizontal() ? "vertical" : "horizontal" : progressbarDirection = swiper.isHorizontal() ? "horizontal" : "vertical";
        let scale2 = (current + 1) / total, scaleX = 1, scaleY = 1;
        progressbarDirection === "horizontal" ? scaleX = scale2 : scaleY = scale2, subEl.querySelectorAll(classesToSelector(params.progressbarFillClass)).forEach((progressEl) => {
          progressEl.style.transform = `translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`, progressEl.style.transitionDuration = `${swiper.params.speed}ms`;
        });
      }
      params.type === "custom" && params.renderCustom ? (subEl.innerHTML = params.renderCustom(swiper, current + 1, total), subElIndex === 0 && emit3("paginationRender", subEl)) : (subElIndex === 0 && emit3("paginationRender", subEl), emit3("paginationUpdate", subEl)), swiper.params.watchOverflow && swiper.enabled && subEl.classList[swiper.isLocked ? "add" : "remove"](params.lockClass);
    });
  }
  function render() {
    let params = swiper.params.pagination;
    if (isPaginationDisabled())
      return;
    let slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length, el = swiper.pagination.el;
    el = makeElementsArray(el);
    let paginationHTML = "";
    if (params.type === "bullets") {
      let numberOfBullets = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
      swiper.params.freeMode && swiper.params.freeMode.enabled && numberOfBullets > slidesLength && (numberOfBullets = slidesLength);
      for (let i3 = 0; i3 < numberOfBullets; i3 += 1)
        params.renderBullet ? paginationHTML += params.renderBullet.call(swiper, i3, params.bulletClass) : paginationHTML += `<${params.bulletElement} class="${params.bulletClass}"></${params.bulletElement}>`;
    }
    params.type === "fraction" && (params.renderFraction ? paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass) : paginationHTML = `<span class="${params.currentClass}"></span> / <span class="${params.totalClass}"></span>`), params.type === "progressbar" && (params.renderProgressbar ? paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass) : paginationHTML = `<span class="${params.progressbarFillClass}"></span>`), swiper.pagination.bullets = [], el.forEach((subEl) => {
      params.type !== "custom" && (subEl.innerHTML = paginationHTML || ""), params.type === "bullets" && swiper.pagination.bullets.push(...subEl.querySelectorAll(classesToSelector(params.bulletClass)));
    }), params.type !== "custom" && emit3("paginationRender", el[0]);
  }
  function init4() {
    swiper.params.pagination = createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {
      el: "swiper-pagination"
    });
    let params = swiper.params.pagination;
    if (!params.el)
      return;
    let el;
    typeof params.el == "string" && swiper.isElement && (el = swiper.el.shadowRoot.querySelector(params.el)), !el && typeof params.el == "string" && (el = [...document.querySelectorAll(params.el)]), el || (el = params.el), !(!el || el.length === 0) && (swiper.params.uniqueNavElements && typeof params.el == "string" && Array.isArray(el) && el.length > 1 && (el = [...swiper.el.querySelectorAll(params.el)], el.length > 1 && (el = el.filter((subEl) => elementParents(subEl, ".swiper")[0] === swiper.el)[0])), Array.isArray(el) && el.length === 1 && (el = el[0]), Object.assign(swiper.pagination, {
      el
    }), el = makeElementsArray(el), el.forEach((subEl) => {
      params.type === "bullets" && params.clickable && subEl.classList.add(params.clickableClass), subEl.classList.add(params.modifierClass + params.type), subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass), params.type === "bullets" && params.dynamicBullets && (subEl.classList.add(`${params.modifierClass}${params.type}-dynamic`), dynamicBulletIndex = 0, params.dynamicMainBullets < 1 && (params.dynamicMainBullets = 1)), params.type === "progressbar" && params.progressbarOpposite && subEl.classList.add(params.progressbarOppositeClass), params.clickable && subEl.addEventListener("click", onBulletClick), swiper.enabled || subEl.classList.add(params.lockClass);
    }));
  }
  function destroy() {
    let params = swiper.params.pagination;
    if (isPaginationDisabled())
      return;
    let el = swiper.pagination.el;
    el && (el = makeElementsArray(el), el.forEach((subEl) => {
      subEl.classList.remove(params.hiddenClass), subEl.classList.remove(params.modifierClass + params.type), subEl.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass), params.clickable && subEl.removeEventListener("click", onBulletClick);
    })), swiper.pagination.bullets && swiper.pagination.bullets.forEach((subEl) => subEl.classList.remove(...params.bulletActiveClass.split(" ")));
  }
  on2("init", () => {
    swiper.params.pagination.enabled === !1 ? disable() : (init4(), render(), update());
  }), on2("activeIndexChange", () => {
    typeof swiper.snapIndex > "u" && update();
  }), on2("snapIndexChange", () => {
    update();
  }), on2("snapGridLengthChange", () => {
    render(), update();
  }), on2("destroy", () => {
    destroy();
  }), on2("enable disable", () => {
    let {
      el
    } = swiper.pagination;
    el && (el = makeElementsArray(el), el.forEach((subEl) => subEl.classList[swiper.enabled ? "remove" : "add"](swiper.params.pagination.lockClass)));
  }), on2("lock unlock", () => {
    update();
  }), on2("click", (_s, e3) => {
    let targetEl = e3.target, {
      el
    } = swiper.pagination;
    if (Array.isArray(el) || (el = [el].filter((element) => !!element)), swiper.params.pagination.el && swiper.params.pagination.hideOnClick && el && el.length > 0 && !targetEl.classList.contains(swiper.params.pagination.bulletClass)) {
      if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl))
        return;
      let isHidden = el[0].classList.contains(swiper.params.pagination.hiddenClass);
      emit3(isHidden === !0 ? "paginationShow" : "paginationHide"), el.forEach((subEl) => subEl.classList.toggle(swiper.params.pagination.hiddenClass));
    }
  });
  let enable = () => {
    swiper.el.classList.remove(swiper.params.pagination.paginationDisabledClass);
    let {
      el
    } = swiper.pagination;
    el && (el = makeElementsArray(el), el.forEach((subEl) => subEl.classList.remove(swiper.params.pagination.paginationDisabledClass))), init4(), render(), update();
  }, disable = () => {
    swiper.el.classList.add(swiper.params.pagination.paginationDisabledClass);
    let {
      el
    } = swiper.pagination;
    el && (el = makeElementsArray(el), el.forEach((subEl) => subEl.classList.add(swiper.params.pagination.paginationDisabledClass))), destroy();
  };
  Object.assign(swiper.pagination, {
    enable,
    disable,
    render,
    update,
    init: init4,
    destroy
  });
}

// node_modules/swiper/react/swiper.js
var import_react55 = __toESM(require_react(), 1);

// node_modules/swiper/components-shared/utils.js
function isObject5(o2) {
  return typeof o2 == "object" && o2 !== null && o2.constructor && Object.prototype.toString.call(o2).slice(8, -1) === "Object";
}
function extend5(target, src) {
  let noExtend = ["__proto__", "constructor", "prototype"];
  Object.keys(src).filter((key2) => noExtend.indexOf(key2) < 0).forEach((key2) => {
    typeof target[key2] > "u" ? target[key2] = src[key2] : isObject5(src[key2]) && isObject5(target[key2]) && Object.keys(src[key2]).length > 0 ? src[key2].__swiper__ ? target[key2] = src[key2] : extend5(target[key2], src[key2]) : target[key2] = src[key2];
  });
}
function needsNavigation(params = {}) {
  return params.navigation && typeof params.navigation.nextEl > "u" && typeof params.navigation.prevEl > "u";
}
function needsPagination(params = {}) {
  return params.pagination && typeof params.pagination.el > "u";
}
function needsScrollbar(params = {}) {
  return params.scrollbar && typeof params.scrollbar.el > "u";
}
function uniqueClasses(classNames = "") {
  let classes = classNames.split(" ").map((c4) => c4.trim()).filter((c4) => !!c4), unique = [];
  return classes.forEach((c4) => {
    unique.indexOf(c4) < 0 && unique.push(c4);
  }), unique.join(" ");
}
function wrapperClass(className = "") {
  return className ? className.includes("swiper-wrapper") ? className : `swiper-wrapper ${className}` : "swiper-wrapper";
}

// node_modules/swiper/components-shared/params-list.js
var paramsList = [
  "eventsPrefix",
  "modules",
  "init",
  "_direction",
  "oneWayMovement",
  "touchEventsTarget",
  "initialSlide",
  "_speed",
  "cssMode",
  "updateOnWindowResize",
  "resizeObserver",
  "nested",
  "focusableElements",
  "_enabled",
  "_width",
  "_height",
  "preventInteractionOnTransition",
  "userAgent",
  "url",
  "_edgeSwipeDetection",
  "_edgeSwipeThreshold",
  "_freeMode",
  "_autoHeight",
  "setWrapperSize",
  "virtualTranslate",
  "_effect",
  "breakpoints",
  "_spaceBetween",
  "_slidesPerView",
  "maxBackfaceHiddenSlides",
  "_grid",
  "_slidesPerGroup",
  "_slidesPerGroupSkip",
  "_slidesPerGroupAuto",
  "_centeredSlides",
  "_centeredSlidesBounds",
  "_slidesOffsetBefore",
  "_slidesOffsetAfter",
  "normalizeSlideIndex",
  "_centerInsufficientSlides",
  "_watchOverflow",
  "roundLengths",
  "touchRatio",
  "touchAngle",
  "simulateTouch",
  "_shortSwipes",
  "_longSwipes",
  "longSwipesRatio",
  "longSwipesMs",
  "_followFinger",
  "allowTouchMove",
  "_threshold",
  "touchMoveStopPropagation",
  "touchStartPreventDefault",
  "touchStartForcePreventDefault",
  "touchReleaseOnEdges",
  "uniqueNavElements",
  "_resistance",
  "_resistanceRatio",
  "_watchSlidesProgress",
  "_grabCursor",
  "preventClicks",
  "preventClicksPropagation",
  "_slideToClickedSlide",
  "_loop",
  "loopedSlides",
  "loopPreventsSliding",
  "_rewind",
  "_allowSlidePrev",
  "_allowSlideNext",
  "_swipeHandler",
  "_noSwiping",
  "noSwipingClass",
  "noSwipingSelector",
  "passiveListeners",
  "containerModifierClass",
  "slideClass",
  "slideActiveClass",
  "slideVisibleClass",
  "slideNextClass",
  "slidePrevClass",
  "wrapperClass",
  "lazyPreloaderClass",
  "lazyPreloadPrevNext",
  "runCallbacksOnInit",
  "observer",
  "observeParents",
  "observeSlideChildren",
  "a11y",
  "_autoplay",
  "_controller",
  "coverflowEffect",
  "cubeEffect",
  "fadeEffect",
  "flipEffect",
  "creativeEffect",
  "cardsEffect",
  "hashNavigation",
  "history",
  "keyboard",
  "mousewheel",
  "_navigation",
  "_pagination",
  "parallax",
  "_scrollbar",
  "_thumbs",
  "virtual",
  "zoom",
  "control",
  "injectStyles",
  "injectStylesUrls"
];

// node_modules/swiper/components-shared/get-params.js
function getParams(obj = {}, splitEvents = !0) {
  let params = {
    on: {}
  }, events2 = {}, passedParams = {};
  extend5(params, core_default.defaults), extend5(params, core_default.extendedDefaults), params._emitClasses = !0, params.init = !1;
  let rest = {}, allowedParams = paramsList.map((key2) => key2.replace(/_/, "")), plainObj = Object.assign({}, obj);
  return Object.keys(plainObj).forEach((key2) => {
    typeof obj[key2] > "u" || (allowedParams.indexOf(key2) >= 0 ? isObject5(obj[key2]) ? (params[key2] = {}, passedParams[key2] = {}, extend5(params[key2], obj[key2]), extend5(passedParams[key2], obj[key2])) : (params[key2] = obj[key2], passedParams[key2] = obj[key2]) : key2.search(/on[A-Z]/) === 0 && typeof obj[key2] == "function" ? splitEvents ? events2[`${key2[2].toLowerCase()}${key2.substr(3)}`] = obj[key2] : params.on[`${key2[2].toLowerCase()}${key2.substr(3)}`] = obj[key2] : rest[key2] = obj[key2]);
  }), ["navigation", "pagination", "scrollbar"].forEach((key2) => {
    params[key2] === !0 && (params[key2] = {}), params[key2] === !1 && delete params[key2];
  }), {
    params,
    passedParams,
    rest,
    events: events2
  };
}

// node_modules/swiper/components-shared/mount-swiper.js
function mountSwiper({
  el,
  nextEl,
  prevEl,
  paginationEl,
  scrollbarEl,
  swiper
}, swiperParams) {
  needsNavigation(swiperParams) && nextEl && prevEl && (swiper.params.navigation.nextEl = nextEl, swiper.originalParams.navigation.nextEl = nextEl, swiper.params.navigation.prevEl = prevEl, swiper.originalParams.navigation.prevEl = prevEl), needsPagination(swiperParams) && paginationEl && (swiper.params.pagination.el = paginationEl, swiper.originalParams.pagination.el = paginationEl), needsScrollbar(swiperParams) && scrollbarEl && (swiper.params.scrollbar.el = scrollbarEl, swiper.originalParams.scrollbar.el = scrollbarEl), swiper.init(el);
}

// node_modules/swiper/components-shared/get-changed-params.js
function getChangedParams(swiperParams, oldParams, children, oldChildren, getKey) {
  let keys2 = [];
  if (!oldParams)
    return keys2;
  let addKey = (key2) => {
    keys2.indexOf(key2) < 0 && keys2.push(key2);
  };
  if (children && oldChildren) {
    let oldChildrenKeys = oldChildren.map(getKey), childrenKeys = children.map(getKey);
    oldChildrenKeys.join("") !== childrenKeys.join("") && addKey("children"), oldChildren.length !== children.length && addKey("children");
  }
  return paramsList.filter((key2) => key2[0] === "_").map((key2) => key2.replace(/_/, "")).forEach((key2) => {
    if (key2 in swiperParams && key2 in oldParams)
      if (isObject5(swiperParams[key2]) && isObject5(oldParams[key2])) {
        let newKeys = Object.keys(swiperParams[key2]), oldKeys = Object.keys(oldParams[key2]);
        newKeys.length !== oldKeys.length ? addKey(key2) : (newKeys.forEach((newKey) => {
          swiperParams[key2][newKey] !== oldParams[key2][newKey] && addKey(key2);
        }), oldKeys.forEach((oldKey) => {
          swiperParams[key2][oldKey] !== oldParams[key2][oldKey] && addKey(key2);
        }));
      } else
        swiperParams[key2] !== oldParams[key2] && addKey(key2);
  }), keys2;
}

// node_modules/swiper/react/get-children.js
var import_react51 = __toESM(require_react(), 1);
function isChildSwiperSlide(child) {
  return child.type && child.type.displayName && child.type.displayName.includes("SwiperSlide");
}
function processChildren(c4) {
  let slides = [];
  return import_react51.default.Children.toArray(c4).forEach((child) => {
    isChildSwiperSlide(child) ? slides.push(child) : child.props && child.props.children && processChildren(child.props.children).forEach((slide) => slides.push(slide));
  }), slides;
}
function getChildren2(c4) {
  let slides = [], slots = {
    "container-start": [],
    "container-end": [],
    "wrapper-start": [],
    "wrapper-end": []
  };
  return import_react51.default.Children.toArray(c4).forEach((child) => {
    if (isChildSwiperSlide(child))
      slides.push(child);
    else if (child.props && child.props.slot && slots[child.props.slot])
      slots[child.props.slot].push(child);
    else if (child.props && child.props.children) {
      let foundSlides = processChildren(child.props.children);
      foundSlides.length > 0 ? foundSlides.forEach((slide) => slides.push(slide)) : slots["container-end"].push(child);
    } else
      slots["container-end"].push(child);
  }), {
    slides,
    slots
  };
}

// node_modules/swiper/components-shared/update-swiper.js
function updateSwiper({
  swiper,
  slides,
  passedParams,
  changedParams,
  nextEl,
  prevEl,
  scrollbarEl,
  paginationEl
}) {
  let updateParams = changedParams.filter((key2) => key2 !== "children" && key2 !== "direction" && key2 !== "wrapperClass"), {
    params: currentParams,
    pagination,
    navigation,
    scrollbar,
    virtual,
    thumbs
  } = swiper, needThumbsInit, needControllerInit, needPaginationInit, needScrollbarInit, needNavigationInit, loopNeedDestroy, loopNeedEnable, loopNeedReloop;
  changedParams.includes("thumbs") && passedParams.thumbs && passedParams.thumbs.swiper && currentParams.thumbs && !currentParams.thumbs.swiper && (needThumbsInit = !0), changedParams.includes("controller") && passedParams.controller && passedParams.controller.control && currentParams.controller && !currentParams.controller.control && (needControllerInit = !0), changedParams.includes("pagination") && passedParams.pagination && (passedParams.pagination.el || paginationEl) && (currentParams.pagination || currentParams.pagination === !1) && pagination && !pagination.el && (needPaginationInit = !0), changedParams.includes("scrollbar") && passedParams.scrollbar && (passedParams.scrollbar.el || scrollbarEl) && (currentParams.scrollbar || currentParams.scrollbar === !1) && scrollbar && !scrollbar.el && (needScrollbarInit = !0), changedParams.includes("navigation") && passedParams.navigation && (passedParams.navigation.prevEl || prevEl) && (passedParams.navigation.nextEl || nextEl) && (currentParams.navigation || currentParams.navigation === !1) && navigation && !navigation.prevEl && !navigation.nextEl && (needNavigationInit = !0);
  let destroyModule = (mod) => {
    !swiper[mod] || (swiper[mod].destroy(), mod === "navigation" ? (swiper.isElement && (swiper[mod].prevEl.remove(), swiper[mod].nextEl.remove()), currentParams[mod].prevEl = void 0, currentParams[mod].nextEl = void 0, swiper[mod].prevEl = void 0, swiper[mod].nextEl = void 0) : (swiper.isElement && swiper[mod].el.remove(), currentParams[mod].el = void 0, swiper[mod].el = void 0));
  };
  changedParams.includes("loop") && swiper.isElement && (currentParams.loop && !passedParams.loop ? loopNeedDestroy = !0 : !currentParams.loop && passedParams.loop ? loopNeedEnable = !0 : loopNeedReloop = !0), updateParams.forEach((key2) => {
    if (isObject5(currentParams[key2]) && isObject5(passedParams[key2]))
      extend5(currentParams[key2], passedParams[key2]);
    else {
      let newValue = passedParams[key2];
      (newValue === !0 || newValue === !1) && (key2 === "navigation" || key2 === "pagination" || key2 === "scrollbar") ? newValue === !1 && destroyModule(key2) : currentParams[key2] = passedParams[key2];
    }
  }), updateParams.includes("controller") && !needControllerInit && swiper.controller && swiper.controller.control && currentParams.controller && currentParams.controller.control && (swiper.controller.control = currentParams.controller.control), changedParams.includes("children") && slides && virtual && currentParams.virtual.enabled && (virtual.slides = slides, virtual.update(!0)), changedParams.includes("children") && slides && currentParams.loop && (loopNeedReloop = !0), needThumbsInit && thumbs.init() && thumbs.update(!0), needControllerInit && (swiper.controller.control = currentParams.controller.control), needPaginationInit && (swiper.isElement && (!paginationEl || typeof paginationEl == "string") && (paginationEl = document.createElement("div"), paginationEl.classList.add("swiper-pagination"), swiper.el.shadowEl.appendChild(paginationEl)), paginationEl && (currentParams.pagination.el = paginationEl), pagination.init(), pagination.render(), pagination.update()), needScrollbarInit && (swiper.isElement && (!scrollbarEl || typeof scrollbarEl == "string") && (scrollbarEl = document.createElement("div"), scrollbarEl.classList.add("swiper-scrollbar"), swiper.el.shadowEl.appendChild(scrollbarEl)), scrollbarEl && (currentParams.scrollbar.el = scrollbarEl), scrollbar.init(), scrollbar.updateSize(), scrollbar.setTranslate()), needNavigationInit && (swiper.isElement && ((!nextEl || typeof nextEl == "string") && (nextEl = document.createElement("div"), nextEl.classList.add("swiper-button-next"), swiper.el.shadowEl.appendChild(nextEl)), (!prevEl || typeof prevEl == "string") && (prevEl = document.createElement("div"), prevEl.classList.add("swiper-button-prev"), swiper.el.shadowEl.appendChild(prevEl))), nextEl && (currentParams.navigation.nextEl = nextEl), prevEl && (currentParams.navigation.prevEl = prevEl), navigation.init(), navigation.update()), changedParams.includes("allowSlideNext") && (swiper.allowSlideNext = passedParams.allowSlideNext), changedParams.includes("allowSlidePrev") && (swiper.allowSlidePrev = passedParams.allowSlidePrev), changedParams.includes("direction") && swiper.changeDirection(passedParams.direction, !1), (loopNeedDestroy || loopNeedReloop) && swiper.loopDestroy(), (loopNeedEnable || loopNeedReloop) && swiper.loopCreate(), swiper.update();
}

// node_modules/swiper/react/virtual.js
var import_react52 = __toESM(require_react(), 1);
function renderVirtual(swiper, slides, virtualData) {
  if (!virtualData)
    return null;
  let getSlideIndex = (index2) => {
    let slideIndex = index2;
    return index2 < 0 ? slideIndex = slides.length + index2 : slideIndex >= slides.length && (slideIndex = slideIndex - slides.length), slideIndex;
  }, style = swiper.isHorizontal() ? {
    [swiper.rtlTranslate ? "right" : "left"]: `${virtualData.offset}px`
  } : {
    top: `${virtualData.offset}px`
  }, {
    from: from2,
    to
  } = virtualData, loopFrom = swiper.params.loop ? -slides.length : 0, loopTo = swiper.params.loop ? slides.length * 2 : slides.length, slidesToRender = [];
  for (let i3 = loopFrom; i3 < loopTo; i3 += 1)
    i3 >= from2 && i3 <= to && slidesToRender.push(slides[getSlideIndex(i3)]);
  return slidesToRender.map((child, index2) => /* @__PURE__ */ import_react52.default.cloneElement(child, {
    swiper,
    style,
    key: `slide-${index2}`
  }));
}

// node_modules/swiper/components-shared/update-on-virtual-data.js
var updateOnVirtualData = (swiper) => {
  !swiper || swiper.destroyed || !swiper.params.virtual || swiper.params.virtual && !swiper.params.virtual.enabled || (swiper.updateSlides(), swiper.updateProgress(), swiper.updateSlidesClasses(), swiper.parallax && swiper.params.parallax && swiper.params.parallax.enabled && swiper.parallax.setTranslate());
};

// node_modules/swiper/react/use-isomorphic-layout-effect.js
var import_react53 = __toESM(require_react(), 1);
function useIsomorphicLayoutEffect2(callback, deps) {
  return typeof window > "u" ? (0, import_react53.useEffect)(callback, deps) : (0, import_react53.useLayoutEffect)(callback, deps);
}

// node_modules/swiper/react/context.js
var import_react54 = __toESM(require_react(), 1), SwiperSlideContext = /* @__PURE__ */ (0, import_react54.createContext)(null);
var SwiperContext = /* @__PURE__ */ (0, import_react54.createContext)(null);

// node_modules/swiper/react/swiper.js
function _extends5() {
  return _extends5 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source2 = arguments[i3];
      for (var key2 in source2)
        Object.prototype.hasOwnProperty.call(source2, key2) && (target[key2] = source2[key2]);
    }
    return target;
  }, _extends5.apply(this, arguments);
}
var Swiper2 = /* @__PURE__ */ (0, import_react55.forwardRef)(function(_temp, externalElRef) {
  let {
    className,
    tag: Tag = "div",
    wrapperTag: WrapperTag = "div",
    children,
    onSwiper,
    ...rest
  } = _temp === void 0 ? {} : _temp, eventsAssigned = !1, [containerClasses, setContainerClasses] = (0, import_react55.useState)("swiper"), [virtualData, setVirtualData] = (0, import_react55.useState)(null), [breakpointChanged, setBreakpointChanged] = (0, import_react55.useState)(!1), initializedRef = (0, import_react55.useRef)(!1), swiperElRef = (0, import_react55.useRef)(null), swiperRef = (0, import_react55.useRef)(null), oldPassedParamsRef = (0, import_react55.useRef)(null), oldSlides = (0, import_react55.useRef)(null), nextElRef = (0, import_react55.useRef)(null), prevElRef = (0, import_react55.useRef)(null), paginationElRef = (0, import_react55.useRef)(null), scrollbarElRef = (0, import_react55.useRef)(null), {
    params: swiperParams,
    passedParams,
    rest: restProps,
    events: events2
  } = getParams(rest), {
    slides,
    slots
  } = getChildren2(children), onBeforeBreakpoint = () => {
    setBreakpointChanged(!breakpointChanged);
  };
  Object.assign(swiperParams.on, {
    _containerClasses(swiper, classes) {
      setContainerClasses(classes);
    }
  });
  let initSwiper = () => {
    Object.assign(swiperParams.on, events2), eventsAssigned = !0;
    let passParams = {
      ...swiperParams
    };
    if (delete passParams.wrapperClass, swiperRef.current = new core_default(passParams), swiperRef.current.virtual && swiperRef.current.params.virtual.enabled) {
      swiperRef.current.virtual.slides = slides;
      let extendWith = {
        cache: !1,
        slides,
        renderExternal: setVirtualData,
        renderExternalUpdate: !1
      };
      extend5(swiperRef.current.params.virtual, extendWith), extend5(swiperRef.current.originalParams.virtual, extendWith);
    }
  };
  swiperElRef.current || initSwiper(), swiperRef.current && swiperRef.current.on("_beforeBreakpoint", onBeforeBreakpoint);
  let attachEvents2 = () => {
    eventsAssigned || !events2 || !swiperRef.current || Object.keys(events2).forEach((eventName) => {
      swiperRef.current.on(eventName, events2[eventName]);
    });
  }, detachEvents2 = () => {
    !events2 || !swiperRef.current || Object.keys(events2).forEach((eventName) => {
      swiperRef.current.off(eventName, events2[eventName]);
    });
  };
  (0, import_react55.useEffect)(() => () => {
    swiperRef.current && swiperRef.current.off("_beforeBreakpoint", onBeforeBreakpoint);
  }), (0, import_react55.useEffect)(() => {
    !initializedRef.current && swiperRef.current && (swiperRef.current.emitSlidesClasses(), initializedRef.current = !0);
  }), useIsomorphicLayoutEffect2(() => {
    if (externalElRef && (externalElRef.current = swiperElRef.current), !!swiperElRef.current)
      return swiperRef.current.destroyed && initSwiper(), mountSwiper({
        el: swiperElRef.current,
        nextEl: nextElRef.current,
        prevEl: prevElRef.current,
        paginationEl: paginationElRef.current,
        scrollbarEl: scrollbarElRef.current,
        swiper: swiperRef.current
      }, swiperParams), onSwiper && onSwiper(swiperRef.current), () => {
        swiperRef.current && !swiperRef.current.destroyed && swiperRef.current.destroy(!0, !1);
      };
  }, []), useIsomorphicLayoutEffect2(() => {
    attachEvents2();
    let changedParams = getChangedParams(passedParams, oldPassedParamsRef.current, slides, oldSlides.current, (c4) => c4.key);
    return oldPassedParamsRef.current = passedParams, oldSlides.current = slides, changedParams.length && swiperRef.current && !swiperRef.current.destroyed && updateSwiper({
      swiper: swiperRef.current,
      slides,
      passedParams,
      changedParams,
      nextEl: nextElRef.current,
      prevEl: prevElRef.current,
      scrollbarEl: scrollbarElRef.current,
      paginationEl: paginationElRef.current
    }), () => {
      detachEvents2();
    };
  }), useIsomorphicLayoutEffect2(() => {
    updateOnVirtualData(swiperRef.current);
  }, [virtualData]);
  function renderSlides() {
    return swiperParams.virtual ? renderVirtual(swiperRef.current, slides, virtualData) : slides.map((child, index2) => /* @__PURE__ */ import_react55.default.cloneElement(child, {
      swiper: swiperRef.current,
      swiperSlideIndex: index2
    }));
  }
  return /* @__PURE__ */ import_react55.default.createElement(Tag, _extends5({
    ref: swiperElRef,
    className: uniqueClasses(`${containerClasses}${className ? ` ${className}` : ""}`)
  }, restProps), /* @__PURE__ */ import_react55.default.createElement(SwiperContext.Provider, {
    value: swiperRef.current
  }, slots["container-start"], /* @__PURE__ */ import_react55.default.createElement(WrapperTag, {
    className: wrapperClass(swiperParams.wrapperClass)
  }, slots["wrapper-start"], renderSlides(), slots["wrapper-end"]), needsNavigation(swiperParams) && /* @__PURE__ */ import_react55.default.createElement(import_react55.default.Fragment, null, /* @__PURE__ */ import_react55.default.createElement("div", {
    ref: prevElRef,
    className: "swiper-button-prev"
  }), /* @__PURE__ */ import_react55.default.createElement("div", {
    ref: nextElRef,
    className: "swiper-button-next"
  })), needsScrollbar(swiperParams) && /* @__PURE__ */ import_react55.default.createElement("div", {
    ref: scrollbarElRef,
    className: "swiper-scrollbar"
  }), needsPagination(swiperParams) && /* @__PURE__ */ import_react55.default.createElement("div", {
    ref: paginationElRef,
    className: "swiper-pagination"
  }), slots["container-end"]));
});
Swiper2.displayName = "Swiper";

// node_modules/swiper/react/swiper-slide.js
var import_react56 = __toESM(require_react(), 1);
function _extends6() {
  return _extends6 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source2 = arguments[i3];
      for (var key2 in source2)
        Object.prototype.hasOwnProperty.call(source2, key2) && (target[key2] = source2[key2]);
    }
    return target;
  }, _extends6.apply(this, arguments);
}
var SwiperSlide = /* @__PURE__ */ (0, import_react56.forwardRef)(function(_temp, externalRef) {
  let {
    tag: Tag = "div",
    children,
    className = "",
    swiper,
    zoom,
    lazy,
    virtualIndex,
    swiperSlideIndex,
    ...rest
  } = _temp === void 0 ? {} : _temp, slideElRef = (0, import_react56.useRef)(null), [slideClasses, setSlideClasses] = (0, import_react56.useState)("swiper-slide"), [lazyLoaded, setLazyLoaded] = (0, import_react56.useState)(!1);
  function updateClasses(_s, el, classNames) {
    el === slideElRef.current && setSlideClasses(classNames);
  }
  useIsomorphicLayoutEffect2(() => {
    if (typeof swiperSlideIndex < "u" && (slideElRef.current.swiperSlideIndex = swiperSlideIndex), externalRef && (externalRef.current = slideElRef.current), !(!slideElRef.current || !swiper)) {
      if (swiper.destroyed) {
        slideClasses !== "swiper-slide" && setSlideClasses("swiper-slide");
        return;
      }
      return swiper.on("_slideClass", updateClasses), () => {
        !swiper || swiper.off("_slideClass", updateClasses);
      };
    }
  }), useIsomorphicLayoutEffect2(() => {
    swiper && slideElRef.current && !swiper.destroyed && setSlideClasses(swiper.getSlideClasses(slideElRef.current));
  }, [swiper]);
  let slideData = {
    isActive: slideClasses.indexOf("swiper-slide-active") >= 0,
    isVisible: slideClasses.indexOf("swiper-slide-visible") >= 0,
    isPrev: slideClasses.indexOf("swiper-slide-prev") >= 0,
    isNext: slideClasses.indexOf("swiper-slide-next") >= 0
  }, renderChildren = () => typeof children == "function" ? children(slideData) : children, onLoad2 = () => {
    setLazyLoaded(!0);
  };
  return /* @__PURE__ */ import_react56.default.createElement(Tag, _extends6({
    ref: slideElRef,
    className: uniqueClasses(`${slideClasses}${className ? ` ${className}` : ""}`),
    "data-swiper-slide-index": virtualIndex,
    onLoad: onLoad2
  }, rest), zoom && /* @__PURE__ */ import_react56.default.createElement(SwiperSlideContext.Provider, {
    value: slideData
  }, /* @__PURE__ */ import_react56.default.createElement("div", {
    className: "swiper-zoom-container",
    "data-swiper-zoom": typeof zoom == "number" ? zoom : void 0
  }, renderChildren(), lazy && !lazyLoaded && /* @__PURE__ */ import_react56.default.createElement("div", {
    className: "swiper-lazy-preloader"
  }))), !zoom && /* @__PURE__ */ import_react56.default.createElement(SwiperSlideContext.Provider, {
    value: slideData
  }, renderChildren(), lazy && !lazyLoaded && /* @__PURE__ */ import_react56.default.createElement("div", {
    className: "swiper-lazy-preloader"
  })));
});
SwiperSlide.displayName = "SwiperSlide";

// app/components/lib/Slider/styles.ts
var SwiperContainer = styled_components_esm_default.div`
  width: 100%;
  display: flex;
  position: relative;

  & .swiper {
    position: initial;
    align-items: stretch;
    padding: 0 10px;
  }

  & .swiper-slide {
    width: ${({ variant }) => variant === "companies" ? "60%" : "auto"};
    text-align: center;
    display: flex;
    justify-content: center;
    align-items: center;
    align-items: stretch;
  }

  & .swiper-slide:nth-child(2n) {
    width: ${({ variant }) => variant === "companies" ? "60%" : "auto"};
  }

  & .swiper-slide:nth-child(3n) {
    width: ${({ variant }) => variant === "companies" ? "60%" : "auto"};
  }
  & .swiper-slide:nth-child(4n) {
    width: ${({ variant }) => variant === "companies" ? "60%" : "auto"};
  }

  @media (min-width: 1280px) {
    width: 1090px;
    & .swiper {
      padding: 20px 10px;
    }
  }
`, SwiperControl = styled_components_esm_default.div`
  position: absolute;
  z-index: 1;
  bottom: 0;
  display: flex;
  justify-content: center;
  flex-direction: row;
  gap: 32px;
  width: 100%;

  & button {
    display: ${({ variant }) => variant === "chips" ? "flex" : "none"};
    @media (min-width: 1024px) {
      display: ${({ variant }) => variant === "articles" ? "flex" : "none"};
    }
  }

  @media (min-width: 1024px) {
    bottom: ${({ variant }) => variant === "articles" ? "-48px" : "0"};
  }

  & .custom-pagination {
    width: auto;
    display: ${({ variant }) => variant === "chips" ? "flex" : "none"};
    flex-direction: row;
    align-items: center;
    gap: 32px;

    & .swiper-pagination-bullet {
      background-color: ${({ theme }) => theme.slider.backgroundBulletColor};
      opacity: 1;
      transition: all 0.15s ease-in;
    }

    & .swiper-pagination-bullet-active {
      position: relative;
      background-color: ${({ theme }) => theme.slider.backgroundBulletActiveColor};

      &::after {
        content: '';
        width: 16px;
        height: 16px;
        position: absolute;
        border: 1.5px solid ${({ theme }) => theme.slider.backgroundBulletActiveColor};
        left: -4px;
        top: -4px;
        border-radius: 50%;
        transition: all 0.15s ease-in;
      }
    }

    @media (min-width: 1024px) {
      display: ${({ variant }) => variant === "articles" ? "flex" : "none"};
    }
  }

  @media (min-width: 1300px) {
    justify-content: ${({ variant }) => variant === "companies" ? "space-between" : "center"};
    bottom: ${({ variant }) => variant === "companies" ? "45%" : "-38px"};
    left: ${({ variant }) => variant === "companies" ? "-56px" : "auto"};
    width: ${({ variant }) => variant === "companies" ? "1200px" : "100%"};
    & button {
      display: ${({ variant }) => variant === "companies" || variant === "articles" ? "flex" : "none"};
    }
  }
`, IconContainerArrow = styled_components_esm_default.button`
  display: flex;
  justify-content: center;
  align-items: center;
  background-color: ${({ theme }) => theme.slider.backgroundButtonArrowColor};
  width: 32px;
  height: 32px;
  border-radius: 50%;
  transition: all 0.15s ease-in;

  &:hover,
  &:focus {
    background-color: ${({ theme }) => theme.slider.hoverButtonArrowColor};
  }
`, ChipsContainer = styled_components_esm_default.div`
  display: flex;
  justify-content: center;
  flex-direction: row;
  flex-wrap: wrap;
  gap: 8px;
  padding-bottom: 56px;
  height: fit-content;
`;

// app/components/lib/Slider/index.tsx
var import_jsx_dev_runtime38 = __toESM(require_jsx_dev_runtime()), CardContainer = styled_components_esm_default.div.withConfig({
  displayName: "Slider__CardContainer",
  componentId: "sc-1ofuhlr-0"
})(["display:flex;flex-direction:row;gap:16px;"]), Slider = (0, import_react57.memo)(function({
  theme,
  slides,
  slideElements = 1,
  variant
}) {
  let swiperRef = (0, import_react57.useRef)(null);
  core_default.use([Pagination]);
  let chunkedArray = [];
  for (let i3 = 0; i3 < slides.length; i3 += slideElements)
    chunkedArray.push(slides.slice(i3, i3 + slideElements));
  let settings = {
    companies: {
      slidesPerView: 2.3,
      spaceBetween: 16,
      navigation: !0,
      modules: [],
      centeredSlides: !1,
      breakpoints: {
        576: {
          slidesPerView: 3.3
        },
        768: {
          slidesPerView: 4.2
        },
        1024: {
          spaceBetween: 24,
          slidesPerView: 4.4
        },
        1280: {
          slidesPerView: 5
        }
      }
    },
    chips: {
      centeredSlides: !0,
      navigation: !0,
      modules: [Pagination],
      slidesPerView: void 0,
      breakpoints: void 0,
      spaceBetween: void 0
    },
    articles: {
      slidesPerView: 1.4,
      spaceBetween: 16,
      navigation: !0,
      modules: [],
      centeredSlides: !0,
      breakpoints: {
        576: {
          slidesPerView: 2.4,
          centeredSlides: !1
        },
        768: {
          slidesPerView: 2.8,
          centeredSlides: !1
        },
        1024: {
          spaceBetween: 24,
          slidesPerView: 3.4,
          centeredSlides: !1,
          modules: [Pagination],
          slidesPerGroup: 3
        },
        1280: {
          slidesPerView: 3,
          slidesPerGroup: 3
        }
      }
    }
  };
  return /* @__PURE__ */ (0, import_jsx_dev_runtime38.jsxDEV)(SwiperContainer, { variant, children: /* @__PURE__ */ (0, import_jsx_dev_runtime38.jsxDEV)(
    Swiper2,
    {
      centeredSlides: settings[variant].centeredSlides,
      slidesPerView: settings[variant].slidesPerView,
      spaceBetween: settings[variant].spaceBetween,
      breakpoints: settings[variant].breakpoints,
      loop: !0,
      pagination: {
        el: ".custom-pagination",
        clickable: !0
      },
      navigation: settings[variant].navigation,
      modules: settings[variant].modules,
      ref: swiperRef,
      children: [
        chunkedArray.map((chunk, index2) => /* @__PURE__ */ (0, import_jsx_dev_runtime38.jsxDEV)(SwiperSlide, { children: [
          variant === "chips" && /* @__PURE__ */ (0, import_jsx_dev_runtime38.jsxDEV)(ChipsContainer, { children: chunk.map((item) => /* @__PURE__ */ (0, import_jsx_dev_runtime38.jsxDEV)(Button_default, { priority: "chips", children: /* @__PURE__ */ (0, import_jsx_dev_runtime38.jsxDEV)(Text, { variant: TextVariantEnum.textSmall, children: item }, void 0, !1, {
            fileName: "app/components/lib/Slider/index.tsx",
            lineNumber: 114,
            columnNumber: 21
          }, this) }, item, !1, {
            fileName: "app/components/lib/Slider/index.tsx",
            lineNumber: 113,
            columnNumber: 36
          }, this)) }, void 0, !1, {
            fileName: "app/components/lib/Slider/index.tsx",
            lineNumber: 112,
            columnNumber: 37
          }, this),
          (variant === "companies" || variant === "articles") && chunk.map((item) => typeof item == "string" ? null : /* @__PURE__ */ (0, import_jsx_dev_runtime38.jsxDEV)(Card_default, { image: item.image, title: item.title, vacancies: item.vacancies, variant, date: item.date }, item.id, !1, {
            fileName: "app/components/lib/Slider/index.tsx",
            lineNumber: 123,
            columnNumber: 18
          }, this))
        ] }, index2, !0, {
          fileName: "app/components/lib/Slider/index.tsx",
          lineNumber: 111,
          columnNumber: 45
        }, this)),
        /* @__PURE__ */ (0, import_jsx_dev_runtime38.jsxDEV)(SwiperControl, { variant, children: [
          /* @__PURE__ */ (0, import_jsx_dev_runtime38.jsxDEV)(
            IconContainerArrow,
            {
              onClick: () => swiperRef.current.swiper.slidePrev(),
              children: /* @__PURE__ */ (0, import_jsx_dev_runtime38.jsxDEV)(Left_default, { color: theme.slider.buttonArrowColor }, void 0, !1, {
                fileName: "app/components/lib/Slider/index.tsx",
                lineNumber: 132,
                columnNumber: 13
              }, this)
            },
            void 0,
            !1,
            {
              fileName: "app/components/lib/Slider/index.tsx",
              lineNumber: 127,
              columnNumber: 11
            },
            this
          ),
          /* @__PURE__ */ (0, import_jsx_dev_runtime38.jsxDEV)("div", { className: "custom-pagination" }, void 0, !1, {
            fileName: "app/components/lib/Slider/index.tsx",
            lineNumber: 134,
            columnNumber: 11
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime38.jsxDEV)(
            IconContainerArrow,
            {
              onClick: () => swiperRef.current.swiper.slideNext(),
              children: /* @__PURE__ */ (0, import_jsx_dev_runtime38.jsxDEV)(Right_default, { color: theme.slider.buttonArrowColor }, void 0, !1, {
                fileName: "app/components/lib/Slider/index.tsx",
                lineNumber: 141,
                columnNumber: 13
              }, this)
            },
            void 0,
            !1,
            {
              fileName: "app/components/lib/Slider/index.tsx",
              lineNumber: 136,
              columnNumber: 11
            },
            this
          )
        ] }, void 0, !0, {
          fileName: "app/components/lib/Slider/index.tsx",
          lineNumber: 126,
          columnNumber: 9
        }, this)
      ]
    },
    void 0,
    !0,
    {
      fileName: "app/components/lib/Slider/index.tsx",
      lineNumber: 104,
      columnNumber: 7
    },
    this
  ) }, void 0, !1, {
    fileName: "app/components/lib/Slider/index.tsx",
    lineNumber: 103,
    columnNumber: 10
  }, this);
});

// app/components/pages/HomePage/SectionTrending/styles.ts
var WrapperSection2 = styled_components_esm_default.div`
  display: flex;
  width: 100%;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  background-size: cover;
  background-repeat: round;
  padding: 32px 28px;
  gap: 24px;
  background-color: ${({ theme }) => theme.mainPage.backgroundSectionTrendingColor};
  @media (min-width: 768px) {
    padding: 40px 34px 48px;
    gap: 32px;
  }

  @media (min-width: 940px) {
    padding: 40px 162px 48px;
  }
  @media (min-width: 1280px) {
    padding: 80px 0;
  }
`, TitleContainer = styled_components_esm_default.div`
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
`, SwiperChips = styled_components_esm_default.div`
  display: flex;
`, MobileContainer = styled_components_esm_default.div`
  width: 100%;
  @media (min-width: 768px) {
    display: none;
  }
`, TabletContainer = styled_components_esm_default.div`
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  @media (max-width: 768px) {
    display: none;
  }
`, ChipsContainer2 = styled_components_esm_default.div`
  display: flex;
  justify-content: center;
  flex-direction: row;
  flex-wrap: wrap;
  max-width: 1090px;
  gap: 16px;
`;

// app/components/pages/HomePage/SectionTrending/index.tsx
var import_jsx_dev_runtime39 = __toESM(require_jsx_dev_runtime()), SectionTrending = (0, import_react59.memo)(function() {
  let {
    theme,
    t: t4
  } = useApp(), temporaryTrending = ["Pattaya Jobs", "Jobs Near Bangkok MRT", "Saturday and Sunday off Jobs", "Phuket Jobs", "Practice after College", "Part-time Jobs", "Pattaya Jobs2", "Jobs Near Bangkok MRT2", "Saturday and Sunday off Jobs2", "Phuket Jobs2", "Practice after College2", "Part-time Jobs2"];
  return /* @__PURE__ */ (0, import_jsx_dev_runtime39.jsxDEV)(WrapperSection2, { children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime39.jsxDEV)(TitleContainer, { children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime39.jsxDEV)(Text, { variant: TextVariantEnum.textBody2medium, color: theme.mainPage.titleColor, children: t4("home:dont_know_where_to_start") }, void 0, !1, {
        fileName: "app/components/pages/HomePage/SectionTrending/index.tsx",
        lineNumber: 16,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime39.jsxDEV)(Text, { variant: TextVariantEnum.textHeading1, color: theme.mainPage.titleColor, children: t4("home:trending_searches") }, void 0, !1, {
        fileName: "app/components/pages/HomePage/SectionTrending/index.tsx",
        lineNumber: 19,
        columnNumber: 9
      }, this)
    ] }, void 0, !0, {
      fileName: "app/components/pages/HomePage/SectionTrending/index.tsx",
      lineNumber: 15,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime39.jsxDEV)(MobileContainer, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime39.jsxDEV)(Slider, { theme, variant: "chips", slides: temporaryTrending, slideElements: 6 }, void 0, !1, {
      fileName: "app/components/pages/HomePage/SectionTrending/index.tsx",
      lineNumber: 24,
      columnNumber: 9
    }, this) }, void 0, !1, {
      fileName: "app/components/pages/HomePage/SectionTrending/index.tsx",
      lineNumber: 23,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime39.jsxDEV)(TabletContainer, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime39.jsxDEV)(ChipsContainer2, { children: temporaryTrending.slice(0, 8).map((item) => /* @__PURE__ */ (0, import_jsx_dev_runtime39.jsxDEV)(Button_default, { priority: "chips", children: /* @__PURE__ */ (0, import_jsx_dev_runtime39.jsxDEV)(Text, { variant: TextVariantEnum.textBody1, children: item }, void 0, !1, {
      fileName: "app/components/pages/HomePage/SectionTrending/index.tsx",
      lineNumber: 29,
      columnNumber: 15
    }, this) }, item, !1, {
      fileName: "app/components/pages/HomePage/SectionTrending/index.tsx",
      lineNumber: 28,
      columnNumber: 54
    }, this)) }, void 0, !1, {
      fileName: "app/components/pages/HomePage/SectionTrending/index.tsx",
      lineNumber: 27,
      columnNumber: 9
    }, this) }, void 0, !1, {
      fileName: "app/components/pages/HomePage/SectionTrending/index.tsx",
      lineNumber: 26,
      columnNumber: 7
    }, this)
  ] }, void 0, !0, {
    fileName: "app/components/pages/HomePage/SectionTrending/index.tsx",
    lineNumber: 14,
    columnNumber: 10
  }, this);
});

// app/components/pages/HomePage/SectionBenefits/index.tsx
var import_react60 = __toESM(require_react());

// app/components/pages/HomePage/SectionBenefits/styles.ts
var TextContainer = styled_components_esm_default.div`
  padding: 0 44px;
  width: 100%;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  text-align: center;
  svg {
    width: 58px;
    height: 18px;
  }

  @media (min-width: 768px) {
    display: none;
  }
`, WrapperBanner = styled_components_esm_default.div`
  display: none;
  @media (min-width: 768px) {
    display: flex;
    height: 560px;
    width: 100%;
    background: url('images/homePage/bannerTablet.jpg');
    background-size: cover;
    background-repeat: round;
  }
  @media (min-width: 1024px) {
    background: url('images/homePage/bannerTabletM.jpg');
    background-size: cover;
    background-repeat: round;
  }
  @media (min-width: 1280px) {
    height: 640px;
    background: ${({ lang }) => lang === LanguageEnum.EN ? "url('images/homePage/bannerDesctopEn.jpg')" : "url('images/homePage/bannerDesctopTh.jpg')"};
    background-size: cover;
    background-repeat: round;
  }
`, WrapperSection3 = styled_components_esm_default.div`
  display: flex;
  width: 100%;
  justify-content: center;
  align-items: center;
  flex-direction: row;
  background-size: cover;
  background-repeat: round;
  background-color: ${({ theme }) => theme.mainPage.backgroundSectionTrendingColor};
  flex-wrap: wrap;
  padding: 32px 16px;

  @media (min-width: 1024px) {
    padding: 40px 104px;
  }
  @media (min-width: 1280px) {
    padding: 64px 120px;
  }
`, BenefitsWrapper = styled_components_esm_default.div`
  display: flex;
  flex-direction: row;
  gap: 16px;
  flex-wrap: wrap;
  max-width: 1200px;
  padding: 0px 16px;

  @media (min-width: 768px) {
    width: 100%;
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 24px;
    padding: 0 44px;
  }
`, BenefitFrame = styled_components_esm_default.div`
  display: flex;
  align-items: left;
  flex-direction: column;
  border: 1px solid #d9dbde;
  border-radius: 8px;
  padding: 16px 24px;
  gap: 6px;
  height: 100%;
  width: 100%;
`, BenefitHeader = styled_components_esm_default(Text)`
  color: ${({ theme }) => theme.mainPage.benefitHeaderColorSmall};

  @media (min-width: 768px) {
    color: ${({ theme }) => theme.mainPage.benefitHeaderColor};
  }
`, BenefitText = styled_components_esm_default(Text)`
  color: ${({ theme }) => theme.mainPage.benefitBodyColorSmall};

  @media (min-width: 768px) {
    color: ${({ theme }) => theme.mainPage.benefitBodyColor};
  }
`;

// app/components/pages/HomePage/SectionBenefits/index.tsx
var import_jsx_dev_runtime40 = __toESM(require_jsx_dev_runtime()), SectionBenefits = (0, import_react60.memo)(function() {
  let {
    theme,
    t: t4,
    userContext
  } = useApp(), benefits = [{
    header: "Free servises for all customers",
    body: "In this difficult time we decided to support the employer and the employee and will not charge for any using services"
  }, {
    header: "Jobs outside Bangkok matter",
    body: "We are working with employers in all the provinces so the people living outside Bangkok have an opportunity to know about new vacancies in their city"
  }, {
    header: "Safety to find a job",
    body: "Find a job without leaving your home. Take care of your health and the health of your family"
  }, {
    header: "Covid safety rules",
    body: "Remember to follow the rules. Wear a mask, wash your hands, don't leave the house unnecessarily"
  }];
  return /* @__PURE__ */ (0, import_jsx_dev_runtime40.jsxDEV)(Box, { width: "100%", flexDirection: "column", children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime40.jsxDEV)(WrapperBanner, { lang: userContext == null ? void 0 : userContext.language }, void 0, !1, {
      fileName: "app/components/pages/HomePage/SectionBenefits/index.tsx",
      lineNumber: 32,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime40.jsxDEV)(WrapperSection3, { children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime40.jsxDEV)(TextContainer, { children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime40.jsxDEV)(Logo_default, { color: theme.navbar.logoColor }, void 0, !1, {
          fileName: "app/components/pages/HomePage/SectionBenefits/index.tsx",
          lineNumber: 35,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime40.jsxDEV)(Text, { variant: TextVariantEnum.textHeading1, color: theme.mainPage.benefitHeadingMobileColor, children: t4("home:the_best_vacancies_are_only_with_us") }, void 0, !1, {
          fileName: "app/components/pages/HomePage/SectionBenefits/index.tsx",
          lineNumber: 36,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime40.jsxDEV)(Text, { variant: TextVariantEnum.textBody2medium, style: {
          marginTop: "8px",
          marginBottom: "32px"
        }, children: t4("home:convenient_service_for_finding_a_job") }, void 0, !1, {
          fileName: "app/components/pages/HomePage/SectionBenefits/index.tsx",
          lineNumber: 39,
          columnNumber: 11
        }, this)
      ] }, void 0, !0, {
        fileName: "app/components/pages/HomePage/SectionBenefits/index.tsx",
        lineNumber: 34,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime40.jsxDEV)(BenefitsWrapper, { children: benefits.map((benefit, index2) => /* @__PURE__ */ (0, import_jsx_dev_runtime40.jsxDEV)(BenefitFrame, { children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime40.jsxDEV)(BenefitHeader, { variant: TextVariantEnum.textHeading3, children: benefit.header }, void 0, !1, {
          fileName: "app/components/pages/HomePage/SectionBenefits/index.tsx",
          lineNumber: 48,
          columnNumber: 15
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime40.jsxDEV)(BenefitText, { variant: TextVariantEnum.textBody2, children: benefit.body }, void 0, !1, {
          fileName: "app/components/pages/HomePage/SectionBenefits/index.tsx",
          lineNumber: 49,
          columnNumber: 15
        }, this)
      ] }, index2, !0, {
        fileName: "app/components/pages/HomePage/SectionBenefits/index.tsx",
        lineNumber: 47,
        columnNumber: 45
      }, this)) }, void 0, !1, {
        fileName: "app/components/pages/HomePage/SectionBenefits/index.tsx",
        lineNumber: 46,
        columnNumber: 9
      }, this)
    ] }, void 0, !0, {
      fileName: "app/components/pages/HomePage/SectionBenefits/index.tsx",
      lineNumber: 33,
      columnNumber: 7
    }, this)
  ] }, void 0, !0, {
    fileName: "app/components/pages/HomePage/SectionBenefits/index.tsx",
    lineNumber: 31,
    columnNumber: 10
  }, this);
});

// app/components/pages/HomePage/SectionCompanies/index.tsx
var import_react61 = __toESM(require_react());

// app/components/pages/HomePage/SectionCompanies/styles.ts
var WrapperSection4 = styled_components_esm_default.div`
  display: flex;
  width: 100%;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  background-size: cover;
  background-repeat: round;
  padding: 32px 0;
  gap: 14px;
  background-color: ${({ theme }) => theme.mainPage.backgroundSectionCompaniesColor};
  @media (min-width: 768px) {
    padding: 40px 0 48px;
    gap: 32px;
  }

  @media (min-width: 1024px) {
    padding: 40px 0 48px;
  }
  @media (min-width: 1280px) {
    padding: 80px 0;
  }
`, TitleContainer2 = styled_components_esm_default.div`
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
`, SwiperChips2 = styled_components_esm_default.div`
  display: flex;
`, MobileContainer2 = styled_components_esm_default.div`
  width: 100%;
  @media (min-width: 768px) {
    display: none;
  }
`, TabletContainer2 = styled_components_esm_default.div`
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  @media (max-width: 768px) {
    display: none;
  }
`, SliderContainer = styled_components_esm_default.div`
  width: 100%;
  padding-left: 18px;

  @media (min-width: 768px) {
    padding-left: 34px;
  }

  @media (min-width: 1240px) {
    padding: 0 162px;
    display: flex;
    justify-content: center;
  }
`, ButtonWrapper = styled_components_esm_default.div`
  margin-top: -6px;

  @media (min-width: 768px) {
    margin-top: -24px;
  }

  @media (min-width: 1280px) {
    margin-top: -42px;
  }
`;

// app/components/pages/HomePage/SectionCompanies/index.tsx
var import_jsx_dev_runtime41 = __toESM(require_jsx_dev_runtime()), SectionCompanies = (0, import_react61.memo)(function() {
  let {
    theme,
    t: t4
  } = useApp(), temporaryCompanies = [{
    id: "1",
    title: "Apple company-4567",
    vacancies: 100,
    image: "images/homePage/apple.png"
  }, {
    id: "2",
    title: "Apple company-4345567",
    vacancies: 23,
    image: "images/homePage/apple.png"
  }, {
    id: "3",
    title: "Apple company-12435",
    vacancies: 0,
    image: "images/homePage/apple.png"
  }, {
    id: "4",
    title: "Apple company-3456",
    vacancies: 100,
    image: "images/homePage/apple.png"
  }, {
    id: "5",
    title: "Apple company-977",
    vacancies: 23,
    image: "images/homePage/apple.png"
  }, {
    id: "6",
    title: "Apple company-888",
    vacancies: 0,
    image: "images/homePage/apple.png"
  }, {
    id: "7",
    title: "Apple company-677",
    vacancies: 100,
    image: "images/homePage/apple.png"
  }, {
    id: "8",
    title: "Apple company-666",
    vacancies: 23,
    image: "images/homePage/apple.png"
  }, {
    id: "9",
    title: "Apple company-555",
    vacancies: 0,
    image: "images/homePage/apple.png"
  }, {
    id: "10",
    title: "Apple company-333",
    vacancies: 100,
    image: "images/homePage/apple.png"
  }, {
    id: "11",
    title: "Apple company-22",
    vacancies: 23,
    image: "images/homePage/apple.png"
  }, {
    id: "12",
    title: "Apple company-11",
    vacancies: 0,
    image: "images/homePage/apple.png"
  }];
  return /* @__PURE__ */ (0, import_jsx_dev_runtime41.jsxDEV)(WrapperSection4, { children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime41.jsxDEV)(TitleContainer2, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime41.jsxDEV)(Text, { variant: TextVariantEnum.textHeading1, color: theme.mainPage.titleColor, children: t4("home:companies") }, void 0, !1, {
      fileName: "app/components/pages/HomePage/SectionCompanies/index.tsx",
      lineNumber: 77,
      columnNumber: 9
    }, this) }, void 0, !1, {
      fileName: "app/components/pages/HomePage/SectionCompanies/index.tsx",
      lineNumber: 76,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime41.jsxDEV)(SliderContainer, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime41.jsxDEV)(Slider, { theme, variant: "companies", slides: temporaryCompanies }, void 0, !1, {
      fileName: "app/components/pages/HomePage/SectionCompanies/index.tsx",
      lineNumber: 82,
      columnNumber: 9
    }, this) }, void 0, !1, {
      fileName: "app/components/pages/HomePage/SectionCompanies/index.tsx",
      lineNumber: 81,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime41.jsxDEV)(ButtonWrapper, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime41.jsxDEV)(Button_default, { priority: "primary", size: "S", children: /* @__PURE__ */ (0, import_jsx_dev_runtime41.jsxDEV)(Text, { variant: TextVariantEnum.textBody2, children: t4("home:see_more_companies") }, void 0, !1, {
      fileName: "app/components/pages/HomePage/SectionCompanies/index.tsx",
      lineNumber: 86,
      columnNumber: 11
    }, this) }, void 0, !1, {
      fileName: "app/components/pages/HomePage/SectionCompanies/index.tsx",
      lineNumber: 85,
      columnNumber: 9
    }, this) }, void 0, !1, {
      fileName: "app/components/pages/HomePage/SectionCompanies/index.tsx",
      lineNumber: 84,
      columnNumber: 7
    }, this)
  ] }, void 0, !0, {
    fileName: "app/components/pages/HomePage/SectionCompanies/index.tsx",
    lineNumber: 75,
    columnNumber: 10
  }, this);
});

// app/components/pages/HomePage/SectionArticles/index.tsx
var import_react62 = __toESM(require_react());

// app/components/pages/HomePage/SectionArticles/styles.ts
var WrapperSection5 = styled_components_esm_default.div`
  display: flex;
  width: 100%;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  background-size: cover;
  background-repeat: round;
  padding: 32px 0;
  gap: 24px;
  background-color: ${({ theme }) => theme.mainPage.backgroundSectionArticlesColor};
  @media (min-width: 768px) {
    padding: 40px 0 48px;
    gap: 32px;
    background-color: ${({ theme }) => theme.mainPage.backgroundSectionNewsColor};
  }

  @media (min-width: 1024px) {
    padding: 40px 0 48px;
  }

  @media (min-width: 1280px) {
    padding: 80px 0;
  }
`, TitleContainer3 = styled_components_esm_default.div`
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  text-align: center;
`, SwiperChips3 = styled_components_esm_default.div`
  display: flex;
`, MobileContainer3 = styled_components_esm_default.div`
  width: 100%;
  @media (min-width: 768px) {
    display: none;
  }
`, TabletContainer3 = styled_components_esm_default.div`
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  @media (max-width: 768px) {
    display: none;
  }
`, SliderContainer2 = styled_components_esm_default.div`
  width: 100%;

  @media (min-width: 576px) {
    padding-left: 28px;
  }

  @media (min-width: 768px) {
    padding-left: 34px;
  }

  @media (min-width: 1240px) {
    padding: 0 162px;
    display: flex;
    justify-content: center;
  }
`, ButtonWrapper2 = styled_components_esm_default.div`
  display: flex;
  max-width: 1090px;
  width: 100%;
  justify-content: center;
  @media (min-width: 1024px) {
    justify-content: flex-end;
  }
`, ButtonInner = styled_components_esm_default.div`
  margin-top: -6px;
  max-width: 1200px;
  @media (min-width: 768px) {
    margin-top: -12px;
  }
  @media (min-width: 1024px) {
    display: none;
  }
  @media (min-width: 1280px) {
    display: flex;
    align-self: end;
    justify-content: flex-end;
    margin-top: -32px;
    z-index: 2;
  }
`;

// app/components/pages/HomePage/SectionNews/styles.ts
var WrapperSection6 = styled_components_esm_default.div`
  display: flex;
  width: 100%;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  background-size: cover;
  background-repeat: round;
  padding: 32px 0;
  gap: 24px;
  background-color: ${({ theme }) => theme.mainPage.backgroundSectionNewsColor};
  @media (min-width: 768px) {
    padding: 40px 0 48px;
    gap: 32px;
    background-color: ${({ theme }) => theme.mainPage.backgroundSectionArticlesColor};
  }

  @media (min-width: 1024px) {
    padding: 40px 0 48px;
  }
  @media (min-width: 1280px) {
    padding: 80px 0;
  }
`, TitleContainer4 = styled_components_esm_default.div`
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  text-align: center;
`, SwiperChips4 = styled_components_esm_default.div`
  display: flex;
`, MobileContainer4 = styled_components_esm_default.div`
  width: 100%;
  @media (min-width: 768px) {
    display: none;
  }
`, TabletContainer4 = styled_components_esm_default.div`
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  @media (max-width: 768px) {
    display: none;
  }
`, SliderContainer3 = styled_components_esm_default.div`
  width: 100%;

  @media (min-width: 576px) {
    padding-left: 28px;
  }

  @media (min-width: 768px) {
    padding-left: 34px;
  }

  @media (min-width: 1240px) {
    padding: 0 162px;
    display: flex;
    justify-content: center;
  }
`, ButtonWrapper3 = styled_components_esm_default.div`
  display: flex;
  max-width: 1090px;
  width: 100%;
  justify-content: center;
  @media (min-width: 1024px) {
    justify-content: flex-end;
  }
`, ButtonInner2 = styled_components_esm_default.div`
  margin-top: -6px;
  max-width: 1200px;
  @media (min-width: 768px) {
    margin-top: -12px;
  }
  @media (min-width: 1024px) {
    display: none;
  }
  @media (min-width: 1280px) {
    display: flex;
    align-self: end;
    justify-content: flex-end;
    margin-top: -32px;
    z-index: 2;
  }
`;

// app/components/pages/HomePage/SectionArticles/index.tsx
var import_jsx_dev_runtime42 = __toESM(require_jsx_dev_runtime()), SectionArticles = (0, import_react62.memo)(function() {
  let {
    theme,
    t: t4
  } = useApp(), temporaryNews = [{
    id: "1",
    title: " 1 - The first Episode of NBT \u201CMee Kam Tob\u201D Features MOL\u2019s Liveasdas",
    date: "17.02.2023",
    image: "images/homePage/new.png"
  }, {
    id: "2",
    title: "2 - The first Episode of NBT \u201CMee Kam Tob\u201D Features MOL\u2019s Liveasdas",
    date: "17.02.2023",
    image: "images/homePage/new.png"
  }, {
    id: "3",
    title: "3 - The first Episode of NBT \u201CMee Kam Tob\u201D Features MOL\u2019s Liveasdas",
    date: "17.02.2023",
    image: "images/homePage/new.png"
  }, {
    id: "4",
    title: "4 - The first Episode of NBT \u201CMee Kam Tob\u201D Features MOL\u2019s Liveasdas",
    date: "17.02.2023",
    image: "images/homePage/new.png"
  }, {
    id: "5",
    title: "5 - The first Episode of NBT \u201CMee Kam Tob\u201D Features MOL\u2019s Liveasdas",
    date: "17.02.2023",
    image: "images/homePage/new.png"
  }, {
    id: "6",
    title: "6 - Apple company-2",
    vacancies: 0,
    image: "images/homePage/new.png"
  }, {
    id: "7",
    title: " 1 - The first Episode of NBT \u201CMee Kam Tob\u201D Features MOL\u2019s Liveasdas",
    date: "17.02.2023",
    image: "images/homePage/new.png"
  }, {
    id: "8",
    title: "2 - The first Episode of NBT \u201CMee Kam Tob\u201D Features MOL\u2019s Liveasdas",
    date: "17.02.2023",
    image: "images/homePage/new.png"
  }, {
    id: "9",
    title: "3 - The first Episode of NBT \u201CMee Kam Tob\u201D Features MOL\u2019s Liveasdas",
    date: "17.02.2023",
    image: "images/homePage/new.png"
  }, {
    id: "10",
    title: "4 - The first Episode of NBT \u201CMee Kam Tob\u201D Features MOL\u2019s Liveasdas",
    date: "17.02.2023",
    image: "images/homePage/new.png"
  }, {
    id: "11",
    title: "5 - The first Episode of NBT \u201CMee Kam Tob\u201D Features MOL\u2019s Liveasdas",
    date: "17.02.2023",
    image: "images/homePage/new.png"
  }, {
    id: "12",
    title: "6 - Apple company-2",
    vacancies: 0,
    image: "images/homePage/new.png"
  }];
  return /* @__PURE__ */ (0, import_jsx_dev_runtime42.jsxDEV)(WrapperSection5, { children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime42.jsxDEV)(TitleContainer3, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime42.jsxDEV)(Text, { variant: TextVariantEnum.textHeading1, color: theme.mainPage.titleColor, children: t4("home:articles") }, void 0, !1, {
      fileName: "app/components/pages/HomePage/SectionArticles/index.tsx",
      lineNumber: 78,
      columnNumber: 9
    }, this) }, void 0, !1, {
      fileName: "app/components/pages/HomePage/SectionArticles/index.tsx",
      lineNumber: 77,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime42.jsxDEV)(SliderContainer2, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime42.jsxDEV)(Slider, { theme, variant: "articles", slides: temporaryNews }, void 0, !1, {
      fileName: "app/components/pages/HomePage/SectionArticles/index.tsx",
      lineNumber: 83,
      columnNumber: 9
    }, this) }, void 0, !1, {
      fileName: "app/components/pages/HomePage/SectionArticles/index.tsx",
      lineNumber: 82,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime42.jsxDEV)(ButtonWrapper2, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime42.jsxDEV)(ButtonInner2, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime42.jsxDEV)(Button_default, { priority: "small", size: "S", children: /* @__PURE__ */ (0, import_jsx_dev_runtime42.jsxDEV)(Text, { variant: TextVariantEnum.textBody2, children: t4("home:see_all_articles") }, void 0, !1, {
      fileName: "app/components/pages/HomePage/SectionArticles/index.tsx",
      lineNumber: 88,
      columnNumber: 13
    }, this) }, void 0, !1, {
      fileName: "app/components/pages/HomePage/SectionArticles/index.tsx",
      lineNumber: 87,
      columnNumber: 11
    }, this) }, void 0, !1, {
      fileName: "app/components/pages/HomePage/SectionArticles/index.tsx",
      lineNumber: 86,
      columnNumber: 9
    }, this) }, void 0, !1, {
      fileName: "app/components/pages/HomePage/SectionArticles/index.tsx",
      lineNumber: 85,
      columnNumber: 7
    }, this)
  ] }, void 0, !0, {
    fileName: "app/components/pages/HomePage/SectionArticles/index.tsx",
    lineNumber: 76,
    columnNumber: 10
  }, this);
});

// app/components/pages/HomePage/SectionNews/index.tsx
var import_react63 = __toESM(require_react());
var import_jsx_dev_runtime43 = __toESM(require_jsx_dev_runtime());
function mapMaterialsToViewModel(material, language) {
  var _a, _b;
  return {
    id: material.id,
    title: lng((_a = material.en) == null ? void 0 : _a.title, (_b = material.th) == null ? void 0 : _b.title, language),
    date: material.created_at,
    vacancies: void 0,
    image: material.image
  };
}
var SectionNews = (0, import_react63.memo)(function({
  news
}) {
  let {
    theme,
    t: t4,
    userContext
  } = useApp(), slides = news.map((item) => mapMaterialsToViewModel(item, userContext.language));
  return /* @__PURE__ */ (0, import_jsx_dev_runtime43.jsxDEV)(WrapperSection6, { children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime43.jsxDEV)(TitleContainer4, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime43.jsxDEV)(Text, { variant: TextVariantEnum.textHeading1, color: theme.mainPage.titleColor, children: t4("home:news") }, void 0, !1, {
      fileName: "app/components/pages/HomePage/SectionNews/index.tsx",
      lineNumber: 35,
      columnNumber: 9
    }, this) }, void 0, !1, {
      fileName: "app/components/pages/HomePage/SectionNews/index.tsx",
      lineNumber: 34,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime43.jsxDEV)(SliderContainer3, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime43.jsxDEV)(Slider, { theme, variant: "articles", slides }, void 0, !1, {
      fileName: "app/components/pages/HomePage/SectionNews/index.tsx",
      lineNumber: 40,
      columnNumber: 9
    }, this) }, void 0, !1, {
      fileName: "app/components/pages/HomePage/SectionNews/index.tsx",
      lineNumber: 39,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime43.jsxDEV)(ButtonWrapper3, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime43.jsxDEV)(ButtonInner2, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime43.jsxDEV)(Button_default, { priority: "small", size: "S", children: /* @__PURE__ */ (0, import_jsx_dev_runtime43.jsxDEV)(Text, { variant: TextVariantEnum.textBody2, children: t4("home:see_all_news") }, void 0, !1, {
      fileName: "app/components/pages/HomePage/SectionNews/index.tsx",
      lineNumber: 45,
      columnNumber: 13
    }, this) }, void 0, !1, {
      fileName: "app/components/pages/HomePage/SectionNews/index.tsx",
      lineNumber: 44,
      columnNumber: 11
    }, this) }, void 0, !1, {
      fileName: "app/components/pages/HomePage/SectionNews/index.tsx",
      lineNumber: 43,
      columnNumber: 9
    }, this) }, void 0, !1, {
      fileName: "app/components/pages/HomePage/SectionNews/index.tsx",
      lineNumber: 42,
      columnNumber: 7
    }, this)
  ] }, void 0, !0, {
    fileName: "app/components/pages/HomePage/SectionNews/index.tsx",
    lineNumber: 33,
    columnNumber: 10
  }, this);
});

// app/components/pages/HomePage/styles.ts
var SectionInnerContaier = styled_components_esm_default.div`
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  width: 100%;
  height: 100%;
  @media (min-width: 768px) {
    flex-direction: column-reverse;
  }
`;

// app/components/pages/HomePage/index.tsx
var import_jsx_dev_runtime44 = __toESM(require_jsx_dev_runtime()), HomePage = (0, import_react64.memo)(function({
  news
}) {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime44.jsxDEV)(CommonLayout, { children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime44.jsxDEV)(SectionTop, {}, void 0, !1, {
      fileName: "app/components/pages/HomePage/index.tsx",
      lineNumber: 18,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime44.jsxDEV)(SectionTrending, {}, void 0, !1, {
      fileName: "app/components/pages/HomePage/index.tsx",
      lineNumber: 19,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime44.jsxDEV)(SectionInnerContaier, { children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime44.jsxDEV)(SectionCompanies, {}, void 0, !1, {
        fileName: "app/components/pages/HomePage/index.tsx",
        lineNumber: 21,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime44.jsxDEV)(SectionBenefits, {}, void 0, !1, {
        fileName: "app/components/pages/HomePage/index.tsx",
        lineNumber: 22,
        columnNumber: 9
      }, this)
    ] }, void 0, !0, {
      fileName: "app/components/pages/HomePage/index.tsx",
      lineNumber: 20,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime44.jsxDEV)(SectionNews, { news }, void 0, !1, {
      fileName: "app/components/pages/HomePage/index.tsx",
      lineNumber: 24,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime44.jsxDEV)(SectionArticles, {}, void 0, !1, {
      fileName: "app/components/pages/HomePage/index.tsx",
      lineNumber: 25,
      columnNumber: 7
    }, this)
  ] }, void 0, !0, {
    fileName: "app/components/pages/HomePage/index.tsx",
    lineNumber: 17,
    columnNumber: 10
  }, this);
});

// app/routes/index.tsx
var import_jsx_dev_runtime45 = __toESM(require_jsx_dev_runtime()), loader4 = async ({
  request
}) => {
  let response = await new Api().materials.newsList();
  return response.data.data ? (0, import_cloudflare7.json)(response.data.data) : (0, import_cloudflare7.json)([]);
};
function Index3() {
  let data2 = (0, import_components6.useLoaderData)();
  return console.warn(data2), /* @__PURE__ */ (0, import_jsx_dev_runtime45.jsxDEV)(HomePage, { news: data2 }, void 0, !1, {
    fileName: "app/routes/index.tsx",
    lineNumber: 19,
    columnNumber: 10
  }, this);
}

// server-assets-manifest:@remix-run/dev/assets-manifest
var assets_manifest_default = { version: "17611358", entry: { module: "/build/entry.client-G24S4VCH.js", imports: ["/build/_shared/chunk-CRGVEBB3.js", "/build/_shared/chunk-YWFOTFS4.js", "/build/_shared/chunk-AAZ33T2Z.js", "/build/_shared/chunk-CUPSZOF3.js"] }, routes: { root: { id: "root", parentId: void 0, path: "", index: void 0, caseSensitive: void 0, module: "/build/root-J5URB4IA.js", imports: ["/build/_shared/chunk-EJ6KTDW6.js", "/build/_shared/chunk-P24T54YX.js"], hasAction: !1, hasLoader: !0, hasCatchBoundary: !1, hasErrorBoundary: !1 }, "routes/account/index": { id: "routes/account/index", parentId: "root", path: "account", index: !0, caseSensitive: void 0, module: "/build/routes/account/index-NEEQ6TL2.js", imports: ["/build/_shared/chunk-3LQHUPDF.js"], hasAction: !1, hasLoader: !1, hasCatchBoundary: !1, hasErrorBoundary: !1 }, "routes/actions/set-user-context": { id: "routes/actions/set-user-context", parentId: "root", path: "actions/set-user-context", index: void 0, caseSensitive: void 0, module: "/build/routes/actions/set-user-context-H2FRT7H5.js", imports: void 0, hasAction: !0, hasLoader: !0, hasCatchBoundary: !1, hasErrorBoundary: !1 }, "routes/auth/login": { id: "routes/auth/login", parentId: "root", path: "auth/login", index: void 0, caseSensitive: void 0, module: "/build/routes/auth/login-OOA3Y7FJ.js", imports: void 0, hasAction: !0, hasLoader: !1, hasCatchBoundary: !1, hasErrorBoundary: !1 }, "routes/index": { id: "routes/index", parentId: "root", path: void 0, index: !0, caseSensitive: void 0, module: "/build/routes/index-K7A2ADAV.js", imports: ["/build/_shared/chunk-NOB3NN62.js", "/build/_shared/chunk-5CIWUDTL.js", "/build/_shared/chunk-3LQHUPDF.js"], hasAction: !1, hasLoader: !0, hasCatchBoundary: !1, hasErrorBoundary: !1 }, "routes/register": { id: "routes/register", parentId: "root", path: "register", index: void 0, caseSensitive: void 0, module: "/build/routes/register-UOEJOEON.js", imports: ["/build/_shared/chunk-5CIWUDTL.js", "/build/_shared/chunk-3LQHUPDF.js"], hasAction: !1, hasLoader: !1, hasCatchBoundary: !1, hasErrorBoundary: !1 }, "routes/ui/index": { id: "routes/ui/index", parentId: "root", path: "ui", index: !0, caseSensitive: void 0, module: "/build/routes/ui/index-SZAIUCPW.js", imports: ["/build/_shared/chunk-NOB3NN62.js", "/build/_shared/chunk-5CIWUDTL.js", "/build/_shared/chunk-3LQHUPDF.js"], hasAction: !1, hasLoader: !1, hasCatchBoundary: !1, hasErrorBoundary: !1 } }, cssBundleHref: void 0, hmr: void 0, url: "/build/manifest-17611358.js" };

// server-entry-module:@remix-run/dev/server-build
var assetsBuildDirectory = "public/build", future = { unstable_cssModules: !1, unstable_cssSideEffectImports: !1, unstable_dev: !1, unstable_postcss: !1, unstable_tailwind: !0, unstable_vanillaExtract: !1, v2_errorBoundary: !1, v2_meta: !1, v2_normalizeFormMethod: !1, v2_routeConvention: !1 }, publicPath = "/build/", entry = { module: entry_server_exports }, routes = {
  root: {
    id: "root",
    parentId: void 0,
    path: "",
    index: void 0,
    caseSensitive: void 0,
    module: root_exports
  },
  "routes/actions/set-user-context": {
    id: "routes/actions/set-user-context",
    parentId: "root",
    path: "actions/set-user-context",
    index: void 0,
    caseSensitive: void 0,
    module: set_user_context_exports
  },
  "routes/account/index": {
    id: "routes/account/index",
    parentId: "root",
    path: "account",
    index: !0,
    caseSensitive: void 0,
    module: account_exports
  },
  "routes/auth/login": {
    id: "routes/auth/login",
    parentId: "root",
    path: "auth/login",
    index: void 0,
    caseSensitive: void 0,
    module: login_exports
  },
  "routes/register": {
    id: "routes/register",
    parentId: "root",
    path: "register",
    index: void 0,
    caseSensitive: void 0,
    module: register_exports
  },
  "routes/ui/index": {
    id: "routes/ui/index",
    parentId: "root",
    path: "ui",
    index: !0,
    caseSensitive: void 0,
    module: ui_exports
  },
  "routes/index": {
    id: "routes/index",
    parentId: "root",
    path: void 0,
    index: !0,
    caseSensitive: void 0,
    module: routes_exports
  }
};

// server.js
var handleRequest2 = createPagesFunctionHandler({
  build: server_build_exports,
  mode: "development",
  getLoadContext: (context) => context.env
});
function onRequest(context) {
  return handleRequest2(context);
}
export {
  onRequest
};
//# sourceMappingURL=/build/[[path]].js.map
