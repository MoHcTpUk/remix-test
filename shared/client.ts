//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export interface IDictionariesClient {

    /**
     * @param title (optional) title
     * @param ids (optional) id or ids
     * @return OK
     */
    citizenship(title: string | null | undefined, ids: string[] | null | undefined): Promise<CommonDictionary[]>;

    /**
     * @return OK
     */
    complianceOfRequirements(): Promise<CommonDictionary[]>;

    /**
     * @return OK
     */
    currency(): Promise<CommonDictionary[]>;

    /**
     * @return OK
     */
    drivingLicenses(): Promise<CommonDictionary[]>;

    /**
     * @return OK
     */
    educationLevel(): Promise<CommonDictionary[]>;

    /**
     * @return OK
     */
    emailNotificationsSettings(): Promise<CommonDictionary[]>;

    /**
     * @return OK
     */
    numbers(): Promise<Employee[]>;

    /**
     * @return OK
     */
    employments(): Promise<CommonDictionary[]>;

    /**
     * @return OK
     */
    genders(): Promise<CommonDictionary[]>;

    /**
     * @return OK
     */
    jobTypes(): Promise<CommonDictionary[]>;

    /**
     * @return OK
     */
    maritalStatuses(): Promise<CommonDictionary[]>;

    /**
     * @return OK
     */
    payoutPeriods(): Promise<CommonDictionary[]>;

    /**
     * @return OK
     */
    religions(): Promise<CommonDictionary[]>;

    /**
     * @return OK
     */
    relocations(): Promise<CommonDictionary[]>;

    /**
     * @return OK
     */
    requirementsLevel(): Promise<CommonDictionary[]>;

    /**
     * @return OK
     */
    responseCanBeDoneBy(): Promise<CommonDictionary[]>;

    /**
     * @return OK
     */
    showEmail(): Promise<CommonDictionary[]>;

    /**
     * @return OK
     */
    showPhoneNumber(): Promise<CommonDictionary[]>;

    /**
     * @param title (optional) title
     * @param ids (optional) id or ids
     * @return OK
     */
    skills(title: string | null | undefined, ids: string[] | null | undefined): Promise<CommonDictionary[]>;

    /**
     * @param title (optional) title
     * @param ids (optional) id or ids
     * @return OK
     */
    specializations(title: string | null | undefined, ids: string[] | null | undefined): Promise<CommonDictionary[]>;

    /**
     * @param specialization_id specialization id
     * @param title (optional) title
     * @param position_ids (optional) position id or ids
     * @return OK
     */
    jobPositions(specialization_id: string, title: string | null | undefined, position_ids: string[] | null | undefined): Promise<CommonDictionary[]>;

    /**
     * @return OK
     */
    workFeatures(): Promise<CommonDictionary[]>;

    /**
     * @return OK
     */
    yearsOfExperience(): Promise<CommonDictionary[]>;
}

export class DictionariesClient implements IDictionariesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://upjob.com/api/v1";
    }

    /**
     * @param title (optional) title
     * @param ids (optional) id or ids
     * @return OK
     */
    citizenship(title: string | null | undefined, ids: string[] | null | undefined): Promise<CommonDictionary[]> {
        let url_ = this.baseUrl + "/citizenship?";
        if (title !== undefined && title !== null)
            url_ += "title=" + encodeURIComponent("" + title) + "&";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCitizenship(_response);
        });
    }

    protected processCitizenship(response: Response): Promise<CommonDictionary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommonDictionary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = EmptyResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommonDictionary[]>(null as any);
    }

    /**
     * @return OK
     */
    complianceOfRequirements(): Promise<CommonDictionary[]> {
        let url_ = this.baseUrl + "/compliance-of-requirements";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processComplianceOfRequirements(_response);
        });
    }

    protected processComplianceOfRequirements(response: Response): Promise<CommonDictionary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommonDictionary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = EmptyResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommonDictionary[]>(null as any);
    }

    /**
     * @return OK
     */
    currency(): Promise<CommonDictionary[]> {
        let url_ = this.baseUrl + "/currency";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCurrency(_response);
        });
    }

    protected processCurrency(response: Response): Promise<CommonDictionary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommonDictionary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = EmptyResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommonDictionary[]>(null as any);
    }

    /**
     * @return OK
     */
    drivingLicenses(): Promise<CommonDictionary[]> {
        let url_ = this.baseUrl + "/driving-licenses";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDrivingLicenses(_response);
        });
    }

    protected processDrivingLicenses(response: Response): Promise<CommonDictionary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommonDictionary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = EmptyResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommonDictionary[]>(null as any);
    }

    /**
     * @return OK
     */
    educationLevel(): Promise<CommonDictionary[]> {
        let url_ = this.baseUrl + "/education-level";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEducationLevel(_response);
        });
    }

    protected processEducationLevel(response: Response): Promise<CommonDictionary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommonDictionary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = EmptyResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommonDictionary[]>(null as any);
    }

    /**
     * @return OK
     */
    emailNotificationsSettings(): Promise<CommonDictionary[]> {
        let url_ = this.baseUrl + "/email-notifications-settings";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEmailNotificationsSettings(_response);
        });
    }

    protected processEmailNotificationsSettings(response: Response): Promise<CommonDictionary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommonDictionary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = EmptyResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommonDictionary[]>(null as any);
    }

    /**
     * @return OK
     */
    numbers(): Promise<Employee[]> {
        let url_ = this.baseUrl + "/employee/numbers";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNumbers(_response);
        });
    }

    protected processNumbers(response: Response): Promise<Employee[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Employee.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = EmptyResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Employee[]>(null as any);
    }

    /**
     * @return OK
     */
    employments(): Promise<CommonDictionary[]> {
        let url_ = this.baseUrl + "/employments";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEmployments(_response);
        });
    }

    protected processEmployments(response: Response): Promise<CommonDictionary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommonDictionary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = EmptyResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommonDictionary[]>(null as any);
    }

    /**
     * @return OK
     */
    genders(): Promise<CommonDictionary[]> {
        let url_ = this.baseUrl + "/genders";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGenders(_response);
        });
    }

    protected processGenders(response: Response): Promise<CommonDictionary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommonDictionary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = EmptyResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommonDictionary[]>(null as any);
    }

    /**
     * @return OK
     */
    jobTypes(): Promise<CommonDictionary[]> {
        let url_ = this.baseUrl + "/job-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processJobTypes(_response);
        });
    }

    protected processJobTypes(response: Response): Promise<CommonDictionary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommonDictionary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = EmptyResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommonDictionary[]>(null as any);
    }

    /**
     * @return OK
     */
    maritalStatuses(): Promise<CommonDictionary[]> {
        let url_ = this.baseUrl + "/marital-statuses";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMaritalStatuses(_response);
        });
    }

    protected processMaritalStatuses(response: Response): Promise<CommonDictionary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommonDictionary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = EmptyResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommonDictionary[]>(null as any);
    }

    /**
     * @return OK
     */
    payoutPeriods(): Promise<CommonDictionary[]> {
        let url_ = this.baseUrl + "/payout-periods";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPayoutPeriods(_response);
        });
    }

    protected processPayoutPeriods(response: Response): Promise<CommonDictionary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommonDictionary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = EmptyResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommonDictionary[]>(null as any);
    }

    /**
     * @return OK
     */
    religions(): Promise<CommonDictionary[]> {
        let url_ = this.baseUrl + "/religions";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReligions(_response);
        });
    }

    protected processReligions(response: Response): Promise<CommonDictionary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommonDictionary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = EmptyResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommonDictionary[]>(null as any);
    }

    /**
     * @return OK
     */
    relocations(): Promise<CommonDictionary[]> {
        let url_ = this.baseUrl + "/relocations";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRelocations(_response);
        });
    }

    protected processRelocations(response: Response): Promise<CommonDictionary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommonDictionary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = EmptyResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommonDictionary[]>(null as any);
    }

    /**
     * @return OK
     */
    requirementsLevel(): Promise<CommonDictionary[]> {
        let url_ = this.baseUrl + "/requirements-level";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRequirementsLevel(_response);
        });
    }

    protected processRequirementsLevel(response: Response): Promise<CommonDictionary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommonDictionary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = EmptyResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommonDictionary[]>(null as any);
    }

    /**
     * @return OK
     */
    responseCanBeDoneBy(): Promise<CommonDictionary[]> {
        let url_ = this.baseUrl + "/response-can-be-done-by";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResponseCanBeDoneBy(_response);
        });
    }

    protected processResponseCanBeDoneBy(response: Response): Promise<CommonDictionary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommonDictionary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = EmptyResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommonDictionary[]>(null as any);
    }

    /**
     * @return OK
     */
    showEmail(): Promise<CommonDictionary[]> {
        let url_ = this.baseUrl + "/show-email";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processShowEmail(_response);
        });
    }

    protected processShowEmail(response: Response): Promise<CommonDictionary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommonDictionary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = EmptyResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommonDictionary[]>(null as any);
    }

    /**
     * @return OK
     */
    showPhoneNumber(): Promise<CommonDictionary[]> {
        let url_ = this.baseUrl + "/show-phone-number";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processShowPhoneNumber(_response);
        });
    }

    protected processShowPhoneNumber(response: Response): Promise<CommonDictionary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommonDictionary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = EmptyResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommonDictionary[]>(null as any);
    }

    /**
     * @param title (optional) title
     * @param ids (optional) id or ids
     * @return OK
     */
    skills(title: string | null | undefined, ids: string[] | null | undefined): Promise<CommonDictionary[]> {
        let url_ = this.baseUrl + "/skills?";
        if (title !== undefined && title !== null)
            url_ += "title=" + encodeURIComponent("" + title) + "&";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSkills(_response);
        });
    }

    protected processSkills(response: Response): Promise<CommonDictionary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommonDictionary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = EmptyResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommonDictionary[]>(null as any);
    }

    /**
     * @param title (optional) title
     * @param ids (optional) id or ids
     * @return OK
     */
    specializations(title: string | null | undefined, ids: string[] | null | undefined): Promise<CommonDictionary[]> {
        let url_ = this.baseUrl + "/specializations?";
        if (title !== undefined && title !== null)
            url_ += "title=" + encodeURIComponent("" + title) + "&";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSpecializations(_response);
        });
    }

    protected processSpecializations(response: Response): Promise<CommonDictionary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommonDictionary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = EmptyResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommonDictionary[]>(null as any);
    }

    /**
     * @param specialization_id specialization id
     * @param title (optional) title
     * @param position_ids (optional) position id or ids
     * @return OK
     */
    jobPositions(specialization_id: string, title: string | null | undefined, position_ids: string[] | null | undefined): Promise<CommonDictionary[]> {
        let url_ = this.baseUrl + "/specializations/{specialization_id}/job-positions?";
        if (specialization_id === undefined || specialization_id === null)
            throw new Error("The parameter 'specialization_id' must be defined.");
        url_ = url_.replace("{specialization_id}", encodeURIComponent("" + specialization_id));
        if (title !== undefined && title !== null)
            url_ += "title=" + encodeURIComponent("" + title) + "&";
        if (position_ids !== undefined && position_ids !== null)
            position_ids && position_ids.forEach(item => { url_ += "position_ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processJobPositions(_response);
        });
    }

    protected processJobPositions(response: Response): Promise<CommonDictionary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommonDictionary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = EmptyResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommonDictionary[]>(null as any);
    }

    /**
     * @return OK
     */
    workFeatures(): Promise<CommonDictionary[]> {
        let url_ = this.baseUrl + "/work-features";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWorkFeatures(_response);
        });
    }

    protected processWorkFeatures(response: Response): Promise<CommonDictionary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommonDictionary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = EmptyResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommonDictionary[]>(null as any);
    }

    /**
     * @return OK
     */
    yearsOfExperience(): Promise<CommonDictionary[]> {
        let url_ = this.baseUrl + "/years-of-experience";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processYearsOfExperience(_response);
        });
    }

    protected processYearsOfExperience(response: Response): Promise<CommonDictionary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommonDictionary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = EmptyResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommonDictionary[]>(null as any);
    }
}

export interface ICompaniesClient {

    /**
     * @param only_my (optional) show companies created by the current user
     * @param on_main_page (optional) show companies on main page
     * @param search_text (optional) search by company name & city
     * @param limit (optional) minimum value: 0, maximum value: 100
     * @param offset (optional) default value: 0
     * @return OK
     */
    companiesGET(only_my: boolean | null | undefined, on_main_page: boolean | null | undefined, search_text: string | null | undefined, limit: number | null | undefined, offset: number | null | undefined): Promise<GetCompaniesResponse>;

    /**
     * @param request add company request
     * @return OK
     */
    companiesPOST(request: CreateCompanyRequest): Promise<Company>;

    /**
     * @param id id
     * @return OK
     */
    companiesGET2(id: string): Promise<Company>;

    /**
     * @param id id
     * @return No Content
     */
    companiesDELETE(id: string): Promise<EmptyResponse>;
}

export class CompaniesClient implements ICompaniesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://upjob.com/api/v1";
    }

    /**
     * @param only_my (optional) show companies created by the current user
     * @param on_main_page (optional) show companies on main page
     * @param search_text (optional) search by company name & city
     * @param limit (optional) minimum value: 0, maximum value: 100
     * @param offset (optional) default value: 0
     * @return OK
     */
    companiesGET(only_my: boolean | null | undefined, on_main_page: boolean | null | undefined, search_text: string | null | undefined, limit: number | null | undefined, offset: number | null | undefined): Promise<GetCompaniesResponse> {
        let url_ = this.baseUrl + "/companies?";
        if (only_my !== undefined && only_my !== null)
            url_ += "only_my=" + encodeURIComponent("" + only_my) + "&";
        if (on_main_page !== undefined && on_main_page !== null)
            url_ += "on_main_page=" + encodeURIComponent("" + on_main_page) + "&";
        if (search_text !== undefined && search_text !== null)
            url_ += "search_text=" + encodeURIComponent("" + search_text) + "&";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset !== undefined && offset !== null)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCompaniesGET(_response);
        });
    }

    protected processCompaniesGET(response: Response): Promise<GetCompaniesResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCompaniesResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = EmptyResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetCompaniesResponse>(null as any);
    }

    /**
     * @param request add company request
     * @return OK
     */
    companiesPOST(request: CreateCompanyRequest): Promise<Company> {
        let url_ = this.baseUrl + "/companies";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCompaniesPOST(_response);
        });
    }

    protected processCompaniesPOST(response: Response): Promise<Company> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Company.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = EmptyResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Company>(null as any);
    }

    /**
     * @param id id
     * @return OK
     */
    companiesGET2(id: string): Promise<Company> {
        let url_ = this.baseUrl + "/companies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCompaniesGET2(_response);
        });
    }

    protected processCompaniesGET2(response: Response): Promise<Company> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Company.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = EmptyResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = EmptyResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Company>(null as any);
    }

    /**
     * @param id id
     * @return No Content
     */
    companiesDELETE(id: string): Promise<EmptyResponse> {
        let url_ = this.baseUrl + "/companies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCompaniesDELETE(_response);
        });
    }

    protected processCompaniesDELETE(response: Response): Promise<EmptyResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = EmptyResponse.fromJS(resultData204);
            return result204;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = EmptyResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = EmptyResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EmptyResponse>(null as any);
    }
}

export interface ICountriesClient {

    /**
     * @return OK
     */
    countries(): Promise<CommonDictionary[]>;

    /**
     * @param country_id country_id
     * @return OK
     */
    regions(country_id: string): Promise<CommonDictionary[]>;

    /**
     * @param country_id country_id
     * @param region_id region_id
     * @return OK
     */
    location(country_id: string, region_id: string): Promise<CommonDictionary[]>;

    /**
     * @param title (optional) title
     * @param ids (optional) id or ids
     * @return OK
     */
    location2(title: string | null | undefined, ids: string[] | null | undefined): Promise<CommonDictionary[]>;
}

export class CountriesClient implements ICountriesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://upjob.com/api/v1";
    }

    /**
     * @return OK
     */
    countries(): Promise<CommonDictionary[]> {
        let url_ = this.baseUrl + "/countries";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCountries(_response);
        });
    }

    protected processCountries(response: Response): Promise<CommonDictionary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommonDictionary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = EmptyResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommonDictionary[]>(null as any);
    }

    /**
     * @param country_id country_id
     * @return OK
     */
    regions(country_id: string): Promise<CommonDictionary[]> {
        let url_ = this.baseUrl + "/countries/{country_id}/regions";
        if (country_id === undefined || country_id === null)
            throw new Error("The parameter 'country_id' must be defined.");
        url_ = url_.replace("{country_id}", encodeURIComponent("" + country_id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegions(_response);
        });
    }

    protected processRegions(response: Response): Promise<CommonDictionary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommonDictionary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = EmptyResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommonDictionary[]>(null as any);
    }

    /**
     * @param country_id country_id
     * @param region_id region_id
     * @return OK
     */
    location(country_id: string, region_id: string): Promise<CommonDictionary[]> {
        let url_ = this.baseUrl + "/countries/{country_id}/regions/{region_id}/location";
        if (country_id === undefined || country_id === null)
            throw new Error("The parameter 'country_id' must be defined.");
        url_ = url_.replace("{country_id}", encodeURIComponent("" + country_id));
        if (region_id === undefined || region_id === null)
            throw new Error("The parameter 'region_id' must be defined.");
        url_ = url_.replace("{region_id}", encodeURIComponent("" + region_id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLocation(_response);
        });
    }

    protected processLocation(response: Response): Promise<CommonDictionary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommonDictionary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = EmptyResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommonDictionary[]>(null as any);
    }

    /**
     * @param title (optional) title
     * @param ids (optional) id or ids
     * @return OK
     */
    location2(title: string | null | undefined, ids: string[] | null | undefined): Promise<CommonDictionary[]> {
        let url_ = this.baseUrl + "/location?";
        if (title !== undefined && title !== null)
            url_ += "title=" + encodeURIComponent("" + title) + "&";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLocation2(_response);
        });
    }

    protected processLocation2(response: Response): Promise<CommonDictionary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommonDictionary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = EmptyResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommonDictionary[]>(null as any);
    }
}

export interface IFaqClient {

    /**
     * @param limit (optional) minimum value: 0, maximum value: 100
     * @return OK
     */
    faq(limit: number | null | undefined): Promise<Faq[]>;
}

export class FaqClient implements IFaqClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://upjob.com/api/v1";
    }

    /**
     * @param limit (optional) minimum value: 0, maximum value: 100
     * @return OK
     */
    faq(limit: number | null | undefined): Promise<Faq[]> {
        let url_ = this.baseUrl + "/faq?";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFaq(_response);
        });
    }

    protected processFaq(response: Response): Promise<Faq[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Faq.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = EmptyResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Faq[]>(null as any);
    }
}

export interface IFeedbackClient {

    /**
     * @param request create feedback request
     * @return No Content
     */
    feedback(request: CreateFeedbackRequest): Promise<EmptyResponse>;
}

export class FeedbackClient implements IFeedbackClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://upjob.com/api/v1";
    }

    /**
     * @param request create feedback request
     * @return No Content
     */
    feedback(request: CreateFeedbackRequest): Promise<EmptyResponse> {
        let url_ = this.baseUrl + "/feedback";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFeedback(_response);
        });
    }

    protected processFeedback(response: Response): Promise<EmptyResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = EmptyResponse.fromJS(resultData204);
            return result204;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = EmptyResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EmptyResponse>(null as any);
    }
}

export interface IUploadClient {

    /**
     * @param file file to upload
     * @return OK
     */
    upload(file: FileParameter): Promise<UploadResponse>;
}

export class UploadClient implements IUploadClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://upjob.com/api/v1";
    }

    /**
     * @param file file to upload
     * @return OK
     */
    upload(file: FileParameter): Promise<UploadResponse> {
        let url_ = this.baseUrl + "/file/upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpload(_response);
        });
    }

    protected processUpload(response: Response): Promise<UploadResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UploadResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = EmptyResponse.fromJS(resultData400);
            return throwException("file is missed", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = EmptyResponse.fromJS(resultData403);
            return throwException("session is missed", status, _responseText, _headers, result403);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = EmptyResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UploadResponse>(null as any);
    }
}

export interface IInitClient {

    /**
     * Main page feed
     * @return OK
     */
    index(): Promise<MainPageResponse>;
}

export class InitClient implements IInitClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://upjob.com/api/v1";
    }

    /**
     * Main page feed
     * @return OK
     */
    index(): Promise<MainPageResponse> {
        let url_ = this.baseUrl + "/init/index";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIndex(_response);
        });
    }

    protected processIndex(response: Response): Promise<MainPageResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MainPageResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MainPageResponse>(null as any);
    }
}

export interface ILanguagesClient {

    /**
     * @return OK
     */
    languageLevel(): Promise<CommonDictionary[]>;

    /**
     * @return OK
     */
    languages(): Promise<CommonDictionary[]>;
}

export class LanguagesClient implements ILanguagesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://upjob.com/api/v1";
    }

    /**
     * @return OK
     */
    languageLevel(): Promise<CommonDictionary[]> {
        let url_ = this.baseUrl + "/language-level";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLanguageLevel(_response);
        });
    }

    protected processLanguageLevel(response: Response): Promise<CommonDictionary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommonDictionary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = EmptyResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommonDictionary[]>(null as any);
    }

    /**
     * @return OK
     */
    languages(): Promise<CommonDictionary[]> {
        let url_ = this.baseUrl + "/languages";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLanguages(_response);
        });
    }

    protected processLanguages(response: Response): Promise<CommonDictionary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommonDictionary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = EmptyResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommonDictionary[]>(null as any);
    }
}

export interface IMaterialsClient {

    /**
     * @param limit (optional) minimum value: 0, maximum value: 100
     * @param scroll (optional) format: 2006-01-02T15:04:05
     * @param onmainpage (optional) is article in main page
     * @return OK
     */
    articles(limit: number | null | undefined, scroll: Date | null | undefined, onmainpage: boolean | null | undefined): Promise<FindPublishedByTypeResponse>;

    /**
     * @param id article id
     * @return OK
     */
    articles2(id: string): Promise<Material>;

    /**
     * @param limit (optional) minimum value: 0, maximum value: 100
     * @param scroll (optional) format: 2006-01-02T15:04:05
     * @param onmainpage (optional) is news in main page
     * @return OK
     */
    news(limit: number | null | undefined, scroll: Date | null | undefined, onmainpage: boolean | null | undefined): Promise<FindPublishedByTypeResponse>;

    /**
     * @param id news id
     * @return OK
     */
    news2(id: string): Promise<Material>;
}

export class MaterialsClient implements IMaterialsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://upjob.com/api/v1";
    }

    /**
     * @param limit (optional) minimum value: 0, maximum value: 100
     * @param scroll (optional) format: 2006-01-02T15:04:05
     * @param onmainpage (optional) is article in main page
     * @return OK
     */
    articles(limit: number | null | undefined, scroll: Date | null | undefined, onmainpage: boolean | null | undefined): Promise<FindPublishedByTypeResponse> {
        let url_ = this.baseUrl + "/materials/articles?";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (scroll !== undefined && scroll !== null)
            url_ += "scroll=" + encodeURIComponent(scroll ? "" + scroll.toISOString() : "") + "&";
        if (onmainpage !== undefined && onmainpage !== null)
            url_ += "onmainpage=" + encodeURIComponent("" + onmainpage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processArticles(_response);
        });
    }

    protected processArticles(response: Response): Promise<FindPublishedByTypeResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FindPublishedByTypeResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = EmptyResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindPublishedByTypeResponse>(null as any);
    }

    /**
     * @param id article id
     * @return OK
     */
    articles2(id: string): Promise<Material> {
        let url_ = this.baseUrl + "/materials/articles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processArticles2(_response);
        });
    }

    protected processArticles2(response: Response): Promise<Material> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Material.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = EmptyResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Material>(null as any);
    }

    /**
     * @param limit (optional) minimum value: 0, maximum value: 100
     * @param scroll (optional) format: 2006-01-02T15:04:05
     * @param onmainpage (optional) is news in main page
     * @return OK
     */
    news(limit: number | null | undefined, scroll: Date | null | undefined, onmainpage: boolean | null | undefined): Promise<FindPublishedByTypeResponse> {
        let url_ = this.baseUrl + "/materials/news?";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (scroll !== undefined && scroll !== null)
            url_ += "scroll=" + encodeURIComponent(scroll ? "" + scroll.toISOString() : "") + "&";
        if (onmainpage !== undefined && onmainpage !== null)
            url_ += "onmainpage=" + encodeURIComponent("" + onmainpage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNews(_response);
        });
    }

    protected processNews(response: Response): Promise<FindPublishedByTypeResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FindPublishedByTypeResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = EmptyResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindPublishedByTypeResponse>(null as any);
    }

    /**
     * @param id news id
     * @return OK
     */
    news2(id: string): Promise<Material> {
        let url_ = this.baseUrl + "/materials/news/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNews2(_response);
        });
    }

    protected processNews2(response: Response): Promise<Material> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Material.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = EmptyResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Material>(null as any);
    }
}

export interface IResumeClient {

    /**
     * @param request create resume request
     * @return OK
     */
    resume(request: CreateResumeRequest): Promise<Resume>;

    /**
     * @param date_of_post (optional) 0 [last 24 hours], 1 [last 5 days], 2 [last 14 days], 3 [last month]
     * @param salary_estimate_to (optional) 657.89
     * @param specialization (optional) specialization id(s)
     * @param currency (optional) currency id
     * @param employment (optional) employment id(s)
     * @param features (optional) features id(s)
     * @param education_level (optional) education level id(s)
     * @param search_by_job_tile (optional) search by job title
     * @param search_by_city (optional) search by city
     * @param only_my (optional) show resumes created by the current user
     * @param limit (optional) minimum value: 0, maximum value: 100
     * @param offset (optional) default value: 0
     * @return OK
     */
    resumesGET(date_of_post: Date_of_post | null | undefined, salary_estimate_to: number | null | undefined, specialization: string[] | null | undefined, currency: string | null | undefined, employment: string[] | null | undefined, features: string[] | null | undefined, education_level: string[] | null | undefined, search_by_job_tile: string | null | undefined, search_by_city: string | null | undefined, only_my: boolean | null | undefined, limit: number | null | undefined, offset: number | null | undefined): Promise<GetResumesResponse>;

    /**
     * Request personal data of resume
     * @param id resume id
     * @param locale (optional) en or th
     * @param vacancy_id vacancy id
     * @return OK
     */
    requestPersonalData(id: string, locale: string | null | undefined, vacancy_id: string): Promise<RequestPersonalDataResponse>;

    /**
     * @param id id
     * @return OK
     */
    resumesGET2(id: string): Promise<Resume>;

    /**
     * @param id id
     * @return No Content
     */
    resumesDELETE(id: string): Promise<EmptyResponse>;

    /**
     * @param id id
     * @return OK
     */
    copy(id: string): Promise<Resume>;

    /**
     * Provide access to resume
     * @param id resume id
     * @param user_id user id (who want access)
     * @param locale (optional) en or th
     * @return OK
     */
    provide(id: string, user_id: string, locale: string | null | undefined): Promise<ProvideAccessToResumeRequest>;

    /**
     * @param id id
     * @return OK
     */
    publish(id: string): Promise<Resume>;

    /**
     * @param id id
     * @return OK
     */
    unpublish(id: string): Promise<Resume>;
}

export class ResumeClient implements IResumeClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://upjob.com/api/v1";
    }

    /**
     * @param request create resume request
     * @return OK
     */
    resume(request: CreateResumeRequest): Promise<Resume> {
        let url_ = this.baseUrl + "/resume";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResume(_response);
        });
    }

    protected processResume(response: Response): Promise<Resume> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Resume.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = EmptyResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Resume>(null as any);
    }

    /**
     * @param date_of_post (optional) 0 [last 24 hours], 1 [last 5 days], 2 [last 14 days], 3 [last month]
     * @param salary_estimate_to (optional) 657.89
     * @param specialization (optional) specialization id(s)
     * @param currency (optional) currency id
     * @param employment (optional) employment id(s)
     * @param features (optional) features id(s)
     * @param education_level (optional) education level id(s)
     * @param search_by_job_tile (optional) search by job title
     * @param search_by_city (optional) search by city
     * @param only_my (optional) show resumes created by the current user
     * @param limit (optional) minimum value: 0, maximum value: 100
     * @param offset (optional) default value: 0
     * @return OK
     */
    resumesGET(date_of_post: Date_of_post | null | undefined, salary_estimate_to: number | null | undefined, specialization: string[] | null | undefined, currency: string | null | undefined, employment: string[] | null | undefined, features: string[] | null | undefined, education_level: string[] | null | undefined, search_by_job_tile: string | null | undefined, search_by_city: string | null | undefined, only_my: boolean | null | undefined, limit: number | null | undefined, offset: number | null | undefined): Promise<GetResumesResponse> {
        let url_ = this.baseUrl + "/resumes?";
        if (date_of_post !== undefined && date_of_post !== null)
            url_ += "date_of_post=" + encodeURIComponent("" + date_of_post) + "&";
        if (salary_estimate_to !== undefined && salary_estimate_to !== null)
            url_ += "salary_estimate_to=" + encodeURIComponent("" + salary_estimate_to) + "&";
        if (specialization !== undefined && specialization !== null)
            specialization && specialization.forEach(item => { url_ += "specialization=" + encodeURIComponent("" + item) + "&"; });
        if (currency !== undefined && currency !== null)
            url_ += "currency=" + encodeURIComponent("" + currency) + "&";
        if (employment !== undefined && employment !== null)
            employment && employment.forEach(item => { url_ += "employment=" + encodeURIComponent("" + item) + "&"; });
        if (features !== undefined && features !== null)
            features && features.forEach(item => { url_ += "features=" + encodeURIComponent("" + item) + "&"; });
        if (education_level !== undefined && education_level !== null)
            education_level && education_level.forEach(item => { url_ += "education_level=" + encodeURIComponent("" + item) + "&"; });
        if (search_by_job_tile !== undefined && search_by_job_tile !== null)
            url_ += "search_by_job_tile=" + encodeURIComponent("" + search_by_job_tile) + "&";
        if (search_by_city !== undefined && search_by_city !== null)
            url_ += "search_by_city=" + encodeURIComponent("" + search_by_city) + "&";
        if (only_my !== undefined && only_my !== null)
            url_ += "only_my=" + encodeURIComponent("" + only_my) + "&";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset !== undefined && offset !== null)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResumesGET(_response);
        });
    }

    protected processResumesGET(response: Response): Promise<GetResumesResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetResumesResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = EmptyResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetResumesResponse>(null as any);
    }

    /**
     * Request personal data of resume
     * @param id resume id
     * @param locale (optional) en or th
     * @param vacancy_id vacancy id
     * @return OK
     */
    requestPersonalData(id: string, locale: string | null | undefined, vacancy_id: string): Promise<RequestPersonalDataResponse> {
        let url_ = this.baseUrl + "/resumes/request-personal-data/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (locale !== undefined && locale !== null)
            url_ += "locale=" + encodeURIComponent("" + locale) + "&";
        if (vacancy_id === undefined || vacancy_id === null)
            throw new Error("The parameter 'vacancy_id' must be defined and cannot be null.");
        else
            url_ += "vacancy_id=" + encodeURIComponent("" + vacancy_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRequestPersonalData(_response);
        });
    }

    protected processRequestPersonalData(response: Response): Promise<RequestPersonalDataResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestPersonalDataResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RequestPersonalDataResponse>(null as any);
    }

    /**
     * @param id id
     * @return OK
     */
    resumesGET2(id: string): Promise<Resume> {
        let url_ = this.baseUrl + "/resumes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResumesGET2(_response);
        });
    }

    protected processResumesGET2(response: Response): Promise<Resume> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Resume.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = EmptyResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Resume>(null as any);
    }

    /**
     * @param id id
     * @return No Content
     */
    resumesDELETE(id: string): Promise<EmptyResponse> {
        let url_ = this.baseUrl + "/resumes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResumesDELETE(_response);
        });
    }

    protected processResumesDELETE(response: Response): Promise<EmptyResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = EmptyResponse.fromJS(resultData204);
            return result204;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = EmptyResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = EmptyResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EmptyResponse>(null as any);
    }

    /**
     * @param id id
     * @return OK
     */
    copy(id: string): Promise<Resume> {
        let url_ = this.baseUrl + "/resumes/{id}/copy";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCopy(_response);
        });
    }

    protected processCopy(response: Response): Promise<Resume> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Resume.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = EmptyResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Resume>(null as any);
    }

    /**
     * Provide access to resume
     * @param id resume id
     * @param user_id user id (who want access)
     * @param locale (optional) en or th
     * @return OK
     */
    provide(id: string, user_id: string, locale: string | null | undefined): Promise<ProvideAccessToResumeRequest> {
        let url_ = this.baseUrl + "/resumes/{id}/provide?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (user_id === undefined || user_id === null)
            throw new Error("The parameter 'user_id' must be defined and cannot be null.");
        else
            url_ += "user_id=" + encodeURIComponent("" + user_id) + "&";
        if (locale !== undefined && locale !== null)
            url_ += "locale=" + encodeURIComponent("" + locale) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProvide(_response);
        });
    }

    protected processProvide(response: Response): Promise<ProvideAccessToResumeRequest> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProvideAccessToResumeRequest.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProvideAccessToResumeRequest>(null as any);
    }

    /**
     * @param id id
     * @return OK
     */
    publish(id: string): Promise<Resume> {
        let url_ = this.baseUrl + "/resumes/{id}/publish";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPublish(_response);
        });
    }

    protected processPublish(response: Response): Promise<Resume> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Resume.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = EmptyResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = EmptyResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Resume>(null as any);
    }

    /**
     * @param id id
     * @return OK
     */
    unpublish(id: string): Promise<Resume> {
        let url_ = this.baseUrl + "/resumes/{id}/unpublish";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUnpublish(_response);
        });
    }

    protected processUnpublish(response: Response): Promise<Resume> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Resume.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = EmptyResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = EmptyResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Resume>(null as any);
    }
}

export interface ISourceOfInformationClient {

    /**
     * @return OK
     */
    source_of_information(): Promise<SourceOfInformation[]>;
}

export class SourceOfInformationClient implements ISourceOfInformationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://upjob.com/api/v1";
    }

    /**
     * @return OK
     */
    source_of_information(): Promise<SourceOfInformation[]> {
        let url_ = this.baseUrl + "/source_of_information";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSource_of_information(_response);
        });
    }

    protected processSource_of_information(response: Response): Promise<SourceOfInformation[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SourceOfInformation.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = EmptyResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SourceOfInformation[]>(null as any);
    }
}

export interface IStaticPagesClient {

    /**
     * @param urn urn
     * @return OK
     */
    staticPages(urn: string): Promise<StaticPage>;
}

export class StaticPagesClient implements IStaticPagesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://upjob.com/api/v1";
    }

    /**
     * @param urn urn
     * @return OK
     */
    staticPages(urn: string): Promise<StaticPage> {
        let url_ = this.baseUrl + "/static-pages/{urn}";
        if (urn === undefined || urn === null)
            throw new Error("The parameter 'urn' must be defined.");
        url_ = url_.replace("{urn}", encodeURIComponent("" + urn));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStaticPages(_response);
        });
    }

    protected processStaticPages(response: Response): Promise<StaticPage> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StaticPage.fromJS(resultData200);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = EmptyResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StaticPage>(null as any);
    }
}

export interface IUserServiceClient {

    /**
     * @param request forgot password request
     * @return No Content
     */
    forgotPassword(request: ForgotPasswordRequest): Promise<EmptyResponse>;

    /**
     * @param secret secret
     */
    forgotPasswordVerify(secret: string): Promise<void>;

    /**
     * @return OK
     */
    infoGET(): Promise<GetUserInfoResponse>;

    /**
     * @param request update info request
     * @return No Content
     */
    infoPUT(request: UpdateUserInfoRequest): Promise<EmptyResponse>;

    /**
     * @param id id
     * @return OK
     */
    infoGET2(id: string): Promise<GetUserInfoResponse>;

    /**
     * @param request sign in request
     * @return No Content
     */
    login(request: SignInRequest): Promise<EmptyResponse>;

    facebook(): Promise<void>;

    google(): Promise<void>;

    logout(): Promise<void>;

    /**
     * @return OK
     */
    me(): Promise<GetMeResponse>;

    /**
     * @param request sign up request
     * @return No Content
     */
    registration(request: SignUpRequest): Promise<EmptyResponse>;

    /**
     * @param hash hash
     */
    confirm(hash: string): Promise<void>;

    /**
     * @param code code
     */
    callback(code: string): Promise<void>;

    /**
     * @param code code
     */
    callback2(code: string): Promise<void>;

    /**
     * @param request reset password request
     * @return No Content
     */
    resetPassword(request: ResetPasswordRequest): Promise<EmptyResponse>;
}

export class UserServiceClient implements IUserServiceClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://upjob.com/api/v1";
    }

    /**
     * @param request forgot password request
     * @return No Content
     */
    forgotPassword(request: ForgotPasswordRequest): Promise<EmptyResponse> {
        let url_ = this.baseUrl + "/user-service/forgot-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processForgotPassword(_response);
        });
    }

    protected processForgotPassword(response: Response): Promise<EmptyResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = EmptyResponse.fromJS(resultData204);
            return result204;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrResponse2.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = EmptyResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EmptyResponse>(null as any);
    }

    /**
     * @param secret secret
     */
    forgotPasswordVerify(secret: string): Promise<void> {
        let url_ = this.baseUrl + "/user-service/forgot-password-verify/{secret}";
        if (secret === undefined || secret === null)
            throw new Error("The parameter 'secret' must be defined.");
        url_ = url_.replace("{secret}", encodeURIComponent("" + secret));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processForgotPasswordVerify(_response);
        });
    }

    protected processForgotPasswordVerify(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrResponse2.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 406) {
            return response.text().then((_responseText) => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ErrResponse2.fromJS(resultData406);
            return throwException("custom codes: 17 (user not existed), 18 (forgot password not requested for secret)", status, _responseText, _headers, result406);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = EmptyResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    infoGET(): Promise<GetUserInfoResponse> {
        let url_ = this.baseUrl + "/user-service/info";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInfoGET(_response);
        });
    }

    protected processInfoGET(response: Response): Promise<GetUserInfoResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserInfoResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = EmptyResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = EmptyResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetUserInfoResponse>(null as any);
    }

    /**
     * @param request update info request
     * @return No Content
     */
    infoPUT(request: UpdateUserInfoRequest): Promise<EmptyResponse> {
        let url_ = this.baseUrl + "/user-service/info";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInfoPUT(_response);
        });
    }

    protected processInfoPUT(response: Response): Promise<EmptyResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = EmptyResponse.fromJS(resultData204);
            return result204;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrResponse2.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = EmptyResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = EmptyResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EmptyResponse>(null as any);
    }

    /**
     * @param id id
     * @return OK
     */
    infoGET2(id: string): Promise<GetUserInfoResponse> {
        let url_ = this.baseUrl + "/user-service/info/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInfoGET2(_response);
        });
    }

    protected processInfoGET2(response: Response): Promise<GetUserInfoResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserInfoResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = EmptyResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = EmptyResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetUserInfoResponse>(null as any);
    }

    /**
     * @param request sign in request
     * @return No Content
     */
    login(request: SignInRequest): Promise<EmptyResponse> {
        let url_ = this.baseUrl + "/user-service/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<EmptyResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = EmptyResponse.fromJS(resultData204);
            return result204;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrResponse2.fromJS(resultData400);
            return throwException("custom codes: 12 (bad request)", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrResponse2.fromJS(resultData401);
            return throwException("custom codes: 1 (incorrect email or password)", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrResponse2.fromJS(resultData500);
            return throwException("custom codes: 4 (can\'t receive data from service)", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EmptyResponse>(null as any);
    }

    facebook(): Promise<void> {
        let url_ = this.baseUrl + "/user-service/login/facebook";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFacebook(_response);
        });
    }

    protected processFacebook(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrResponse2.fromJS(resultData500);
            return throwException("custom codes: 7 (can\'t prepare oauth url)", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    google(): Promise<void> {
        let url_ = this.baseUrl + "/user-service/login/google";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGoogle(_response);
        });
    }

    protected processGoogle(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrResponse2.fromJS(resultData500);
            return throwException("custom codes: 7 (can\'t prepare oauth url)", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    logout(): Promise<void> {
        let url_ = this.baseUrl + "/user-service/logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogout(_response);
        });
    }

    protected processLogout(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    me(): Promise<GetMeResponse> {
        let url_ = this.baseUrl + "/user-service/me";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMe(_response);
        });
    }

    protected processMe(response: Response): Promise<GetMeResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetMeResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = EmptyResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = EmptyResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetMeResponse>(null as any);
    }

    /**
     * @param request sign up request
     * @return No Content
     */
    registration(request: SignUpRequest): Promise<EmptyResponse> {
        let url_ = this.baseUrl + "/user-service/registration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegistration(_response);
        });
    }

    protected processRegistration(response: Response): Promise<EmptyResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = EmptyResponse.fromJS(resultData204);
            return result204;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrResponse2.fromJS(resultData400);
            return throwException("custom codes: 12 (bad request)", status, _responseText, _headers, result400);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ErrResponse2.fromJS(resultData409);
            return throwException("custom codes: 2 (user already exists)", status, _responseText, _headers, result409);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrResponse2.fromJS(resultData500);
            return throwException("custom codes: 4 (can\'t receive data from service)", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EmptyResponse>(null as any);
    }

    /**
     * @param hash hash
     */
    confirm(hash: string): Promise<void> {
        let url_ = this.baseUrl + "/user-service/registration/confirm/{hash}";
        if (hash === undefined || hash === null)
            throw new Error("The parameter 'hash' must be defined.");
        url_ = url_.replace("{hash}", encodeURIComponent("" + hash));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processConfirm(_response);
        });
    }

    protected processConfirm(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrResponse2.fromJS(resultData400);
            return throwException("custom codes: 12 (bad request)", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrResponse2.fromJS(resultData500);
            return throwException("custom codes: 11 (can\'t confirm email)", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param code code
     */
    callback(code: string): Promise<void> {
        let url_ = this.baseUrl + "/user-service/registration/facebook/callback?";
        if (code === undefined || code === null)
            throw new Error("The parameter 'code' must be defined and cannot be null.");
        else
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCallback(_response);
        });
    }

    protected processCallback(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrResponse2.fromJS(resultData401);
            return throwException("custom codes: 6 (code is empty); 8 (can\'t receive token)", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrResponse2.fromJS(resultData500);
            return throwException("custom codes: 10 (can\'t receive user info); 3 (can\'t prepare request to service); 4 (can\'t receive data from service)", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param code code
     */
    callback2(code: string): Promise<void> {
        let url_ = this.baseUrl + "/user-service/registration/google/callback?";
        if (code === undefined || code === null)
            throw new Error("The parameter 'code' must be defined and cannot be null.");
        else
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCallback2(_response);
        });
    }

    protected processCallback2(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrResponse2.fromJS(resultData401);
            return throwException("custom codes: 6 (code is empty); 8 (can\'t receive token)", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrResponse2.fromJS(resultData500);
            return throwException("custom codes: 9 (can\'t parse user info url); 10 (can\'t receive user info); 3 (can\'t prepare request to service); 4 (can\'t receive data from service)", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param request reset password request
     * @return No Content
     */
    resetPassword(request: ResetPasswordRequest): Promise<EmptyResponse> {
        let url_ = this.baseUrl + "/user-service/reset-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResetPassword(_response);
        });
    }

    protected processResetPassword(response: Response): Promise<EmptyResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = EmptyResponse.fromJS(resultData204);
            return result204;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrResponse2.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 406) {
            return response.text().then((_responseText) => {
            let result406: any = null;
            let resultData406 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result406 = ErrResponse2.fromJS(resultData406);
            return throwException("custom codes: 17 (user not existed)", status, _responseText, _headers, result406);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = EmptyResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EmptyResponse>(null as any);
    }
}

export interface IVacancyClient {

    /**
     * @param company_id (optional) show company's vacancies
     * @param date_of_post (optional) 0 [last 24 hours], 1 [last 5 days], 2 [last 14 days], 3 [last month]
     * @param specialization (optional) specialization id(s)
     * @param salary_estimate_from (optional) 657.89
     * @param currency (optional) currency id
     * @param employment (optional) employment id(s)
     * @param features (optional) features id(s)
     * @param education_level (optional) education level id(s)
     * @param work_experience (optional) work experience id(s)
     * @param search_by_job_tile (optional) search by job title
     * @param search_by_city (optional) search by city
     * @param show_archived (optional) include archived vacancies
     * @param only_my (optional) show vacancies created by the current user
     * @param limit (optional) minimum value: 0, maximum value: 100
     * @param offset (optional) default value: 0
     * @return OK
     */
    vacanciesGET(company_id: string | null | undefined, date_of_post: Date_of_post2 | null | undefined, specialization: string[] | null | undefined, salary_estimate_from: number | null | undefined, currency: string | null | undefined, employment: string[] | null | undefined, features: string[] | null | undefined, education_level: string[] | null | undefined, work_experience: string[] | null | undefined, search_by_job_tile: string | null | undefined, search_by_city: string | null | undefined, show_archived: boolean | null | undefined, only_my: boolean | null | undefined, limit: number | null | undefined, offset: number | null | undefined): Promise<GetVacanciesResponse>;

    /**
     * Request personal data of vacancy
     * @param id vacancy id
     * @param locale (optional) en or th
     * @param resume_id resume id
     * @return OK
     */
    requestPersonalData2(id: string, locale: string | null | undefined, resume_id: string): Promise<RequestPersonalDataResponse>;

    /**
     * @param id id
     * @return OK
     */
    vacanciesGET2(id: string): Promise<Vacancy>;

    /**
     * @param id id
     * @return No Content
     */
    vacanciesDELETE(id: string): Promise<EmptyResponse>;

    /**
     * @param id id
     * @return No Content
     */
    archive(id: string): Promise<EmptyResponse>;

    /**
     * Provide access to vacancy
     * @param id vacancy id
     * @param user_id user id (who want access)
     * @param locale (optional) en or th
     * @return OK
     */
    provide2(id: string, user_id: string, locale: string | null | undefined): Promise<ProvideAccessToVacancyResponse>;

    /**
     * @param id id
     * @return No Content
     */
    publish2(id: string): Promise<EmptyResponse>;

    /**
     * @param id id
     * @return No Content
     */
    unarchive(id: string): Promise<EmptyResponse>;

    /**
     * @param id id
     * @return No Content
     */
    unpublish2(id: string): Promise<EmptyResponse>;

    /**
     * @param request create vacancy request
     * @return OK
     */
    vacancy(request: CreateVacancyRequest): Promise<Vacancy>;
}

export class VacancyClient implements IVacancyClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://upjob.com/api/v1";
    }

    /**
     * @param company_id (optional) show company's vacancies
     * @param date_of_post (optional) 0 [last 24 hours], 1 [last 5 days], 2 [last 14 days], 3 [last month]
     * @param specialization (optional) specialization id(s)
     * @param salary_estimate_from (optional) 657.89
     * @param currency (optional) currency id
     * @param employment (optional) employment id(s)
     * @param features (optional) features id(s)
     * @param education_level (optional) education level id(s)
     * @param work_experience (optional) work experience id(s)
     * @param search_by_job_tile (optional) search by job title
     * @param search_by_city (optional) search by city
     * @param show_archived (optional) include archived vacancies
     * @param only_my (optional) show vacancies created by the current user
     * @param limit (optional) minimum value: 0, maximum value: 100
     * @param offset (optional) default value: 0
     * @return OK
     */
    vacanciesGET(company_id: string | null | undefined, date_of_post: Date_of_post2 | null | undefined, specialization: string[] | null | undefined, salary_estimate_from: number | null | undefined, currency: string | null | undefined, employment: string[] | null | undefined, features: string[] | null | undefined, education_level: string[] | null | undefined, work_experience: string[] | null | undefined, search_by_job_tile: string | null | undefined, search_by_city: string | null | undefined, show_archived: boolean | null | undefined, only_my: boolean | null | undefined, limit: number | null | undefined, offset: number | null | undefined): Promise<GetVacanciesResponse> {
        let url_ = this.baseUrl + "/vacancies?";
        if (company_id !== undefined && company_id !== null)
            url_ += "company_id=" + encodeURIComponent("" + company_id) + "&";
        if (date_of_post !== undefined && date_of_post !== null)
            url_ += "date_of_post=" + encodeURIComponent("" + date_of_post) + "&";
        if (specialization !== undefined && specialization !== null)
            specialization && specialization.forEach(item => { url_ += "specialization=" + encodeURIComponent("" + item) + "&"; });
        if (salary_estimate_from !== undefined && salary_estimate_from !== null)
            url_ += "salary_estimate_from=" + encodeURIComponent("" + salary_estimate_from) + "&";
        if (currency !== undefined && currency !== null)
            url_ += "currency=" + encodeURIComponent("" + currency) + "&";
        if (employment !== undefined && employment !== null)
            employment && employment.forEach(item => { url_ += "employment=" + encodeURIComponent("" + item) + "&"; });
        if (features !== undefined && features !== null)
            features && features.forEach(item => { url_ += "features=" + encodeURIComponent("" + item) + "&"; });
        if (education_level !== undefined && education_level !== null)
            education_level && education_level.forEach(item => { url_ += "education_level=" + encodeURIComponent("" + item) + "&"; });
        if (work_experience !== undefined && work_experience !== null)
            work_experience && work_experience.forEach(item => { url_ += "work_experience=" + encodeURIComponent("" + item) + "&"; });
        if (search_by_job_tile !== undefined && search_by_job_tile !== null)
            url_ += "search_by_job_tile=" + encodeURIComponent("" + search_by_job_tile) + "&";
        if (search_by_city !== undefined && search_by_city !== null)
            url_ += "search_by_city=" + encodeURIComponent("" + search_by_city) + "&";
        if (show_archived !== undefined && show_archived !== null)
            url_ += "show_archived=" + encodeURIComponent("" + show_archived) + "&";
        if (only_my !== undefined && only_my !== null)
            url_ += "only_my=" + encodeURIComponent("" + only_my) + "&";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset !== undefined && offset !== null)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processVacanciesGET(_response);
        });
    }

    protected processVacanciesGET(response: Response): Promise<GetVacanciesResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetVacanciesResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = EmptyResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetVacanciesResponse>(null as any);
    }

    /**
     * Request personal data of vacancy
     * @param id vacancy id
     * @param locale (optional) en or th
     * @param resume_id resume id
     * @return OK
     */
    requestPersonalData2(id: string, locale: string | null | undefined, resume_id: string): Promise<RequestPersonalDataResponse> {
        let url_ = this.baseUrl + "/vacancies/request-personal-data/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (locale !== undefined && locale !== null)
            url_ += "locale=" + encodeURIComponent("" + locale) + "&";
        if (resume_id === undefined || resume_id === null)
            throw new Error("The parameter 'resume_id' must be defined and cannot be null.");
        else
            url_ += "resume_id=" + encodeURIComponent("" + resume_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRequestPersonalData2(_response);
        });
    }

    protected processRequestPersonalData2(response: Response): Promise<RequestPersonalDataResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestPersonalDataResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RequestPersonalDataResponse>(null as any);
    }

    /**
     * @param id id
     * @return OK
     */
    vacanciesGET2(id: string): Promise<Vacancy> {
        let url_ = this.baseUrl + "/vacancies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processVacanciesGET2(_response);
        });
    }

    protected processVacanciesGET2(response: Response): Promise<Vacancy> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Vacancy.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = EmptyResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = EmptyResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Vacancy>(null as any);
    }

    /**
     * @param id id
     * @return No Content
     */
    vacanciesDELETE(id: string): Promise<EmptyResponse> {
        let url_ = this.baseUrl + "/vacancies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processVacanciesDELETE(_response);
        });
    }

    protected processVacanciesDELETE(response: Response): Promise<EmptyResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = EmptyResponse.fromJS(resultData204);
            return result204;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = EmptyResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = EmptyResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EmptyResponse>(null as any);
    }

    /**
     * @param id id
     * @return No Content
     */
    archive(id: string): Promise<EmptyResponse> {
        let url_ = this.baseUrl + "/vacancies/{id}/archive";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processArchive(_response);
        });
    }

    protected processArchive(response: Response): Promise<EmptyResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = EmptyResponse.fromJS(resultData204);
            return result204;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = EmptyResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = EmptyResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EmptyResponse>(null as any);
    }

    /**
     * Provide access to vacancy
     * @param id vacancy id
     * @param user_id user id (who want access)
     * @param locale (optional) en or th
     * @return OK
     */
    provide2(id: string, user_id: string, locale: string | null | undefined): Promise<ProvideAccessToVacancyResponse> {
        let url_ = this.baseUrl + "/vacancies/{id}/provide?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (user_id === undefined || user_id === null)
            throw new Error("The parameter 'user_id' must be defined and cannot be null.");
        else
            url_ += "user_id=" + encodeURIComponent("" + user_id) + "&";
        if (locale !== undefined && locale !== null)
            url_ += "locale=" + encodeURIComponent("" + locale) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProvide2(_response);
        });
    }

    protected processProvide2(response: Response): Promise<ProvideAccessToVacancyResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProvideAccessToVacancyResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProvideAccessToVacancyResponse>(null as any);
    }

    /**
     * @param id id
     * @return No Content
     */
    publish2(id: string): Promise<EmptyResponse> {
        let url_ = this.baseUrl + "/vacancies/{id}/publish";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPublish2(_response);
        });
    }

    protected processPublish2(response: Response): Promise<EmptyResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = EmptyResponse.fromJS(resultData204);
            return result204;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = EmptyResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = EmptyResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EmptyResponse>(null as any);
    }

    /**
     * @param id id
     * @return No Content
     */
    unarchive(id: string): Promise<EmptyResponse> {
        let url_ = this.baseUrl + "/vacancies/{id}/unarchive";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUnarchive(_response);
        });
    }

    protected processUnarchive(response: Response): Promise<EmptyResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = EmptyResponse.fromJS(resultData204);
            return result204;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = EmptyResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = EmptyResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EmptyResponse>(null as any);
    }

    /**
     * @param id id
     * @return No Content
     */
    unpublish2(id: string): Promise<EmptyResponse> {
        let url_ = this.baseUrl + "/vacancies/{id}/unpublish";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUnpublish2(_response);
        });
    }

    protected processUnpublish2(response: Response): Promise<EmptyResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = EmptyResponse.fromJS(resultData204);
            return result204;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = EmptyResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = EmptyResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EmptyResponse>(null as any);
    }

    /**
     * @param request create vacancy request
     * @return OK
     */
    vacancy(request: CreateVacancyRequest): Promise<Vacancy> {
        let url_ = this.baseUrl + "/vacancy";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processVacancy(_response);
        });
    }

    protected processVacancy(response: Response): Promise<Vacancy> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Vacancy.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = EmptyResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Vacancy>(null as any);
    }
}

export class EmptyResponse implements IEmptyResponse {

    constructor(data?: IEmptyResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): EmptyResponse {
        data = typeof data === 'object' ? data : {};
        let result = new EmptyResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IEmptyResponse {
}

export class CommonDictionary implements ICommonDictionary {
    en?: TitleField | undefined;
    id?: string | undefined;
    th?: TitleField | undefined;

    constructor(data?: ICommonDictionary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.en = _data["en"] ? TitleField.fromJS(_data["en"]) : <any>undefined;
            this.id = _data["id"];
            this.th = _data["th"] ? TitleField.fromJS(_data["th"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CommonDictionary {
        data = typeof data === 'object' ? data : {};
        let result = new CommonDictionary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["en"] = this.en ? this.en.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["th"] = this.th ? this.th.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICommonDictionary {
    en?: TitleField | undefined;
    id?: string | undefined;
    th?: TitleField | undefined;
}

export class Company implements ICompany {
    address?: string | undefined;
    canEdit?: boolean | undefined;
    city?: string | undefined;
    description?: string | undefined;
    employee?: string | undefined;
    id?: string | undefined;
    logo?: string | undefined;
    name?: string | undefined;
    onMainPage?: boolean | undefined;
    phone?: string | undefined;
    roles?: string[] | undefined;
    users?: string[] | undefined;
    vacancies?: GetCompanyVacancies | undefined;
    website?: string | undefined;
    zip?: string | undefined;

    constructor(data?: ICompany) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.address = _data["address"];
            this.canEdit = _data["canEdit"];
            this.city = _data["city"];
            this.description = _data["description"];
            this.employee = _data["employee"];
            this.id = _data["id"];
            this.logo = _data["logo"];
            this.name = _data["name"];
            this.onMainPage = _data["onMainPage"];
            this.phone = _data["phone"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(item);
            }
            this.vacancies = _data["vacancies"] ? GetCompanyVacancies.fromJS(_data["vacancies"]) : <any>undefined;
            this.website = _data["website"];
            this.zip = _data["zip"];
        }
    }

    static fromJS(data: any): Company {
        data = typeof data === 'object' ? data : {};
        let result = new Company();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address;
        data["canEdit"] = this.canEdit;
        data["city"] = this.city;
        data["description"] = this.description;
        data["employee"] = this.employee;
        data["id"] = this.id;
        data["logo"] = this.logo;
        data["name"] = this.name;
        data["onMainPage"] = this.onMainPage;
        data["phone"] = this.phone;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item);
        }
        data["vacancies"] = this.vacancies ? this.vacancies.toJSON() : <any>undefined;
        data["website"] = this.website;
        data["zip"] = this.zip;
        return data;
    }
}

export interface ICompany {
    address?: string | undefined;
    canEdit?: boolean | undefined;
    city?: string | undefined;
    description?: string | undefined;
    employee?: string | undefined;
    id?: string | undefined;
    logo?: string | undefined;
    name?: string | undefined;
    onMainPage?: boolean | undefined;
    phone?: string | undefined;
    roles?: string[] | undefined;
    users?: string[] | undefined;
    vacancies?: GetCompanyVacancies | undefined;
    website?: string | undefined;
    zip?: string | undefined;
}

export class CreateCompanyRequest implements ICreateCompanyRequest {
    address?: string | undefined;
    city?: string | undefined;
    description?: string | undefined;
    employee?: string | undefined;
    id?: string | undefined;
    logo?: string | undefined;
    name?: string | undefined;
    phone?: string | undefined;
    website?: string | undefined;
    zip?: string | undefined;

    constructor(data?: ICreateCompanyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.address = _data["address"];
            this.city = _data["city"];
            this.description = _data["description"];
            this.employee = _data["employee"];
            this.id = _data["id"];
            this.logo = _data["logo"];
            this.name = _data["name"];
            this.phone = _data["phone"];
            this.website = _data["website"];
            this.zip = _data["zip"];
        }
    }

    static fromJS(data: any): CreateCompanyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCompanyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address;
        data["city"] = this.city;
        data["description"] = this.description;
        data["employee"] = this.employee;
        data["id"] = this.id;
        data["logo"] = this.logo;
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["website"] = this.website;
        data["zip"] = this.zip;
        return data;
    }
}

export interface ICreateCompanyRequest {
    address?: string | undefined;
    city?: string | undefined;
    description?: string | undefined;
    employee?: string | undefined;
    id?: string | undefined;
    logo?: string | undefined;
    name?: string | undefined;
    phone?: string | undefined;
    website?: string | undefined;
    zip?: string | undefined;
}

export class CreateFeedbackRequest implements ICreateFeedbackRequest {
    email?: string | undefined;
    name?: string | undefined;
    subject?: string | undefined;
    text?: string | undefined;

    constructor(data?: ICreateFeedbackRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.name = _data["name"];
            this.subject = _data["subject"];
            this.text = _data["text"];
        }
    }

    static fromJS(data: any): CreateFeedbackRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFeedbackRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["name"] = this.name;
        data["subject"] = this.subject;
        data["text"] = this.text;
        return data;
    }
}

export interface ICreateFeedbackRequest {
    email?: string | undefined;
    name?: string | undefined;
    subject?: string | undefined;
    text?: string | undefined;
}

export class CreateResumeRequest implements ICreateResumeRequest {
    additionalInformation?: ResumeAdditionalInformation | undefined;
    education?: ResumeEducation[] | undefined;
    id?: string | undefined;
    information?: ResumeInformation | undefined;
    jobPosition?: ResumeJobPosition | undefined;
    location?: ResumeLocation | undefined;
    settings?: ResumeSettings | undefined;
    workExperience?: ResumeWorkExperience[] | undefined;

    constructor(data?: ICreateResumeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.additionalInformation = _data["additionalInformation"] ? ResumeAdditionalInformation.fromJS(_data["additionalInformation"]) : <any>undefined;
            if (Array.isArray(_data["education"])) {
                this.education = [] as any;
                for (let item of _data["education"])
                    this.education!.push(ResumeEducation.fromJS(item));
            }
            this.id = _data["id"];
            this.information = _data["information"] ? ResumeInformation.fromJS(_data["information"]) : <any>undefined;
            this.jobPosition = _data["jobPosition"] ? ResumeJobPosition.fromJS(_data["jobPosition"]) : <any>undefined;
            this.location = _data["location"] ? ResumeLocation.fromJS(_data["location"]) : <any>undefined;
            this.settings = _data["settings"] ? ResumeSettings.fromJS(_data["settings"]) : <any>undefined;
            if (Array.isArray(_data["workExperience"])) {
                this.workExperience = [] as any;
                for (let item of _data["workExperience"])
                    this.workExperience!.push(ResumeWorkExperience.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateResumeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateResumeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["additionalInformation"] = this.additionalInformation ? this.additionalInformation.toJSON() : <any>undefined;
        if (Array.isArray(this.education)) {
            data["education"] = [];
            for (let item of this.education)
                data["education"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["information"] = this.information ? this.information.toJSON() : <any>undefined;
        data["jobPosition"] = this.jobPosition ? this.jobPosition.toJSON() : <any>undefined;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["settings"] = this.settings ? this.settings.toJSON() : <any>undefined;
        if (Array.isArray(this.workExperience)) {
            data["workExperience"] = [];
            for (let item of this.workExperience)
                data["workExperience"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateResumeRequest {
    additionalInformation?: ResumeAdditionalInformation | undefined;
    education?: ResumeEducation[] | undefined;
    id?: string | undefined;
    information?: ResumeInformation | undefined;
    jobPosition?: ResumeJobPosition | undefined;
    location?: ResumeLocation | undefined;
    settings?: ResumeSettings | undefined;
    workExperience?: ResumeWorkExperience[] | undefined;
}

export class CreateVacancyRequest implements ICreateVacancyRequest {
    additional?: VacancyAdditional | undefined;
    companyId?: string | undefined;
    employer?: VacancyEmployer | undefined;
    location?: VacancyLocation | undefined;
    requirements?: VacancyRequirements | undefined;
    responses?: VacancyResponses | undefined;
    vacancy?: VacancyInRequest | undefined;
    vacancyId?: string | undefined;

    constructor(data?: ICreateVacancyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.additional = _data["additional"] ? VacancyAdditional.fromJS(_data["additional"]) : <any>undefined;
            this.companyId = _data["companyId"];
            this.employer = _data["employer"] ? VacancyEmployer.fromJS(_data["employer"]) : <any>undefined;
            this.location = _data["location"] ? VacancyLocation.fromJS(_data["location"]) : <any>undefined;
            this.requirements = _data["requirements"] ? VacancyRequirements.fromJS(_data["requirements"]) : <any>undefined;
            this.responses = _data["responses"] ? VacancyResponses.fromJS(_data["responses"]) : <any>undefined;
            this.vacancy = _data["vacancy"] ? VacancyInRequest.fromJS(_data["vacancy"]) : <any>undefined;
            this.vacancyId = _data["vacancyId"];
        }
    }

    static fromJS(data: any): CreateVacancyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateVacancyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["additional"] = this.additional ? this.additional.toJSON() : <any>undefined;
        data["companyId"] = this.companyId;
        data["employer"] = this.employer ? this.employer.toJSON() : <any>undefined;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["requirements"] = this.requirements ? this.requirements.toJSON() : <any>undefined;
        data["responses"] = this.responses ? this.responses.toJSON() : <any>undefined;
        data["vacancy"] = this.vacancy ? this.vacancy.toJSON() : <any>undefined;
        data["vacancyId"] = this.vacancyId;
        return data;
    }
}

export interface ICreateVacancyRequest {
    additional?: VacancyAdditional | undefined;
    companyId?: string | undefined;
    employer?: VacancyEmployer | undefined;
    location?: VacancyLocation | undefined;
    requirements?: VacancyRequirements | undefined;
    responses?: VacancyResponses | undefined;
    vacancy?: VacancyInRequest | undefined;
    vacancyId?: string | undefined;
}

export enum EmailNotificationsType {
    _0 = 0,
    _1 = 1,
}

export class Faq implements IFaq {
    created_at?: string | undefined;
    en?: MultiLanguageField | undefined;
    id?: string | undefined;
    published?: boolean | undefined;
    sort_order?: number | undefined;
    th?: MultiLanguageField | undefined;
    updated_at?: string | undefined;

    constructor(data?: IFaq) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.created_at = _data["created_at"];
            this.en = _data["en"] ? MultiLanguageField.fromJS(_data["en"]) : <any>undefined;
            this.id = _data["id"];
            this.published = _data["published"];
            this.sort_order = _data["sort_order"];
            this.th = _data["th"] ? MultiLanguageField.fromJS(_data["th"]) : <any>undefined;
            this.updated_at = _data["updated_at"];
        }
    }

    static fromJS(data: any): Faq {
        data = typeof data === 'object' ? data : {};
        let result = new Faq();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["created_at"] = this.created_at;
        data["en"] = this.en ? this.en.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["published"] = this.published;
        data["sort_order"] = this.sort_order;
        data["th"] = this.th ? this.th.toJSON() : <any>undefined;
        data["updated_at"] = this.updated_at;
        return data;
    }
}

export interface IFaq {
    created_at?: string | undefined;
    en?: MultiLanguageField | undefined;
    id?: string | undefined;
    published?: boolean | undefined;
    sort_order?: number | undefined;
    th?: MultiLanguageField | undefined;
    updated_at?: string | undefined;
}

export class FindPublishedByTypeResponse implements IFindPublishedByTypeResponse {
    data?: Material[] | undefined;
    hasMore?: boolean | undefined;

    constructor(data?: IFindPublishedByTypeResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(Material.fromJS(item));
            }
            this.hasMore = _data["hasMore"];
        }
    }

    static fromJS(data: any): FindPublishedByTypeResponse {
        data = typeof data === 'object' ? data : {};
        let result = new FindPublishedByTypeResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["hasMore"] = this.hasMore;
        return data;
    }
}

export interface IFindPublishedByTypeResponse {
    data?: Material[] | undefined;
    hasMore?: boolean | undefined;
}

export class ForgotPasswordRequest implements IForgotPasswordRequest {
    email?: string | undefined;
    locale?: string | undefined;

    constructor(data?: IForgotPasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.locale = _data["locale"];
        }
    }

    static fromJS(data: any): ForgotPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ForgotPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["locale"] = this.locale;
        return data;
    }
}

export interface IForgotPasswordRequest {
    email?: string | undefined;
    locale?: string | undefined;
}

export class GetCompaniesResponse implements IGetCompaniesResponse {
    data?: Company[] | undefined;
    hasMore?: boolean | undefined;
    limit?: number | undefined;
    offset?: number | undefined;

    constructor(data?: IGetCompaniesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(Company.fromJS(item));
            }
            this.hasMore = _data["hasMore"];
            this.limit = _data["limit"];
            this.offset = _data["offset"];
        }
    }

    static fromJS(data: any): GetCompaniesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetCompaniesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["hasMore"] = this.hasMore;
        data["limit"] = this.limit;
        data["offset"] = this.offset;
        return data;
    }
}

export interface IGetCompaniesResponse {
    data?: Company[] | undefined;
    hasMore?: boolean | undefined;
    limit?: number | undefined;
    offset?: number | undefined;
}

export class GetCompanyVacancies implements IGetCompanyVacancies {
    all?: string[] | undefined;
    opened?: string[] | undefined;

    constructor(data?: IGetCompanyVacancies) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["all"])) {
                this.all = [] as any;
                for (let item of _data["all"])
                    this.all!.push(item);
            }
            if (Array.isArray(_data["opened"])) {
                this.opened = [] as any;
                for (let item of _data["opened"])
                    this.opened!.push(item);
            }
        }
    }

    static fromJS(data: any): GetCompanyVacancies {
        data = typeof data === 'object' ? data : {};
        let result = new GetCompanyVacancies();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.all)) {
            data["all"] = [];
            for (let item of this.all)
                data["all"].push(item);
        }
        if (Array.isArray(this.opened)) {
            data["opened"] = [];
            for (let item of this.opened)
                data["opened"].push(item);
        }
        return data;
    }
}

export interface IGetCompanyVacancies {
    all?: string[] | undefined;
    opened?: string[] | undefined;
}

export class GetMeResponse implements IGetMeResponse {
    email?: string | undefined;
    email_confirmed?: boolean | undefined;
    first_name?: string | undefined;
    last_name?: string | undefined;

    constructor(data?: IGetMeResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.email_confirmed = _data["email_confirmed"];
            this.first_name = _data["first_name"];
            this.last_name = _data["last_name"];
        }
    }

    static fromJS(data: any): GetMeResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetMeResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["email_confirmed"] = this.email_confirmed;
        data["first_name"] = this.first_name;
        data["last_name"] = this.last_name;
        return data;
    }
}

export interface IGetMeResponse {
    email?: string | undefined;
    email_confirmed?: boolean | undefined;
    first_name?: string | undefined;
    last_name?: string | undefined;
}

export class GetResumesResponse implements IGetResumesResponse {
    hasMore?: boolean | undefined;
    limit?: number | undefined;
    offset?: number | undefined;
    resumes?: Resume[] | undefined;

    constructor(data?: IGetResumesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasMore = _data["hasMore"];
            this.limit = _data["limit"];
            this.offset = _data["offset"];
            if (Array.isArray(_data["resumes"])) {
                this.resumes = [] as any;
                for (let item of _data["resumes"])
                    this.resumes!.push(Resume.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetResumesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetResumesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasMore"] = this.hasMore;
        data["limit"] = this.limit;
        data["offset"] = this.offset;
        if (Array.isArray(this.resumes)) {
            data["resumes"] = [];
            for (let item of this.resumes)
                data["resumes"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetResumesResponse {
    hasMore?: boolean | undefined;
    limit?: number | undefined;
    offset?: number | undefined;
    resumes?: Resume[] | undefined;
}

export class GetUserInfoResponse implements IGetUserInfoResponse {
    birthday?: string | undefined;
    email?: string | undefined;
    emailConfirmed?: boolean | undefined;
    firstName?: string | undefined;
    gender?: string | undefined;
    id?: string | undefined;
    lastName?: string | undefined;
    notifications?: Notifications | undefined;
    phone?: string | undefined;
    photo?: string | undefined;
    primaryLanguage?: string | undefined;

    constructor(data?: IGetUserInfoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.birthday = _data["birthday"];
            this.email = _data["email"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.firstName = _data["firstName"];
            this.gender = _data["gender"];
            this.id = _data["id"];
            this.lastName = _data["lastName"];
            this.notifications = _data["notifications"] ? Notifications.fromJS(_data["notifications"]) : <any>undefined;
            this.phone = _data["phone"];
            this.photo = _data["photo"];
            this.primaryLanguage = _data["primaryLanguage"];
        }
    }

    static fromJS(data: any): GetUserInfoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserInfoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["birthday"] = this.birthday;
        data["email"] = this.email;
        data["emailConfirmed"] = this.emailConfirmed;
        data["firstName"] = this.firstName;
        data["gender"] = this.gender;
        data["id"] = this.id;
        data["lastName"] = this.lastName;
        data["notifications"] = this.notifications ? this.notifications.toJSON() : <any>undefined;
        data["phone"] = this.phone;
        data["photo"] = this.photo;
        data["primaryLanguage"] = this.primaryLanguage;
        return data;
    }
}

export interface IGetUserInfoResponse {
    birthday?: string | undefined;
    email?: string | undefined;
    emailConfirmed?: boolean | undefined;
    firstName?: string | undefined;
    gender?: string | undefined;
    id?: string | undefined;
    lastName?: string | undefined;
    notifications?: Notifications | undefined;
    phone?: string | undefined;
    photo?: string | undefined;
    primaryLanguage?: string | undefined;
}

export class GetVacanciesResponse implements IGetVacanciesResponse {
    hasMore?: boolean | undefined;
    limit?: number | undefined;
    offset?: number | undefined;
    vacancies?: Vacancy[] | undefined;

    constructor(data?: IGetVacanciesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasMore = _data["hasMore"];
            this.limit = _data["limit"];
            this.offset = _data["offset"];
            if (Array.isArray(_data["vacancies"])) {
                this.vacancies = [] as any;
                for (let item of _data["vacancies"])
                    this.vacancies!.push(Vacancy.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetVacanciesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetVacanciesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasMore"] = this.hasMore;
        data["limit"] = this.limit;
        data["offset"] = this.offset;
        if (Array.isArray(this.vacancies)) {
            data["vacancies"] = [];
            for (let item of this.vacancies)
                data["vacancies"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetVacanciesResponse {
    hasMore?: boolean | undefined;
    limit?: number | undefined;
    offset?: number | undefined;
    vacancies?: Vacancy[] | undefined;
}

export enum Lang {
    _0 = 0,
    _1 = 1,
}

export class MainPageResponse implements IMainPageResponse {
    articles?: any | undefined;
    companies?: GetCompaniesResponse | undefined;
    news?: FindPublishedByTypeResponse | undefined;
    questions?: any | undefined;

    constructor(data?: IMainPageResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.articles = _data["articles"];
            this.companies = _data["companies"] ? GetCompaniesResponse.fromJS(_data["companies"]) : <any>undefined;
            this.news = _data["news"] ? FindPublishedByTypeResponse.fromJS(_data["news"]) : <any>undefined;
            this.questions = _data["questions"];
        }
    }

    static fromJS(data: any): MainPageResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MainPageResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["articles"] = this.articles;
        data["companies"] = this.companies ? this.companies.toJSON() : <any>undefined;
        data["news"] = this.news ? this.news.toJSON() : <any>undefined;
        data["questions"] = this.questions;
        return data;
    }
}

export interface IMainPageResponse {
    articles?: any | undefined;
    companies?: GetCompaniesResponse | undefined;
    news?: FindPublishedByTypeResponse | undefined;
    questions?: any | undefined;
}

export class Material implements IMaterial {
    created_at?: string | undefined;
    en?: MultiLanguageField | undefined;
    id?: string | undefined;
    image?: string | undefined;
    language?: Lang | undefined;
    onmainpage?: boolean | undefined;
    published?: boolean | undefined;
    published_at_utc?: string | undefined;
    source?: string | undefined;
    th?: MultiLanguageField | undefined;
    thumbnail?: string | undefined;
    type?: number | undefined;
    updated_at?: string | undefined;
    urn?: string | undefined;

    constructor(data?: IMaterial) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.created_at = _data["created_at"];
            this.en = _data["en"] ? MultiLanguageField.fromJS(_data["en"]) : <any>undefined;
            this.id = _data["id"];
            this.image = _data["image"];
            this.language = _data["language"];
            this.onmainpage = _data["onmainpage"];
            this.published = _data["published"];
            this.published_at_utc = _data["published_at_utc"];
            this.source = _data["source"];
            this.th = _data["th"] ? MultiLanguageField.fromJS(_data["th"]) : <any>undefined;
            this.thumbnail = _data["thumbnail"];
            this.type = _data["type"];
            this.updated_at = _data["updated_at"];
            this.urn = _data["urn"];
        }
    }

    static fromJS(data: any): Material {
        data = typeof data === 'object' ? data : {};
        let result = new Material();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["created_at"] = this.created_at;
        data["en"] = this.en ? this.en.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["image"] = this.image;
        data["language"] = this.language;
        data["onmainpage"] = this.onmainpage;
        data["published"] = this.published;
        data["published_at_utc"] = this.published_at_utc;
        data["source"] = this.source;
        data["th"] = this.th ? this.th.toJSON() : <any>undefined;
        data["thumbnail"] = this.thumbnail;
        data["type"] = this.type;
        data["updated_at"] = this.updated_at;
        data["urn"] = this.urn;
        return data;
    }
}

export interface IMaterial {
    created_at?: string | undefined;
    en?: MultiLanguageField | undefined;
    id?: string | undefined;
    image?: string | undefined;
    language?: Lang | undefined;
    onmainpage?: boolean | undefined;
    published?: boolean | undefined;
    published_at_utc?: string | undefined;
    source?: string | undefined;
    th?: MultiLanguageField | undefined;
    thumbnail?: string | undefined;
    type?: number | undefined;
    updated_at?: string | undefined;
    urn?: string | undefined;
}

export class Message implements IMessage {
    en?: string | undefined;
    th?: string | undefined;

    constructor(data?: IMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.en = _data["en"];
            this.th = _data["th"];
        }
    }

    static fromJS(data: any): Message {
        data = typeof data === 'object' ? data : {};
        let result = new Message();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["en"] = this.en;
        data["th"] = this.th;
        return data;
    }
}

export interface IMessage {
    en?: string | undefined;
    th?: string | undefined;
}

export class MultiLanguageField implements IMultiLanguageField {
    shorttext?: string | undefined;
    text?: string | undefined;
    title?: string | undefined;

    constructor(data?: IMultiLanguageField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.shorttext = _data["shorttext"];
            this.text = _data["text"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): MultiLanguageField {
        data = typeof data === 'object' ? data : {};
        let result = new MultiLanguageField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shorttext"] = this.shorttext;
        data["text"] = this.text;
        data["title"] = this.title;
        return data;
    }
}

export interface IMultiLanguageField {
    shorttext?: string | undefined;
    text?: string | undefined;
    title?: string | undefined;
}

export class Notifications implements INotifications {
    email?: boolean | undefined;
    phone?: boolean | undefined;

    constructor(data?: INotifications) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.phone = _data["phone"];
        }
    }

    static fromJS(data: any): Notifications {
        data = typeof data === 'object' ? data : {};
        let result = new Notifications();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["phone"] = this.phone;
        return data;
    }
}

export interface INotifications {
    email?: boolean | undefined;
    phone?: boolean | undefined;
}

export class ProvideAccessToResumeRequest implements IProvideAccessToResumeRequest {
    locale?: string | undefined;
    resumeID?: string | undefined;
    /** who want access */
    userID?: string | undefined;

    constructor(data?: IProvideAccessToResumeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.locale = _data["locale"];
            this.resumeID = _data["resumeID"];
            this.userID = _data["userID"];
        }
    }

    static fromJS(data: any): ProvideAccessToResumeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ProvideAccessToResumeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["locale"] = this.locale;
        data["resumeID"] = this.resumeID;
        data["userID"] = this.userID;
        return data;
    }
}

export interface IProvideAccessToResumeRequest {
    locale?: string | undefined;
    resumeID?: string | undefined;
    /** who want access */
    userID?: string | undefined;
}

export class ProvideAccessToVacancyResponse implements IProvideAccessToVacancyResponse {

    constructor(data?: IProvideAccessToVacancyResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): ProvideAccessToVacancyResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProvideAccessToVacancyResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IProvideAccessToVacancyResponse {
}

export class RequestPersonalDataResponse implements IRequestPersonalDataResponse {
    message?: Message | undefined;

    constructor(data?: IRequestPersonalDataResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"] ? Message.fromJS(_data["message"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RequestPersonalDataResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RequestPersonalDataResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message ? this.message.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRequestPersonalDataResponse {
    message?: Message | undefined;
}

export class ResetPasswordRequest implements IResetPasswordRequest {
    newPassword?: string | undefined;

    constructor(data?: IResetPasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IResetPasswordRequest {
    newPassword?: string | undefined;
}

export class Resume implements IResume {
    additionalInformation?: ResumeAdditionalInformation | undefined;
    canEdit?: boolean | undefined;
    education?: ResumeEducation[] | undefined;
    id?: string | undefined;
    information?: ResumeInformation | undefined;
    jobPosition?: ResumeJobPosition | undefined;
    location?: ResumeLocation | undefined;
    published?: boolean | undefined;
    publishedTime?: string | undefined;
    settings?: ResumeSettings | undefined;
    workExperience?: ResumeWorkExperience[] | undefined;

    constructor(data?: IResume) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.additionalInformation = _data["additionalInformation"] ? ResumeAdditionalInformation.fromJS(_data["additionalInformation"]) : <any>undefined;
            this.canEdit = _data["canEdit"];
            if (Array.isArray(_data["education"])) {
                this.education = [] as any;
                for (let item of _data["education"])
                    this.education!.push(ResumeEducation.fromJS(item));
            }
            this.id = _data["id"];
            this.information = _data["information"] ? ResumeInformation.fromJS(_data["information"]) : <any>undefined;
            this.jobPosition = _data["jobPosition"] ? ResumeJobPosition.fromJS(_data["jobPosition"]) : <any>undefined;
            this.location = _data["location"] ? ResumeLocation.fromJS(_data["location"]) : <any>undefined;
            this.published = _data["published"];
            this.publishedTime = _data["publishedTime"];
            this.settings = _data["settings"] ? ResumeSettings.fromJS(_data["settings"]) : <any>undefined;
            if (Array.isArray(_data["workExperience"])) {
                this.workExperience = [] as any;
                for (let item of _data["workExperience"])
                    this.workExperience!.push(ResumeWorkExperience.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Resume {
        data = typeof data === 'object' ? data : {};
        let result = new Resume();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["additionalInformation"] = this.additionalInformation ? this.additionalInformation.toJSON() : <any>undefined;
        data["canEdit"] = this.canEdit;
        if (Array.isArray(this.education)) {
            data["education"] = [];
            for (let item of this.education)
                data["education"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["information"] = this.information ? this.information.toJSON() : <any>undefined;
        data["jobPosition"] = this.jobPosition ? this.jobPosition.toJSON() : <any>undefined;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["published"] = this.published;
        data["publishedTime"] = this.publishedTime;
        data["settings"] = this.settings ? this.settings.toJSON() : <any>undefined;
        if (Array.isArray(this.workExperience)) {
            data["workExperience"] = [];
            for (let item of this.workExperience)
                data["workExperience"].push(item.toJSON());
        }
        return data;
    }
}

export interface IResume {
    additionalInformation?: ResumeAdditionalInformation | undefined;
    canEdit?: boolean | undefined;
    education?: ResumeEducation[] | undefined;
    id?: string | undefined;
    information?: ResumeInformation | undefined;
    jobPosition?: ResumeJobPosition | undefined;
    location?: ResumeLocation | undefined;
    published?: boolean | undefined;
    publishedTime?: string | undefined;
    settings?: ResumeSettings | undefined;
    workExperience?: ResumeWorkExperience[] | undefined;
}

export class ResumeAdditionalInformation implements IResumeAdditionalInformation {
    /** citizenship table */
    citizenship?: string | undefined;
    /** driving_license table */
    driveLicense?: string[] | undefined;
    languages?: ResumeLanguages[] | undefined;
    /** marital_status table */
    maritalStatus?: string | undefined;
    otherLicenses?: string | undefined;
    /** religion table */
    religion?: string | undefined;
    /** skill table */
    skills?: string[] | undefined;

    constructor(data?: IResumeAdditionalInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.citizenship = _data["citizenship"];
            if (Array.isArray(_data["driveLicense"])) {
                this.driveLicense = [] as any;
                for (let item of _data["driveLicense"])
                    this.driveLicense!.push(item);
            }
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages!.push(ResumeLanguages.fromJS(item));
            }
            this.maritalStatus = _data["maritalStatus"];
            this.otherLicenses = _data["otherLicenses"];
            this.religion = _data["religion"];
            if (Array.isArray(_data["skills"])) {
                this.skills = [] as any;
                for (let item of _data["skills"])
                    this.skills!.push(item);
            }
        }
    }

    static fromJS(data: any): ResumeAdditionalInformation {
        data = typeof data === 'object' ? data : {};
        let result = new ResumeAdditionalInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["citizenship"] = this.citizenship;
        if (Array.isArray(this.driveLicense)) {
            data["driveLicense"] = [];
            for (let item of this.driveLicense)
                data["driveLicense"].push(item);
        }
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        data["maritalStatus"] = this.maritalStatus;
        data["otherLicenses"] = this.otherLicenses;
        data["religion"] = this.religion;
        if (Array.isArray(this.skills)) {
            data["skills"] = [];
            for (let item of this.skills)
                data["skills"].push(item);
        }
        return data;
    }
}

export interface IResumeAdditionalInformation {
    /** citizenship table */
    citizenship?: string | undefined;
    /** driving_license table */
    driveLicense?: string[] | undefined;
    languages?: ResumeLanguages[] | undefined;
    /** marital_status table */
    maritalStatus?: string | undefined;
    otherLicenses?: string | undefined;
    /** religion table */
    religion?: string | undefined;
    /** skill table */
    skills?: string[] | undefined;
}

export class ResumeDate implements IResumeDate {
    from?: string | undefined;
    present?: boolean | undefined;
    to?: string | undefined;

    constructor(data?: IResumeDate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.from = _data["from"];
            this.present = _data["present"];
            this.to = _data["to"];
        }
    }

    static fromJS(data: any): ResumeDate {
        data = typeof data === 'object' ? data : {};
        let result = new ResumeDate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["from"] = this.from;
        data["present"] = this.present;
        data["to"] = this.to;
        return data;
    }
}

export interface IResumeDate {
    from?: string | undefined;
    present?: boolean | undefined;
    to?: string | undefined;
}

export class ResumeEducation implements IResumeEducation {
    date?: ResumeDate | undefined;
    institution?: string | undefined;
    level?: string | undefined;
    position?: string | undefined;
    specialization?: string | undefined;

    constructor(data?: IResumeEducation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? ResumeDate.fromJS(_data["date"]) : <any>undefined;
            this.institution = _data["institution"];
            this.level = _data["level"];
            this.position = _data["position"];
            this.specialization = _data["specialization"];
        }
    }

    static fromJS(data: any): ResumeEducation {
        data = typeof data === 'object' ? data : {};
        let result = new ResumeEducation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toJSON() : <any>undefined;
        data["institution"] = this.institution;
        data["level"] = this.level;
        data["position"] = this.position;
        data["specialization"] = this.specialization;
        return data;
    }
}

export interface IResumeEducation {
    date?: ResumeDate | undefined;
    institution?: string | undefined;
    level?: string | undefined;
    position?: string | undefined;
    specialization?: string | undefined;
}

export class ResumeInformation implements IResumeInformation {
    accept?: boolean | undefined;
    birthday?: string | undefined;
    email?: string | undefined;
    firstName?: string | undefined;
    gender?: string | undefined;
    lastName?: string | undefined;
    phone?: string | undefined;
    photo?: string | undefined;
    primaryLanguage?: string | undefined;

    constructor(data?: IResumeInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accept = _data["accept"];
            this.birthday = _data["birthday"];
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.gender = _data["gender"];
            this.lastName = _data["lastName"];
            this.phone = _data["phone"];
            this.photo = _data["photo"];
            this.primaryLanguage = _data["primaryLanguage"];
        }
    }

    static fromJS(data: any): ResumeInformation {
        data = typeof data === 'object' ? data : {};
        let result = new ResumeInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accept"] = this.accept;
        data["birthday"] = this.birthday;
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["gender"] = this.gender;
        data["lastName"] = this.lastName;
        data["phone"] = this.phone;
        data["photo"] = this.photo;
        data["primaryLanguage"] = this.primaryLanguage;
        return data;
    }
}

export interface IResumeInformation {
    accept?: boolean | undefined;
    birthday?: string | undefined;
    email?: string | undefined;
    firstName?: string | undefined;
    gender?: string | undefined;
    lastName?: string | undefined;
    phone?: string | undefined;
    photo?: string | undefined;
    primaryLanguage?: string | undefined;
}

export class ResumeJobPosition implements IResumeJobPosition {
    description?: string | undefined;
    employment?: string | undefined;
    position?: string | undefined;
    salary?: ResumeSalary | undefined;
    specialization?: string | undefined;
    /** work_feature table */
    workType?: string[] | undefined;

    constructor(data?: IResumeJobPosition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.employment = _data["employment"];
            this.position = _data["position"];
            this.salary = _data["salary"] ? ResumeSalary.fromJS(_data["salary"]) : <any>undefined;
            this.specialization = _data["specialization"];
            if (Array.isArray(_data["workType"])) {
                this.workType = [] as any;
                for (let item of _data["workType"])
                    this.workType!.push(item);
            }
        }
    }

    static fromJS(data: any): ResumeJobPosition {
        data = typeof data === 'object' ? data : {};
        let result = new ResumeJobPosition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["employment"] = this.employment;
        data["position"] = this.position;
        data["salary"] = this.salary ? this.salary.toJSON() : <any>undefined;
        data["specialization"] = this.specialization;
        if (Array.isArray(this.workType)) {
            data["workType"] = [];
            for (let item of this.workType)
                data["workType"].push(item);
        }
        return data;
    }
}

export interface IResumeJobPosition {
    description?: string | undefined;
    employment?: string | undefined;
    position?: string | undefined;
    salary?: ResumeSalary | undefined;
    specialization?: string | undefined;
    /** work_feature table */
    workType?: string[] | undefined;
}

export class ResumeLanguages implements IResumeLanguages {
    language?: string | undefined;
    level?: string | undefined;

    constructor(data?: IResumeLanguages) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.language = _data["language"];
            this.level = _data["level"];
        }
    }

    static fromJS(data: any): ResumeLanguages {
        data = typeof data === 'object' ? data : {};
        let result = new ResumeLanguages();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language;
        data["level"] = this.level;
        return data;
    }
}

export interface IResumeLanguages {
    language?: string | undefined;
    level?: string | undefined;
}

export class ResumeLocation implements IResumeLocation {
    address?: string | undefined;
    city?: string | undefined;
    country?: string | undefined;
    region?: string | undefined;
    relocation?: string | undefined;
    source?: string | undefined;
    trips?: boolean | undefined;

    constructor(data?: IResumeLocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.address = _data["address"];
            this.city = _data["city"];
            this.country = _data["country"];
            this.region = _data["region"];
            this.relocation = _data["relocation"];
            this.source = _data["source"];
            this.trips = _data["trips"];
        }
    }

    static fromJS(data: any): ResumeLocation {
        data = typeof data === 'object' ? data : {};
        let result = new ResumeLocation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address;
        data["city"] = this.city;
        data["country"] = this.country;
        data["region"] = this.region;
        data["relocation"] = this.relocation;
        data["source"] = this.source;
        data["trips"] = this.trips;
        return data;
    }
}

export interface IResumeLocation {
    address?: string | undefined;
    city?: string | undefined;
    country?: string | undefined;
    region?: string | undefined;
    relocation?: string | undefined;
    source?: string | undefined;
    trips?: boolean | undefined;
}

export class ResumeSalary implements IResumeSalary {
    /** currency table */
    currency?: string | undefined;
    fixed?: number | undefined;
    from?: number | undefined;
    /** payout_period table */
    payoutPeriod?: string | undefined;
    to?: number | undefined;

    constructor(data?: IResumeSalary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currency = _data["currency"];
            this.fixed = _data["fixed"];
            this.from = _data["from"];
            this.payoutPeriod = _data["payoutPeriod"];
            this.to = _data["to"];
        }
    }

    static fromJS(data: any): ResumeSalary {
        data = typeof data === 'object' ? data : {};
        let result = new ResumeSalary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currency"] = this.currency;
        data["fixed"] = this.fixed;
        data["from"] = this.from;
        data["payoutPeriod"] = this.payoutPeriod;
        data["to"] = this.to;
        return data;
    }
}

export interface IResumeSalary {
    /** currency table */
    currency?: string | undefined;
    fixed?: number | undefined;
    from?: number | undefined;
    /** payout_period table */
    payoutPeriod?: string | undefined;
    to?: number | undefined;
}

export class ResumeSettings implements IResumeSettings {
    canResponse?: ShowTo | undefined;
    emailNotificationsType?: EmailNotificationsType | undefined;
    showEmail?: ShowTo | undefined;
    showPhone?: ShowTo | undefined;

    constructor(data?: IResumeSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canResponse = _data["canResponse"];
            this.emailNotificationsType = _data["emailNotificationsType"];
            this.showEmail = _data["showEmail"];
            this.showPhone = _data["showPhone"];
        }
    }

    static fromJS(data: any): ResumeSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ResumeSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canResponse"] = this.canResponse;
        data["emailNotificationsType"] = this.emailNotificationsType;
        data["showEmail"] = this.showEmail;
        data["showPhone"] = this.showPhone;
        return data;
    }
}

export interface IResumeSettings {
    canResponse?: ShowTo | undefined;
    emailNotificationsType?: EmailNotificationsType | undefined;
    showEmail?: ShowTo | undefined;
    showPhone?: ShowTo | undefined;
}

export class ResumeWorkExperience implements IResumeWorkExperience {
    company?: string | undefined;
    date?: ResumeDate | undefined;
    description?: string | undefined;
    position?: string | undefined;
    specialization?: string | undefined;

    constructor(data?: IResumeWorkExperience) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.company = _data["company"];
            this.date = _data["date"] ? ResumeDate.fromJS(_data["date"]) : <any>undefined;
            this.description = _data["description"];
            this.position = _data["position"];
            this.specialization = _data["specialization"];
        }
    }

    static fromJS(data: any): ResumeWorkExperience {
        data = typeof data === 'object' ? data : {};
        let result = new ResumeWorkExperience();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["company"] = this.company;
        data["date"] = this.date ? this.date.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["position"] = this.position;
        data["specialization"] = this.specialization;
        return data;
    }
}

export interface IResumeWorkExperience {
    company?: string | undefined;
    date?: ResumeDate | undefined;
    description?: string | undefined;
    position?: string | undefined;
    specialization?: string | undefined;
}

export enum ShowTo {
    _0 = 0,
    _1 = 1,
}

export class SignInRequest implements ISignInRequest {
    email?: string | undefined;
    password?: string | undefined;

    constructor(data?: ISignInRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): SignInRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SignInRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface ISignInRequest {
    email?: string | undefined;
    password?: string | undefined;
}

export class SignUpRequest implements ISignUpRequest {
    email?: string | undefined;
    first_name?: string | undefined;
    last_name?: string | undefined;
    locale?: string | undefined;
    password?: string | undefined;

    constructor(data?: ISignUpRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.first_name = _data["first_name"];
            this.last_name = _data["last_name"];
            this.locale = _data["locale"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): SignUpRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SignUpRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["first_name"] = this.first_name;
        data["last_name"] = this.last_name;
        data["locale"] = this.locale;
        data["password"] = this.password;
        return data;
    }
}

export interface ISignUpRequest {
    email?: string | undefined;
    first_name?: string | undefined;
    last_name?: string | undefined;
    locale?: string | undefined;
    password?: string | undefined;
}

export class StaticPage implements IStaticPage {
    en?: MultiLanguageField | undefined;
    id?: string | undefined;
    th?: MultiLanguageField | undefined;

    constructor(data?: IStaticPage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.en = _data["en"] ? MultiLanguageField.fromJS(_data["en"]) : <any>undefined;
            this.id = _data["id"];
            this.th = _data["th"] ? MultiLanguageField.fromJS(_data["th"]) : <any>undefined;
        }
    }

    static fromJS(data: any): StaticPage {
        data = typeof data === 'object' ? data : {};
        let result = new StaticPage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["en"] = this.en ? this.en.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["th"] = this.th ? this.th.toJSON() : <any>undefined;
        return data;
    }
}

export interface IStaticPage {
    en?: MultiLanguageField | undefined;
    id?: string | undefined;
    th?: MultiLanguageField | undefined;
}

export class TitleField implements ITitleField {
    title?: string | undefined;

    constructor(data?: ITitleField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): TitleField {
        data = typeof data === 'object' ? data : {};
        let result = new TitleField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        return data;
    }
}

export interface ITitleField {
    title?: string | undefined;
}

export class UpdateUserInfoRequest implements IUpdateUserInfoRequest {
    birthday?: string | undefined;
    firstName?: string | undefined;
    gender?: string | undefined;
    lastName?: string | undefined;
    notifications?: Notifications | undefined;
    phone?: string | undefined;
    photo?: string | undefined;
    primaryLanguage?: string | undefined;

    constructor(data?: IUpdateUserInfoRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.birthday = _data["birthday"];
            this.firstName = _data["firstName"];
            this.gender = _data["gender"];
            this.lastName = _data["lastName"];
            this.notifications = _data["notifications"] ? Notifications.fromJS(_data["notifications"]) : <any>undefined;
            this.phone = _data["phone"];
            this.photo = _data["photo"];
            this.primaryLanguage = _data["primaryLanguage"];
        }
    }

    static fromJS(data: any): UpdateUserInfoRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserInfoRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["birthday"] = this.birthday;
        data["firstName"] = this.firstName;
        data["gender"] = this.gender;
        data["lastName"] = this.lastName;
        data["notifications"] = this.notifications ? this.notifications.toJSON() : <any>undefined;
        data["phone"] = this.phone;
        data["photo"] = this.photo;
        data["primaryLanguage"] = this.primaryLanguage;
        return data;
    }
}

export interface IUpdateUserInfoRequest {
    birthday?: string | undefined;
    firstName?: string | undefined;
    gender?: string | undefined;
    lastName?: string | undefined;
    notifications?: Notifications | undefined;
    phone?: string | undefined;
    photo?: string | undefined;
    primaryLanguage?: string | undefined;
}

export class Vacancy implements IVacancy {
    additional?: VacancyAdditional | undefined;
    archived?: boolean | undefined;
    canEdit?: boolean | undefined;
    companyId?: string | undefined;
    companyLogo?: string | undefined;
    employer?: VacancyEmployer | undefined;
    id?: string | undefined;
    location?: VacancyLocation | undefined;
    published?: boolean | undefined;
    publishedTime?: string | undefined;
    requirements?: VacancyRequirements | undefined;
    responses?: VacancyResponses | undefined;
    vacancy?: VacancyInRequest | undefined;
    vacancyRequestStatus?: string | undefined;

    constructor(data?: IVacancy) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.additional = _data["additional"] ? VacancyAdditional.fromJS(_data["additional"]) : <any>undefined;
            this.archived = _data["archived"];
            this.canEdit = _data["canEdit"];
            this.companyId = _data["companyId"];
            this.companyLogo = _data["companyLogo"];
            this.employer = _data["employer"] ? VacancyEmployer.fromJS(_data["employer"]) : <any>undefined;
            this.id = _data["id"];
            this.location = _data["location"] ? VacancyLocation.fromJS(_data["location"]) : <any>undefined;
            this.published = _data["published"];
            this.publishedTime = _data["publishedTime"];
            this.requirements = _data["requirements"] ? VacancyRequirements.fromJS(_data["requirements"]) : <any>undefined;
            this.responses = _data["responses"] ? VacancyResponses.fromJS(_data["responses"]) : <any>undefined;
            this.vacancy = _data["vacancy"] ? VacancyInRequest.fromJS(_data["vacancy"]) : <any>undefined;
            this.vacancyRequestStatus = _data["vacancyRequestStatus"];
        }
    }

    static fromJS(data: any): Vacancy {
        data = typeof data === 'object' ? data : {};
        let result = new Vacancy();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["additional"] = this.additional ? this.additional.toJSON() : <any>undefined;
        data["archived"] = this.archived;
        data["canEdit"] = this.canEdit;
        data["companyId"] = this.companyId;
        data["companyLogo"] = this.companyLogo;
        data["employer"] = this.employer ? this.employer.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["published"] = this.published;
        data["publishedTime"] = this.publishedTime;
        data["requirements"] = this.requirements ? this.requirements.toJSON() : <any>undefined;
        data["responses"] = this.responses ? this.responses.toJSON() : <any>undefined;
        data["vacancy"] = this.vacancy ? this.vacancy.toJSON() : <any>undefined;
        data["vacancyRequestStatus"] = this.vacancyRequestStatus;
        return data;
    }
}

export interface IVacancy {
    additional?: VacancyAdditional | undefined;
    archived?: boolean | undefined;
    canEdit?: boolean | undefined;
    companyId?: string | undefined;
    companyLogo?: string | undefined;
    employer?: VacancyEmployer | undefined;
    id?: string | undefined;
    location?: VacancyLocation | undefined;
    published?: boolean | undefined;
    publishedTime?: string | undefined;
    requirements?: VacancyRequirements | undefined;
    responses?: VacancyResponses | undefined;
    vacancy?: VacancyInRequest | undefined;
    vacancyRequestStatus?: string | undefined;
}

export class VacancyAdditional implements IVacancyAdditional {
    drivingLicense?: string[] | undefined;
    otherLicenseNeeded?: string[] | undefined;
    skills?: string[] | undefined;

    constructor(data?: IVacancyAdditional) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["drivingLicense"])) {
                this.drivingLicense = [] as any;
                for (let item of _data["drivingLicense"])
                    this.drivingLicense!.push(item);
            }
            if (Array.isArray(_data["otherLicenseNeeded"])) {
                this.otherLicenseNeeded = [] as any;
                for (let item of _data["otherLicenseNeeded"])
                    this.otherLicenseNeeded!.push(item);
            }
            if (Array.isArray(_data["skills"])) {
                this.skills = [] as any;
                for (let item of _data["skills"])
                    this.skills!.push(item);
            }
        }
    }

    static fromJS(data: any): VacancyAdditional {
        data = typeof data === 'object' ? data : {};
        let result = new VacancyAdditional();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.drivingLicense)) {
            data["drivingLicense"] = [];
            for (let item of this.drivingLicense)
                data["drivingLicense"].push(item);
        }
        if (Array.isArray(this.otherLicenseNeeded)) {
            data["otherLicenseNeeded"] = [];
            for (let item of this.otherLicenseNeeded)
                data["otherLicenseNeeded"].push(item);
        }
        if (Array.isArray(this.skills)) {
            data["skills"] = [];
            for (let item of this.skills)
                data["skills"].push(item);
        }
        return data;
    }
}

export interface IVacancyAdditional {
    drivingLicense?: string[] | undefined;
    otherLicenseNeeded?: string[] | undefined;
    skills?: string[] | undefined;
}

export class VacancyEducation implements IVacancyEducation {
    /** education_level */
    levelOfEducation?: string | undefined;
    /** dictionary_requirements_level */
    obligatoriness?: string | undefined;
    /** specialization */
    specialization?: string | undefined;

    constructor(data?: IVacancyEducation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.levelOfEducation = _data["levelOfEducation"];
            this.obligatoriness = _data["obligatoriness"];
            this.specialization = _data["specialization"];
        }
    }

    static fromJS(data: any): VacancyEducation {
        data = typeof data === 'object' ? data : {};
        let result = new VacancyEducation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["levelOfEducation"] = this.levelOfEducation;
        data["obligatoriness"] = this.obligatoriness;
        data["specialization"] = this.specialization;
        return data;
    }
}

export interface IVacancyEducation {
    /** education_level */
    levelOfEducation?: string | undefined;
    /** dictionary_requirements_level */
    obligatoriness?: string | undefined;
    /** specialization */
    specialization?: string | undefined;
}

export class VacancyEmployer implements IVacancyEmployer {
    companyName?: string | undefined;
    contactPhone?: string | undefined;
    firstName?: string | undefined;
    infoSource?: string | undefined;
    lastName?: string | undefined;

    constructor(data?: IVacancyEmployer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.companyName = _data["companyName"];
            this.contactPhone = _data["contactPhone"];
            this.firstName = _data["firstName"];
            this.infoSource = _data["infoSource"];
            this.lastName = _data["lastName"];
        }
    }

    static fromJS(data: any): VacancyEmployer {
        data = typeof data === 'object' ? data : {};
        let result = new VacancyEmployer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyName"] = this.companyName;
        data["contactPhone"] = this.contactPhone;
        data["firstName"] = this.firstName;
        data["infoSource"] = this.infoSource;
        data["lastName"] = this.lastName;
        return data;
    }
}

export interface IVacancyEmployer {
    companyName?: string | undefined;
    contactPhone?: string | undefined;
    firstName?: string | undefined;
    infoSource?: string | undefined;
    lastName?: string | undefined;
}

export class VacancyInRequest implements IVacancyInRequest {
    description?: string | undefined;
    employment?: string | undefined;
    salary?: VacancySalary | undefined;
    specialization?: string | undefined;
    vacancyName?: string | undefined;
    /** years_of_experience */
    workFeatures?: string[] | undefined;

    constructor(data?: IVacancyInRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.employment = _data["employment"];
            this.salary = _data["salary"] ? VacancySalary.fromJS(_data["salary"]) : <any>undefined;
            this.specialization = _data["specialization"];
            this.vacancyName = _data["vacancyName"];
            if (Array.isArray(_data["workFeatures"])) {
                this.workFeatures = [] as any;
                for (let item of _data["workFeatures"])
                    this.workFeatures!.push(item);
            }
        }
    }

    static fromJS(data: any): VacancyInRequest {
        data = typeof data === 'object' ? data : {};
        let result = new VacancyInRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["employment"] = this.employment;
        data["salary"] = this.salary ? this.salary.toJSON() : <any>undefined;
        data["specialization"] = this.specialization;
        data["vacancyName"] = this.vacancyName;
        if (Array.isArray(this.workFeatures)) {
            data["workFeatures"] = [];
            for (let item of this.workFeatures)
                data["workFeatures"].push(item);
        }
        return data;
    }
}

export interface IVacancyInRequest {
    description?: string | undefined;
    employment?: string | undefined;
    salary?: VacancySalary | undefined;
    specialization?: string | undefined;
    vacancyName?: string | undefined;
    /** years_of_experience */
    workFeatures?: string[] | undefined;
}

export class VacancyLanguages implements IVacancyLanguages {
    /** language */
    language?: string | undefined;
    /** language_level */
    level?: string | undefined;
    /** dictionary_requirements_level */
    obligatoriness?: string | undefined;

    constructor(data?: IVacancyLanguages) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.language = _data["language"];
            this.level = _data["level"];
            this.obligatoriness = _data["obligatoriness"];
        }
    }

    static fromJS(data: any): VacancyLanguages {
        data = typeof data === 'object' ? data : {};
        let result = new VacancyLanguages();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language;
        data["level"] = this.level;
        data["obligatoriness"] = this.obligatoriness;
        return data;
    }
}

export interface IVacancyLanguages {
    /** language */
    language?: string | undefined;
    /** language_level */
    level?: string | undefined;
    /** dictionary_requirements_level */
    obligatoriness?: string | undefined;
}

export class VacancyLocation implements IVacancyLocation {
    city?: string | undefined;
    country?: string | undefined;
    language?: string | undefined;
    numberOfEmployee?: string | undefined;
    region?: string | undefined;

    constructor(data?: IVacancyLocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.city = _data["city"];
            this.country = _data["country"];
            this.language = _data["language"];
            this.numberOfEmployee = _data["numberOfEmployee"];
            this.region = _data["region"];
        }
    }

    static fromJS(data: any): VacancyLocation {
        data = typeof data === 'object' ? data : {};
        let result = new VacancyLocation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["city"] = this.city;
        data["country"] = this.country;
        data["language"] = this.language;
        data["numberOfEmployee"] = this.numberOfEmployee;
        data["region"] = this.region;
        return data;
    }
}

export interface IVacancyLocation {
    city?: string | undefined;
    country?: string | undefined;
    language?: string | undefined;
    numberOfEmployee?: string | undefined;
    region?: string | undefined;
}

export class VacancyRequirements implements IVacancyRequirements {
    educations?: VacancyEducation[] | undefined;
    languages?: VacancyLanguages[] | undefined;
    workExperiences?: VacancyWorkExperiences[] | undefined;

    constructor(data?: IVacancyRequirements) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["educations"])) {
                this.educations = [] as any;
                for (let item of _data["educations"])
                    this.educations!.push(VacancyEducation.fromJS(item));
            }
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages!.push(VacancyLanguages.fromJS(item));
            }
            if (Array.isArray(_data["workExperiences"])) {
                this.workExperiences = [] as any;
                for (let item of _data["workExperiences"])
                    this.workExperiences!.push(VacancyWorkExperiences.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VacancyRequirements {
        data = typeof data === 'object' ? data : {};
        let result = new VacancyRequirements();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.educations)) {
            data["educations"] = [];
            for (let item of this.educations)
                data["educations"].push(item.toJSON());
        }
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        if (Array.isArray(this.workExperiences)) {
            data["workExperiences"] = [];
            for (let item of this.workExperiences)
                data["workExperiences"].push(item.toJSON());
        }
        return data;
    }
}

export interface IVacancyRequirements {
    educations?: VacancyEducation[] | undefined;
    languages?: VacancyLanguages[] | undefined;
    workExperiences?: VacancyWorkExperiences[] | undefined;
}

export class VacancyResponses implements IVacancyResponses {
    canBeDoneBy?: string | undefined;
    complianceOfRequirements?: string | undefined;
    email?: string | undefined;
    notificationsSettings?: string | undefined;
    showEmail?: string | undefined;
    showPhoneNumber?: string | undefined;

    constructor(data?: IVacancyResponses) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canBeDoneBy = _data["canBeDoneBy"];
            this.complianceOfRequirements = _data["complianceOfRequirements"];
            this.email = _data["email"];
            this.notificationsSettings = _data["notificationsSettings"];
            this.showEmail = _data["showEmail"];
            this.showPhoneNumber = _data["showPhoneNumber"];
        }
    }

    static fromJS(data: any): VacancyResponses {
        data = typeof data === 'object' ? data : {};
        let result = new VacancyResponses();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canBeDoneBy"] = this.canBeDoneBy;
        data["complianceOfRequirements"] = this.complianceOfRequirements;
        data["email"] = this.email;
        data["notificationsSettings"] = this.notificationsSettings;
        data["showEmail"] = this.showEmail;
        data["showPhoneNumber"] = this.showPhoneNumber;
        return data;
    }
}

export interface IVacancyResponses {
    canBeDoneBy?: string | undefined;
    complianceOfRequirements?: string | undefined;
    email?: string | undefined;
    notificationsSettings?: string | undefined;
    showEmail?: string | undefined;
    showPhoneNumber?: string | undefined;
}

export class VacancySalary implements IVacancySalary {
    currency?: string | undefined;
    fixed?: string | undefined;
    from?: string | undefined;
    payoutPeriod?: string | undefined;
    to?: string | undefined;

    constructor(data?: IVacancySalary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currency = _data["currency"];
            this.fixed = _data["fixed"];
            this.from = _data["from"];
            this.payoutPeriod = _data["payoutPeriod"];
            this.to = _data["to"];
        }
    }

    static fromJS(data: any): VacancySalary {
        data = typeof data === 'object' ? data : {};
        let result = new VacancySalary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currency"] = this.currency;
        data["fixed"] = this.fixed;
        data["from"] = this.from;
        data["payoutPeriod"] = this.payoutPeriod;
        data["to"] = this.to;
        return data;
    }
}

export interface IVacancySalary {
    currency?: string | undefined;
    fixed?: string | undefined;
    from?: string | undefined;
    payoutPeriod?: string | undefined;
    to?: string | undefined;
}

export class VacancyWorkExperiences implements IVacancyWorkExperiences {
    /** dictionary_requirements_level */
    obligatoriness?: string | undefined;
    /** years_of_experience */
    periodOfWork?: string | undefined;
    /** specialization */
    specialization?: string | undefined;

    constructor(data?: IVacancyWorkExperiences) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.obligatoriness = _data["obligatoriness"];
            this.periodOfWork = _data["periodOfWork"];
            this.specialization = _data["specialization"];
        }
    }

    static fromJS(data: any): VacancyWorkExperiences {
        data = typeof data === 'object' ? data : {};
        let result = new VacancyWorkExperiences();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["obligatoriness"] = this.obligatoriness;
        data["periodOfWork"] = this.periodOfWork;
        data["specialization"] = this.specialization;
        return data;
    }
}

export interface IVacancyWorkExperiences {
    /** dictionary_requirements_level */
    obligatoriness?: string | undefined;
    /** years_of_experience */
    periodOfWork?: string | undefined;
    /** specialization */
    specialization?: string | undefined;
}

export class ErrFields implements IErrFields {
    code?: number | undefined;
    params?: string | undefined;

    constructor(data?: IErrFields) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.params = _data["params"];
        }
    }

    static fromJS(data: any): ErrFields {
        data = typeof data === 'object' ? data : {};
        let result = new ErrFields();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["params"] = this.params;
        return data;
    }
}

export interface IErrFields {
    code?: number | undefined;
    params?: string | undefined;
}

export class ErrResponse implements IErrResponse {
    error?: ErrFields | undefined;

    constructor(data?: IErrResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.error = _data["error"] ? ErrFields.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ErrResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ErrResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data;
    }
}

export interface IErrResponse {
    error?: ErrFields | undefined;
}

export class Employee implements IEmployee {
    en?: TitleField | undefined;
    id?: string | undefined;
    th?: TitleField | undefined;

    constructor(data?: IEmployee) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.en = _data["en"] ? TitleField.fromJS(_data["en"]) : <any>undefined;
            this.id = _data["id"];
            this.th = _data["th"] ? TitleField.fromJS(_data["th"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Employee {
        data = typeof data === 'object' ? data : {};
        let result = new Employee();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["en"] = this.en ? this.en.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["th"] = this.th ? this.th.toJSON() : <any>undefined;
        return data;
    }
}

export interface IEmployee {
    en?: TitleField | undefined;
    id?: string | undefined;
    th?: TitleField | undefined;
}

export class SourceOfInformation implements ISourceOfInformation {
    en?: TitleField | undefined;
    id?: string | undefined;
    th?: TitleField | undefined;

    constructor(data?: ISourceOfInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.en = _data["en"] ? TitleField.fromJS(_data["en"]) : <any>undefined;
            this.id = _data["id"];
            this.th = _data["th"] ? TitleField.fromJS(_data["th"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SourceOfInformation {
        data = typeof data === 'object' ? data : {};
        let result = new SourceOfInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["en"] = this.en ? this.en.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["th"] = this.th ? this.th.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISourceOfInformation {
    en?: TitleField | undefined;
    id?: string | undefined;
    th?: TitleField | undefined;
}

export class UploadResponse implements IUploadResponse {
    url?: string | undefined;

    constructor(data?: IUploadResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): UploadResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UploadResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        return data;
    }
}

export interface IUploadResponse {
    url?: string | undefined;
}

export class ErrFields2 implements IErrFields2 {
    code?: number | undefined;
    params?: string | undefined;

    constructor(data?: IErrFields2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.params = _data["params"];
        }
    }

    static fromJS(data: any): ErrFields2 {
        data = typeof data === 'object' ? data : {};
        let result = new ErrFields2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["params"] = this.params;
        return data;
    }
}

export interface IErrFields2 {
    code?: number | undefined;
    params?: string | undefined;
}

export class ErrResponse2 implements IErrResponse2 {
    error?: ErrFields2 | undefined;

    constructor(data?: IErrResponse2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.error = _data["error"] ? ErrFields2.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ErrResponse2 {
        data = typeof data === 'object' ? data : {};
        let result = new ErrResponse2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data;
    }
}

export interface IErrResponse2 {
    error?: ErrFields2 | undefined;
}

/** 0 [last 24 hours], 1 [last 5 days], 2 [last 14 days], 3 [last month] */
export enum Date_of_post {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

/** 0 [last 24 hours], 1 [last 5 days], 2 [last 14 days], 3 [last month] */
export enum Date_of_post2 {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}