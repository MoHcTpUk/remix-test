{
  "version": 3,
  "sources": ["../../../../../app/routes/user/responses/vacancy.$id.tsx", "../../../../../app/components/pages/User/Responses/components/Vacancies/InnerResponsesResumesComponent/index.tsx"],
  "sourcesContent": ["import type { ActionArgs, LoaderArgs } from '@remix-run/cloudflare';\nimport { json } from '@remix-run/cloudflare';\nimport { Outlet, useActionData, useLoaderData, useMatches } from '@remix-run/react';\nimport qs from 'qs';\nimport { ClientFactory } from 'shared/clientFactory';\nimport { ResponsesApi } from 'shared/v2/responses';\nimport { ResumesApi } from 'shared/v2/resumes';\nimport { VacanciesApi } from 'shared/v2/vacancies';\n\nimport { Box } from '~/components/common/Box';\nimport { InnerResponsesResumesComponent } from '~/components/pages/User/Responses/components/Vacancies/InnerResponsesResumesComponent';\nimport { useScreenWidth } from '~/hooks';\nimport { getMessageContext } from '~/storages/message.server';\nimport { ResponseState } from '~/types/enums/responseState';\nimport { successAccessMessage } from '~/utils/messages';\n\nexport const loader = async ({ context, request, params }: LoaderArgs) => {\n  const clientResponses = ClientFactory.createClient(ResponsesApi, context.session);\n  const clientResumes = ClientFactory.createClient(ResumesApi, context.session);\n  const clientVacancies = ClientFactory.createClient(VacanciesApi, context.session);\n\n  const vacancyId = params.id;\n\n  const url = new URL(request.url);\n  const max_page_size = url.searchParams.get('max_page_size');\n  const current_token = url.searchParams.get('current_token');\n  const current_page = url.searchParams.get('current_page');\n  const max_pages = url.searchParams.get('max_pages');\n\n  // const pages = getPaginationPages(current_page, max_pages);\n\n  const [\n    genders,\n    specializations,\n    location,\n    // employment,\n    // workfeatures,\n    // educationLevel,\n    // yearsOfExperience,\n    responses,\n    vacancy,\n  ] = await Promise.all([\n    context.references.gendersMap,\n    context.references.specializationsMap,\n    context.references.locationMap,\n    // context.references.employmentsMap,\n    // context.references.workFeaturesMap,\n    // context.references.educationLevelMap,\n    // context.references.yearsOfExperienceMap,\n    clientResponses.getEntityResponses({\n      id: vacancyId || '',\n      max_page_size: max_page_size ? +max_page_size : 10,\n      // pages,\n      page_token: current_page && +current_page !== 1 && current_token ? current_token : undefined,\n      // entity_type: 'VACANCY',\n    }),\n    clientVacancies.getVacancy({ id: vacancyId || '' }),\n  ]);\n\n  let resumes;\n\n  if (responses.data.length > 0) {\n    const resumesIds = responses.data\n      .map((item) => (item.target_type === 'RESUME' ? item.target_id : item.shared_id))\n      .join(',');\n\n    resumes = await clientResumes.getBatchResumes({ ids: resumesIds }).then((res) => res.data);\n  }\n\n  const dictionaries = {\n    genders: genders.ToArray(),\n    specializations: specializations.ToArray(),\n    location: location.ToArray(),\n  };\n\n  // const paginationRange = getPaginationRange(pages, vacancies?.max_pages, vacancies?.page_tokens);\n  // const maxPages = vacancies.max_pages;\n\n  const pagination = {\n    max_page_size,\n    current_token,\n    current_page,\n    // paginationRange,\n    // maxPages,\n  };\n\n  // return json({});\n\n  return json({ resumes, dictionaries, pagination, vacancy, responses });\n};\n\nexport const action = async ({ request, context }: ActionArgs) => {\n  const text = await request.text();\n  const { ...data } = qs.parse(text);\n\n  const clientResponses = ClientFactory.createClient(ResponsesApi, context.session);\n  const messageContextStorage = await getMessageContext(request);\n\n  const responseId = data?.responseId;\n  try {\n    if (responseId) {\n      await clientResponses.patchResponse({\n        id: responseId.toString(),\n        response: {\n          id: responseId.toString(),\n          state: ResponseState.APPROVED,\n        },\n      });\n\n      const headers: HeadersInit = new Headers();\n\n      messageContextStorage.setSuccessMessage(\n        '',\n        successAccessMessage(context.userContext.language),\n      );\n      headers.append('Set-Cookie', await messageContextStorage.commit());\n    }\n    return json(\n      {\n        success: true,\n        message: {\n          en: 'Successfully!',\n          th: 'สำเร็จ!',\n        },\n      },\n      { headers: { 'Set-Cookie': await messageContextStorage.commit() } },\n    );\n  } catch (e) {\n    const headers: HeadersInit = new Headers();\n\n    messageContextStorage.setErrorMessage(\n      context.userContext.language === 'en' ? 'Something went wrong' : 'มีบางอย่างผิดพลาด',\n      context.userContext.language === 'en' ? 'Error' : 'ข้อผิดพลาด',\n    );\n\n    headers.append('Set-Cookie', await messageContextStorage.commit());\n    console.log(e);\n    return json({\n      success: false,\n      message: {\n        en: 'Something went wrong',\n        th: 'มีบางอย่างผิดพลาด',\n      },\n    });\n  }\n};\n\nexport default function ResponseResumeIndex() {\n  const request = useLoaderData<typeof loader>();\n  const actionData = useActionData<typeof action>();\n\n  const { resumes, responses, vacancy } = request;\n  const matches = useMatches();\n  const widthScreen = useScreenWidth();\n\n  const checkSelectedResumeAndMobile = widthScreen < 1280 && matches[4].id.includes('resumeId');\n\n  return (\n    <Box flexDirection='row' width='100%' gap={widthScreen < 1280 ? '12px' : '24px'}>\n      {!checkSelectedResumeAndMobile && (\n        <InnerResponsesResumesComponent\n          resumes={resumes}\n          vacancy={vacancy}\n          responses={responses.data}\n          responseAction={actionData?.success}\n        />\n      )}\n\n      <Outlet />\n    </Box>\n  );\n}\n", "import { motion } from 'framer-motion';\nimport { memo } from 'react';\nimport type { Response } from 'shared/v2/responses';\nimport type { Resume } from 'shared/v2/resumes';\nimport type { Vacancy } from 'shared/v2/vacancies';\n\nimport { Box } from '~/components/common/Box';\nimport { ResumePartCardWidget } from '~/components/entities/cardWidgets';\nimport { useScreenWidth } from '~/hooks';\n\nexport const InnerResponsesResumesComponent = memo(\n  ({\n    resumes,\n    vacancy,\n    responses,\n    responseAction,\n  }: {\n    resumes?: Resume[] | null;\n    vacancy?: Vacancy;\n    responses?: Response[];\n    responseAction?: boolean;\n  }): JSX.Element => {\n    const widthScreen = useScreenWidth();\n\n    const getResponseForResume = (resume: Resume) =>\n      responses?.find((item) => item.shared_id === resume.id || item.target_id === resume.id);\n\n    return (\n      <Box\n        flexDirection='column'\n        alignItems='flex-start'\n        width='100%'\n        gap='24px'\n        as={motion.div}\n        initial={{ opacity: 0 }}\n        animate={{ opacity: 1 }}\n        exit={{ opacity: 0 }}\n      >\n        <Box\n          flexDirection='column'\n          width='100%'\n          gap={widthScreen > 1024 ? '24px' : '16px'}\n          style={{\n            flex: '1',\n          }}\n        >\n          {/* <Heading variant='resumes' title={t('user:my_resumes')} /> */}\n\n          {resumes?.map((item, index) => (\n            <ResumePartCardWidget\n              key={item.id}\n              state={getResponseForResume(item)?.state}\n              type={\n                getResponseForResume(item)?.shared_id === vacancy?.id ? 'REQUEST' : 'INVITATION'\n              }\n              responseId={getResponseForResume(item)?.id}\n              resume={item}\n              selectedResume={vacancy?.id}\n              variant='response'\n              responseAction={responseAction}\n            />\n          ))}\n        </Box>\n      </Box>\n    );\n  },\n);\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,wBAAqB;AACrB;AACA,gBAAe;;;ACFf,mBAAqB;AAgDT;AAvCL,IAAMA,qCAAiCC,mBAC5C,CAAC;EACCC;EACAC;EACAC;EACAC;AAMF,MAAmB;AACjB,QAAMC,cAAcC,eAAe;AAEnC,QAAMC,uBAAuBA,CAACC,WAC5BL,WAAWM,KAAMC,UAASA,KAAKC,cAAcH,OAAOI,MAAMF,KAAKG,cAAcL,OAAOI,EAAE;AAExF,SACE,mDAAC,OACC,eAAc,UACd,YAAW,cACX,OAAM,QACN,KAAI,QACJ,IAAIE,OAAOC,KACX,SAAS;IAAEC,SAAS;EAAE,GACtB,SAAS;IAAEA,SAAS;EAAE,GACtB,MAAM;IAAEA,SAAS;EAAE,GAEnB,6DAAC,OACC,eAAc,UACd,OAAM,QACN,KAAKX,cAAc,OAAO,SAAS,QACnC,OAAO;IACLY,MAAM;EACR,GAIChB,mBAASiB,IAAI,CAACR,MAAMS,UACnB,mDAAC,wBAEC,OAAOZ,qBAAqBG,IAAI,GAAGU,OACnC,MACEb,qBAAqBG,IAAI,GAAGC,cAAcT,SAASU,KAAK,YAAY,cAEtE,YAAYL,qBAAqBG,IAAI,GAAGE,IACxC,QAAQF,MACR,gBAAgBR,SAASU,IACzB,SAAQ,YACR,kBATKF,KAAKE,IADZ;;;;SAUiC,CAElC,KAvBH;;;;SAwBA,KAlCF;;;;SAmCA;AAEJ,CACF;;;ADtDA,qBAAkC;AAoJ1B,IAAAS,0BAAA;AAbO,SAAf,sBAA8C;AAC5C,QAAMC,UAAUC,cAA6B;AAC7C,QAAMC,aAAaC,cAA6B;AAEhD,QAAM;IAAEC;IAASC;IAAWC;EAAQ,IAAIN;AACxC,QAAMO,UAAUC,WAAW;AAC3B,QAAMC,cAAcC,eAAe;AAEnC,QAAMC,+BAA+BF,cAAc,QAAQF,QAAQ,CAAC,EAAEK,GAAGC,SAAS,UAAU;AAE5F,SACE,oDAAC,OAAI,eAAc,OAAM,OAAM,QAAO,KAAKJ,cAAc,OAAO,SAAS,QACtE;KAACE,gCACA,oDAAC,kCACC,SACA,SACA,WAAWN,UAAUS,MACrB,gBAAgBZ,YAAYa,WAJ9B;;;;WAIsC;IAIxC,oDAAC,YAAD;;;;WAAO;OAVT;;;;SAWA;AAEJ;",
  "names": ["InnerResponsesResumesComponent", "memo", "resumes", "vacancy", "responses", "responseAction", "widthScreen", "useScreenWidth", "getResponseForResume", "resume", "find", "item", "shared_id", "id", "target_id", "motion", "div", "opacity", "flex", "map", "index", "state", "import_jsx_dev_runtime", "request", "useLoaderData", "actionData", "useActionData", "resumes", "responses", "vacancy", "matches", "useMatches", "widthScreen", "useScreenWidth", "checkSelectedResumeAndMobile", "id", "includes", "data", "success"]
}
