{
  "version": 3,
  "sources": ["../../../../../app/routes/user/responses/resume.$id.tsx", "../../../../../app/components/pages/User/Responses/components/Resumes/InnerResponsesVacanciesComponent/index.tsx"],
  "sourcesContent": ["import type { ActionArgs, LoaderArgs, LoaderFunction } from '@remix-run/cloudflare';\nimport { json } from '@remix-run/cloudflare';\nimport { Outlet, useActionData, useLoaderData, useMatches } from '@remix-run/react';\nimport qs from 'qs';\nimport { ClientFactory } from 'shared/clientFactory';\nimport { ResponsesApi } from 'shared/v2/responses';\nimport { ResumesApi } from 'shared/v2/resumes';\nimport { VacanciesApi } from 'shared/v2/vacancies';\n\nimport { Box } from '~/components/common/Box';\nimport { InnerResponsesVacanciesComponent } from '~/components/pages/User/Responses/components/Resumes/InnerResponsesVacanciesComponent';\nimport { useScreenWidth } from '~/hooks';\nimport { getMessageContext } from '~/storages/message.server';\nimport { ResponseState } from '~/types/enums/responseState';\nimport { successAccessMessage, successAccessTitle } from '~/utils/messages';\n\nexport const loader = async ({ context, request, params }: LoaderArgs) => {\n  const clientResponses = ClientFactory.createClient(ResponsesApi, context.session);\n  const clientResumes = ClientFactory.createClient(ResumesApi, context.session);\n  const clientVacancies = ClientFactory.createClient(VacanciesApi, context.session);\n\n  const resumeId = params.id;\n\n  const url = new URL(request.url);\n  const max_page_size = url.searchParams.get('max_page_size');\n  const current_token = url.searchParams.get('current_token');\n  const current_page = url.searchParams.get('current_page');\n  const max_pages = url.searchParams.get('max_pages');\n\n  // const pages = getPaginationPages(current_page, max_pages);\n\n  const [\n    genders,\n    specializations,\n    location,\n    employment,\n    workfeatures,\n    educationLevel,\n    yearsOfExperience,\n    responses,\n    resume,\n  ] = await Promise.all([\n    context.references.gendersMap,\n    context.references.specializationsMap,\n    context.references.locationMap,\n    context.references.employmentsMap,\n    context.references.workFeaturesMap,\n    context.references.educationLevelMap,\n    context.references.yearsOfExperienceMap,\n    clientResponses.getEntityResponses({\n      id: resumeId || '',\n      max_page_size: max_page_size ? +max_page_size : 10,\n      // pages,\n      page_token: current_page && +current_page !== 1 && current_token ? current_token : undefined,\n      // entity_type: 'VACANCY',\n    }),\n    clientResumes.getResume({ id: resumeId || '' }),\n  ]);\n\n  let vacancies;\n\n  if (responses.data.length > 0) {\n    const vacancyIds = responses.data\n      .map((item) => (item.target_type === 'VACANCY' ? item.target_id : item.shared_id))\n      .join(',');\n\n    vacancies = await clientVacancies\n      .getBatchVacancies({ ids: vacancyIds })\n      .then((res) => res.data);\n  }\n\n  const dictionaries = {\n    genders: genders.ToArray(),\n    specializations: specializations.ToArray(),\n    location: location.ToArray(),\n    employment: employment.ToArray(),\n    workfeatures: workfeatures.ToArray(),\n    educationLevel: educationLevel.ToArray(),\n    yearsOfExperience: yearsOfExperience.ToArray(),\n  };\n\n  // const paginationRange = getPaginationRange(pages, vacancies?.max_pages, vacancies?.page_tokens);\n  // const maxPages = vacancies.max_pages;\n\n  const pagination = {\n    max_page_size,\n    current_token,\n    current_page,\n    // paginationRange,\n    // maxPages,\n  };\n\n  // return json({});\n\n  return json({ vacancies, dictionaries, pagination, resume, responses });\n};\n\nexport const action = async ({ request, context }: ActionArgs) => {\n  const text = await request.text();\n  const { ...data } = qs.parse(text);\n\n  const clientResponses = ClientFactory.createClient(ResponsesApi, context.session);\n  const messageContextStorage = await getMessageContext(request);\n\n  const responseId = data?.responseId;\n  try {\n    if (responseId) {\n      await clientResponses.patchResponse({\n        id: responseId.toString(),\n        response: {\n          id: responseId.toString(),\n          state: ResponseState.APPROVED,\n        },\n      });\n\n      const headers: HeadersInit = new Headers();\n\n      messageContextStorage.setSuccessMessage(\n        successAccessTitle(context.userContext.language),\n        successAccessMessage(context.userContext.language),\n      );\n      headers.append('Set-Cookie', await messageContextStorage.commit());\n    }\n    return json(\n      {\n        success: true,\n        message: {\n          en: 'Successfully!',\n          th: 'สำเร็จ!',\n        },\n      },\n      { headers: { 'Set-Cookie': await messageContextStorage.commit() } },\n    );\n  } catch (e) {\n    const headers: HeadersInit = new Headers();\n\n    messageContextStorage.setErrorMessage(\n      context.userContext.language === 'en' ? 'Something went wrong' : 'มีบางอย่างผิดพลาด',\n      context.userContext.language === 'en' ? 'Error' : 'ข้อผิดพลาด',\n    );\n\n    headers.append('Set-Cookie', await messageContextStorage.commit());\n    console.log(e);\n    return json({\n      success: false,\n      message: {\n        en: 'Something went wrong',\n        th: 'มีบางอย่างผิดพลาด',\n      },\n    });\n  }\n};\n\nexport default function ResponseResumeIndex() {\n  const request = useLoaderData<typeof loader>();\n  const actionData = useActionData<typeof action>();\n  const { vacancies, resume, responses } = request;\n  const matches = useMatches();\n  const widthScreen = useScreenWidth();\n\n  const checkSelectedVacancyAndMobile = widthScreen < 1280 && matches[4].id.includes('vacancyId');\n\n  return (\n    <Box flexDirection='row' width='100%' gap={widthScreen < 1280 ? '12px' : '24px'}>\n      {!checkSelectedVacancyAndMobile && (\n        <InnerResponsesVacanciesComponent\n          resume={resume}\n          vacancies={vacancies}\n          responses={responses.data}\n          responseAction={actionData?.success}\n        />\n      )}\n      <Outlet />\n    </Box>\n  );\n}\n", "import { motion } from 'framer-motion';\nimport { memo } from 'react';\nimport type { Response } from 'shared/v2/responses';\nimport type { Resume } from 'shared/v2/resumes';\nimport type { Vacancy } from 'shared/v2/vacancies';\n\nimport { Box } from '~/components/common/Box';\nimport { VacancyPartCardWidget } from '~/components/entities/cardWidgets';\nimport { useScreenWidth } from '~/hooks';\nimport type { IDictionaries } from '~/types/interfaces/iDictionaries';\n\nexport const InnerResponsesVacanciesComponent = memo(\n  ({\n    vacancies,\n    resume,\n    dictionaries,\n    responses,\n    responseAction,\n  }: {\n    vacancies?: Vacancy[] | null;\n    resume?: Resume;\n    dictionaries?: IDictionaries;\n    responses?: Response[];\n    responseAction?: boolean;\n  }): JSX.Element => {\n    const widthScreen = useScreenWidth();\n\n    const getResponseForVacancy = (vacancy: Vacancy) =>\n      responses?.find((item) => item.shared_id === vacancy.id || item.target_id === vacancy.id);\n\n    return (\n      <Box\n        flexDirection='column'\n        alignItems='flex-start'\n        width='100%'\n        gap='24px'\n        as={motion.div}\n        initial={{ opacity: 0 }}\n        animate={{ opacity: 1 }}\n        exit={{ opacity: 0 }}\n      >\n        <Box\n          flexDirection='column'\n          width='100%'\n          gap={widthScreen > 1024 ? '24px' : '16px'}\n          style={{\n            flex: '1',\n          }}\n        >\n          {/* <Heading variant='resumes' title={t('user:my_resumes')} /> */}\n\n          {vacancies?.map((item, index) => (\n            <VacancyPartCardWidget\n              key={item.id}\n              state={getResponseForVacancy(item)?.state}\n              type={\n                getResponseForVacancy(item)?.shared_id === resume?.id ? 'REQUEST' : 'INVITATION'\n              }\n              responseId={getResponseForVacancy(item)?.id}\n              vacancy={item}\n              // selectedVacancy={item?.id}\n              variant='response'\n              responseAction={responseAction}\n            />\n          ))}\n        </Box>\n      </Box>\n    );\n  },\n);\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,wBAAqB;AACrB;AACA,gBAAe;;;ACFf,mBAAqB;AAmDT;AAzCL,IAAMA,uCAAmCC,mBAC9C,CAAC;EACCC;EACAC;EACAC;EACAC;EACAC;AAOF,MAAmB;AACjB,QAAMC,cAAcC,eAAe;AAEnC,QAAMC,wBAAwBA,CAACC,YAC7BL,WAAWM,KAAMC,UAASA,KAAKC,cAAcH,QAAQI,MAAMF,KAAKG,cAAcL,QAAQI,EAAE;AAE1F,SACE,mDAAC,OACC,eAAc,UACd,YAAW,cACX,OAAM,QACN,KAAI,QACJ,IAAIE,OAAOC,KACX,SAAS;IAAEC,SAAS;EAAE,GACtB,SAAS;IAAEA,SAAS;EAAE,GACtB,MAAM;IAAEA,SAAS;EAAE,GAEnB,6DAAC,OACC,eAAc,UACd,OAAM,QACN,KAAKX,cAAc,OAAO,SAAS,QACnC,OAAO;IACLY,MAAM;EACR,GAICjB,qBAAWkB,IAAI,CAACR,MAAMS,UACrB;IAAC;;MAEC,OAAOZ,sBAAsBG,IAAI,GAAGU;MACpC,MACEb,sBAAsBG,IAAI,GAAGC,cAAcV,QAAQW,KAAK,YAAY;MAEtE,YAAYL,sBAAsBG,IAAI,GAAGE;MACzC,SAASF;MAET,SAAQ;MACR;;IATKA,KAAKE;IADZ;;;;;;;EAUiC,CAElC,KAvBH;;;;SAwBA,KAlCF;;;;SAmCA;AAEJ,CACF;;;ADzDA,qBAAkC;AAyJ1B,IAAAS,0BAAA;AAZO,SAAf,sBAA8C;AAC5C,QAAMC,UAAUC,cAA6B;AAC7C,QAAMC,aAAaC,cAA6B;AAChD,QAAM;IAAEC;IAAWC;IAAQC;EAAU,IAAIN;AACzC,QAAMO,UAAUC,WAAW;AAC3B,QAAMC,cAAcC,eAAe;AAEnC,QAAMC,gCAAgCF,cAAc,QAAQF,QAAQ,CAAC,EAAEK,GAAGC,SAAS,WAAW;AAE9F,SACE,oDAAC,OAAI,eAAc,OAAM,OAAM,QAAO,KAAKJ,cAAc,OAAO,SAAS,QACtE;KAACE,iCACA,oDAAC,oCACC,QACA,WACA,WAAWL,UAAUQ,MACrB,gBAAgBZ,YAAYa,WAJ9B;;;;WAIsC;IAGxC,oDAAC,YAAD;;;;WAAO;OATT;;;;SAUA;AAEJ;",
  "names": ["InnerResponsesVacanciesComponent", "memo", "vacancies", "resume", "dictionaries", "responses", "responseAction", "widthScreen", "useScreenWidth", "getResponseForVacancy", "vacancy", "find", "item", "shared_id", "id", "target_id", "motion", "div", "opacity", "flex", "map", "index", "state", "import_jsx_dev_runtime", "request", "useLoaderData", "actionData", "useActionData", "vacancies", "resume", "responses", "matches", "useMatches", "widthScreen", "useScreenWidth", "checkSelectedVacancyAndMobile", "id", "includes", "data", "success"]
}
